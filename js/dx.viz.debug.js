/*! 
 * DevExtreme (dx.viz.debug.js)
 * Version: 16.1.5
 * Build date: Mon Jul 25 2016
 *
 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
 */
"use strict";
! function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports
        }
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0)
}([
    /*!**************************!*\
      !*** multi dx.viz.debug ***!
      \**************************/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__( /*! c:\projects\DevExtreme\16.1\BuildLabel\Temp\DevExtreme.v16.1\repo\DXTreme.ClientResources\Root\Scripts\bundles\dx.viz.js */ 590)
    },
    /*!*************************!*\
      !*** external "jQuery" ***!
      \*************************/
    function(module, exports) {
        module.exports = jQuery
    },
    /*!**************************************!*\
      !*** ./Scripts/core/utils/common.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                config = __webpack_require__( /*! ../config */ 35);
            var isDefined = function(object) {
                return null !== object && void 0 !== object
            };
            var isString = function(object) {
                return "string" === $.type(object)
            };
            var isNumber = function(object) {
                return "number" === typeof object && isFinite(object) || $.isNumeric(object)
            };
            var isObject = function(object) {
                return "object" === $.type(object)
            };
            var isArray = function(object) {
                return "array" === $.type(object)
            };
            var isDate = function(object) {
                return "date" === $.type(object)
            };
            var isBoolean = function(object) {
                return "boolean" === $.type(object)
            };
            var isFunction = function(object) {
                return "function" === $.type(object)
            };
            var isPrimitive = function(value) {
                return -1 === $.inArray($.type(value), ["object", "array", "function"])
            };
            var isExponential = function(value) {
                return isNumber(value) && -1 !== value.toString().indexOf("e")
            };
            var ensureDefined = function(value, defaultValue) {
                return isDefined(value) ? value : defaultValue
            };
            var getDefaultAlignment = function(isRtlEnabled) {
                var rtlEnabled = isRtlEnabled || config().rtlEnabled;
                return rtlEnabled ? "right" : "left"
            };
            var executeAsync = function(action, context) {
                var timerId, deferred = $.Deferred(),
                    normalizedContext = context || this,
                    task = {
                        promise: deferred.promise(),
                        abort: function() {
                            clearTimeout(timerId);
                            deferred.rejectWith(normalizedContext)
                        }
                    },
                    callback = function() {
                        var result = action.call(normalizedContext);
                        if (result && result.done && $.isFunction(result.done)) {
                            result.done(function() {
                                deferred.resolveWith(normalizedContext)
                            })
                        } else {
                            deferred.resolveWith(normalizedContext)
                        }
                    };
                timerId = (arguments[2] || setTimeout)(callback, "number" === typeof context ? context : 0);
                return task
            };
            var delayedFuncs = [];
            var delayedNames = [];
            var delayedDeferreds = [];
            var executingName;
            var deferExecute = function(name, func, deferred) {
                if (executingName && executingName !== name) {
                    delayedFuncs.push(func);
                    delayedNames.push(name);
                    deferred = deferred || $.Deferred();
                    delayedDeferreds.push(deferred);
                    return deferred
                } else {
                    var oldExecutingName = executingName,
                        currentDelayedCount = delayedDeferreds.length;
                    executingName = name;
                    var result = func();
                    if (!result) {
                        if (delayedDeferreds.length > currentDelayedCount) {
                            result = $.when.apply($, delayedDeferreds.slice(currentDelayedCount))
                        } else {
                            if (deferred) {
                                deferred.resolve()
                            }
                        }
                    }
                    executingName = oldExecutingName;
                    if (deferred && result && result.done) {
                        result.done(deferred.resolve).fail(deferred.reject)
                    }
                    if (!executingName && delayedFuncs.length) {
                        ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift())
                    }
                    return result
                }
            };
            var deferRender = function(func, deferred) {
                return deferExecute("render", func, deferred)
            };
            var deferUpdate = function(func, deferred) {
                return deferExecute("update", func, deferred)
            };
            var deferRenderer = function(func) {
                return function() {
                    var that = this;
                    return deferExecute("render", function() {
                        return func.call(that)
                    })
                }
            };
            var deferUpdater = function(func) {
                return function() {
                    var that = this;
                    return deferExecute("update", function() {
                        return func.call(that)
                    })
                }
            };
            var findBestMatches = function(targetFilter, items, mapFn) {
                var bestMatches = [],
                    maxMatchCount = 0;
                $.each(items, function(index, itemSrc) {
                    var matchCount = 0,
                        item = mapFn ? mapFn(itemSrc) : itemSrc;
                    $.each(targetFilter, function(paramName, targetValue) {
                        var value = item[paramName];
                        if (void 0 === value) {
                            return
                        }
                        if (match(value, targetValue)) {
                            matchCount++;
                            return
                        }
                        matchCount = -1;
                        return false
                    });
                    if (matchCount < maxMatchCount) {
                        return
                    }
                    if (matchCount > maxMatchCount) {
                        bestMatches.length = 0;
                        maxMatchCount = matchCount
                    }
                    bestMatches.push(itemSrc)
                });
                return bestMatches
            };
            var match = function(value, targetValue) {
                if ($.isArray(value) && $.isArray(targetValue)) {
                    var mismatch = false;
                    $.each(value, function(index, valueItem) {
                        if (valueItem !== targetValue[index]) {
                            mismatch = true;
                            return false
                        }
                    });
                    if (mismatch) {
                        return false
                    }
                    return true
                }
                if (value === targetValue) {
                    return true
                }
                return false
            };
            var splitPair = function(raw) {
                switch (typeof raw) {
                    case "string":
                        return raw.split(/\s+/, 2);
                    case "object":
                        return [raw.x || raw.h, raw.y || raw.v];
                    case "number":
                        return [raw];
                    default:
                        return raw
                }
            };
            var splitQuad = function(raw) {
                switch (typeof raw) {
                    case "string":
                        return raw.split(/\s+/, 4);
                    case "object":
                        return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
                    case "number":
                        return [raw];
                    default:
                        return raw
                }
            };
            var normalizeKey = function(id) {
                var key = isString(id) ? id : id.toString(),
                    arr = key.match(/[^a-zA-Z0-9]/g);
                arr && $.each(arr, function(_, sign) {
                    key = key.replace(sign, "_" + sign.charCodeAt() + "_")
                });
                return key
            };
            exports.isDefined = isDefined;
            exports.isString = isString;
            exports.isNumber = isNumber;
            exports.isObject = isObject;
            exports.isArray = isArray;
            exports.isDate = isDate;
            exports.isBoolean = isBoolean;
            exports.isFunction = isFunction;
            exports.isPrimitive = isPrimitive;
            exports.isExponential = isExponential;
            exports.ensureDefined = ensureDefined;
            exports.executeAsync = executeAsync;
            exports.deferRender = deferRender;
            exports.deferRenderer = deferRenderer;
            exports.deferUpdate = deferUpdate;
            exports.deferUpdater = deferUpdater;
            exports.splitPair = splitPair;
            exports.splitQuad = splitQuad;
            exports.findBestMatches = findBestMatches;
            exports.getDefaultAlignment = getDefaultAlignment;
            exports.normalizeKey = normalizeKey
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/core/component_registrator.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ./errors */ 10),
                MemorizedCallbacks = __webpack_require__( /*! ./memorized_callbacks */ 140);
            var callbacks = new MemorizedCallbacks;
            var registerComponent = function(name, namespace, componentClass) {
                if (!componentClass) {
                    componentClass = namespace
                } else {
                    namespace[name] = componentClass
                }
                componentClass.publicName(name);
                callbacks.fire(name, componentClass)
            };
            registerComponent.callbacks = callbacks;
            var registerJQueryComponent = function(name, componentClass) {
                $.fn[name] = function(options) {
                    var result, isMemberInvoke = "string" === typeof options;
                    if (isMemberInvoke) {
                        var memberName = options,
                            memberArgs = $.makeArray(arguments).slice(1);
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (!instance) {
                                throw errors.Error("E0009", name)
                            }
                            var member = instance[memberName],
                                memberValue = member.apply(instance, memberArgs);
                            if (void 0 === result) {
                                result = memberValue
                            }
                        })
                    } else {
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (instance) {
                                instance.option(options)
                            } else {
                                new componentClass(this, options)
                            }
                        });
                        result = this
                    }
                    return result
                }
            };
            callbacks.add(registerJQueryComponent);
            module.exports = registerComponent
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/events/utils.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                eventNS = $.event,
                hooksNS = eventNS.fixHooks;
            var eventSource = function() {
                var EVENT_SOURCES_REGEX = {
                    dx: /^dx/i,
                    mouse: /(mouse|wheel)/i,
                    touch: /^touch/i,
                    keyboard: /^key/i,
                    pointer: /^(ms)?pointer/i
                };
                return function(e) {
                    var result = "other";
                    $.each(EVENT_SOURCES_REGEX, function(key) {
                        if (this.test(e.type)) {
                            result = key;
                            return false
                        }
                    });
                    return result
                }
            }();
            var isDxEvent = function(e) {
                return "dx" === eventSource(e)
            };
            var isNativeMouseEvent = function(e) {
                return "mouse" === eventSource(e)
            };
            var isNativeTouchEvent = function(e) {
                return "touch" === eventSource(e)
            };
            var isPointerEvent = function(e) {
                return "pointer" === eventSource(e)
            };
            var isMouseEvent = function(e) {
                return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType
            };
            var isTouchEvent = function(e) {
                return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType
            };
            var isKeyboardEvent = function(e) {
                return "keyboard" === eventSource(e)
            };
            var isFakeClickEvent = function(e) {
                return 0 === e.screenX && !e.offsetX && 0 === e.pageX
            };
            var eventData = function(e) {
                return {
                    x: e.pageX,
                    y: e.pageY,
                    time: e.timeStamp
                }
            };
            var eventDelta = function(from, to) {
                return {
                    x: to.x - from.x,
                    y: to.y - from.y,
                    time: to.time - from.time || 1
                }
            };
            var hasTouches = function(e) {
                if (isNativeTouchEvent(e)) {
                    return (e.originalEvent.touches || []).length
                }
                if (isDxEvent(e)) {
                    return (e.pointers || []).length
                }
                return 0
            };
            var needSkipEvent = function(e) {
                var $target = $(e.target),
                    touchInInput = $target.is("input, textarea, select");
                if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event")) {
                    return true
                }
                if ("dxmousewheel" === e.type) {
                    return $target.is("input[type='number'], textarea, select") && $target.is(":focus")
                }
                if (isMouseEvent(e)) {
                    return touchInInput || e.which > 1
                }
                if (isTouchEvent(e)) {
                    return touchInInput && $target.is(":focus")
                }
            };
            var createEvent = function(originalEvent, args) {
                var event = $.Event(originalEvent),
                    fixHook = hooksNS[originalEvent.type] || eventNS.mouseHooks;
                var props = fixHook.props ? eventNS.props.concat(fixHook.props) : eventNS.props,
                    propIndex = props.length;
                while (propIndex--) {
                    var prop = props[propIndex];
                    event[prop] = originalEvent[prop]
                }
                if (args) {
                    $.extend(event, args)
                }
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event
            };
            var fireEvent = function(props) {
                var event = createEvent(props.originalEvent, props);
                eventNS.trigger(event, null, props.delegateTarget || event.target);
                return event
            };
            var addNamespace = function(eventNames, namespace) {
                if (!namespace) {
                    throw errors.Error("E0017")
                }
                if ("string" === typeof eventNames) {
                    if (-1 === eventNames.indexOf(" ")) {
                        return eventNames + "." + namespace
                    }
                    return addNamespace(eventNames.split(/\s+/g), namespace)
                }
                $.each(eventNames, function(index, eventName) {
                    eventNames[index] = eventName + "." + namespace
                });
                return eventNames.join(" ")
            };
            module.exports = {
                eventSource: eventSource,
                isPointerEvent: isPointerEvent,
                isMouseEvent: isMouseEvent,
                isTouchEvent: isTouchEvent,
                isKeyboardEvent: isKeyboardEvent,
                isFakeClickEvent: isFakeClickEvent,
                hasTouches: hasTouches,
                eventData: eventData,
                eventDelta: eventDelta,
                needSkipEvent: needSkipEvent,
                createEvent: createEvent,
                fireEvent: fireEvent,
                addNamespace: addNamespace
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/core/class.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errors = __webpack_require__( /*! ./errors */ 10);
            var wrapOverridden = function(baseProto, methodName, method) {
                return function() {
                    var prevCallBase = this.callBase;
                    this.callBase = baseProto[methodName];
                    try {
                        return method.apply(this, arguments)
                    } finally {
                        this.callBase = prevCallBase
                    }
                }
            };
            var clonePrototype = function(obj) {
                var func = function() {};
                func.prototype = obj.prototype;
                return new func
            };
            var redefine = function(members) {
                var overridden, memberName, member, that = this;
                if (!members) {
                    return that
                }
                for (memberName in members) {
                    member = members[memberName];
                    overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
                    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member
                }
                return that
            };
            var include = function() {
                var argument, name, i, classObj = this;
                for (i = 0; i < arguments.length; i++) {
                    argument = arguments[i];
                    if (argument.ctor) {
                        classObj._includedCtors.push(argument.ctor)
                    }
                    if (argument.postCtor) {
                        classObj._includedPostCtors.push(argument.postCtor)
                    }
                    for (name in argument) {
                        if ("ctor" === name || "postCtor" === name) {
                            continue
                        }
                        if (name in classObj.prototype) {
                            throw errors.Error("E0002", name)
                        }
                        classObj.prototype[name] = argument[name]
                    }
                }
                return classObj
            };
            var subclassOf = function(parentClass) {
                if (this.parent === parentClass) {
                    return true
                }
                if (!this.parent || !this.parent.subclassOf) {
                    return false
                }
                return this.parent.subclassOf(parentClass)
            };
            var abstract = function() {
                throw errors.Error("E0001")
            };
            var copyStatic = function() {
                var hasOwn = Object.prototype.hasOwnProperty;
                return function(source, destination) {
                    for (var key in source) {
                        if (!hasOwn.call(source, key)) {
                            return
                        }
                        destination[key] = source[key]
                    }
                }
            }();
            var classImpl = function() {};
            classImpl.inherit = function(members) {
                var inheritor = function() {
                    if (!this || this === window || "function" !== typeof this.constructor) {
                        throw errors.Error("E0003")
                    }
                    var i, instance = this,
                        ctor = instance.ctor,
                        includedCtors = instance.constructor._includedCtors,
                        includedPostCtors = instance.constructor._includedPostCtors;
                    for (i = 0; i < includedCtors.length; i++) {
                        includedCtors[i].call(instance)
                    }
                    if (ctor) {
                        ctor.apply(instance, arguments)
                    }
                    for (i = 0; i < includedPostCtors.length; i++) {
                        includedPostCtors[i].call(instance)
                    }
                };
                inheritor.prototype = clonePrototype(this);
                copyStatic(this, inheritor);
                inheritor.inherit = this.inherit;
                inheritor.abstract = abstract;
                inheritor.redefine = redefine;
                inheritor.include = include;
                inheritor.subclassOf = subclassOf;
                inheritor.parent = this;
                inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
                inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
                inheritor.prototype.constructor = inheritor;
                inheritor.redefine(members);
                return inheritor
            };
            classImpl.abstract = abstract;
            module.exports = classImpl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/viz/core/utils.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _inArray = $.inArray,
                _each = $.each,
                _math = Math,
                _round = _math.round,
                _sqrt = Math.sqrt,
                _extend = $.extend;
            var PI = Math.PI,
                MAX_PIXEL_COUNT = 1e10,
                PI_DIV_180 = PI / 180,
                LN10 = Math.LN10;
            var cosFunc = Math.cos,
                sinFunc = Math.sin,
                abs = Math.abs,
                log = Math.log,
                floor = Math.floor,
                ceil = Math.ceil,
                max = Math.max,
                isNaN = window.isNaN,
                Number = window.Number,
                NaN = window.NaN;
            var isNumber = commonUtils.isNumber,
                isExponential = commonUtils.isExponential;
            var getPrecision = function(value) {
                var stringFraction, startIndex, precision, stringValue = value.toString(),
                    pointIndex = stringValue.indexOf(".");
                if (isExponential(value)) {
                    precision = getDecimalOrder(value);
                    if (precision < 0) {
                        return Math.abs(precision)
                    } else {
                        return 0
                    }
                }
                if (-1 !== pointIndex) {
                    startIndex = pointIndex + 1;
                    stringFraction = stringValue.substring(startIndex, startIndex + 20);
                    return stringFraction.length
                }
                return 0
            };
            var getLog = function(value, base) {
                if (!value) {
                    return NaN
                }
                return Math.log(value) / Math.log(base)
            };
            var raiseTo = function(power, base) {
                return Math.pow(base, power)
            };
            var normalizeAngle = function(angle) {
                return (angle % 360 + 360) % 360
            };
            var convertAngleToRendererSpace = function(angle) {
                return 90 - angle
            };
            var degreesToRadians = function(value) {
                return PI * value / 180
            };
            var getCosAndSin = function(angle) {
                var angleInRadians = degreesToRadians(angle);
                return {
                    cos: cosFunc(angleInRadians),
                    sin: sinFunc(angleInRadians)
                }
            };
            var DECIMAL_ORDER_THRESHOLD = 1e-14;
            var getDistance = function(x1, y1, x2, y2) {
                var diffX = x2 - x1,
                    diffY = y2 - y1;
                return Math.sqrt(diffY * diffY + diffX * diffX)
            };
            var getDecimalOrder = function(number) {
                var cn, n = abs(number);
                if (!isNaN(n)) {
                    if (n > 0) {
                        n = log(n) / LN10;
                        cn = ceil(n);
                        return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                    }
                    return 0
                }
                return NaN
            };
            var getAppropriateFormat = function(start, end, count) {
                var format, order = max(getDecimalOrder(start), getDecimalOrder(end)),
                    precision = -getDecimalOrder(abs(end - start) / count);
                if (!isNaN(order) && !isNaN(precision)) {
                    if (abs(order) <= 4) {
                        format = "fixedPoint";
                        precision < 0 && (precision = 0);
                        precision > 4 && (precision = 4)
                    } else {
                        format = "exponential";
                        precision += order - 1;
                        precision > 3 && (precision = 3)
                    }
                    return {
                        type: format,
                        precision: precision
                    }
                }
                return null
            };
            var getFraction = function(value) {
                var valueString, dotIndex;
                if (isNumber(value)) {
                    valueString = value.toString();
                    dotIndex = valueString.indexOf(".");
                    if (dotIndex >= 0) {
                        if (isExponential(value)) {
                            return valueString.substr(dotIndex + 1, valueString.indexOf("e") - dotIndex - 1)
                        } else {
                            valueString = value.toFixed(20);
                            return valueString.substr(dotIndex + 1, valueString.length - dotIndex + 1)
                        }
                    }
                }
                return ""
            };
            var getSignificantDigitPosition = function(value) {
                var i, fraction = getFraction(value);
                if (fraction) {
                    for (i = 0; i < fraction.length; i++) {
                        if ("0" !== fraction.charAt(i)) {
                            return i + 1
                        }
                    }
                }
                return 0
            };
            var adjustValue = function(value) {
                var nextValue, i, fraction = getFraction(value);
                if (fraction) {
                    for (i = 1; i <= fraction.length; i++) {
                        nextValue = roundValue(value, i);
                        if (0 !== nextValue && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1]) {
                            return nextValue
                        }
                    }
                }
                return value
            };
            var roundValue = function(value, precision) {
                if (precision > 20) {
                    precision = 20
                }
                if (isNumber(value)) {
                    if (isExponential(value)) {
                        return Number(value.toExponential(precision))
                    } else {
                        return Number(value.toFixed(precision))
                    }
                }
            };
            var applyPrecisionByMinDelta = function(min, delta, value) {
                var minPrecision = getPrecision(min),
                    deltaPrecision = getPrecision(delta);
                return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
            };
            var getPower = function(value) {
                return value.toExponential().split("e")[1]
            };

            function map(array, callback) {
                var value, i = 0,
                    len = array.length,
                    ret = [];
                while (i < len) {
                    value = callback(array[i], i);
                    if (null !== value) {
                        ret.push(value)
                    }
                    i++
                }
                return ret
            }

            function selectByKeys(object, keys) {
                return map(keys, function(key) {
                    return object[key] ? object[key] : null
                })
            }

            function decreaseFields(object, keys, eachDecrease, decrease) {
                var dec = decrease;
                _each(keys, function(_, key) {
                    if (object[key]) {
                        object[key] -= eachDecrease;
                        dec -= eachDecrease
                    }
                });
                return dec
            }

            function normalizeEnum(value) {
                return String(value).toLowerCase()
            }

            function setCanvasValues(canvas) {
                if (canvas) {
                    canvas.originalTop = canvas.top;
                    canvas.originalBottom = canvas.bottom;
                    canvas.originalLeft = canvas.left;
                    canvas.originalRight = canvas.right
                }
            }

            function normalizeBBoxField(value) {
                return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0
            }

            function normalizeBBox(bbox) {
                var rxl = normalizeBBoxField(floor(bbox.x)),
                    ryt = normalizeBBoxField(floor(bbox.y)),
                    rxr = normalizeBBoxField(ceil(bbox.width + bbox.x)),
                    ryb = normalizeBBoxField(ceil(bbox.height + bbox.y)),
                    result = {
                        x: rxl,
                        y: ryt,
                        width: rxr - rxl,
                        height: ryb - ryt
                    };
                result.isEmpty = !result.x && !result.y && !result.width && !result.height;
                return result
            }

            function rotateBBox(bbox, center, angle) {
                var cos = Number(cosFunc(angle * PI_DIV_180).toFixed(3)),
                    sin = Number(sinFunc(angle * PI_DIV_180).toFixed(3)),
                    w2 = bbox.width / 2,
                    h2 = bbox.height / 2,
                    xc = bbox.x + w2,
                    yc = bbox.y + h2,
                    w2_ = abs(w2 * cos) + abs(h2 * sin),
                    h2_ = abs(w2 * sin) + abs(h2 * cos),
                    xc_ = center[0] + (xc - center[0]) * cos + (yc - center[1]) * sin,
                    yc_ = center[1] - (xc - center[0]) * sin + (yc - center[1]) * cos;
                return normalizeBBox({
                    x: xc_ - w2_,
                    y: yc_ - h2_,
                    width: 2 * w2_,
                    height: 2 * h2_
                })
            }
            $.extend(exports, {
                decreaseGaps: function(object, keys, decrease) {
                    var arrayGaps;
                    do {
                        arrayGaps = selectByKeys(object, keys);
                        arrayGaps.push(_math.ceil(decrease / arrayGaps.length));
                        decrease = decreaseFields(object, keys, _math.min.apply(null, arrayGaps), decrease)
                    } while (decrease > 0 && arrayGaps.length > 1);
                    return decrease
                },
                normalizeEnum: normalizeEnum,
                parseScalar: function(value, defaultValue) {
                    return void 0 !== value ? value : defaultValue
                },
                enumParser: function(values) {
                    var i, ii, stored = {};
                    for (i = 0, ii = values.length; i < ii; ++i) {
                        stored[normalizeEnum(values[i])] = 1
                    }
                    return function(value, defaultValue) {
                        var _value = normalizeEnum(value);
                        return stored[_value] ? _value : defaultValue
                    }
                },
                patchFontOptions: function(options) {
                    var fontOptions = {};
                    _each(options || {}, function(key, value) {
                        if (/^(cursor|opacity)$/i.test(key)) {} else {
                            if ("color" === key) {
                                key = "fill"
                            } else {
                                key = "font-" + key
                            }
                        }
                        fontOptions[key] = value
                    });
                    return fontOptions
                },
                convertPolarToXY: function(centerCoords, startAngle, angle, radius) {
                    var cossin, shiftAngle = 90;
                    angle = _isDefined(angle) ? angle + startAngle - shiftAngle : 0;
                    cossin = getCosAndSin(angle);
                    return {
                        x: _round(centerCoords.x + radius * cossin.cos),
                        y: _round(centerCoords.y + radius * cossin.sin)
                    }
                },
                convertXYToPolar: function(centerCoords, x, y) {
                    var radius = getDistance(centerCoords.x, centerCoords.y, x, y),
                        angle = _math.atan2(y - centerCoords.y, x - centerCoords.x);
                    return {
                        phi: _round(normalizeAngle(180 * angle / _math.PI)),
                        r: _round(radius)
                    }
                },
                processSeriesTemplate: function(seriesTemplate, items) {
                    var series, length, data, customizeSeries = commonUtils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : $.noop,
                        nameField = seriesTemplate.nameField || "series",
                        generatedSeries = {},
                        seriesOrder = [],
                        i = 0;
                    for (length = items.length; i < length; i++) {
                        data = items[i];
                        if (nameField in data) {
                            series = generatedSeries[data[nameField]];
                            if (!series) {
                                series = generatedSeries[data[nameField]] = {
                                    name: data[nameField],
                                    data: []
                                };
                                seriesOrder.push(series.name)
                            }
                            series.data.push(data)
                        }
                    }
                    return map(seriesOrder, function(orderedName) {
                        var group = generatedSeries[orderedName];
                        return $.extend(group, customizeSeries.call(null, group.name))
                    })
                },
                getCategoriesInfo: function(categories, startValue, endValue) {
                    if (!(categories && categories.length > 0)) {
                        return {}
                    }
                    startValue = _isDefined(startValue) ? startValue : categories[0];
                    endValue = _isDefined(endValue) ? endValue : categories[categories.length - 1];
                    var visibleCategories, swapBuf, hasVisibleCategories, visibleCategoriesLen, categoriesValue = map(categories, function(category) {
                            return _isDefined(category) ? category.valueOf() : null
                        }),
                        indexStartValue = _isDefined(startValue) ? _inArray(startValue.valueOf(), categoriesValue) : 0,
                        indexEndValue = _isDefined(endValue) ? _inArray(endValue.valueOf(), categoriesValue) : categories.length - 1,
                        inverted = false;
                    indexStartValue < 0 && (indexStartValue = 0);
                    indexEndValue < 0 && (indexEndValue = categories.length - 1);
                    if (indexEndValue < indexStartValue) {
                        swapBuf = indexEndValue;
                        indexEndValue = indexStartValue;
                        indexStartValue = swapBuf;
                        inverted = true
                    }
                    visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
                    visibleCategoriesLen = visibleCategories.length;
                    hasVisibleCategories = visibleCategoriesLen > 0;
                    return {
                        categories: hasVisibleCategories ? visibleCategories : null,
                        start: hasVisibleCategories ? visibleCategories[inverted ? visibleCategoriesLen - 1 : 0] : null,
                        end: hasVisibleCategories ? visibleCategories[inverted ? 0 : visibleCategoriesLen - 1] : null,
                        inverted: inverted
                    }
                },
                setCanvasValues: setCanvasValues,
                updatePanesCanvases: function(panes, canvas, rotated) {
                    var weightSum = 0;
                    _each(panes, function(_, pane) {
                        pane.weight = pane.weight || 1;
                        weightSum += pane.weight
                    });
                    var distributedSpace = 0,
                        padding = panes.padding || 10,
                        paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom,
                        oneWeight = (paneSpace - padding * (panes.length - 1)) / weightSum,
                        startName = rotated ? "left" : "top",
                        endName = rotated ? "right" : "bottom";
                    _each(panes, function(_, pane) {
                        var calcLength = _round(pane.weight * oneWeight);
                        pane.canvas = pane.canvas || {};
                        _extend(pane.canvas, {
                            deltaLeft: 0,
                            deltaRight: 0,
                            deltaTop: 0,
                            deltaBottom: 0
                        }, canvas);
                        pane.canvas[startName] = canvas[startName] + distributedSpace;
                        pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
                        distributedSpace = distributedSpace + calcLength + padding;
                        setCanvasValues(pane.canvas)
                    })
                },
                unique: function(array) {
                    var values = {};
                    return map(array, function(item) {
                        var result = !values[item] ? item : null;
                        values[item] = true;
                        return result
                    })
                },
                map: map,
                getVerticallyShiftedAngularCoords: function(bbox, dy, center) {
                    var isPositive = bbox.x + bbox.width / 2 >= center.x,
                        dx1 = (isPositive ? bbox.x : bbox.x + bbox.width) - center.x,
                        dy1 = bbox.y - center.y,
                        dy2 = dy1 + dy,
                        dx2 = _round(_sqrt(dx1 * dx1 + dy1 * dy1 - dy2 * dy2)),
                        dx = (isPositive ? +dx2 : -dx2) || dx1;
                    return {
                        x: center.x + (isPositive ? dx : dx - bbox.width),
                        y: bbox.y + dy
                    }
                }
            });
            exports.getPrecision = getPrecision;
            exports.getLog = getLog;
            exports.raiseTo = raiseTo;
            exports.normalizeAngle = normalizeAngle;
            exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
            exports.degreesToRadians = degreesToRadians;
            exports.getCosAndSin = getCosAndSin;
            exports.getDecimalOrder = getDecimalOrder;
            exports.getAppropriateFormat = getAppropriateFormat;
            exports.getDistance = getDistance;
            exports.getFraction = getFraction;
            exports.adjustValue = adjustValue;
            exports.roundValue = roundValue;
            exports.applyPrecisionByMinDelta = applyPrecisionByMinDelta;
            exports.getSignificantDigitPosition = getSignificantDigitPosition;
            exports.getPower = getPower;
            exports.rotateBBox = rotateBBox;
            exports.normalizeBBox = normalizeBBox
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/core/devices.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ./class */ 5),
                errors = __webpack_require__( /*! ./errors */ 10),
                resizeCallbacks = __webpack_require__( /*! ./utils/window */ 57).resizeCallbacks,
                EventsMixin = __webpack_require__( /*! ./events_mixin */ 32),
                SessionStorage = __webpack_require__( /*! ./utils/storage */ 122).sessionStorage,
                viewPort = __webpack_require__( /*! ./utils/view_port */ 52),
                Config = __webpack_require__( /*! ./config */ 35);
            var KNOWN_UA_TABLE = {
                iPhone: "iPhone",
                iPhone5: "iPhone",
                iPhone6: "iPhone",
                iPhone6plus: "iPhone",
                iPad: "iPad",
                iPadMini: "iPad Mini",
                androidPhone: "Android Mobile",
                androidTablet: "Android",
                win8: "MSAppHost",
                win8Phone: "Windows Phone 8.0",
                msSurface: "MSIE ARM Tablet PC",
                desktop: "desktop",
                win10Phone: "Windows Phone 10.0",
                win10: "MSAppHost/3.0"
            };
            var DEFAULT_DEVICE = {
                deviceType: "desktop",
                platform: "generic",
                version: [],
                phone: false,
                tablet: false,
                android: false,
                ios: false,
                win: false,
                generic: true,
                grade: "A",
                mac: false
            };
            var uaParsers = {
                win: function(userAgent) {
                    var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/),
                        isTablet = !isPhone && /arm(.*)trident/i.test(userAgent),
                        isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
                    if (!(isPhone || isTablet || isDesktop)) {
                        return
                    }
                    var matches = userAgent.match(/windows phone (\d+).(\d+)/i) || userAgent.match(/windows nt (\d+).(\d+)/i),
                        version = [];
                    if (matches) {
                        version.push(parseInt(matches[1], 10), parseInt(matches[2], 10))
                    } else {
                        matches = userAgent.match(/msapphost(\/(\d+).(\d+))?/i);
                        matches && version.push(3 === parseInt(matches[2], 10) ? 10 : 8)
                    }
                    return {
                        deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
                        platform: "win",
                        version: version,
                        grade: "A"
                    }
                },
                ios: function(userAgent) {
                    if (!/ip(hone|od|ad)/i.test(userAgent)) {
                        return
                    }
                    var isPhone = /ip(hone|od)/i.test(userAgent),
                        matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i),
                        version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
                        isIPhone4 = 480 === window.screen.height,
                        grade = isIPhone4 ? "B" : "A";
                    return {
                        deviceType: isPhone ? "phone" : "tablet",
                        platform: "ios",
                        version: version,
                        grade: grade
                    }
                },
                android: function(userAgent) {
                    if (!/android|htc_|silk/i.test(userAgent)) {
                        return
                    }
                    var isPhone = /mobile/i.test(userAgent),
                        matches = userAgent.match(/android (\d+)\.(\d+)\.?(\d+)?/i),
                        version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
                        worseThan4_4 = version.length > 1 && (version[0] < 4 || 4 === version[0] && version[1] < 4),
                        grade = worseThan4_4 ? "B" : "A";
                    return {
                        deviceType: isPhone ? "phone" : "tablet",
                        platform: "android",
                        version: version,
                        grade: grade
                    }
                }
            };
            var Devices = Class.inherit({
                ctor: function(options) {
                    this._window = options && options.window || window;
                    this._realDevice = this._getDevice();
                    this._currentDevice = void 0;
                    this._currentOrientation = void 0;
                    this.changed = $.Callbacks();
                    this._recalculateOrientation();
                    resizeCallbacks.add($.proxy(this._recalculateOrientation, this))
                },
                current: function(deviceOrName) {
                    if (deviceOrName) {
                        this._currentDevice = this._getDevice(deviceOrName);
                        this._forced = true;
                        this.changed.fire();
                        if ("win" === this._currentDevice.platform && 8 === this._currentDevice.version[0]) {
                            errors.log("W0010", "the 'win8' theme", "16.1", "Use the 'win10' theme instead.")
                        }
                        return
                    }
                    if (!this._currentDevice) {
                        deviceOrName = void 0;
                        try {
                            deviceOrName = this._getDeviceOrNameFromWindowScope()
                        } catch (e) {
                            deviceOrName = this._getDeviceNameFromSessionStorage()
                        } finally {
                            if (!deviceOrName) {
                                deviceOrName = this._getDeviceNameFromSessionStorage()
                            }
                            if (deviceOrName) {
                                this._forced = true
                            }
                        }
                        this._currentDevice = this._getDevice(deviceOrName)
                    }
                    return this._currentDevice
                },
                real: function() {
                    var forceDevice = arguments[0];
                    if ($.isPlainObject(forceDevice)) {
                        $.extend(this._realDevice, forceDevice);
                        return
                    }
                    return $.extend({}, this._realDevice)
                },
                orientation: function() {
                    return this._currentOrientation
                },
                isForced: function() {
                    return this._forced
                },
                isRippleEmulator: function() {
                    return !!this._window.tinyHippos
                },
                _getCssClasses: function(device) {
                    var result = [];
                    var realDevice = this._realDevice;
                    device = device || this.current();
                    if (device.deviceType) {
                        result.push("dx-device-" + device.deviceType);
                        if ("desktop" !== device.deviceType) {
                            result.push("dx-device-mobile")
                        }
                    }
                    result.push("dx-device-" + realDevice.platform);
                    if (realDevice.version && realDevice.version.length) {
                        result.push("dx-device-" + realDevice.platform + "-" + realDevice.version[0])
                    }
                    if (devices.isSimulator()) {
                        result.push("dx-simulator")
                    }
                    if (Config().rtlEnabled) {
                        result.push("dx-rtl")
                    }
                    return result
                },
                attachCssClasses: function(element, device) {
                    this._deviceClasses = this._getCssClasses(device).join(" ");
                    $(element).addClass(this._deviceClasses)
                },
                detachCssClasses: function(element) {
                    $(element).removeClass(this._deviceClasses)
                },
                isSimulator: function() {
                    try {
                        return this._isSimulator || this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
                    } catch (e) {
                        return false
                    }
                },
                forceSimulator: function() {
                    this._isSimulator = true
                },
                _getDevice: function(deviceName) {
                    if ("genericPhone" === deviceName) {
                        deviceName = {
                            deviceType: "phone",
                            platform: "generic",
                            generic: true
                        }
                    }
                    if ($.isPlainObject(deviceName)) {
                        return this._fromConfig(deviceName)
                    } else {
                        var ua;
                        if (deviceName) {
                            ua = KNOWN_UA_TABLE[deviceName];
                            if (!ua) {
                                throw errors.Error("E0005")
                            }
                        } else {
                            ua = navigator.userAgent
                        }
                        return this._fromUA(ua)
                    }
                },
                _getDeviceOrNameFromWindowScope: function() {
                    var result;
                    if (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]) {
                        result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]
                    }
                    return result
                },
                _getDeviceNameFromSessionStorage: function() {
                    var sessionStorage = SessionStorage();
                    if (!sessionStorage) {
                        return
                    }
                    var deviceOrName = sessionStorage.getItem("dx-force-device");
                    try {
                        return $.parseJSON(deviceOrName)
                    } catch (ex) {
                        return deviceOrName
                    }
                },
                _fromConfig: function(config) {
                    var result = $.extend({}, DEFAULT_DEVICE, this._currentDevice, config),
                        shortcuts = {
                            phone: "phone" === result.deviceType,
                            tablet: "tablet" === result.deviceType,
                            android: "android" === result.platform,
                            ios: "ios" === result.platform,
                            win: "win" === result.platform,
                            generic: "generic" === result.platform
                        };
                    return $.extend(result, shortcuts)
                },
                _fromUA: function(ua) {
                    var config;
                    $.each(uaParsers, function(platform, parser) {
                        config = parser(ua);
                        return !config
                    });
                    if (config) {
                        return this._fromConfig(config)
                    }
                    var isMac = /(mac os)/.test(ua.toLowerCase()),
                        deviceWithOS = DEFAULT_DEVICE;
                    deviceWithOS.mac = isMac;
                    return deviceWithOS
                },
                _changeOrientation: function() {
                    var $window = $(this._window),
                        orientation = $window.height() > $window.width() ? "portrait" : "landscape";
                    if (this._currentOrientation === orientation) {
                        return
                    }
                    this._currentOrientation = orientation;
                    this.fireEvent("orientationChanged", [{
                        orientation: orientation
                    }])
                },
                _recalculateOrientation: function() {
                    var windowWidth = $(this._window).width();
                    if (this._currentWidth === windowWidth) {
                        return
                    }
                    this._currentWidth = windowWidth;
                    this._changeOrientation()
                }
            }).include(EventsMixin);
            var devices = new Devices;
            viewPort.changeCallback.add(function(viewPort, prevViewport) {
                devices.detachCssClasses(prevViewport);
                devices.attachCssClasses(viewPort)
            });
            if (!devices.isForced() && "win" === devices.current().platform) {
                devices.current({
                    version: [10]
                })
            }
            module.exports = devices
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/localization/message.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dependencyInjector = __webpack_require__( /*! ../core/utils/dependency_injector */ 80),
                stringFormat = __webpack_require__( /*! ../core/utils/string */ 26).format,
                humanize = __webpack_require__( /*! ../core/utils/inflector */ 29).humanize;
            __webpack_require__( /*! ./core */ 217);
            var baseDictionary = $.extend(true, {}, __webpack_require__( /*! ./en/core.en */ 296), __webpack_require__( /*! ./en/widgets-base.en */ 297), __webpack_require__( /*! ./en/widgets-mobile.en */ 298), __webpack_require__( /*! ./en/widgets-web.en */ 299));
            var newMessages = {};
            var messageLocalization = dependencyInjector({
                _dictionary: baseDictionary,
                locale: function() {
                    var currentLocale = "en";
                    return function(locale) {
                        if (!locale) {
                            return currentLocale
                        }
                        currentLocale = locale
                    }
                }(),
                load: function(messages) {
                    $.extend(true, this._dictionary, messages)
                },
                _localizablePrefix: "@",
                setup: function(localizablePrefix) {
                    this._localizablePrefix = localizablePrefix
                },
                localizeString: function(text) {
                    var that = this,
                        regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"),
                        escapeString = that._localizablePrefix + that._localizablePrefix;
                    return text.replace(regex, function(str, prefix, escape, localizationKey) {
                        var result, defaultResult = that._localizablePrefix + localizationKey;
                        if (escape !== escapeString) {
                            result = that.format(localizationKey)
                        }
                        if (!result) {
                            newMessages[localizationKey] = humanize(localizationKey)
                        }
                        return prefix + (result || defaultResult)
                    })
                },
                _messageLoaded: function(key, locale) {
                    return void 0 !== this._dictionary[locale || this.locale()][key]
                },
                localizeNode: function(node) {
                    var that = this;
                    $(node).each(function(index, nodeItem) {
                        if (!nodeItem.nodeType) {
                            return
                        }
                        if (3 === nodeItem.nodeType) {
                            nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue)
                        } else {
                            if (!$(nodeItem).is("iframe")) {
                                $.each(nodeItem.attributes || [], function(index, attr) {
                                    if ("string" === typeof attr.value) {
                                        var localizedValue = that.localizeString(attr.value);
                                        if (attr.value !== localizedValue) {
                                            attr.value = localizedValue
                                        }
                                    }
                                });
                                $(nodeItem).contents().each(function(index, node) {
                                    that.localizeNode(node)
                                })
                            }
                        }
                    })
                },
                getMessagesByLocales: function() {
                    return this._dictionary
                },
                getDictionary: function(onlyNew) {
                    if (onlyNew) {
                        return newMessages
                    }
                    return $.extend({}, newMessages, this.getMessagesByLocales()[this.locale()])
                },
                getFormatter: function(key, locale) {
                    var localeMessages = this._dictionary[locale || this.locale()],
                        message = localeMessages && localeMessages[key];
                    if (message) {
                        return function() {
                            var args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
                            args.unshift(message);
                            return stringFormat.apply(this, args)
                        }
                    }
                },
                format: function(key) {
                    var formatter = this.getFormatter(key);
                    return formatter && formatter() || ""
                }
            });
            module.exports = messageLocalization
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/events/click.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                domUtils = __webpack_require__( /*! ../core/utils/dom */ 11),
                animationFrame = __webpack_require__( /*! ../animation/frame */ 75),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                pointerEvents = __webpack_require__( /*! ./pointer */ 13),
                Emitter = __webpack_require__( /*! ./core/emitter */ 81),
                registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 61);
            var CLICK_EVENT_NAME = "dxclick",
                TOUCH_BOUNDARY = 10,
                abs = Math.abs;
            var isInput = function(element) {
                return $(element).is("input, textarea, select, button ,:focus, :focus *")
            };
            var misc = {
                requestAnimationFrame: animationFrame.requestAnimationFrame
            };
            var ClickEmitter = Emitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this._makeElementClickable($(element))
                },
                _makeElementClickable: function($element) {
                    if (!$element.attr("onclick")) {
                        $element.attr("onclick", "void(0)")
                    }
                },
                start: function(e) {
                    this._blurPrevented = e.isDefaultPrevented();
                    this._startTarget = e.target;
                    this._startEventData = eventUtils.eventData(e)
                },
                end: function(e) {
                    if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointerEvents.cancel) {
                        this._cancel(e);
                        return
                    }
                    if (!isInput(e.target) && !this._blurPrevented) {
                        domUtils.resetActiveElement()
                    }
                    this._accept(e);
                    misc.requestAnimationFrame($.proxy(function() {
                        this._fireClickEvent(e)
                    }, this))
                },
                _eventOutOfElement: function(e, element) {
                    var target = e.target,
                        targetChanged = !$.contains(element, target) && element !== target,
                        gestureDelta = eventUtils.eventDelta(eventUtils.eventData(e), this._startEventData),
                        boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
                    return targetChanged || boundsExceeded
                },
                _fireClickEvent: function(e) {
                    this._fireEvent(CLICK_EVENT_NAME, e, {
                        target: domUtils.closestCommonParent(this._startTarget, e.target)
                    })
                }
            });
            ! function() {
                var NATIVE_CLICK_CLASS = "dx-native-click";
                var useNativeClick = devices.real().generic;
                var prevented = null;

                function isNativeClickEvent(e) {
                    return useNativeClick || $(e.target).closest("." + NATIVE_CLICK_CLASS).length
                }
                ClickEmitter = ClickEmitter.inherit({
                    configurate: function(data) {
                        this.callBase(data);
                        if (data.useNative) {
                            this.getElement().addClass(NATIVE_CLICK_CLASS)
                        }
                    },
                    start: function(e) {
                        prevented = null;
                        if (!isNativeClickEvent(e)) {
                            this.callBase(e)
                        }
                    },
                    end: function(e) {
                        if (!isNativeClickEvent(e)) {
                            this.callBase(e)
                        }
                    },
                    cancel: function() {
                        prevented = true
                    }
                });
                var clickHandler = function(e) {
                    if ((!e.which || 1 === e.which) && !prevented && isNativeClickEvent(e)) {
                        eventUtils.fireEvent({
                            type: CLICK_EVENT_NAME,
                            originalEvent: e
                        })
                    }
                };
                $(document).on(eventUtils.addNamespace("click", "NATIVE_DXCLICK_STRATEGY"), clickHandler);
                exports.useNativeClick = useNativeClick
            }();
            ! function() {
                var desktopDevice = devices.real().generic;
                if (!desktopDevice) {
                    var startTarget = null,
                        blurPrevented = false;
                    var pointerDownHandler = function(e) {
                        startTarget = e.target;
                        blurPrevented = e.isDefaultPrevented()
                    };
                    var clickHandler = function(e) {
                        var $target = $(e.target);
                        if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target)) {
                            domUtils.resetActiveElement()
                        }
                        startTarget = null;
                        blurPrevented = false
                    };
                    var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
                    $(document).on(eventUtils.addNamespace(pointerEvents.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler).on(eventUtils.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
                }
            }();
            registerEmitter({
                emitter: ClickEmitter,
                bubble: true,
                events: [CLICK_EVENT_NAME]
            });
            exports.name = CLICK_EVENT_NAME;
            exports.misc = misc
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************!*\
      !*** ./Scripts/core/errors.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errorUtils = __webpack_require__( /*! ./utils/error */ 94);
            module.exports = errorUtils({
                E0001: "Method is not implemented",
                E0002: "Member name collision: {0}",
                E0003: "A class must be instantiated using the 'new' keyword",
                E0004: "The NAME property of the component is not specified",
                E0005: "Unknown device",
                E0006: "Unknown endpoint key is requested",
                E0007: "'Invalidate' method is called outside the update transaction",
                E0008: "Type of the option name is not appropriate to create an action",
                E0009: "Component '{0}' has not been initialized for an element",
                E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
                E0011: "Unknown animation type '{0}'",
                E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
                E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
                E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
                E0015: "Queued task returned an unexpected result",
                E0017: "Event namespace is not defined",
                E0018: "DevExpress.ui.DevExpressPopup widget is required",
                E0020: "Template engine '{0}' is not supported",
                E0021: "Unknown theme is set: {0}",
                E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
                E0023: "Template name is not specified",
                E0100: "Unknown validation type is detected",
                E0101: "Misconfigured range validation rule is detected",
                E0102: "Misconfigured comparison validation rule is detected",
                E0110: "Unknown validation group is detected",
                E0120: "Adapter for a DevExpressValidator component cannot be configured",
                E0121: "The onCustomItemCreating action should return an item or Promise of jQuery Deferred object resolved when an item is created",
                E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
                W0000: "'{0}' is deprecated in {1}. {2}",
                W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
                W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
                W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
                W0004: "Timeout for theme loading is over: {0}",
                W0005: "'{0}' event is deprecated in {1}. {2}",
                W0006: "Invalid recurrence rule: '{0}'",
                W0008: "Invalid view name: '{0}'",
                W0009: "Invalid time zone name: '{0}'",
                W0010: "{0} is deprecated in {1}. {2}",
                W0011: "Number parsing is invoked while the parser is not defined",
                W0012: "Date parsing is invoked while the parser is not defined"
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/core/utils/dom.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../errors */ 10),
                commonUtils = __webpack_require__( /*! ./common */ 2);
            var resetActiveElement = function() {
                var activeElement = document.activeElement;
                if (activeElement && activeElement !== document.body && activeElement.blur) {
                    activeElement.blur()
                }
            };
            var getSelection = function() {
                if (window.getSelection) {
                    return window.getSelection()
                }
                if (document.selection) {
                    return document.selection
                }
                return null
            };
            var clearSelection = function() {
                var selection = getSelection();
                if (!selection) {
                    return
                }
                if ("Caret" === selection.type) {
                    return
                }
                if (selection.empty) {
                    selection.empty()
                } else {
                    if (selection.removeAllRanges) {
                        selection.removeAllRanges()
                    }
                }
            };
            var closestCommonParent = function(startTarget, endTarget) {
                var $startParents = $(startTarget).parents().addBack(),
                    $endParents = $(endTarget).parents().addBack(),
                    startingParent = Math.min($startParents.length, $endParents.length) - 1;
                for (var i = startingParent; i >= 0; i--) {
                    if ($startParents.eq(i).is($endParents.eq(i))) {
                        return $startParents.get(i)
                    }
                }
            };
            var triggerVisibilityChangeEvent = function(eventName) {
                var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
                return function(element) {
                    var $element = $(element || "body");
                    var $changeHandlers = $element.find(VISIBILITY_CHANGE_SELECTOR).add($element.filter(VISIBILITY_CHANGE_SELECTOR));
                    $changeHandlers.each(function() {
                        $(this).triggerHandler(eventName)
                    })
                }
            };
            var uniqueId = function() {
                var counter = 0;
                return function(prefix) {
                    return (prefix || "") + counter++
                }
            }();
            var dataOptionsAttributeName = "data-options";
            var getElementOptions = function(element) {
                var result, optionsString = $(element).attr(dataOptionsAttributeName);
                if ("{" !== $.trim(optionsString).charAt(0)) {
                    optionsString = "{" + optionsString + "}"
                }
                try {
                    result = new Function("return " + optionsString)()
                } catch (ex) {
                    throw errors.Error("E3018", ex, optionsString)
                }
                return result
            };
            var createComponents = function(elements, componentTypes) {
                var result = [],
                    selector = "[" + dataOptionsAttributeName + "]";
                elements.find(selector).addBack(selector).each(function(index, element) {
                    var $element = $(element),
                        options = getElementOptions(element);
                    for (var componentName in options) {
                        if (!componentTypes || $.inArray(componentName, componentTypes) > -1) {
                            if ($element[componentName]) {
                                $element[componentName](options[componentName]);
                                result.push($element[componentName]("instance"))
                            }
                        }
                    }
                });
                return result
            };
            var createMarkupFromString = function(str) {
                if (!window.WinJS) {
                    return $(str)
                }
                var tempElement = $("<div />");
                window.WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
                return tempElement.contents()
            };
            var normalizeTemplateElement = function(element) {
                var $element = commonUtils.isDefined(element) && (element.nodeType || element.jquery) ? $(element) : $("<div>").html(element).contents();
                if (1 === $element.length && $element.is("script")) {
                    $element = normalizeTemplateElement($element.html())
                }
                return $element
            };
            var toggleAttr = function($target, attr, value) {
                value ? $target.attr(attr, value) : $target.removeAttr(attr)
            };
            var clipboardText = function(event, text) {
                var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
                if (1 === arguments.length) {
                    return clipboard && clipboard.getData("Text")
                }
                clipboard && clipboard.setData("Text", text)
            };
            exports.resetActiveElement = resetActiveElement;
            exports.createMarkupFromString = createMarkupFromString;
            exports.triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
            exports.triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
            exports.triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
            exports.getElementOptions = getElementOptions;
            exports.createComponents = createComponents;
            exports.normalizeTemplateElement = normalizeTemplateElement;
            exports.clearSelection = clearSelection;
            exports.getSelection = getSelection;
            exports.uniqueId = uniqueId;
            exports.closestCommonParent = closestCommonParent;
            exports.clipboardText = clipboardText;
            exports.toggleAttr = toggleAttr
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/core/utils/date.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ./common */ 2),
                inflector = __webpack_require__( /*! ./inflector */ 29),
                isObject = commonUtils.isObject,
                isString = commonUtils.isString,
                isDate = commonUtils.isDate,
                isDefined = commonUtils.isDefined,
                camelize = inflector.camelize;
            var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
            var toMilliseconds = function(value) {
                switch (value) {
                    case "millisecond":
                        return 1;
                    case "second":
                        return 1e3 * toMilliseconds("millisecond");
                    case "minute":
                        return 60 * toMilliseconds("second");
                    case "hour":
                        return 60 * toMilliseconds("minute");
                    case "day":
                        return 24 * toMilliseconds("hour");
                    case "week":
                        return 7 * toMilliseconds("day");
                    case "month":
                        return 30 * toMilliseconds("day");
                    case "quarter":
                        return 3 * toMilliseconds("month");
                    case "year":
                        return 365 * toMilliseconds("day");
                    default:
                        return 0
                }
            };
            var getDatesInterval = function(startDate, endDate, intervalUnit) {
                var delta = endDate.getTime() - startDate.getTime(),
                    millisecondCount = toMilliseconds(intervalUnit) || 1;
                return Math.floor(delta / millisecondCount)
            };
            var getNextDateUnit = function(unit, withWeeks) {
                var interval = getDateUnitInterval(unit);
                switch (interval) {
                    case "millisecond":
                        return "second";
                    case "second":
                        return "minute";
                    case "minute":
                        return "hour";
                    case "hour":
                        return "day";
                    case "day":
                        return withWeeks ? "week" : "month";
                    case "week":
                        return "month";
                    case "month":
                        return "quarter";
                    case "quarter":
                        return "year";
                    case "year":
                        return "year";
                    default:
                        return 0
                }
            };
            var convertMillisecondsToDateUnits = function(value) {
                var i, dateUnitCount, dateUnitInterval, dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"],
                    result = {};
                for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                    dateUnitInterval = dateUnitIntervals[i];
                    dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                    if (dateUnitCount > 0) {
                        result[dateUnitInterval + "s"] = dateUnitCount;
                        value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                    }
                }
                return result
            };
            var dateToMilliseconds = function(tickInterval) {
                var milliseconds = 0;
                if (isObject(tickInterval)) {
                    $.each(tickInterval, function(key, value) {
                        milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                    })
                }
                if (isString(tickInterval)) {
                    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1)
                }
                return milliseconds
            };
            var convertDateUnitToMilliseconds = function(dateUnit, count) {
                return toMilliseconds(dateUnit) * count
            };
            var getDateUnitInterval = function(tickInterval) {
                var i, maxInterval = -1;
                if (isString(tickInterval)) {
                    return tickInterval
                }
                if (isObject(tickInterval)) {
                    $.each(tickInterval, function(key, value) {
                        for (i = 0; i < dateUnitIntervals.length; i++) {
                            if (value && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
                                maxInterval = i
                            }
                        }
                    });
                    return dateUnitIntervals[maxInterval]
                }
                return ""
            };
            var tickIntervalToFormatMap = {
                millisecond: "millisecond",
                second: "longtime",
                minute: "shorttime",
                hour: "shorttime",
                day: "day",
                week: "day",
                month: "month",
                quarter: "quarter",
                year: "year"
            };

            function getDateFormatByTickInterval(tickInterval) {
                return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || ""
            }
            var getQuarter = function(month) {
                return Math.floor(month / 3)
            };
            var getFirstQuarterMonth = function(month) {
                return 3 * getQuarter(month)
            };
            var correctDateWithUnitBeginning = function(date, dateInterval, withCorrection) {
                var firstQuarterMonth, oldDate = new Date(date.getTime()),
                    dateUnitInterval = getDateUnitInterval(dateInterval);
                switch (dateUnitInterval) {
                    case "second":
                        date.setMilliseconds(0);
                        break;
                    case "minute":
                        date.setSeconds(0, 0);
                        break;
                    case "hour":
                        date.setMinutes(0, 0, 0);
                        break;
                    case "year":
                        date.setMonth(0);
                    case "month":
                        date.setDate(1);
                    case "day":
                        date.setHours(0, 0, 0, 0);
                        break;
                    case "week":
                        date.setDate(date.getDate() - date.getDay());
                        date.setHours(0, 0, 0, 0);
                        break;
                    case "quarter":
                        firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
                        if (date.getMonth() !== firstQuarterMonth) {
                            date.setMonth(firstQuarterMonth)
                        }
                        date.setDate(1);
                        date.setHours(0, 0, 0, 0)
                }
                if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
                    fixTimezoneGap(oldDate, date)
                }
            };
            var trimTime = function(date) {
                dateUtils.correctDateWithUnitBeginning(date, "day");
                return date
            };
            var getDatesDifferences = function(date1, date2) {
                var differences, counter = 0;
                differences = {
                    year: date1.getFullYear() !== date2.getFullYear(),
                    month: date1.getMonth() !== date2.getMonth(),
                    day: date1.getDate() !== date2.getDate(),
                    hour: date1.getHours() !== date2.getHours(),
                    minute: date1.getMinutes() !== date2.getMinutes(),
                    second: date1.getSeconds() !== date2.getSeconds()
                };
                $.each(differences, function(key, value) {
                    if (value) {
                        counter++
                    }
                });
                differences.count = counter;
                return differences
            };

            function addDateInterval(value, interval, dir) {
                var result = new Date(value.getTime()),
                    intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
                if (intervalObject.years) {
                    result.setFullYear(result.getFullYear() + intervalObject.years * dir)
                }
                if (intervalObject.quarters) {
                    result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir)
                }
                if (intervalObject.months) {
                    result.setMonth(result.getMonth() + intervalObject.months * dir)
                }
                if (intervalObject.weeks) {
                    result.setDate(result.getDate() + 7 * intervalObject.weeks * dir)
                }
                if (intervalObject.days) {
                    result.setDate(result.getDate() + intervalObject.days * dir)
                }
                if (intervalObject.hours) {
                    result.setHours(result.getHours() + intervalObject.hours * dir)
                }
                if (intervalObject.minutes) {
                    result.setMinutes(result.getMinutes() + intervalObject.minutes * dir)
                }
                if (intervalObject.seconds) {
                    result.setSeconds(result.getSeconds() + intervalObject.seconds * dir)
                }
                if (intervalObject.milliseconds) {
                    result.setMilliseconds(value.getMilliseconds() + intervalObject.milliseconds * dir)
                }
                return result
            }
            var addInterval = function(value, interval, isNegative) {
                var dir = isNegative ? -1 : 1;
                return isDate(value) ? addDateInterval(value, interval, dir) : value + interval * dir
            };
            var getViewFirstCellDate = function(viewType, date) {
                if ("month" === viewType) {
                    return new Date(date.getFullYear(), date.getMonth(), 1)
                }
                if ("year" === viewType) {
                    return new Date(date.getFullYear(), 0, date.getDate())
                }
                if ("decade" === viewType) {
                    return new Date(getFirstYearInDecade(date), date.getMonth(), date.getDate())
                }
                if ("century" === viewType) {
                    return new Date(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
                }
            };
            var getViewLastCellDate = function(viewType, date) {
                if ("month" === viewType) {
                    return new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date))
                }
                if ("year" === viewType) {
                    return new Date(date.getFullYear(), 11, date.getDate())
                }
                if ("decade" === viewType) {
                    return new Date(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate())
                }
                if ("century" === viewType) {
                    return new Date(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
                }
            };
            var getViewMinBoundaryDate = function(viewType, date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth(), 1);
                if ("month" === viewType) {
                    return resultDate
                }
                resultDate.setMonth(0);
                if ("year" === viewType) {
                    return resultDate
                }
                if ("decade" === viewType) {
                    resultDate.setFullYear(getFirstYearInDecade(date))
                }
                if ("century" === viewType) {
                    resultDate.setFullYear(getFirstDecadeInCentury(date))
                }
                return resultDate
            };
            var getViewMaxBoundaryDate = function(viewType, date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
                if ("month" === viewType) {
                    return resultDate
                }
                resultDate.setMonth(11);
                resultDate.setDate(getLastMonthDay(resultDate));
                if ("year" === viewType) {
                    return resultDate
                }
                if ("decade" === viewType) {
                    resultDate.setFullYear(getFirstYearInDecade(date) + 9)
                }
                if ("century" === viewType) {
                    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99)
                }
                return resultDate
            };
            var getLastMonthDay = function(date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return resultDate.getDate()
            };
            var sameView = function(view, date1, date2) {
                return dateUtils[camelize("same " + view)](date1, date2)
            };
            var getViewUp = function(typeView) {
                switch (typeView) {
                    case "month":
                        return "year";
                    case "year":
                        return "decade";
                    case "decade":
                        return "century"
                }
            };
            var getViewDown = function(typeView) {
                switch (typeView) {
                    case "century":
                        return "decade";
                    case "decade":
                        return "year";
                    case "year":
                        return "month"
                }
            };
            var getDifferenceInMonth = function(typeView) {
                var difference = 1;
                if ("year" === typeView) {
                    difference = 12
                }
                if ("decade" === typeView) {
                    difference = 120
                }
                if ("century" === typeView) {
                    difference = 1200
                }
                return difference
            };
            var getDifferenceInMonthForCells = function(typeView) {
                var difference = 1;
                if ("decade" === typeView) {
                    difference = 12
                }
                if ("century" === typeView) {
                    difference = 120
                }
                return difference
            };
            var getDateIntervalByString = function(intervalString) {
                var result = {};
                switch (intervalString) {
                    case "year":
                        result.years = 1;
                        break;
                    case "month":
                        result.months = 1;
                        break;
                    case "quarter":
                        result.months = 3;
                        break;
                    case "week":
                        result.days = 7;
                        break;
                    case "day":
                        result.days = 1;
                        break;
                    case "hour":
                        result.hours = 1;
                        break;
                    case "minute":
                        result.minutes = 1;
                        break;
                    case "second":
                        result.seconds = 1;
                        break;
                    case "millisecond":
                        result.milliseconds = 1
                }
                return result
            };
            var sameMonthAndYear = function(date1, date2) {
                return date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth()
            };
            var sameYear = function(date1, date2) {
                return date1 && date2 && date1.getFullYear() === date2.getFullYear()
            };
            var sameDecade = function(date1, date2) {
                if (!isDefined(date1) || !isDefined(date2)) {
                    return
                }
                var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10,
                    startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
                return date1 && date2 && startDecadeDate1 === startDecadeDate2
            };
            var sameCentury = function(date1, date2) {
                if (!isDefined(date1) || !isDefined(date2)) {
                    return
                }
                var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100,
                    startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
                return date1 && date2 && startCenturyDate1 === startCenturyDate2
            };
            var getFirstDecadeInCentury = function(date) {
                return date && date.getFullYear() - date.getFullYear() % 100
            };
            var getFirstYearInDecade = function(date) {
                return date && date.getFullYear() - date.getFullYear() % 10
            };
            var getShortDateFormat = function() {
                return "yyyy/M/d"
            };
            var getFirstMonthDate = function(date) {
                if (!isDefined(date)) {
                    return
                }
                var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
                return newDate
            };
            var getLastMonthDate = function(date) {
                if (!isDefined(date)) {
                    return
                }
                var newDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return newDate
            };
            var getFirstWeekDate = function(date, firstDayOfWeek) {
                var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
                var result = new Date(date);
                result.setDate(date.getDate() - delta);
                return result
            };
            var normalizeDateByWeek = function(date, currentDate) {
                var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day"),
                    resultDate = new Date(date);
                if (differenceInDays >= 6) {
                    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7))
                }
                return resultDate
            };
            var dateInRange = function(date, min, max, format) {
                if ("date" === format) {
                    min = min && new Date(min.getFullYear(), min.getMonth(), min.getDate());
                    max = max && new Date(max.getFullYear(), max.getMonth(), max.getDate());
                    date = date && new Date(date.getFullYear(), date.getMonth(), date.getDate())
                }
                return normalizeDate(date, min, max) === date
            };
            var normalizeDate = function(date, min, max) {
                var normalizedDate = date;
                if (!isDefined(date)) {
                    return date
                }
                if (isDefined(min) && date < min) {
                    normalizedDate = min
                }
                if (isDefined(max) && date > max) {
                    normalizedDate = max
                }
                return normalizedDate
            };
            var fixTimezoneGap = function(oldDate, newDate) {
                if (!isDefined(oldDate)) {
                    return
                }
                var sign, trial, diff = newDate.getHours() - oldDate.getHours();
                if (0 === diff) {
                    return
                }
                sign = 1 === diff || -23 === diff ? -1 : 1, trial = new Date(newDate.getTime() + 36e5 * sign);
                if (sign > 0 || trial.getDate() === newDate.getDate()) {
                    newDate.setTime(trial.getTime())
                }
            };
            var getTimezonesDifference = function(min, max) {
                return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3
            };
            var makeDate = function(date) {
                return new Date(date)
            };
            var NUMBER_SERIALIZATION_FORMAT = "number",
                DATE_SERIALIZATION_FORMAT = "yyyy'/'MM'/'dd",
                DATETIME_SERIALIZATION_FORMAT = "yyyy'/'MM'/'dd HH:mm:ss";
            var getDateSerializationFormat = function(value) {
                if (commonUtils.isNumber(value)) {
                    return NUMBER_SERIALIZATION_FORMAT
                } else {
                    if (commonUtils.isString(value)) {
                        if (value.indexOf(":") >= 0) {
                            return DATETIME_SERIALIZATION_FORMAT
                        } else {
                            return DATE_SERIALIZATION_FORMAT
                        }
                    }
                }
            };
            var deserializeDate = function(value, serializationFormat, localizationParseFunc) {
                var parsedValue;
                if (!serializationFormat || serializationFormat === NUMBER_SERIALIZATION_FORMAT || serializationFormat === DATE_SERIALIZATION_FORMAT || serializationFormat === DATETIME_SERIALIZATION_FORMAT) {
                    parsedValue = serializationFormat === NUMBER_SERIALIZATION_FORMAT ? value : !isDate(value) && Date.parse(value);
                    return parsedValue ? new Date(parsedValue) : value
                }
                if (void 0 !== value) {
                    return localizationParseFunc(value, serializationFormat)
                }
            };
            var serializeDate = function(value, serializationFormat, localizationFormatFunc) {
                if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
                    return value && value.valueOf && value.valueOf()
                }
                if (serializationFormat) {
                    return localizationFormatFunc(value, serializationFormat)
                }
                return value
            };
            var dateUtils = {
                dateUnitIntervals: dateUnitIntervals,
                convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
                dateToMilliseconds: dateToMilliseconds,
                getNextDateUnit: getNextDateUnit,
                convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
                getDateUnitInterval: getDateUnitInterval,
                getDateFormatByTickInterval: getDateFormatByTickInterval,
                getDatesDifferences: getDatesDifferences,
                correctDateWithUnitBeginning: correctDateWithUnitBeginning,
                trimTime: trimTime,
                addDateInterval: addDateInterval,
                addInterval: addInterval,
                getDateIntervalByString: getDateIntervalByString,
                sameMonthAndYear: sameMonthAndYear,
                sameMonth: sameMonthAndYear,
                sameYear: sameYear,
                sameDecade: sameDecade,
                sameCentury: sameCentury,
                sameView: sameView,
                getDifferenceInMonth: getDifferenceInMonth,
                getDifferenceInMonthForCells: getDifferenceInMonthForCells,
                getFirstYearInDecade: getFirstYearInDecade,
                getFirstDecadeInCentury: getFirstDecadeInCentury,
                getShortDateFormat: getShortDateFormat,
                getViewFirstCellDate: getViewFirstCellDate,
                getViewLastCellDate: getViewLastCellDate,
                getViewDown: getViewDown,
                getViewUp: getViewUp,
                getLastMonthDay: getLastMonthDay,
                getLastMonthDate: getLastMonthDate,
                getFirstMonthDate: getFirstMonthDate,
                getFirstWeekDate: getFirstWeekDate,
                normalizeDateByWeek: normalizeDateByWeek,
                getQuarter: getQuarter,
                getFirstQuarterMonth: getFirstQuarterMonth,
                dateInRange: dateInRange,
                normalizeDate: normalizeDate,
                getViewMinBoundaryDate: getViewMinBoundaryDate,
                getViewMaxBoundaryDate: getViewMaxBoundaryDate,
                fixTimezoneGap: fixTimezoneGap,
                getTimezonesDifference: getTimezonesDifference,
                makeDate: makeDate,
                deserializeDate: deserializeDate,
                serializeDate: serializeDate,
                getDateSerializationFormat: getDateSerializationFormat,
                getDatesInterval: getDatesInterval
            };
            module.exports = dateUtils
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/events/pointer.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                support = __webpack_require__( /*! ../core/utils/support */ 18),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                registerEvent = __webpack_require__( /*! ./core/event_registrator */ 43),
                TouchStrategy = __webpack_require__( /*! ./pointer/touch */ 208),
                MsPointerStrategy = __webpack_require__( /*! ./pointer/mspointer */ 275),
                MouseStrategy = __webpack_require__( /*! ./pointer/mouse */ 206),
                MouseAndTouchStrategy = __webpack_require__( /*! ./pointer/mouse_and_touch */ 274);
            var EventStrategy = function() {
                if (support.pointerEvents) {
                    return MsPointerStrategy
                }
                var device = devices.real();
                if (support.touch && !(device.tablet || device.phone)) {
                    return MouseAndTouchStrategy
                }
                if (support.touch) {
                    return TouchStrategy
                }
                return MouseStrategy
            }();
            $.each(EventStrategy.map, function(pointerEvent, originalEvents) {
                registerEvent(pointerEvent, new EventStrategy(pointerEvent, originalEvents))
            });
            module.exports = {
                down: "dxpointerdown",
                up: "dxpointerup",
                move: "dxpointermove",
                cancel: "dxpointercancel",
                enter: "dxpointerenter",
                leave: "dxpointerleave",
                over: "dxpointerover",
                out: "dxpointerout"
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/localization/date.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                numberLocalization = __webpack_require__( /*! ./number */ 38),
                dependencyInjector = __webpack_require__( /*! ../core/utils/dependency_injector */ 80),
                errors = __webpack_require__( /*! ../core/errors */ 10);
            __webpack_require__( /*! ./core */ 217);
            var FORMATS_TO_PATTERN_MAP = {
                shortdate: "M/d/y",
                shorttime: "h:mm a",
                longdate: "EEEE, MMMM d, y",
                longtime: "h:mm:ss a",
                monthandday: "MMMM d",
                monthandyear: "MMMM y",
                quarterandyear: "QQQ y",
                day: "d",
                year: "y",
                shortdateshorttime: "M/d/y, h:mm a",
                mediumdatemediumtime: "MMMM d, h:mm a",
                longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
                month: "LLLL",
                shortyear: "yy",
                dayofweek: "EEEE",
                quarter: "QQQ",
                hour: "HH",
                minute: "mm",
                second: "ss",
                millisecond: "SSS",
                "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
            };
            var parseTime = function(text) {
                var now = new Date,
                    parts = text.split(" "),
                    time = parts[0].split(":"),
                    hours = Number(time[0]),
                    minutes = Number(time[1]),
                    second = Number(time[2]) || 0;
                if (/^pm$/i.test(parts[1])) {
                    hours += 12
                }
                return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, second)
            };
            var removeTimezoneOffset = function(date) {
                return new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
            };
            var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var ampm = function(date) {
                return date.getHours() >= 12 ? "PM" : "AM"
            };
            var getTwelveHourTimeFormat = function(hours) {
                return hours % 12 || 12
            };
            var formatNumber = function(number, precision) {
                return numberLocalization.format(number, {
                    type: "decimal",
                    precision: precision
                })
            };
            var FORMATTERS = {
                millisecond: function(date) {
                    return formatNumber(date.getMilliseconds(date), 3)
                },
                second: function(date) {
                    return formatNumber(date.getSeconds(), 2)
                },
                minute: function(date) {
                    return formatNumber(date.getMinutes(), 2)
                },
                h: function(date) {
                    return formatNumber(getTwelveHourTimeFormat(date.getHours()), 1)
                },
                hh: function(date) {
                    return formatNumber(getTwelveHourTimeFormat(date.getHours()), 2)
                },
                hour: function(date) {
                    return formatNumber(date.getHours(), 2)
                },
                day: function(date) {
                    return date.getDate()
                },
                dayofweek: function(date) {
                    return days[date.getDay()]
                },
                M: function(date) {
                    return date.getMonth() + 1
                },
                MM: function(date) {
                    return formatNumber(date.getMonth() + 1, 2)
                },
                month: function(date) {
                    return months[date.getMonth()]
                },
                year: function(date) {
                    return date.getFullYear()
                },
                shortyear: function(date) {
                    return String(date.getFullYear()).substr(2, 2)
                },
                shorttime: function(date) {
                    return FORMATTERS.h(date) + ":" + FORMATTERS.minute(date) + " " + ampm(date)
                },
                shortdate: function(date) {
                    return [FORMATTERS.M(date), FORMATTERS.day(date), FORMATTERS.year(date)].join("/")
                },
                shortdateshorttime: function(date) {
                    return [FORMATTERS.shortdate(date), FORMATTERS.shorttime(date)].join(", ")
                },
                mediumdatemediumtime: function(date) {
                    return [FORMATTERS.monthandday(date), FORMATTERS.shorttime(date)].join(", ")
                },
                monthandyear: function(date) {
                    return [FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
                },
                monthandday: function(date) {
                    return [FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
                },
                longdate: function(date) {
                    return FORMATTERS.dayofweek(date) + ", " + FORMATTERS.month(date) + " " + FORMATTERS.day(date) + ", " + FORMATTERS.year(date)
                },
                longtime: function(date) {
                    return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + " " + ampm(date)
                },
                longdatelongtime: function(date) {
                    return [FORMATTERS.longdate(date), FORMATTERS.longtime(date)].join(", ")
                },
                d: function(date) {
                    return formatNumber(FORMATTERS.day(date), 1)
                },
                dd: function(date) {
                    return formatNumber(FORMATTERS.day(date), 2)
                },
                "d MMMM": function(date) {
                    return FORMATTERS.day(date) + " " + FORMATTERS.month(date)
                },
                "yyyy/M/d": function(date) {
                    return [FORMATTERS.year(date), FORMATTERS.M(date), FORMATTERS.day(date)].join("/")
                },
                "yyyy/MM/dd": function(date) {
                    return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("/")
                },
                "dd.MM.yyyy": function(date) {
                    return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join(".")
                },
                "HH:mm": function(date) {
                    return [FORMATTERS.hour(date), FORMATTERS.minute(date)].join(":")
                },
                "HH:mm:ss": function(date) {
                    return [FORMATTERS["HH:mm"](date), FORMATTERS.second(date)].join(":")
                },
                "h:mm:ss": function(date) {
                    return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":")
                },
                "h:mm:ss:SSS": function(date) {
                    return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date), FORMATTERS.SSS(date)].join(":")
                },
                "yyyy/MM/dd HH:mm:ss": function(date) {
                    return [FORMATTERS["yyyy/MM/dd"](date), FORMATTERS["HH:mm:ss"](date)].join(" ")
                },
                "yyyy-MM-dd hh:mm:ss.SSS a": function(date) {
                    return [
                        [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-"), [FORMATTERS.hh(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + "." + FORMATTERS.SSS(date), ampm(date)
                    ].join(" ")
                },
                "yyyy-MM-dd": function(date) {
                    return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-")
                },
                yyyyMMddTHHmmss: function(date) {
                    return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date), "T", FORMATTERS.hour(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join("")
                },
                "datetime-local": function(date) {
                    return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS["HH:mm:ss"](date)
                },
                "yyyy-MM-ddTHH:mm:ssZ": function(date) {
                    return FORMATTERS["datetime-local"](date) + "Z"
                },
                "yyyy-MM-ddTHH:mmZ": function(date) {
                    return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS.hour(date) + ":" + FORMATTERS.minute(date) + "Z"
                },
                "dd/MM/yyyy": function(date) {
                    return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join("/")
                },
                "yyyy MMMM d": function(date) {
                    return [FORMATTERS.year(date), FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
                },
                "EEEE, d": function(date) {
                    return [FORMATTERS.dayofweek(date), FORMATTERS.d(date)].join(", ")
                },
                "EEEE MM yy": function(date) {
                    return [FORMATTERS.dayofweek(date), FORMATTERS.MM(date), FORMATTERS.shortyear(date)].join(" ")
                },
                "d MMMM yyyy": function(date) {
                    return [FORMATTERS.day(date), FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
                },
                "E d": function(date) {
                    return FORMATTERS.E(date) + " " + FORMATTERS.day(date)
                },
                E: function(date) {
                    return cutCaptions([FORMATTERS.dayofweek(date)], "abbreviated")[0]
                },
                EEE: function(date) {
                    return FORMATTERS.E(date)
                },
                "EEE hh": function(date) {
                    return [FORMATTERS.EEE(date), FORMATTERS.hh(date)].join(" ")
                },
                "ss SSS": function(date) {
                    return [FORMATTERS.second(date), FORMATTERS.SSS(date)].join(" ")
                },
                quarter: function(date) {
                    var month = date.getMonth();
                    if (month >= 0 && month < 3) {
                        return "Q1"
                    }
                    if (month > 2 && month < 6) {
                        return "Q2"
                    }
                    if (month > 5 && month < 9) {
                        return "Q3"
                    }
                    return "Q4"
                },
                quarterandyear: function(date) {
                    return FORMATTERS.quarter(date) + " " + FORMATTERS.year(date)
                }
            };
            var parseWithoutTimezone = function(text) {
                if ("Z" !== text.slice(-1)) {
                    text += "Z"
                }
                return removeTimezoneOffset(new Date(text))
            };
            var PARSERS = {
                day: function(text) {
                    var now = new Date;
                    return new Date(now.getFullYear(), now.getMonth(), Number(text))
                },
                hour: function(text) {
                    var now = new Date;
                    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), Number(text))
                },
                minute: function(text) {
                    var now = new Date;
                    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), Number(text))
                },
                month: function(text) {
                    return new Date((new Date).getFullYear(), $.inArray(text, months))
                },
                monthandday: function(text) {
                    var parts = text.split(" "),
                        ret = PARSERS.month(parts[0]);
                    ret.setDate(Number(parts[1]));
                    return ret
                },
                monthandyear: function(text) {
                    var parts = text.split(" "),
                        ret = PARSERS.month(parts[0]);
                    ret.setYear(Number(parts[1]));
                    return ret
                },
                year: function(text) {
                    var date = new Date(new Date(0));
                    date.setUTCFullYear(Number(text));
                    return removeTimezoneOffset(date)
                },
                shortyear: function(text) {
                    var MAX_YEAR_IN_XXI_CENTURY = 36;
                    var year = Number(text);
                    if (year > MAX_YEAR_IN_XXI_CENTURY) {
                        year += 1900
                    } else {
                        year += 2e3
                    }
                    return PARSERS.year(year)
                },
                shortdate: function(text) {
                    var parts = text.split("/");
                    if (3 !== parts.length) {
                        return
                    }
                    return new Date(Number(parts[2]), Number(parts[0]) - 1, Number(parts[1]))
                },
                longtime: function(text) {
                    return parseTime(text)
                },
                shorttime: function(text) {
                    return parseTime(text)
                },
                millisecond: function(text) {
                    return new Date(Number(text))
                },
                "yyyy MMMM d": function(text) {
                    var parts = text.split(" ");
                    if (3 !== parts.length) {
                        return
                    }
                    return new Date(Number(parts[0]), $.inArray(parts[1], months), Number(parts[2]))
                },
                "HH:mm": function(text) {
                    var parts = text.split(":");
                    return new Date(0, 0, 0, Number(parts[0]), Number(parts[1]), 0, 0)
                },
                "yyyy-MM-ddTHH:mm:ssZ": parseWithoutTimezone,
                "yyyy-MM-ddTHH:mmZ": parseWithoutTimezone,
                "datetime-local": parseWithoutTimezone,
                mediumdatemediumtime: function(text) {
                    var parts = text.split(", "),
                        dateParts = parts[0].split(" "),
                        timeParts = parts[1].split(" ");
                    var ampm = 2 === timeParts.length ? timeParts.pop() : void 0;
                    var ret = PARSERS.month(dateParts[0]);
                    ret.setDate(Number(dateParts[1]));
                    timeParts = timeParts[0].split(":");
                    var hours = Number(timeParts[0]);
                    switch (String(ampm).toLowerCase()) {
                        case "am":
                            hours = 12 === hours ? 0 : hours;
                            break;
                        case "pm":
                            hours = 12 === hours ? 12 : hours + 12
                    }
                    ret.setHours(hours);
                    ret.setMinutes(Number(timeParts[1]));
                    return ret
                }
            };
            $.each(FORMATS_TO_PATTERN_MAP, function(key, value) {
                value = value.replace(/'/g, "");
                FORMATTERS[value] = FORMATTERS[key];
                PARSERS[value] = PARSERS[key]
            });
            var getByFormat = function(obj, format) {
                return obj[format.toLowerCase()] || obj[format.replace(/'/g, "")]
            };
            var cutCaptions = function(captions, format) {
                var lengthByFormat = {
                    abbreviated: 3,
                    "short": 2,
                    narrow: 1
                };
                return $.map(captions, function(caption) {
                    return caption.substr(0, lengthByFormat[format])
                })
            };
            var dateLocalization = dependencyInjector({
                getPatternByFormat: function(format) {
                    return FORMATS_TO_PATTERN_MAP[format.toLowerCase()]
                },
                getMonthNames: function(format) {
                    return cutCaptions(months, format)
                },
                getDayNames: function(format) {
                    return cutCaptions(days, format)
                },
                getTimeSeparator: function() {
                    return ":"
                },
                format: function(date, format) {
                    if (!date) {
                        return
                    }
                    if (!format) {
                        return date
                    }
                    var formatter;
                    if ("function" === typeof format) {
                        formatter = format
                    } else {
                        if (format.formatter) {
                            formatter = format.formatter
                        } else {
                            format = format.type || format;
                            formatter = getByFormat(FORMATTERS, format)
                        }
                    }
                    if (!formatter) {
                        return
                    }
                    return formatter(date)
                },
                parse: function(text, format) {
                    var result, parser;
                    if (!text) {
                        return
                    }
                    if (!format) {
                        return new Date(text)
                    }
                    if (format.parser) {
                        return format.parser(text)
                    }
                    if (format.type || format.formatter) {
                        format = format.type
                    }
                    if (format && "function" !== typeof format) {
                        parser = getByFormat(PARSERS, format)
                    }
                    if (parser) {
                        result = parser(text)
                    } else {
                        errors.log("W0012");
                        result = new Date(text)
                    }
                    if (!result || isNaN(result.getTime())) {
                        return
                    }
                    return result
                },
                firstDayOfWeekIndex: function() {
                    return 0
                }
            });
            module.exports = dateLocalization
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/animation/translator.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                support = __webpack_require__( /*! ../core/utils/support */ 18);
            var TRANSLATOR_DATA_KEY = "dxTranslator",
                TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
                TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
            var locate = function($element) {
                var translate = support.transform ? getTranslate($element) : getTranslateFallback($element);
                return {
                    left: translate.x,
                    top: translate.y
                }
            };
            var move = function($element, position) {
                if (!support.transform) {
                    $element.css(position);
                    return
                }
                var translate, left = position.left,
                    top = position.top;
                if (void 0 === left) {
                    translate = getTranslate($element);
                    translate.y = top || 0
                } else {
                    if (void 0 === top) {
                        translate = getTranslate($element);
                        translate.x = left || 0
                    } else {
                        translate = {
                            x: left || 0,
                            y: top || 0,
                            z: 0
                        };
                        cacheTranslate($element, translate)
                    }
                }
                $element.css({
                    transform: getTranslateCss(translate)
                });
                if (isPercentValue(left) || isPercentValue(top)) {
                    clearCache($element)
                }
            };
            var isPercentValue = function(value) {
                return "string" === $.type(value) && "%" === value[value.length - 1]
            };
            var getTranslateFallback = function($element) {
                var result;
                try {
                    var originalTop = $element.css("top"),
                        originalLeft = $element.css("left");
                    var position = $element.position();
                    $element.css({
                        transform: "none",
                        top: 0,
                        left: 0
                    });
                    clearCache($element);
                    var finalPosition = $element.position();
                    result = {
                        x: position.left - finalPosition.left || parseInt(originalLeft) || 0,
                        y: position.top - finalPosition.top || parseInt(originalTop) || 0
                    };
                    $element.css({
                        top: originalTop,
                        left: originalLeft
                    })
                } catch (e) {
                    result = {
                        x: 0,
                        y: 0
                    }
                }
                return result
            };
            var getTranslate = function($element) {
                var result = $element.length ? $.data($element.get(0), TRANSLATOR_DATA_KEY) : null;
                if (!result) {
                    var transformValue = $element.css("transform") || getTranslateCss({
                            x: 0,
                            y: 0
                        }),
                        matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
                        is3D = matrix && matrix[1];
                    if (matrix) {
                        matrix = matrix[2].split(",");
                        if ("3d" === is3D) {
                            matrix = matrix.slice(12, 15)
                        } else {
                            matrix.push(0);
                            matrix = matrix.slice(4, 7)
                        }
                    } else {
                        matrix = [0, 0, 0]
                    }
                    result = {
                        x: parseFloat(matrix[0]),
                        y: parseFloat(matrix[1]),
                        z: parseFloat(matrix[2])
                    };
                    cacheTranslate($element, result)
                }
                return result
            };
            var cacheTranslate = function($element, translate) {
                if ($element.length) {
                    $.data($element.get(0), TRANSLATOR_DATA_KEY, translate)
                }
            };
            var clearCache = function($element) {
                if ($element.length) {
                    $.removeData($element.get(0), TRANSLATOR_DATA_KEY)
                }
            };
            var resetPosition = function($element) {
                $element.css({
                    left: 0,
                    top: 0,
                    transform: "none"
                });
                clearCache($element)
            };
            var parseTranslate = function(translateString) {
                var result = translateString.match(TRANSLATE_REGEX);
                if (!result || !result[1]) {
                    return
                }
                result = result[1].split(",");
                result = {
                    x: parseFloat(result[0]),
                    y: parseFloat(result[1]),
                    z: parseFloat(result[2])
                };
                return result
            };
            var getTranslateCss = function(translate) {
                translate.x = translate.x || 0;
                translate.y = translate.y || 0;
                var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
                var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
                return "translate(" + xValueString + ", " + yValueString + ")"
            };
            exports.move = move;
            exports.locate = locate;
            exports.clearCache = clearCache;
            exports.parseTranslate = parseTranslate;
            exports.getTranslate = getTranslate;
            exports.getTranslateCss = getTranslateCss;
            exports.resetPosition = resetPosition
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/core/utils/data.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../errors */ 10),
                Class = __webpack_require__( /*! ../class */ 5),
                objectUtils = __webpack_require__( /*! ./object */ 30),
                variableWrapper = __webpack_require__( /*! ./variable_wrapper */ 73),
                unwrapVariable = variableWrapper.unwrap,
                isWrapped = variableWrapper.isWrapped,
                assign = variableWrapper.assign;
            var bracketsToDots = function(expr) {
                return expr.replace(/\[/g, ".").replace(/\]/g, "")
            };
            var readPropValue = function(obj, propName) {
                if ("this" === propName) {
                    return obj
                }
                return obj[propName]
            };
            var assignPropValue = function(obj, propName, value, options) {
                if ("this" === propName) {
                    throw new errors.Error("E4016")
                }
                var propValue = obj[propName];
                if (options.unwrapObservables && isWrapped(propValue)) {
                    assign(propValue, value)
                } else {
                    obj[propName] = value
                }
            };
            var prepareOptions = function(options) {
                options = options || {};
                options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;
                return options
            };
            var unwrap = function(value, options) {
                return options.unwrapObservables ? unwrapVariable(value) : value
            };
            var compileGetter = function(expr) {
                if (arguments.length > 1) {
                    expr = $.makeArray(arguments)
                }
                if (!expr || "this" === expr) {
                    return function(obj) {
                        return obj
                    }
                }
                if ("string" === typeof expr) {
                    expr = bracketsToDots(expr);
                    var path = expr.split(".");
                    return function(obj, options) {
                        options = prepareOptions(options);
                        var functionAsIs = options.functionsAsIs,
                            current = unwrap(obj, options);
                        for (var i = 0; i < path.length; i++) {
                            if (!current) {
                                break
                            }
                            var next = unwrap(current[path[i]], options);
                            if (!functionAsIs && $.isFunction(next)) {
                                next = next.call(current)
                            }
                            current = next
                        }
                        return current
                    }
                }
                if ($.isArray(expr)) {
                    return combineGetters(expr)
                }
                if ($.isFunction(expr)) {
                    return expr
                }
            };
            var combineGetters = function(getters) {
                var compiledGetters = {};
                for (var i = 0, l = getters.length; i < l; i++) {
                    var getter = getters[i];
                    compiledGetters[getter] = compileGetter(getter)
                }
                return function(obj, options) {
                    var result;
                    $.each(compiledGetters, function(name) {
                        var current, path, last, i, value = this(obj, options);
                        if (void 0 === value) {
                            return
                        }
                        current = result || (result = {});
                        path = name.split(".");
                        last = path.length - 1;
                        for (i = 0; i < last; i++) {
                            current = current[path[i]] = {}
                        }
                        current[path[i]] = value
                    });
                    return result
                }
            };
            var compileSetter = function(expr) {
                expr = expr || "this";
                expr = bracketsToDots(expr);
                var pos = expr.lastIndexOf("."),
                    targetGetter = compileGetter(expr.substr(0, pos)),
                    targetPropName = expr.substr(1 + pos);
                return function(obj, value, options) {
                    options = prepareOptions(options);
                    var target = targetGetter(obj, {
                            functionsAsIs: options.functionsAsIs,
                            unwrapObservables: options.unwrapObservables
                        }),
                        prevTargetValue = readPropValue(target, targetPropName);
                    if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isWrapped(prevTargetValue)) {
                        target[targetPropName](value)
                    } else {
                        prevTargetValue = unwrap(prevTargetValue, options);
                        if (options.merge && $.isPlainObject(value) && (void 0 === prevTargetValue || $.isPlainObject(prevTargetValue)) && !(value instanceof $.Event)) {
                            if (!prevTargetValue) {
                                assignPropValue(target, targetPropName, {}, options)
                            }
                            objectUtils.deepExtendArraySafe(unwrap(readPropValue(target, targetPropName), options), value)
                        } else {
                            assignPropValue(target, targetPropName, value, options)
                        }
                    }
                }
            };
            var toComparable = function(value, caseSensitive) {
                if (value instanceof Date) {
                    return value.getTime()
                }
                if (value && value instanceof Class && value.valueOf) {
                    return value.valueOf()
                }
                if (!caseSensitive && "string" === typeof value) {
                    return value.toLowerCase()
                }
                return value
            };
            exports.compileGetter = compileGetter;
            exports.compileSetter = compileSetter;
            exports.toComparable = toComparable
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!***************************************!*\
      !*** ./Scripts/core/utils/support.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                inflector = __webpack_require__( /*! ./inflector */ 29),
                devices = __webpack_require__( /*! ../devices */ 7);
            var camelize = inflector.camelize;
            var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"],
                cssPrefixes = {
                    "": "",
                    Webkit: "-webkit-",
                    Moz: "-moz-",
                    O: "-o-",
                    ms: "-ms-"
                },
                styles = document.createElement("dx").style;
            var transitionEndEventNames = {
                webkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd",
                msTransition: "MsTransitionEnd",
                transition: "transitionend"
            };
            var forEachPrefixes = function(prop, callBack) {
                prop = camelize(prop, true);
                var result;
                for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
                    var jsPrefix = jsPrefixes[i];
                    var prefixedProp = jsPrefix + prop;
                    var lowerPrefixedProp = camelize(prefixedProp);
                    result = callBack(lowerPrefixedProp, jsPrefix);
                    if (void 0 === result) {
                        result = callBack(prefixedProp, jsPrefix)
                    }
                    if (void 0 !== result) {
                        break
                    }
                }
                return result
            };
            var styleProp = function(prop) {
                return forEachPrefixes(prop, function(specific) {
                    if (specific in styles) {
                        return specific
                    }
                })
            };
            var stylePropPrefix = function(prop) {
                return forEachPrefixes(prop, function(specific, jsPrefix) {
                    if (specific in styles) {
                        return cssPrefixes[jsPrefix]
                    }
                })
            };
            var supportProp = function(prop) {
                return !!styleProp(prop)
            };
            var isNativeScrollingSupported = function() {
                var realDevice = devices.real(),
                    realPlatform = realDevice.platform,
                    realVersion = realDevice.version,
                    isObsoleteAndroid = realVersion && realVersion[0] < 4 && "android" === realPlatform,
                    isNativeScrollDevice = !isObsoleteAndroid && $.inArray(realPlatform, ["ios", "android", "win"]) > -1 || realDevice.mac;
                return isNativeScrollDevice
            };
            var inputType = function(type) {
                if ("text" === type) {
                    return true
                }
                var input = document.createElement("input");
                try {
                    input.setAttribute("type", type);
                    input.value = "wrongValue";
                    return !input.value
                } catch (e) {
                    return false
                }
            };
            var touchEvents = "ontouchstart" in window && !("callPhantom" in window),
                pointerEvents = !!window.navigator.pointerEnabled || !!window.navigator.msPointerEnabled,
                touchPointersPresent = !!window.navigator.maxTouchPoints || !!window.navigator.msMaxTouchPoints;
            exports.touchEvents = touchEvents;
            exports.pointerEvents = pointerEvents;
            exports.touch = touchEvents || pointerEvents && touchPointersPresent;
            exports.transform = supportProp("transform");
            exports.transition = supportProp("transition");
            exports.transitionEndEventName = transitionEndEventNames[styleProp("transition")];
            exports.animation = supportProp("animation");
            exports.nativeScrolling = isNativeScrollingSupported();
            exports.winJS = "WinJS" in window;
            exports.styleProp = styleProp;
            exports.stylePropPrefix = stylePropPrefix;
            exports.supportProp = supportProp;
            exports.hasKo = !!window.ko;
            exports.inputType = inputType
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/ui/widget/ui.widget.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ./ui.errors */ 20),
                Action = __webpack_require__( /*! ../../core/action */ 54),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                DOMComponent = __webpack_require__( /*! ../../core/dom_component */ 39),
                TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47),
                DynamicTemplate = __webpack_require__( /*! ./ui.template.dynamic */ 187),
                EmptyTemplate = __webpack_require__( /*! ./ui.template.empty */ 323),
                MoveTemplate = __webpack_require__( /*! ./ui.template.move */ 188),
                TemplateProvider = __webpack_require__( /*! ./jquery.template_provider */ 160),
                KeyboardProcessor = __webpack_require__( /*! ./ui.keyboard_processor */ 175),
                selectors = __webpack_require__( /*! ./jquery.selectors */ 98),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4),
                hoverEvents = __webpack_require__( /*! ../../events/hover */ 133),
                feedbackEvents = __webpack_require__( /*! ../../events/core/emitter.feedback */ 70),
                clickEvent = __webpack_require__( /*! ../../events/click */ 9);
            var UI_FEEDBACK = "UIFeedback",
                WIDGET_CLASS = "dx-widget",
                ACTIVE_STATE_CLASS = "dx-state-active",
                DISABLED_STATE_CLASS = "dx-state-disabled",
                INVISIBLE_STATE_CLASS = "dx-state-invisible",
                HOVER_STATE_CLASS = "dx-state-hover",
                FOCUSED_STATE_CLASS = "dx-state-focused",
                FEEDBACK_SHOW_TIMEOUT = 30,
                FEEDBACK_HIDE_TIMEOUT = 400,
                FOCUS_NAMESPACE = "Focus",
                ANONYMOUS_TEMPLATE_NAME = "template",
                TEXT_NODE = 3,
                TEMPLATE_SELECTOR = "[data-options*='dxTemplate']",
                TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
            var beforeActivateExists = void 0 !== document.onbeforeactivate;
            var Widget = DOMComponent.inherit({
                _supportedKeys: function() {
                    return {}
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        disabled: false,
                        visible: true,
                        hint: void 0,
                        activeStateEnabled: false,
                        onContentReady: null,
                        hoverStateEnabled: false,
                        focusStateEnabled: false,
                        tabIndex: 0,
                        accessKey: null,
                        onFocusIn: null,
                        onFocusOut: null,
                        watchMethod: $.noop,
                        _keyboardProcessor: void 0,
                        templateProvider: TemplateProvider,
                        _templates: {}
                    })
                },
                _feedbackShowTimeout: FEEDBACK_SHOW_TIMEOUT,
                _feedbackHideTimeout: FEEDBACK_HIDE_TIMEOUT,
                _init: function() {
                    this.callBase();
                    this._tempTemplates = [];
                    this._dynamicTemplates = {};
                    this._initTemplates();
                    this._initContentReadyAction()
                },
                _initTemplates: function() {
                    this._extractTemplates();
                    this._extractAnonymousTemplate()
                },
                _extractTemplates: function() {
                    var templates = this.option("_templates"),
                        templateElements = this.element().contents().filter(TEMPLATE_SELECTOR);
                    var templatesMap = {};
                    templateElements.each(function(_, template) {
                        var templateOptions = domUtils.getElementOptions(template).dxTemplate;
                        if (!templateOptions) {
                            return
                        }
                        if (!templateOptions.name) {
                            throw errors.Error("E0023")
                        }
                        $(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();
                        templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
                        templatesMap[templateOptions.name].push(template)
                    });
                    $.each(templatesMap, $.proxy(function(templateName, value) {
                        var deviceTemplate = this._findTemplateByDevice(value);
                        if (deviceTemplate) {
                            templates[templateName] = this._createTemplate(deviceTemplate, this)
                        }
                    }, this))
                },
                _findTemplateByDevice: function(templates) {
                    var suitableTemplate = commonUtils.findBestMatches(devices.current(), templates, function(template) {
                        return domUtils.getElementOptions(template).dxTemplate
                    })[0];
                    $.each(templates, function(index, template) {
                        if (template !== suitableTemplate) {
                            $(template).remove()
                        }
                    });
                    return suitableTemplate
                },
                _extractAnonymousTemplate: function() {
                    var templates = this.option("_templates"),
                        anonymousTemplateName = this._getAnonymousTemplateName(),
                        $anonymousTemplate = this.element().contents().detach();
                    var $notJunkTemplateContent = $anonymousTemplate.filter(function(_, element) {
                            var isTextNode = element.nodeType === TEXT_NODE,
                                isEmptyText = $.trim($(element).text()).length < 1;
                            return !(isTextNode && isEmptyText)
                        }),
                        onlyJunkTemplateContent = $notJunkTemplateContent.length < 1;
                    if (!templates[anonymousTemplateName] && !onlyJunkTemplateContent) {
                        templates[anonymousTemplateName] = this._createTemplate($anonymousTemplate, this)
                    }
                },
                _getAriaTarget: function() {
                    return this._focusTarget()
                },
                _getAnonymousTemplateName: function() {
                    return ANONYMOUS_TEMPLATE_NAME
                },
                _getTemplateByOption: function(optionName) {
                    return this._getTemplate(this.option(optionName))
                },
                _getTemplate: function(templateSource) {
                    if ($.isFunction(templateSource)) {
                        var that = this;
                        return new DynamicTemplate(function() {
                            var templateSourceResult = templateSource.apply(that, arguments);
                            if (commonUtils.isDefined(templateSourceResult)) {
                                return that._acquireTemplate(templateSourceResult, this, true)
                            } else {
                                return new EmptyTemplate
                            }
                        }, this)
                    }
                    return this._acquireTemplate(templateSource, this)
                },
                _acquireTemplate: function(templateSource, owner, preferRenderer) {
                    if (null == templateSource) {
                        return this._createTemplate(domUtils.normalizeTemplateElement(templateSource), owner)
                    }
                    if (templateSource instanceof TemplateBase) {
                        return templateSource
                    }
                    if (templateSource.nodeType || templateSource.jquery) {
                        templateSource = $(templateSource);
                        if (preferRenderer && !templateSource.is("script")) {
                            return new MoveTemplate(templateSource, owner)
                        }
                        return this._createTemplate(templateSource, owner)
                    }
                    if ("string" === typeof templateSource) {
                        var userTemplate = this.option("_templates")[templateSource];
                        if (userTemplate) {
                            return userTemplate
                        }
                        var dynamicTemplate = this._dynamicTemplates[templateSource];
                        if (dynamicTemplate) {
                            return dynamicTemplate
                        }
                        var defaultTemplate = this.option("templateProvider").getTemplates(this)[templateSource];
                        if (defaultTemplate) {
                            return defaultTemplate
                        }
                        return this._createTemplate(domUtils.normalizeTemplateElement(templateSource), owner)
                    }
                    return this._acquireTemplate(templateSource.toString(), owner)
                },
                _createTemplate: function(element, owner) {
                    var template = this.option("templateProvider").createTemplate(element, owner);
                    this._tempTemplates.push(template);
                    return template
                },
                _cleanTemplates: function() {
                    var that = this;
                    $.each(this.option("_templates"), function(_, template) {
                        if (that === template.owner()) {
                            template.dispose()
                        }
                    });
                    $.each(this._tempTemplates, function(_, template) {
                        template.dispose()
                    })
                },
                _initContentReadyAction: function() {
                    this._contentReadyAction = this._createActionByOption("onContentReady", {
                        excludeValidators: ["designMode", "disabled", "readOnly"]
                    })
                },
                _render: function() {
                    this.element().addClass(WIDGET_CLASS);
                    this.callBase();
                    this._toggleDisabledState(this.option("disabled"));
                    this._toggleVisibility(this.option("visible"));
                    this._renderHint();
                    this._renderContent();
                    this._renderFocusState();
                    this._attachFeedbackEvents();
                    this._attachHoverEvents()
                },
                _renderHint: function() {
                    domUtils.toggleAttr(this.element(), "title", this.option("hint"))
                },
                _renderContent: function() {
                    var that = this;
                    commonUtils.deferRender(function() {
                        that._renderContentImpl()
                    });
                    that._fireContentReadyAction()
                },
                _renderContentImpl: $.noop,
                _fireContentReadyAction: function() {
                    this._contentReadyAction()
                },
                _dispose: function() {
                    this._cleanTemplates();
                    this._contentReadyAction = null;
                    this.callBase()
                },
                _clean: function() {
                    this._cleanFocusState();
                    this.callBase();
                    this.element().empty()
                },
                _toggleVisibility: function(visible) {
                    this.element().toggleClass(INVISIBLE_STATE_CLASS, !visible);
                    this.setAria("hidden", !visible || void 0)
                },
                _renderFocusState: function() {
                    if (!this.option("focusStateEnabled") || this.option("disabled")) {
                        return
                    }
                    this._renderFocusTarget();
                    this._attachFocusEvents();
                    this._attachKeyboardEvents();
                    this._renderAccessKey()
                },
                _renderAccessKey: function() {
                    var focusTarget = this._focusTarget();
                    focusTarget.attr("accesskey", this.option("accessKey"));
                    var clickNamespace = eventUtils.addNamespace(clickEvent.name, UI_FEEDBACK);
                    focusTarget.off(clickNamespace);
                    this.option("accessKey") && focusTarget.on(clickNamespace, $.proxy(function(e) {
                        if (eventUtils.isFakeClickEvent(e)) {
                            e.stopImmediatePropagation();
                            this.focus()
                        }
                    }, this))
                },
                _eventBindingTarget: function() {
                    return this.element()
                },
                _focusTarget: function() {
                    return this._getActiveElement()
                },
                _getActiveElement: function() {
                    var activeElement = this._eventBindingTarget();
                    if (this._activeStateUnit) {
                        activeElement = activeElement.find(this._activeStateUnit).not("." + DISABLED_STATE_CLASS)
                    }
                    return activeElement
                },
                _renderFocusTarget: function() {
                    this._focusTarget().attr("tabindex", this.option("tabIndex"))
                },
                _keyboardEventBindingTarget: function() {
                    return this._eventBindingTarget()
                },
                _detachFocusEvents: function() {
                    var $element = this._focusTarget(),
                        namespace = this.NAME + FOCUS_NAMESPACE,
                        focusEvents = eventUtils.addNamespace("focusin", namespace);
                    focusEvents = focusEvents + " " + eventUtils.addNamespace("focusout", namespace);
                    if (beforeActivateExists) {
                        focusEvents = focusEvents + " " + eventUtils.addNamespace("beforeactivate", namespace)
                    }
                    $element.off(focusEvents)
                },
                _attachFocusEvents: function() {
                    var namespace = this.NAME + FOCUS_NAMESPACE,
                        focusInEvent = eventUtils.addNamespace("focusin", namespace),
                        focusOutEvent = eventUtils.addNamespace("focusout", namespace);
                    this._focusTarget().on(focusInEvent, $.proxy(this._focusInHandler, this)).on(focusOutEvent, $.proxy(this._focusOutHandler, this));
                    if (beforeActivateExists) {
                        var beforeactivateEvent = eventUtils.addNamespace("beforeactivate", namespace);
                        this._focusTarget().on(beforeactivateEvent, function(e) {
                            if (!$(e.target).is(selectors.focusable)) {
                                e.preventDefault()
                            }
                        })
                    }
                },
                _refreshFocusEvent: function() {
                    this._detachFocusEvents();
                    this._attachFocusEvents()
                },
                _focusInHandler: function(e) {
                    var that = this;
                    that._createActionByOption("onFocusIn", {
                        beforeExecute: function() {
                            that._updateFocusState(e, true)
                        },
                        excludeValidators: ["readOnly"]
                    })({
                        jQueryEvent: e
                    })
                },
                _focusOutHandler: function(e) {
                    var that = this;
                    that._createActionByOption("onFocusOut", {
                        beforeExecute: function() {
                            that._updateFocusState(e, false)
                        },
                        excludeValidators: ["readOnly", "disabled"]
                    })({
                        jQueryEvent: e
                    })
                },
                _updateFocusState: function(e, isFocused) {
                    var target = e.target;
                    if (-1 !== $.inArray(target, this._focusTarget())) {
                        this._toggleFocusClass(isFocused, $(target))
                    }
                },
                _toggleFocusClass: function(isFocused, $element) {
                    var $focusTarget = $element && $element.length ? $element : this._focusTarget();
                    $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused)
                },
                _hasFocusClass: function(element) {
                    var $focusTarget = $(element || this._focusTarget());
                    return $focusTarget.hasClass(FOCUSED_STATE_CLASS)
                },
                _attachKeyboardEvents: function() {
                    var processor = this.option("_keyboardProcessor") || new KeyboardProcessor({
                        element: this._keyboardEventBindingTarget(),
                        focusTarget: this._focusTarget()
                    });
                    this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this)
                },
                _keyboardHandler: function(options) {
                    var e = options.originalEvent,
                        key = options.key;
                    var keys = this._supportedKeys(),
                        func = keys[key];
                    if (void 0 !== func) {
                        var handler = $.proxy(func, this);
                        return handler(e) || false
                    } else {
                        return true
                    }
                },
                _refreshFocusState: function() {
                    this._cleanFocusState();
                    this._renderFocusState()
                },
                _cleanFocusState: function() {
                    var $element = this._focusTarget();
                    this._detachFocusEvents();
                    this._toggleFocusClass(false);
                    $element.removeAttr("tabindex");
                    if (this._keyboardProcessor) {
                        this._keyboardProcessor.dispose()
                    }
                },
                _attachHoverEvents: function() {
                    var that = this,
                        hoverableSelector = that._activeStateUnit,
                        nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),
                        nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);
                    that._eventBindingTarget().off(nameStart, hoverableSelector).off(nameEnd, hoverableSelector);
                    if (that.option("hoverStateEnabled")) {
                        var startAction = new Action(function(args) {
                            that._hoverStartHandler(args.event);
                            var $target = args.element;
                            that._refreshHoveredElement($target)
                        }, {
                            excludeValidators: ["readOnly"]
                        });
                        that._eventBindingTarget().on(nameStart, hoverableSelector, function(e) {
                            startAction.execute({
                                element: $(e.target),
                                event: e
                            })
                        }).on(nameEnd, hoverableSelector, function(e) {
                            that._hoverEndHandler(e);
                            that._forgetHoveredElement()
                        })
                    } else {
                        that._toggleHoverClass(false)
                    }
                },
                _hoverStartHandler: $.noop,
                _hoverEndHandler: $.noop,
                _attachFeedbackEvents: function() {
                    var feedbackAction, feedbackActionDisabled, that = this,
                        feedbackSelector = that._activeStateUnit,
                        activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),
                        inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK);
                    that._eventBindingTarget().off(activeEventName, feedbackSelector).off(inactiveEventName, feedbackSelector);
                    if (that.option("activeStateEnabled")) {
                        var feedbackActionHandler = function(args) {
                            var $element = args.element,
                                value = args.value,
                                jQueryEvent = args.jQueryEvent;
                            that._toggleActiveState($element, value, jQueryEvent)
                        };
                        that._eventBindingTarget().on(activeEventName, feedbackSelector, {
                            timeout: that._feedbackShowTimeout
                        }, function(e) {
                            feedbackAction = feedbackAction || new Action(feedbackActionHandler), feedbackAction.execute({
                                element: $(e.currentTarget),
                                value: true,
                                jQueryEvent: e
                            })
                        }).on(inactiveEventName, feedbackSelector, {
                            timeout: that._feedbackHideTimeout
                        }, function(e) {
                            feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {
                                excludeValidators: ["disabled", "readOnly"]
                            }), feedbackActionDisabled.execute({
                                element: $(e.currentTarget),
                                value: false,
                                jQueryEvent: e
                            })
                        })
                    }
                },
                _toggleActiveState: function($element, value) {
                    this._toggleHoverClass(!value);
                    $element.toggleClass(ACTIVE_STATE_CLASS, value)
                },
                _refreshHoveredElement: function(hoveredElement) {
                    var selector = this._activeStateUnit || this._eventBindingTarget();
                    this._forgetHoveredElement();
                    this._hoveredElement = hoveredElement.closest(selector);
                    this._toggleHoverClass(true)
                },
                _forgetHoveredElement: function() {
                    this._toggleHoverClass(false);
                    delete this._hoveredElement
                },
                _toggleHoverClass: function(value) {
                    if (this._hoveredElement) {
                        this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option("hoverStateEnabled"))
                    }
                },
                _toggleDisabledState: function(value) {
                    this.element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));
                    this._toggleHoverClass(!value);
                    this.setAria("disabled", value || void 0)
                },
                _setWidgetOption: function(widgetName, args) {
                    if (!this[widgetName]) {
                        return
                    }
                    if ($.isPlainObject(args[0])) {
                        $.each(args[0], $.proxy(function(option, value) {
                            this._setWidgetOption(widgetName, [option, value])
                        }, this));
                        return
                    }
                    var optionName = args[0];
                    var value = args[1];
                    if (1 === args.length) {
                        value = this.option(optionName)
                    }
                    var widgetOptionMap = this[widgetName + "OptionMap"];
                    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
                },
                _createComponent: function(element, name, config) {
                    config = config || {};
                    this._extendConfig(config, {
                        templateProvider: this.option("templateProvider"),
                        _templates: this.option("_templates")
                    });
                    return this.callBase(element, name, config)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case "disabled":
                            this._toggleDisabledState(args.value);
                            this._refreshFocusState();
                            break;
                        case "hint":
                            this._renderHint();
                            break;
                        case "activeStateEnabled":
                            this._attachFeedbackEvents();
                            break;
                        case "hoverStateEnabled":
                            this._attachHoverEvents();
                            break;
                        case "tabIndex":
                        case "_keyboardProcessor":
                        case "focusStateEnabled":
                            this._refreshFocusState();
                            break;
                        case "onFocusIn":
                        case "onFocusOut":
                            break;
                        case "accessKey":
                            this._renderAccessKey();
                            break;
                        case "visible":
                            var visible = args.value;
                            this._toggleVisibility(visible);
                            if (this._isVisibilityChangeSupported()) {
                                this._checkVisibilityChanged(args.value ? "shown" : "hiding")
                            }
                            break;
                        case "onContentReady":
                            this._initContentReadyAction();
                            break;
                        case "_templates":
                        case "templateProvider":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _isVisible: function() {
                    return this.callBase() && this.option("visible")
                },
                beginUpdate: function() {
                    this._ready(false);
                    this.callBase()
                },
                endUpdate: function() {
                    this.callBase();
                    if (this._initialized) {
                        this._ready(true)
                    }
                },
                _ready: function(value) {
                    if (0 === arguments.length) {
                        return this._isReady
                    }
                    this._isReady = value
                },
                setAria: function() {
                    var setAttribute = function(option) {
                        var attrName = "role" === option.name || "id" === option.name ? option.name : "aria-" + option.name,
                            attrValue = option.value;
                        if (null === attrValue || void 0 === attrValue) {
                            attrValue = void 0
                        } else {
                            attrValue = attrValue.toString()
                        }
                        domUtils.toggleAttr(option.target, attrName, attrValue)
                    };
                    if (!$.isPlainObject(arguments[0])) {
                        setAttribute({
                            name: arguments[0],
                            value: arguments[1],
                            target: arguments[2] || this._getAriaTarget()
                        })
                    } else {
                        var $target = arguments[1] || this._getAriaTarget();
                        $.each(arguments[0], function(key, value) {
                            setAttribute({
                                name: key,
                                value: value,
                                target: $target
                            })
                        })
                    }
                },
                isReady: function() {
                    return this._ready()
                },
                repaint: function() {
                    this._refresh()
                },
                focus: function() {
                    this._focusTarget().focus()
                },
                registerKeyHandler: function(key, handler) {
                    var currentKeys = this._supportedKeys(),
                        addingKeys = {};
                    addingKeys[key] = handler;
                    this._supportedKeys = function() {
                        return $.extend(currentKeys, addingKeys)
                    }
                }
            });
            module.exports = Widget
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/ui/widget/ui.errors.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errorUtils = __webpack_require__( /*! ../../core/utils/error */ 94),
                errors = __webpack_require__( /*! ../../core/errors */ 10);
            module.exports = errorUtils(errors.ERROR_MESSAGES, {
                E1001: "Module '{0}'. Controller '{1}' is already registered",
                E1002: "Module '{0}'. Controller '{1}' must be inheritor of DevExpress.ui.dxDataGrid.Controller",
                E1003: "Module '{0}'. View '{1}' is already registered",
                E1004: "Module '{0}'. View '{1}' must be inheritor of DevExpress.ui.dxDataGrid.View",
                E1005: "Public method '{0}' is already registered",
                E1006: "Public method '{0}.{1}' is not exists",
                E1007: "State storing can not be provided due to the restrictions of your browser",
                E1010: "A template should contain dxTextBox widget",
                E1011: "You have to implement 'remove' method in dataStore used by dxList to be able to delete items",
                E1012: "Editing type '{0}' with name '{1}' not supported",
                E1016: "Unexpected type of data source is provided for a lookup column",
                E1018: "The 'collapseAll' method cannot be called when using a remote data source",
                E1019: "Search mode '{0}' is unavailable",
                E1020: "Type can not be changed after initialization",
                E1021: "{0} '{1}' you are trying to remove does not exist",
                E1022: "Markers option should be an array",
                E1023: "Routes option should be an array",
                E1024: "Google provider cannot be used in WinJS application",
                E1025: "This layout is too complex to render",
                E1026: "The 'custom' value is set to a summary item's summaryType option, but a function for calculating the custom summary is not assigned to the grid's calculateCustomSummary option",
                E1030: "Unknown dxScrollView refresh strategy: '{0}'",
                E1031: "Unknown subscription is detected in the dxScheduler widget: '{0}'",
                E1032: "Unknown start date is detected in an appointment of the dxScheduler widget: '{0}'",
                E1033: "Unknown step is specified for the scheduler's navigator: '{0}'",
                E1034: "The current browser does not implement an API required for saving files",
                E1035: "The editor could not be created because of the internal error: {0}",
                E1036: "Validation rules are not defined for any form item",
                E1037: "Invalid structure of grouped data",
                E1038: "Your browser does not support local storage for local web pages",
                E0139: "The cell position can not be calculated",
                W1001: "Key option can not be modified after initialization",
                W1002: "Item '{0}' you are trying to select does not exist",
                W1003: "Group with key '{0}' in which you are trying to select items does not exist",
                W1004: "Item '{0}' you are trying to select in group '{1}' does not exist",
                W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns."
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/animation/fx.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                translator = __webpack_require__( /*! ./translator */ 15),
                animationFrame = __webpack_require__( /*! ./frame */ 75),
                support = __webpack_require__( /*! ../core/utils/support */ 18),
                positionUtils = __webpack_require__( /*! ./position */ 65),
                removeEvent = __webpack_require__( /*! ../core/remove_event */ 141),
                eventUtils = __webpack_require__( /*! ../events/utils */ 4),
                transitionEndEventName = support.transitionEndEventName + ".dxFX",
                removeEventName = eventUtils.addNamespace(removeEvent, "dxFX");
            var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
                RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i,
                ANIM_DATA_KEY = "dxAnimData",
                ANIM_QUEUE_KEY = "dxAnimQueue",
                TRANSFORM_PROP = "transform";
            var TransitionAnimationStrategy = {
                initAnimation: function($element, config) {
                    $element.css({
                        transitionProperty: "none"
                    });
                    if ("string" === typeof config.from) {
                        $element.addClass(config.from)
                    } else {
                        setProps($element, config.from)
                    }
                    var that = this,
                        deferred = $.Deferred(),
                        cleanupWhen = config.cleanupWhen;
                    config.transitionAnimation = {
                        deferred: deferred,
                        finish: function() {
                            that._finishTransition($element, config);
                            if (cleanupWhen) {
                                $.when(deferred, cleanupWhen).always(function() {
                                    that._cleanup($element, config)
                                })
                            } else {
                                that._cleanup($element, config)
                            }
                            deferred.resolveWith($element, [config, $element])
                        }
                    };
                    this._completeAnimationCallback($element, config).done(function() {
                        config.transitionAnimation.finish()
                    }).fail(function() {
                        deferred.rejectWith($element, [config, $element])
                    });
                    if (!config.duration) {
                        config.transitionAnimation.finish()
                    }
                    $element.css("transform")
                },
                animate: function($element, config) {
                    this._startAnimation($element, config);
                    return config.transitionAnimation.deferred.promise()
                },
                _completeAnimationCallback: function($element, config) {
                    var simulatedEndEventTimer, waitForJSCompleteTimer, that = this,
                        startTime = $.now() + config.delay,
                        deferred = $.Deferred(),
                        transitionEndFired = $.Deferred(),
                        simulatedTransitionEndFired = $.Deferred();
                    config.transitionAnimation.cleanup = function() {
                        clearTimeout(simulatedEndEventTimer);
                        clearTimeout(waitForJSCompleteTimer);
                        $element.off(transitionEndEventName);
                        $element.off(removeEventName)
                    };
                    $element.one(transitionEndEventName, function() {
                        if ($.now() - startTime >= config.duration) {
                            transitionEndFired.reject()
                        }
                    }).off(removeEventName).on(removeEventName, function() {
                        that.stop($element, config);
                        deferred.reject()
                    });
                    waitForJSCompleteTimer = setTimeout(function() {
                        simulatedEndEventTimer = setTimeout(function() {
                            simulatedTransitionEndFired.reject()
                        }, config.duration + config.delay + fx._simulatedTransitionEndDelay);
                        $.when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
                            deferred.resolve()
                        }, this))
                    });
                    return deferred.promise()
                },
                _startAnimation: function($element, config) {
                    $element.css({
                        transitionProperty: "all",
                        transitionDelay: config.delay + "ms",
                        transitionDuration: config.duration + "ms",
                        transitionTimingFunction: config.easing
                    });
                    if ("string" === typeof config.to) {
                        $element[0].className += " " + config.to
                    } else {
                        if (config.to) {
                            setProps($element, config.to)
                        }
                    }
                },
                _finishTransition: function($element, config) {
                    $element.css("transition", "none")
                },
                _cleanup: function($element, config) {
                    config.transitionAnimation.cleanup();
                    if ("string" === typeof config.from) {
                        $element.removeClass(config.from);
                        $element.removeClass(config.to)
                    }
                },
                stop: function($element, config, jumpToEnd) {
                    if (!config) {
                        return
                    }
                    if (jumpToEnd) {
                        config.transitionAnimation.finish()
                    } else {
                        if ($.isPlainObject(config.to)) {
                            $.each(config.to, function(key) {
                                $element.css(key, $element.css(key))
                            })
                        }
                        this._finishTransition($element, config);
                        this._cleanup($element, config)
                    }
                }
            };
            var FrameAnimationStrategy = {
                initAnimation: function($element, config) {
                    setProps($element, config.from)
                },
                animate: function($element, config) {
                    var deferred = $.Deferred(),
                        that = this;
                    if (!config) {
                        return deferred.reject().promise()
                    }
                    $.each(config.to, function(prop) {
                        if (void 0 === config.from[prop]) {
                            config.from[prop] = that._normalizeValue($element.css(prop))
                        }
                    });
                    if (config.to[TRANSFORM_PROP]) {
                        config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
                        config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
                    }
                    config.frameAnimation = {
                        to: config.to,
                        from: config.from,
                        currentValue: config.from,
                        easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
                        duration: config.duration,
                        startTime: (new Date).valueOf(),
                        finish: function() {
                            this.currentValue = this.to;
                            this.draw();
                            animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);
                            deferred.resolve()
                        },
                        draw: function() {
                            if (config.draw) {
                                config.draw(this.currentValue);
                                return
                            }
                            var currentValue = $.extend({}, this.currentValue);
                            if (currentValue[TRANSFORM_PROP]) {
                                currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                    if ("translate" === prop) {
                                        return translator.getTranslateCss(value)
                                    } else {
                                        if ("scale" === prop) {
                                            return "scale(" + value + ")"
                                        } else {
                                            if ("rotate" === prop.substr(0, prop.length - 1)) {
                                                return prop + "(" + value + "deg)"
                                            }
                                        }
                                    }
                                }).join(" ")
                            }
                            $element.css(currentValue)
                        }
                    };
                    if (config.delay) {
                        config.frameAnimation.startTime += config.delay;
                        config.frameAnimation.delayTimeout = setTimeout(function() {
                            that._startAnimation($element, config)
                        }, config.delay)
                    } else {
                        that._startAnimation($element, config)
                    }
                    return deferred.promise()
                },
                _startAnimation: function($element, config) {
                    $element.off(removeEventName).on(removeEventName, function() {
                        if (config.frameAnimation) {
                            animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId)
                        }
                    });
                    this._animationStep($element, config)
                },
                _parseTransform: function(transformString) {
                    var result = {};
                    $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
                        var translateData = translator.parseTranslate(part),
                            scaleData = part.match(/scale\((.+?)\)/),
                            rotateData = part.match(/(rotate.)\((.+)deg\)/);
                        if (translateData) {
                            result.translate = translateData
                        }
                        if (scaleData && scaleData[1]) {
                            result.scale = parseFloat(scaleData[1])
                        }
                        if (rotateData && rotateData[1]) {
                            result[rotateData[1]] = parseFloat(rotateData[2])
                        }
                    });
                    return result
                },
                stop: function($element, config, jumpToEnd) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation) {
                        return
                    }
                    animationFrame.cancelAnimationFrame(frameAnimation.animationFrameId);
                    clearTimeout(frameAnimation.delayTimeout);
                    if (jumpToEnd) {
                        frameAnimation.finish()
                    }
                    delete config.frameAnimation
                },
                _animationStep: function($element, config) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation) {
                        return
                    }
                    var now = (new Date).valueOf();
                    if (now >= frameAnimation.startTime + frameAnimation.duration) {
                        frameAnimation.finish();
                        return
                    }
                    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                    frameAnimation.draw();
                    var that = this;
                    frameAnimation.animationFrameId = animationFrame.requestAnimationFrame(function() {
                        that._animationStep($element, config)
                    })
                },
                _calcStepValue: function(frameAnimation, currentDuration) {
                    var calcValueRecursively = function(from, to) {
                        var result = $.isArray(to) ? [] : {};
                        var calcEasedValue = function(propName) {
                            var x = currentDuration / frameAnimation.duration,
                                t = currentDuration,
                                b = 1 * from[propName],
                                c = to[propName] - from[propName],
                                d = frameAnimation.duration;
                            return $.easing[frameAnimation.easing](x, t, b, c, d)
                        };
                        $.each(to, function(propName, endPropValue) {
                            if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
                                return true
                            }
                            result[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                        });
                        return result
                    };
                    return calcValueRecursively(frameAnimation.from, frameAnimation.to)
                },
                _normalizeValue: function(value) {
                    var numericValue = parseFloat(value, 10);
                    if (false === numericValue) {
                        return value
                    }
                    return numericValue
                }
            };
            var FallbackToNoAnimationStrategy = {
                initAnimation: function($element, config) {},
                animate: function($element, config) {
                    return $.Deferred().resolve().promise()
                },
                stop: $.noop,
                isSynchronous: true
            };
            var animationStrategies = {
                transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
                frame: FrameAnimationStrategy,
                noAnimation: FallbackToNoAnimationStrategy
            };
            var getAnimationStrategy = function(config) {
                config = config || {};
                var strategy = config.strategy || "transition";
                if ("css" === config.type && !support.transition) {
                    strategy = "noAnimation"
                }
                return animationStrategies[strategy]
            };
            var TransitionTimingFuncMap = {
                linear: "cubic-bezier(0, 0, 1, 1)",
                ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
                "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
                "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
                "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
            };
            var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
                cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
                var bezCoeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
                if (!bezCoeffs) {
                    return "linear"
                }
                bezCoeffs = bezCoeffs.slice(1, 5);
                $.each(bezCoeffs, function(index, value) {
                    bezCoeffs[index] = parseFloat(value)
                });
                var easingName = "cubicbezier_" + bezCoeffs.join("_").replace(/\./g, "p");
                if (!$.isFunction($.easing[easingName])) {
                    var polynomBezier = function(x1, y1, x2, y2) {
                        var Cx = 3 * x1,
                            Bx = 3 * (x2 - x1) - Cx,
                            Ax = 1 - Cx - Bx,
                            Cy = 3 * y1,
                            By = 3 * (y2 - y1) - Cy,
                            Ay = 1 - Cy - By;
                        var bezierX = function(t) {
                            return t * (Cx + t * (Bx + t * Ax))
                        };
                        var bezierY = function(t) {
                            return t * (Cy + t * (By + t * Ay))
                        };
                        var findXfor = function(t) {
                            var z, x = t,
                                i = 0;
                            while (i < 14) {
                                z = bezierX(x) - t;
                                if (Math.abs(z) < .001) {
                                    break
                                }
                                x -= z / derivativeX(x);
                                i++
                            }
                            return x
                        };
                        var derivativeX = function(t) {
                            return Cx + t * (2 * Bx + 3 * t * Ax)
                        };
                        return function(t) {
                            return bezierY(findXfor(t))
                        }
                    };
                    $.easing[easingName] = function(x, t, b, c, d) {
                        return c * polynomBezier(bezCoeffs[0], bezCoeffs[1], bezCoeffs[2], bezCoeffs[3])(t / d) + b
                    }
                }
                return easingName
            };
            var baseConfigValidator = function(config, animationType, validate, typeMessage) {
                $.each(["from", "to"], function() {
                    if (!validate(config[this])) {
                        throw errors.Error("E0010", animationType, this, typeMessage)
                    }
                })
            };
            var isObjectConfigValidator = function(config, animationType) {
                return baseConfigValidator(config, animationType, function(target) {
                    return $.isPlainObject(target)
                }, "a plain object")
            };
            var isStringConfigValidator = function(config, animationType) {
                return baseConfigValidator(config, animationType, function(target) {
                    return "string" === typeof target
                }, "a string")
            };
            var CustomAnimationConfigurator = {
                setup: function($element, config) {}
            };
            var CssAnimationConfigurator = {
                validateConfig: function(config) {
                    isStringConfigValidator(config, "css")
                },
                setup: function($element, config) {}
            };
            var positionAliases = {
                top: {
                    my: "bottom center",
                    at: "top center"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center"
                },
                right: {
                    my: "left center",
                    at: "right center"
                },
                left: {
                    my: "right center",
                    at: "left center"
                }
            };
            var SlideAnimationConfigurator = {
                validateConfig: function(config) {
                    isObjectConfigValidator(config, "slide")
                },
                setup: function($element, config) {
                    var location = translator.locate($element);
                    if ("slide" !== config.type) {
                        var positioningConfig = "slideIn" === config.type ? config.from : config.to;
                        positioningConfig.position = $.extend({
                            of: window
                        }, positionAliases[config.direction]);
                        setupPosition($element, positioningConfig)
                    }
                    this._setUpConfig(location, config.from);
                    this._setUpConfig(location, config.to);
                    translator.clearCache($element);
                    if (!support.transform && "static" === $element.css("position")) {
                        $element.css("position", "relative")
                    }
                },
                _setUpConfig: function(location, config) {
                    config.left = "left" in config ? config.left : "+=0";
                    config.top = "top" in config ? config.top : "+=0";
                    this._initNewPosition(location, config)
                },
                _initNewPosition: function(location, config) {
                    var position = {
                        left: config.left,
                        top: config.top
                    };
                    delete config.left;
                    delete config.top;
                    var relativeValue = this._getRelativeValue(position.left);
                    if (void 0 !== relativeValue) {
                        position.left = relativeValue + location.left
                    } else {
                        config.left = 0
                    }
                    relativeValue = this._getRelativeValue(position.top);
                    if (void 0 !== relativeValue) {
                        position.top = relativeValue + location.top
                    } else {
                        config.top = 0
                    }
                    var translate = {
                        x: 0,
                        y: 0
                    };
                    if (support.transform) {
                        translate = {
                            x: position.left,
                            y: position.top
                        }
                    } else {
                        config.left = position.left;
                        config.top = position.top
                    }
                    config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
                },
                _getRelativeValue: function(value) {
                    var relativeValue;
                    if ("string" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
                        return parseInt(relativeValue[1] + "1") * relativeValue[2]
                    }
                }
            };
            var FadeAnimationConfigurator = {
                setup: function($element, config) {
                    var toOpacity, from = config.from,
                        fromOpacity = $.isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from);
                    switch (config.type) {
                        case "fadeIn":
                            toOpacity = 1;
                            break;
                        case "fadeOut":
                            toOpacity = 0;
                            break;
                        default:
                            toOpacity = String(config.to)
                    }
                    config.from = {
                        visibility: "visible",
                        opacity: fromOpacity
                    };
                    config.to = {
                        opacity: toOpacity
                    }
                }
            };
            var PopAnimationConfigurator = {
                validateConfig: function(config) {
                    isObjectConfigValidator(config, "pop")
                },
                setup: function($element, config) {
                    var from = config.from,
                        to = config.to,
                        fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
                        toOpacity = "opacity" in to ? to.opacity : 1,
                        fromScale = "scale" in from ? from.scale : 0,
                        toScale = "scale" in to ? to.scale : 1;
                    config.from = {
                        opacity: fromOpacity
                    };
                    var translate = translator.getTranslate($element);
                    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
                    config.to = {
                        opacity: toOpacity
                    };
                    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
                },
                _getCssTransform: function(translate, scale) {
                    return translator.getTranslateCss(translate) + "scale(" + scale + ")"
                }
            };
            var animationConfigurators = {
                custom: CustomAnimationConfigurator,
                slide: SlideAnimationConfigurator,
                slideIn: SlideAnimationConfigurator,
                slideOut: SlideAnimationConfigurator,
                fade: FadeAnimationConfigurator,
                fadeIn: FadeAnimationConfigurator,
                fadeOut: FadeAnimationConfigurator,
                pop: PopAnimationConfigurator,
                css: CssAnimationConfigurator
            };
            var getAnimationConfigurator = function(config) {
                var result = animationConfigurators[config.type];
                if (!result) {
                    throw errors.Error("E0011", config.type)
                }
                return result
            };
            var defaultJSConfig = {
                    type: "custom",
                    from: {},
                    to: {},
                    duration: 400,
                    start: $.noop,
                    complete: $.noop,
                    easing: "ease",
                    delay: 0
                },
                defaultCssConfig = {
                    duration: 400,
                    easing: "ease",
                    delay: 0
                };
            var setupAnimationOnElement = function() {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                setupPosition($element, config.from);
                setupPosition($element, config.to);
                animation.configurator.setup($element, config);
                $element.data(ANIM_DATA_KEY, animation);
                if (fx.off) {
                    config.duration = 0;
                    config.delay = 0
                }
                animation.strategy.initAnimation($element, config);
                if (config.start) {
                    config.start.apply(this, [$element, config])
                }
            };
            var onElementAnimationComplete = function(animation) {
                var $element = animation.element,
                    config = animation.config;
                $element.removeData(ANIM_DATA_KEY);
                if (config.complete) {
                    config.complete.apply(this, [$element, config])
                }
                animation.deferred.resolveWith(this, [$element, config])
            };
            var startAnimationOnElement = function() {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                animation.isStarted = true;
                return animation.strategy.animate($element, config).done(function() {
                    onElementAnimationComplete(animation)
                }).fail(function() {
                    animation.deferred.rejectWith(this, [$element, config])
                })
            };
            var stopAnimationOnElement = function(jumpToEnd) {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                clearTimeout(animation.startTimeout);
                if (!animation.isStarted) {
                    animation.start()
                }
                animation.strategy.stop($element, config, jumpToEnd)
            };
            var createAnimation = function(element, initialConfig) {
                var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig,
                    config = $.extend(true, {}, defaultConfig, initialConfig),
                    configurator = getAnimationConfigurator(config),
                    strategy = getAnimationStrategy(config),
                    animation = {
                        element: $(element),
                        config: config,
                        configurator: configurator,
                        strategy: strategy,
                        isSynchronous: strategy.isSynchronous,
                        setup: setupAnimationOnElement,
                        start: startAnimationOnElement,
                        stop: stopAnimationOnElement,
                        deferred: $.Deferred()
                    };
                if ($.isFunction(configurator.validateConfig)) {
                    configurator.validateConfig(config)
                }
                return animation
            };
            var animate = function(element, config) {
                var $element = $(element);
                if (!$element.length) {
                    return $.Deferred().resolve().promise()
                }
                var animation = createAnimation($element, config);
                pushInAnimationQueue($element, animation);
                return animation.deferred.promise()
            };
            var pushInAnimationQueue = function($element, animation) {
                var queueData = getAnimQueueData($element);
                writeAnimQueueData($element, queueData);
                queueData.push(animation);
                if (!isAnimating($element)) {
                    shiftFromAnimationQueue($element, queueData)
                }
            };
            var getAnimQueueData = function($element) {
                return $element.data(ANIM_QUEUE_KEY) || []
            };
            var writeAnimQueueData = function($element, queueData) {
                $element.data(ANIM_QUEUE_KEY, queueData)
            };
            var destroyAnimQueueData = function($element) {
                $element.removeData(ANIM_QUEUE_KEY)
            };
            var isAnimating = function($element) {
                return !!$element.data(ANIM_DATA_KEY)
            };
            var shiftFromAnimationQueue = function($element, queueData) {
                queueData = getAnimQueueData($element);
                if (!queueData.length) {
                    return
                }
                var animation = queueData.shift();
                if (0 === queueData.length) {
                    destroyAnimQueueData($element)
                }
                executeAnimation(animation).done(function() {
                    if (!isAnimating($element)) {
                        shiftFromAnimationQueue($element)
                    }
                })
            };
            var executeAnimation = function(animation) {
                animation.setup();
                if (fx.off || animation.isSynchronous) {
                    animation.start()
                } else {
                    animation.startTimeout = setTimeout(function() {
                        animation.start()
                    });
                    var namespacedRemoveEvent = eventUtils.addNamespace(removeEvent, "dxFXStartAnimation");
                    animation.element.off(namespacedRemoveEvent).on(namespacedRemoveEvent, function() {
                        clearTimeout(animation.startTimeout)
                    })
                }
                return animation.deferred.promise()
            };
            var setupPosition = function($element, config) {
                if (!config || !config.position) {
                    return
                }
                var position = positionUtils.calculate($element, config.position),
                    offset = $element.offset(),
                    currentPosition = $element.position();
                $.extend(config, {
                    left: position.h.location - offset.left + currentPosition.left,
                    top: position.v.location - offset.top + currentPosition.top
                });
                delete config.position
            };
            var setProps = function($element, props) {
                $.each(props, function(key, value) {
                    try {
                        $element.css(key, value)
                    } catch (e) {}
                })
            };
            var stop = function(element, jumpToEnd) {
                var $element = $(element),
                    queueData = getAnimQueueData($element);
                $.each(queueData, function(_, animation) {
                    animation.config.delay = 0;
                    animation.config.duration = 0;
                    animation.isSynchronous = true
                });
                if (!isAnimating($element)) {
                    shiftFromAnimationQueue($element, queueData)
                }
                var animation = $element.data(ANIM_DATA_KEY);
                if (animation) {
                    animation.stop(jumpToEnd)
                }
                $element.removeData(ANIM_DATA_KEY);
                destroyAnimQueueData($element)
            };
            var fx = {
                off: false,
                animationTypes: animationConfigurators,
                animate: animate,
                createAnimation: createAnimation,
                isAnimating: isAnimating,
                stop: stop,
                _simulatedTransitionEndDelay: 100
            };
            fx.__internals = {
                convertTransitionTimingFuncToJQueryEasing: convertTransitionTimingFuncToJQueryEasing
            };
            module.exports = fx
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/core/utils/browser.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
                ieRegExp = /(msie) (\d{1,2}\.\d)/,
                ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/,
                msEdge = /(edge)\/((\d+)?[\w\.]+)/,
                mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
            var browserFromUA = function(ua) {
                ua = ua.toLowerCase();
                var result = {},
                    matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [],
                    browserName = matches[1],
                    browserVersion = matches[2];
                if ("trident" === browserName || "edge" === browserName) {
                    browserName = "msie"
                }
                if (browserName) {
                    result[browserName] = true;
                    result.version = browserVersion
                }
                return result
            };
            module.exports = $.extend({
                _fromUA: browserFromUA
            }, browserFromUA(navigator.userAgent))
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************!*\
      !*** ./Scripts/ui/themes.js ***!
      \******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ./widget/ui.errors */ 20),
                domUtils = __webpack_require__( /*! ../core/utils/dom */ 11),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                viewPortUtils = __webpack_require__( /*! ../core/utils/view_port */ 52),
                viewPort = viewPortUtils.value,
                viewPortChanged = viewPortUtils.changeCallback;
            var DX_LINK_SELECTOR = "link[rel=dx-theme]",
                THEME_ATTR = "data-theme",
                ACTIVE_ATTR = "data-active",
                DX_HAIRLINES_CLASS = "dx-hairlines";
            var context, $activeThemeLink, knownThemes, currentThemeName, pendingThemeName;
            var THEME_MARKER_PREFIX = "dx.";

            function readThemeMarker() {
                var result, element = $("<div></div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
                try {
                    result = element.css("font-family");
                    if (!result) {
                        return null
                    }
                    result = result.replace(/["']/g, "");
                    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
                        return null
                    }
                    return result.substr(THEME_MARKER_PREFIX.length)
                } finally {
                    element.remove()
                }
            }

            function waitForThemeLoad(themeName, callback) {
                var timerId, waitStartTime;
                pendingThemeName = themeName;

                function handleLoaded() {
                    pendingThemeName = null;
                    callback()
                }
                if (isPendingThemeLoaded()) {
                    handleLoaded()
                } else {
                    waitStartTime = $.now();
                    timerId = setInterval(function() {
                        var isLoaded = isPendingThemeLoaded(),
                            isTimeout = !isLoaded && $.now() - waitStartTime > 15e3;
                        if (isTimeout) {
                            errors.log("W0004", pendingThemeName)
                        }
                        if (isLoaded || isTimeout) {
                            clearInterval(timerId);
                            handleLoaded()
                        }
                    }, 10)
                }
            }

            function isPendingThemeLoaded() {
                return !pendingThemeName || readThemeMarker() === pendingThemeName
            }

            function processMarkup() {
                var $allThemeLinks = $(DX_LINK_SELECTOR, context);
                if (!$allThemeLinks.length) {
                    return
                }
                knownThemes = {};
                $activeThemeLink = $(domUtils.createMarkupFromString("<link rel=stylesheet>"), context);
                $allThemeLinks.each(function() {
                    var link = $(this, context),
                        fullThemeName = link.attr(THEME_ATTR),
                        url = link.attr("href"),
                        isActive = "true" === link.attr(ACTIVE_ATTR);
                    knownThemes[fullThemeName] = {
                        url: url,
                        isActive: isActive
                    }
                });
                $allThemeLinks.last().after($activeThemeLink);
                $allThemeLinks.remove()
            }

            function resolveFullThemeName(desiredThemeName) {
                var desiredThemeParts = desiredThemeName.split("."),
                    result = null;
                if (knownThemes) {
                    $.each(knownThemes, function(knownThemeName, themeData) {
                        var knownThemeParts = knownThemeName.split(".");
                        if (knownThemeParts[0] !== desiredThemeParts[0]) {
                            return
                        }
                        if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
                            return
                        }
                        if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
                            return
                        }
                        if (!result || themeData.isActive) {
                            result = knownThemeName
                        }
                        if (themeData.isActive) {
                            return false
                        }
                    })
                }
                return result
            }

            function initContext(newContext) {
                try {
                    if (newContext !== context) {
                        knownThemes = null
                    }
                } catch (x) {
                    knownThemes = null
                }
                context = newContext
            }

            function init(options) {
                options = options || {};
                initContext(options.context || document);
                processMarkup();
                currentThemeName = void 0;
                current(options)
            }

            function current(options) {
                if (!arguments.length) {
                    currentThemeName = currentThemeName || readThemeMarker();
                    return currentThemeName
                }
                detachCssClasses(viewPort(), currentThemeName);
                options = options || {};
                if ("string" === typeof options) {
                    options = {
                        theme: options
                    }
                }
                var currentThemeData, isAutoInit = options._autoInit,
                    loadCallback = options.loadCallback;
                currentThemeName = options.theme || currentThemeName;
                if (isAutoInit && !currentThemeName) {
                    currentThemeName = themeNameFromDevice(devices.current())
                }
                currentThemeName = resolveFullThemeName(currentThemeName);
                if (currentThemeName) {
                    currentThemeData = knownThemes[currentThemeName]
                }
                if (currentThemeData) {
                    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
                    if (loadCallback) {
                        waitForThemeLoad(currentThemeName, loadCallback)
                    } else {
                        if (pendingThemeName) {
                            pendingThemeName = currentThemeName
                        }
                    }
                } else {
                    if (isAutoInit) {
                        if (loadCallback) {
                            loadCallback()
                        }
                    } else {
                        throw errors.Error("E0021", currentThemeName)
                    }
                }
                attachCssClasses(viewPortUtils.originalViewPort(), currentThemeName)
            }

            function themeNameFromDevice(device) {
                var themeName = device.platform;
                var majorVersion = device.version && device.version[0];
                switch (themeName) {
                    case "ios":
                        themeName += "7";
                        break;
                    case "android":
                        themeName += "5";
                        break;
                    case "win":
                        themeName += majorVersion && 8 === majorVersion ? "8" : "10"
                }
                return themeName
            }

            function getCssClasses(themeName) {
                themeName = themeName || current();
                var result = [],
                    themeNameParts = themeName && themeName.split(".");
                if (themeNameParts) {
                    result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
                    if (themeNameParts.length > 1) {
                        result.push("dx-color-scheme-" + themeNameParts[1])
                    }
                }
                return result
            }
            var themeClasses;

            function attachCssClasses(element, themeName) {
                themeClasses = getCssClasses(themeName).join(" ");
                $(element).addClass(themeClasses);
                var activateHairlines = function() {
                    var pixelRatio = window.devicePixelRatio;
                    if (!pixelRatio || pixelRatio < 2) {
                        return
                    }
                    var $tester = $("<div>");
                    $tester.css("border", ".5px solid transparent");
                    $("body").append($tester);
                    if (1 === $tester.outerHeight()) {
                        $(element).addClass(DX_HAIRLINES_CLASS);
                        themeClasses += " " + DX_HAIRLINES_CLASS
                    }
                    $tester.remove()
                };
                activateHairlines()
            }

            function detachCssClasses(element, themeName) {
                $(element).removeClass(themeClasses)
            }
            $.holdReady(true);
            init({
                _autoInit: true,
                loadCallback: function() {
                    $.holdReady(false)
                }
            });
            $(function() {
                if ($(DX_LINK_SELECTOR, context).length) {
                    throw errors.Error("E0022")
                }
            });
            viewPortChanged.add(function(viewPort, prevViewPort) {
                detachCssClasses(prevViewPort);
                attachCssClasses(viewPort)
            });
            devices.changed.add(function() {
                init({
                    _autoInit: true
                })
            });
            exports.current = current;
            exports.init = init;
            exports.attachCssClasses = attachCssClasses;
            exports.detachCssClasses = detachCssClasses;
            exports.themeNameFromDevice = themeNameFromDevice;
            exports.waitForThemeLoad = waitForThemeLoad;
            exports.resetTheme = function() {
                $activeThemeLink && $activeThemeLink.attr("href", "about:blank");
                currentThemeName = null;
                pendingThemeName = null
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!********************************!*\
      !*** ./Scripts/data/errors.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errorUtils = __webpack_require__( /*! ../core/utils/error */ 94),
                coreErrors = __webpack_require__( /*! ../core/errors */ 10),
                handlers = {};
            var errors = errorUtils(coreErrors.ERROR_MESSAGES, {
                E4000: "[DevExpress.data]: {0}",
                E4001: "Unknown aggregating function is detected: '{0}'",
                E4002: "Unsupported OData protocol version is used",
                E4003: "Unknown filter operation is used: {0}",
                E4004: "The thenby() method is called before the sortby() method",
                E4005: "Store requires a key expression for this operation",
                E4006: "ArrayStore 'data' option must be an array",
                E4007: "Compound keys cannot be auto-generated",
                E4008: "Attempt to insert an item with the a duplicated key",
                E4009: "Data item cannot be found",
                E4010: "CustomStore does not support creating queries",
                E4011: "Custom Store method is not implemented or is not a function: {0}",
                E4012: "Custom Store method returns an invalid value: {0}",
                E4013: "Local Store requires the 'name' configuration option is specified",
                E4014: "Unknown key type is detected: {0}",
                E4015: "Unknown entity name or alias is used: {0}",
                E4017: "Keys cannot be modified",
                E4018: "The server has returned a non-numeric value in a response to an item count request",
                E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
                E4020: "Unknown store type is detected: {0}"
            });

            function handleError(error) {
                var id = "E4000";
                if (error && "__id" in error) {
                    id = error.__id
                }
                errors.log(id, error)
            }
            var errorHandler = null;
            var _errorHandler = function(error) {
                handleError(error);
                if (handlers.errorHandler) {
                    handlers.errorHandler(error)
                }
            };
            handlers = {
                errors: errors,
                errorHandler: errorHandler,
                _errorHandler: _errorHandler
            };
            module.exports = handlers
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/utils/string.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ./common */ 2);
            var encodeHtml = function() {
                var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
                return function(str) {
                    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;")
                }
            }();
            var pairToObject = function(raw) {
                var pair = commonUtils.splitPair(raw),
                    h = parseInt(pair && pair[0], 10),
                    v = parseInt(pair && pair[1], 10);
                if (!isFinite(h)) {
                    h = 0
                }
                if (!isFinite(v)) {
                    v = h
                }
                return {
                    h: h,
                    v: v
                }
            };
            var quadToObject = function(raw) {
                var quad = commonUtils.splitQuad(raw),
                    left = parseInt(quad && quad[0], 10),
                    top = parseInt(quad && quad[1], 10),
                    right = parseInt(quad && quad[2], 10),
                    bottom = parseInt(quad && quad[3], 10);
                if (!isFinite(left)) {
                    left = 0
                }
                if (!isFinite(top)) {
                    top = left
                }
                if (!isFinite(right)) {
                    right = left
                }
                if (!isFinite(bottom)) {
                    bottom = top
                }
                return {
                    top: top,
                    right: right,
                    bottom: bottom,
                    left: left
                }
            };
            var stringFormat = function() {
                var replaceDollarCount, reg, value, s = arguments[0],
                    values = $.makeArray(arguments).slice(1);
                if ($.isFunction(s)) {
                    return s.apply(this, values)
                }
                for (var i = 0; i < values.length; i++) {
                    reg = new RegExp("\\{" + i + "\\}", "gm");
                    value = values[i];
                    if ("string" === $.type(value) && value.indexOf("$") >= 0) {
                        replaceDollarCount = "$".replace("$", "$$").length;
                        value = value.replace("$", 1 === replaceDollarCount ? "$$$$" : "$$")
                    }
                    s = s.replace(reg, value)
                }
                return s
            };
            var replaceAll = function() {
                var preg_quote = function(str) {
                    return (str + "").replace(/([\+\*\?\\\.\[\^\]\$\(\)\{\}\><\|\=\!\:])/g, "\\$1")
                };
                return function(text, searchToken, replacementToken) {
                    return text.replace(new RegExp("(" + preg_quote(searchToken) + ")", "gi"), replacementToken)
                }
            }();
            var isEmpty = function(text) {
                var SPACE_REGEXP = /\s/g;
                return function(text) {
                    return !text || !text.replace(SPACE_REGEXP, "")
                }
            }();
            exports.encodeHtml = encodeHtml;
            exports.pairToObject = pairToObject;
            exports.quadToObject = quadToObject;
            exports.format = stringFormat;
            exports.replaceAll = replaceAll;
            exports.isEmpty = isEmpty
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************************!*\
      !*** ./Scripts/ui/collection/ui.collection_widget.edit.js ***!
      \************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseCollectionWidget = __webpack_require__( /*! ./ui.collection_widget.base */ 303),
                errors = __webpack_require__( /*! ../widget/ui.errors */ 20),
                arrayUtils = __webpack_require__( /*! ../../core/utils/array */ 41),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                PlainEditStrategy = __webpack_require__( /*! ./ui.collection_widget.edit.strategy.plain */ 153),
                DataSource = __webpack_require__( /*! ../../data/data_source/data_source */ 37).DataSource;
            var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
            var CollectionWidget = BaseCollectionWidget.inherit({
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {
                        selectedItem: true
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        selectionMode: "none",
                        selectionRequired: false,
                        selectionByClick: true,
                        selectedItems: [],
                        selectedIndex: -1,
                        selectedItem: null,
                        onSelectionChanged: null,
                        onItemReordered: null,
                        onItemDeleting: null,
                        onItemDeleted: null
                    })
                },
                _init: function() {
                    this._initEditStrategy();
                    this.callBase();
                    this._selectedItemIndices = [];
                    if ("multi" === this.option("selectionMode")) {
                        this._showDeprecatedSelectionMode()
                    }
                },
                _initEditStrategy: function() {
                    var Strategy = PlainEditStrategy;
                    this._editStrategy = new Strategy(this)
                },
                _forgetNextPageLoading: function() {
                    this.callBase();
                    this._selectedItemIndices = this._editStrategy.selectedItemIndices()
                },
                _render: function() {
                    this._syncSelectionOptions();
                    this._normalizeSelectedItems();
                    this._initSelectedItems();
                    this.callBase();
                    this._renderSelection(this._selectedItemIndices, [])
                },
                _syncSelectionOptions: function(byOption) {
                    byOption = byOption || this._chooseSelectOption();
                    var selectedItem, selectedItems;
                    switch (byOption) {
                        case "selectedIndex":
                            selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
                            if (commonUtils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedItem", selectedItem)
                            } else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedItem", null)
                            }
                            break;
                        case "selectedItems":
                            selectedItems = this.option("selectedItems") || [];
                            this._setOptionSilent("selectedItem", selectedItems[0]);
                            this._setOptionSilent("selectedIndex", this._editStrategy.getIndexByItemData(selectedItems[0]));
                            break;
                        case "selectedItem":
                            selectedItem = this.option("selectedItem");
                            if (commonUtils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedIndex", this._editStrategy.getIndexByItemData(selectedItem))
                            } else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedIndex", -1)
                            }
                    }
                },
                _chooseSelectOption: function() {
                    var optionName = "selectedIndex";
                    if (this.option("selectedItems").length) {
                        optionName = "selectedItems"
                    } else {
                        if (commonUtils.isDefined(this.option("selectedItem"))) {
                            optionName = "selectedItem"
                        }
                    }
                    return optionName
                },
                _normalizeSelectedItems: function() {
                    if ("none" === this.option("selectionMode")) {
                        this._setOptionSilent("selectedItems", []);
                        this._syncSelectionOptions("selectedItems")
                    } else {
                        if ("single" === this.option("selectionMode")) {
                            var newSelection = this._editStrategy.selectedItemIndices(this.option("selectedItems"));
                            if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                                var normalizedSelection = [newSelection[0] || this._selectedItemIndices[0] || 0];
                                this._setOptionSilent("selectedItems", this._editStrategy.fetchSelectedItems(normalizedSelection));
                                this._syncSelectionOptions("selectedItems")
                            }
                        }
                    }
                },
                _initSelectedItems: function() {
                    this._selectedItemIndices = this._editStrategy.selectedItemIndices(this.option("selectedItems"))
                },
                _renderSelection: $.noop,
                _itemClickHandler: function(e) {
                    this._createAction($.proxy(function(e) {
                        this._itemSelectHandler(e.jQueryEvent)
                    }, this), {
                        validatingTargetName: "itemElement"
                    })({
                        itemElement: $(e.currentTarget),
                        jQueryEvent: e
                    });
                    this.callBase.apply(this, arguments)
                },
                _itemSelectHandler: function(e) {
                    if (!this.option("selectionByClick")) {
                        return
                    }
                    var $itemElement = e.currentTarget;
                    if (this.isItemSelected($itemElement)) {
                        this.unselectItem(e.currentTarget)
                    } else {
                        this.selectItem(e.currentTarget)
                    }
                },
                _selectedItemElement: function(index) {
                    return this._itemElements().eq(index)
                },
                _postprocessRenderItem: function(args) {
                    var $itemElement = $(args.itemElement);
                    if (this._isItemSelected(this._editStrategy.getNormalizedIndex($itemElement))) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true")
                    } else {
                        this._setAriaSelected($itemElement, "false")
                    }
                },
                _updateSelectedItems: function() {
                    var that = this,
                        oldSelection = this._selectedItemIndices.slice(),
                        newSelection = this._editStrategy.selectedItemIndices(),
                        addedSelection = arrayUtils.removeDuplicates(newSelection, oldSelection),
                        removedSelection = arrayUtils.removeDuplicates(oldSelection, newSelection);
                    $.each(removedSelection, function(_, normalizedIndex) {
                        that._removeSelection(normalizedIndex)
                    });
                    $.each(addedSelection, function(_, normalizedIndex) {
                        that._addSelection(normalizedIndex)
                    });
                    if (removedSelection.length || addedSelection.length) {
                        var selectionChangePromise = this._selectionChangePromise;
                        this._updateSelection(addedSelection, removedSelection);
                        $.when(selectionChangePromise).done(function() {
                            that._fireSelectionChangeEvent(addedSelection, removedSelection)
                        })
                    }
                },
                _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
                    this._createActionByOption("onSelectionChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    })(this._editStrategy.fetchSelectionDifference(addedSelection, removedSelection))
                },
                _updateSelection: function() {
                    this._renderSelection.apply(this, arguments)
                },
                _setAriaSelected: function($target, value) {
                    this.setAria("selected", value, $target)
                },
                _removeSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex),
                        itemSelectionIndex = $.inArray(normalizedIndex, this._selectedItemIndices);
                    if (itemSelectionIndex > -1) {
                        $itemElement.removeClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "false");
                        this._selectedItemIndices.splice(itemSelectionIndex, 1);
                        $itemElement.triggerHandler("stateChanged")
                    }
                },
                _showDeprecatedSelectionMode: function() {
                    errors.log("W0001", this.NAME, "selectionMode: 'multi'", "16.1", "Use selectionMode: 'multiple' instead");
                    this.option("selectionMode", "multiple")
                },
                _addSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
                    if (normalizedIndex > -1 && !this._isItemSelected(normalizedIndex)) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true");
                        this._selectedItemIndices.push(normalizedIndex);
                        $itemElement.triggerHandler("stateChanged")
                    }
                },
                _isItemSelected: function(index) {
                    return $.inArray(index, this._selectedItemIndices) > -1
                },
                _optionChanged: function(args) {
                    if (this._cancelOptionChange) {
                        return
                    }
                    switch (args.name) {
                        case "selectionMode":
                            if ("multi" === args.value) {
                                this._showDeprecatedSelectionMode()
                            } else {
                                this._invalidate()
                            }
                            break;
                        case "selectedIndex":
                        case "selectedItem":
                        case "selectedItems":
                            this._syncSelectionOptions(args.name);
                            this._normalizeSelectedItems();
                            this._updateSelectedItems();
                            break;
                        case "selectionRequired":
                            this._normalizeSelectedItems();
                            this._updateSelectedItems();
                            break;
                        case "selectionByClick":
                        case "onSelectionChanged":
                        case "onItemDeleting":
                        case "onItemDeleted":
                        case "onItemReordered":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _clearSelectedItems: function() {
                    this._selectedItemIndices = [];
                    this._setOptionSilent("selectedItems", []);
                    this._syncSelectionOptions("selectedItems")
                },
                _setOptionSilent: function(name, value) {
                    this._cancelOptionChange = true;
                    this.option(name, value);
                    this._cancelOptionChange = false
                },
                _waitDeletingPrepare: function($itemElement) {
                    if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
                        return $.Deferred().resolve().promise()
                    }
                    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
                    var deferred = $.Deferred(),
                        deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", {}, {
                            excludeValidators: ["disabled", "readOnly"]
                        });
                    $.when(deletePromise).always($.proxy(function(value) {
                        var deletePromiseExists = !deletePromise,
                            deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state(),
                            argumentsSpecified = !!arguments.length,
                            shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
                        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
                        shouldDelete ? deferred.resolve() : deferred.reject()
                    }, this));
                    return deferred.promise()
                },
                _deleteItemFromDS: function($item) {
                    if (!this._dataSource) {
                        return $.Deferred().resolve().promise()
                    }
                    var deferred = $.Deferred(),
                        disabledState = this.option("disabled"),
                        dataStore = this._dataSource.store();
                    this.option("disabled", true);
                    if (!dataStore.remove) {
                        throw errors.Error("E1011")
                    }
                    dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
                        if (void 0 !== key) {
                            deferred.resolve()
                        } else {
                            deferred.reject()
                        }
                    }).fail(function() {
                        deferred.reject()
                    });
                    deferred.always($.proxy(function() {
                        this.option("disabled", disabledState)
                    }, this));
                    return deferred
                },
                _tryRefreshLastPage: function() {
                    var deferred = $.Deferred();
                    if (this._isLastPage() || this.option("grouped")) {
                        deferred.resolve()
                    } else {
                        this._refreshLastPage().done(function() {
                            deferred.resolve()
                        })
                    }
                    return deferred.promise()
                },
                _refreshLastPage: function() {
                    this._expectLastItemLoading();
                    return this._dataSource.load()
                },
                _updateSelectionAfterDelete: function(fromIndex) {
                    var itemIndex = $.inArray(fromIndex, this._selectedItemIndices);
                    if (itemIndex > -1) {
                        this._selectedItemIndices.splice(itemIndex, 1)
                    }
                    this._editStrategy.updateSelectionAfterDelete(fromIndex);
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems())
                },
                _simulateOptionChange: function(optionName) {
                    var optionValue = this.option(optionName);
                    if (optionValue instanceof DataSource) {
                        return
                    }
                    this._optionChangedAction({
                        name: optionName,
                        fullName: optionName,
                        value: optionValue
                    })
                },
                isItemSelected: function(itemElement) {
                    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
                },
                selectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (-1 === itemIndex) {
                        return
                    }
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (-1 !== itemSelectionIndex) {
                        return
                    }
                    if ("single" === this.option("selectionMode")) {
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems([itemIndex]))
                    } else {
                        var newSelectedIndices = this._selectedItemIndices.slice();
                        newSelectedIndices.push(itemIndex);
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                    }
                },
                unselectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (-1 === itemIndex) {
                        return
                    }
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (-1 === itemSelectionIndex) {
                        return
                    }
                    var newSelectedIndices = this._selectedItemIndices.slice();
                    newSelectedIndices.splice(itemSelectionIndex, 1);
                    if (this.option("selectionRequired") && 0 === newSelectedIndices.length) {
                        return
                    }
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                },
                deleteItem: function(itemElement) {
                    var that = this,
                        deferred = $.Deferred(),
                        $item = this._editStrategy.getItemElement(itemElement),
                        index = this._editStrategy.getNormalizedIndex(itemElement),
                        changingOption = this._dataSource ? "dataSource" : "items",
                        itemResponseWaitClass = this._itemResponseWaitClass();
                    if (index > -1) {
                        this._waitDeletingPrepare($item).done(function() {
                            $item.addClass(itemResponseWaitClass);
                            var deletedActionArgs = that._extendActionArgs($item);
                            that._deleteItemFromDS($item).done(function() {
                                that._editStrategy.deleteItemAtIndex(index);
                                that._simulateOptionChange(changingOption);
                                that._updateSelectionAfterDelete(index);
                                that._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
                                    beforeExecute: function() {
                                        $item.detach()
                                    },
                                    excludeValidators: ["disabled", "readOnly"]
                                });
                                that._renderEmptyMessage();
                                that._tryRefreshLastPage().done(function() {
                                    deferred.resolveWith(that)
                                })
                            }).fail(function() {
                                $item.removeClass(itemResponseWaitClass);
                                deferred.rejectWith(that)
                            })
                        }).fail(function() {
                            deferred.rejectWith(that)
                        })
                    } else {
                        deferred.rejectWith(that)
                    }
                    return deferred.promise()
                },
                reorderItem: function(itemElement, toItemElement) {
                    var deferred = $.Deferred(),
                        that = this,
                        strategy = this._editStrategy,
                        $movingItem = strategy.getItemElement(itemElement),
                        $destinationItem = strategy.getItemElement(toItemElement),
                        movingIndex = strategy.getNormalizedIndex(itemElement),
                        destinationIndex = strategy.getNormalizedIndex(toItemElement),
                        changingOption = this._dataSource ? "dataSource" : "items";
                    var canMoveItems = movingIndex > -1 && destinationIndex > -1 && movingIndex !== destinationIndex;
                    if (canMoveItems) {
                        deferred.resolveWith(this)
                    } else {
                        deferred.rejectWith(this)
                    }
                    return deferred.promise().done(function() {
                        $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
                        var newSelectedItems = strategy.getSelectedItemsAfterReorderItem(movingIndex, destinationIndex);
                        strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
                        that._selectedItemIndices = strategy.selectedItemIndices(newSelectedItems);
                        that.option("selectedItems", strategy.fetchSelectedItems());
                        if ("items" === changingOption) {
                            that._simulateOptionChange(changingOption)
                        }
                        that._itemEventHandler($movingItem, "onItemReordered", {
                            fromIndex: strategy.getIndex(movingIndex),
                            toIndex: strategy.getIndex(destinationIndex)
                        }, {
                            excludeValidators: ["disabled", "readOnly"]
                        })
                    })
                }
            });
            module.exports = CollectionWidget
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/data/utils.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                toComparable = __webpack_require__( /*! ../core/utils/data */ 16).toComparable;
            var normalizeBinaryCriterion = function(crit) {
                return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
            };
            var normalizeSortingInfo = function(info) {
                if (!$.isArray(info)) {
                    info = [info]
                }
                return $.map(info, function(i) {
                    return {
                        selector: $.isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
                        desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
                    }
                })
            };
            var errorMessageFromXhr = function() {
                var textStatusMessages = {
                    timeout: "Network connection timeout",
                    error: "Unspecified network error",
                    parsererror: "Unexpected server response"
                };
                var textStatusDetails = {
                    timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                    error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                    parsererror: "the remote host did not respond with valid JSON data"
                };
                var explainTextStatus = function(textStatus) {
                    var result = textStatusMessages[textStatus];
                    if (!result) {
                        return textStatus
                    }
                    result += " (" + textStatusDetails[textStatus] + ")";
                    return result
                };
                return function(xhr, textStatus) {
                    if (xhr.status < 400) {
                        return explainTextStatus(textStatus)
                    }
                    return xhr.statusText
                }
            }();
            var aggregators = {
                count: {
                    seed: 0,
                    step: function(count) {
                        return 1 + count
                    }
                },
                sum: {
                    seed: 0,
                    step: function(sum, item) {
                        return sum + item
                    }
                },
                min: {
                    step: function(min, item) {
                        return item < min ? item : min
                    }
                },
                max: {
                    step: function(max, item) {
                        return item > max ? item : max
                    }
                },
                avg: {
                    seed: [0, 0],
                    step: function(pair, value) {
                        return [pair[0] + value, pair[1] + 1]
                    },
                    finalize: function(pair) {
                        return pair[1] ? pair[0] / pair[1] : NaN
                    }
                }
            };
            var processRequestResultLock = function() {
                var lockDeferred, lockCount = 0;
                var obtain = function() {
                    if (0 === lockCount) {
                        lockDeferred = $.Deferred()
                    }
                    lockCount++
                };
                var release = function() {
                    lockCount--;
                    if (lockCount < 1) {
                        lockDeferred.resolve()
                    }
                };
                var promise = function() {
                    var deferred = 0 === lockCount ? $.Deferred().resolve() : lockDeferred;
                    return deferred.promise()
                };
                var reset = function() {
                    lockCount = 0;
                    if (lockDeferred) {
                        lockDeferred.resolve()
                    }
                };
                return {
                    obtain: obtain,
                    release: release,
                    promise: promise,
                    reset: reset
                }
            }();

            function isDisjunctiveOperator(condition) {
                return /^(or|\|\||\|)$/i.test(condition)
            }

            function isConjunctiveOperator(condition) {
                return /^(and|\&\&|\&)$/i.test(condition)
            }
            var keysEqual = function(keyExpr, key1, key2) {
                if ($.isArray(keyExpr)) {
                    var name, names = $.map(key1, function(v, k) {
                        return k
                    });
                    for (var i = 0; i < names.length; i++) {
                        name = names[i];
                        if (toComparable(key1[name], true) != toComparable(key2[name], true)) {
                            return false
                        }
                    }
                    return true
                }
                return toComparable(key1, true) == toComparable(key2, true)
            };
            var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var base64_encode = function(input) {
                if (!$.isArray(input)) {
                    input = stringToByteArray(String(input))
                }
                var result = "";

                function getBase64Char(index) {
                    return BASE64_CHARS.charAt(index)
                }
                for (var i = 0; i < input.length; i += 3) {
                    var octet1 = input[i],
                        octet2 = input[i + 1],
                        octet3 = input[i + 2];
                    result += $.map([octet1 >> 2, (3 & octet1) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (15 & octet2) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : 63 & octet3], getBase64Char).join("")
                }
                return result
            };
            var stringToByteArray = function(str) {
                var code, i, bytes = [];
                for (i = 0; i < str.length; i++) {
                    code = str.charCodeAt(i);
                    if (code < 128) {
                        bytes.push(code)
                    } else {
                        if (code < 2048) {
                            bytes.push(192 + (code >> 6), 128 + (63 & code))
                        } else {
                            if (code < 65536) {
                                bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (63 & code))
                            } else {
                                if (code < 2097152) {
                                    bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (63 & code))
                                }
                            }
                        }
                    }
                }
                return bytes
            };
            var utils = {
                normalizeBinaryCriterion: normalizeBinaryCriterion,
                normalizeSortingInfo: normalizeSortingInfo,
                errorMessageFromXhr: errorMessageFromXhr,
                aggregators: aggregators,
                keysEqual: keysEqual,
                isDisjunctiveOperator: isDisjunctiveOperator,
                isConjunctiveOperator: isConjunctiveOperator,
                processRequestResultLock: processRequestResultLock,
                base64_encode: base64_encode
            };
            module.exports = utils
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/core/utils/inflector.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var _normalize = function(text) {
                if (void 0 === text || null === text) {
                    return ""
                }
                return String(text)
            };
            var _ucfirst = function(text) {
                return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
            };
            var _chop = function(text) {
                return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
            };
            var dasherize = function(text) {
                return $.map(_chop(text), function(p) {
                    return p.toLowerCase()
                }).join("-")
            };
            var underscore = function(text) {
                return dasherize(text).replace(/-/g, "_")
            };
            var camelize = function(text, upperFirst) {
                return $.map(_chop(text), function(p, i) {
                    p = p.toLowerCase();
                    if (upperFirst || i > 0) {
                        p = _ucfirst(p)
                    }
                    return p
                }).join("")
            };
            var humanize = function(text) {
                return _ucfirst(dasherize(text).replace(/-/g, " "))
            };
            var titleize = function(text) {
                return $.map(_chop(text), function(p) {
                    return _ucfirst(p.toLowerCase())
                }).join(" ")
            };
            var captionize = function(name) {
                var i, char, captionList = [],
                    isPrevCharNewWord = false,
                    isNewWord = false;
                for (i = 0; i < name.length; i++) {
                    char = name.charAt(i);
                    isNewWord = char === char.toUpperCase() || char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
                    if ("_" === char || "." === char) {
                        char = " ";
                        isNewWord = true
                    } else {
                        if (0 === i) {
                            char = char.toUpperCase();
                            isNewWord = true
                        } else {
                            if (!isPrevCharNewWord && isNewWord) {
                                if (captionList.length > 0) {
                                    captionList.push(" ")
                                }
                            }
                        }
                    }
                    captionList.push(char);
                    isPrevCharNewWord = isNewWord
                }
                return captionList.join("")
            };
            exports.dasherize = dasherize;
            exports.camelize = camelize;
            exports.humanize = humanize;
            exports.titleize = titleize;
            exports.underscore = underscore;
            exports.captionize = captionize
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/utils/object.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ./common */ 2);
            var clone = function() {
                function Clone() {}
                return function(obj) {
                    Clone.prototype = obj;
                    return new Clone
                }
            }();
            var extendFromObject = function(target, source, overrideExistingValues) {
                target = target || {};
                for (var prop in source) {
                    if (source.hasOwnProperty(prop)) {
                        var value = source[prop];
                        if (!(prop in target) || overrideExistingValues) {
                            target[prop] = value
                        }
                    }
                }
                return target
            };
            var orderEach = function(map, func) {
                var key, i, keys = [];
                for (key in map) {
                    if (map.hasOwnProperty(key)) {
                        keys.push(key)
                    }
                }
                keys.sort(function(x, y) {
                    var isNumberX = commonUtils.isNumber(x),
                        isNumberY = commonUtils.isNumber(y);
                    if (isNumberX && isNumberY) {
                        return x - y
                    }
                    if (isNumberX && !isNumberY) {
                        return -1
                    }
                    if (!isNumberX && isNumberY) {
                        return 1
                    }
                    if (x < y) {
                        return -1
                    }
                    if (x > y) {
                        return 1
                    }
                    return 0
                });
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    func(key, map[key])
                }
            };
            var deepExtendArraySafe = function(target, changes) {
                var prevValue, newValue;
                for (var name in changes) {
                    prevValue = target[name];
                    newValue = changes[name];
                    if (target === newValue) {
                        continue
                    }
                    if ($.isPlainObject(newValue) && !(newValue instanceof $.Event)) {
                        target[name] = deepExtendArraySafe($.isPlainObject(prevValue) ? prevValue : {}, newValue)
                    } else {
                        if (void 0 !== newValue) {
                            target[name] = newValue
                        }
                    }
                }
                return target
            };
            exports.clone = clone;
            exports.extendFromObject = extendFromObject;
            exports.orderEach = orderEach;
            exports.deepExtendArraySafe = deepExtendArraySafe
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/ui/editor/editor.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                themes = __webpack_require__( /*! ../themes */ 23),
                Widget = __webpack_require__( /*! ../widget/ui.widget */ 19),
                ValidationMixin = __webpack_require__( /*! ../validation/validation_mixin */ 132),
                Overlay = __webpack_require__( /*! ../overlay */ 49);
            var READONLY_STATE_CLASS = "dx-state-readonly",
                INVALID_CLASS = "dx-invalid",
                INVALID_MESSAGE = "dx-invalid-message",
                INVALID_MESSAGE_AUTO = "dx-invalid-message-auto",
                INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always",
                VALIDATION_TARGET = "dx-validation-target",
                VALIDATION_MESSAGE_MIN_WIDTH = 100;
            var Editor = Widget.inherit({
                _init: function() {
                    this.callBase();
                    this.validationRequest = $.Callbacks();
                    var $element = this.element();
                    if ($element) {
                        $.data($element[0], VALIDATION_TARGET, this)
                    }
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        value: null,
                        onValueChanged: null,
                        readOnly: false,
                        isValid: true,
                        validationError: null,
                        validationMessageMode: "auto",
                        validationBoundary: void 0,
                        validationMessageOffset: {
                            h: 0,
                            v: 0
                        }
                    })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                        device: function() {
                            var currentTheme = (themes.current() || "").split(".")[0];
                            return "android5" === currentTheme
                        },
                        options: {
                            validationMessageOffset: {
                                v: -8
                            }
                        }
                    }])
                },
                _attachKeyboardEvents: function() {
                    if (this.option("readOnly")) {
                        return
                    }
                    this.callBase();
                    this._attachChildKeyboardEvents()
                },
                _attachChildKeyboardEvents: $.noop,
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {
                        validationError: true
                    })
                },
                _createValueChangeAction: function() {
                    this._valueChangeAction = this._createActionByOption("onValueChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    })
                },
                _suppressValueChangeAction: function() {
                    this._valueChangeActionSuppressed = true
                },
                _resumeValueChangeAction: function() {
                    this._valueChangeActionSuppressed = false
                },
                _render: function() {
                    this.callBase();
                    this._renderValidationState();
                    this._toggleReadOnlyState()
                },
                _raiseValueChangeAction: function(value, previousValue, extraArguments) {
                    if (!this._valueChangeAction) {
                        this._createValueChangeAction()
                    }
                    this._valueChangeAction(this._valueChangeArgs(value, previousValue))
                },
                _valueChangeArgs: function(value, previousValue) {
                    return {
                        value: value,
                        previousValue: previousValue,
                        jQueryEvent: this._valueChangeEventInstance
                    }
                },
                _saveValueChangeEvent: function(e) {
                    this._valueChangeEventInstance = e
                },
                _renderValidationState: function() {
                    var isValid = this.option("isValid"),
                        validationError = this.option("validationError"),
                        validationMessageMode = this.option("validationMessageMode"),
                        $element = this.element();
                    $element.toggleClass(INVALID_CLASS, !isValid);
                    this.setAria("invalid", !isValid || void 0);
                    if (this._$validationMessage) {
                        this._$validationMessage.remove();
                        this._$validationMessage = null
                    }
                    if (!isValid && validationError && validationError.message) {
                        this._$validationMessage = $("<div/>", {
                            "class": INVALID_MESSAGE
                        }).html(validationError.message).appendTo($element);
                        this._validationMessage = this._createComponent(this._$validationMessage, Overlay, {
                            target: this._getValidationMessageTarget(),
                            shading: false,
                            width: "auto",
                            height: "auto",
                            container: $element,
                            position: this._getValidationMessagePosition("below"),
                            closeOnOutsideClick: false,
                            closeOnTargetScroll: false,
                            animation: null,
                            visible: true,
                            propagateOutsideClick: true
                        });
                        this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, "auto" === validationMessageMode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === validationMessageMode);
                        this._setValidationMessageMaxWidth()
                    }
                },
                _setValidationMessageMaxWidth: function() {
                    if (!this._validationMessage) {
                        return
                    }
                    var validationMessageMaxWidth = Math.max(VALIDATION_MESSAGE_MIN_WIDTH, this._getValidationMessageTarget().outerWidth());
                    this._validationMessage.option("maxWidth", validationMessageMaxWidth)
                },
                _getValidationMessageTarget: function() {
                    return this.element()
                },
                _getValidationMessagePosition: function(positionRequest) {
                    var rtlEnabled = this.option("rtlEnabled"),
                        messagePositionSide = commonUtils.getDefaultAlignment(rtlEnabled),
                        messageOriginalOffset = this.option("validationMessageOffset"),
                        messageOffset = {
                            h: messageOriginalOffset.h,
                            v: messageOriginalOffset.v
                        },
                        verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
                    if (rtlEnabled) {
                        messageOffset.h = -messageOffset.h
                    }
                    if ("below" !== positionRequest) {
                        messageOffset.v = -messageOffset.v
                    }
                    return {
                        offset: messageOffset,
                        boundary: this.option("validationBoundary"),
                        my: messagePositionSide + verticalPositions[0],
                        at: messagePositionSide + verticalPositions[1],
                        collision: "none flip"
                    }
                },
                _toggleReadOnlyState: function() {
                    this.element().toggleClass(READONLY_STATE_CLASS, this.option("readOnly"));
                    this.setAria("readonly", this.option("readOnly") || void 0)
                },
                _dispose: function() {
                    var element = this.element()[0];
                    $.data(element, VALIDATION_TARGET, null);
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case "onValueChanged":
                            this._createValueChangeAction();
                            break;
                        case "isValid":
                        case "validationError":
                        case "validationBoundary":
                        case "validationMessageMode":
                            this._renderValidationState();
                            break;
                        case "readOnly":
                            this._toggleReadOnlyState();
                            this._refreshFocusState();
                            break;
                        case "value":
                            if (!this._valueChangeActionSuppressed) {
                                this._raiseValueChangeAction(args.value, args.previousValue);
                                this._saveValueChangeEvent(void 0)
                            }
                            if (args.value != args.previousValue) {
                                this.validationRequest.fire({
                                    value: args.value,
                                    editor: this
                                })
                            }
                            break;
                        case "width":
                            this.callBase(args);
                            this._setValidationMessageMaxWidth();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                reset: function() {
                    this.option("value", null)
                }
            }).include(ValidationMixin);
            module.exports = Editor
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/events_mixin.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            module.exports = {
                ctor: function() {
                    this._events = {}
                },
                hasEvent: function(eventName) {
                    var callbacks = this._events[eventName];
                    if (callbacks) {
                        return callbacks.has()
                    }
                    return false
                },
                fireEvent: function(eventName, eventArgs) {
                    var callbacks = this._events[eventName];
                    if (callbacks) {
                        callbacks.fireWith(this, eventArgs)
                    }
                    return this
                },
                on: function(eventName, eventHandler) {
                    if ($.isPlainObject(eventName)) {
                        $.each(eventName, $.proxy(function(e, h) {
                            this.on(e, h)
                        }, this))
                    } else {
                        var addFn, callbacks = this._events[eventName];
                        if (!callbacks) {
                            callbacks = $.Callbacks();
                            this._events[eventName] = callbacks
                        }
                        addFn = callbacks.originalAdd || callbacks.add;
                        addFn.call(callbacks, eventHandler)
                    }
                    return this
                },
                off: function(eventName, eventHandler) {
                    var callbacks = this._events[eventName];
                    if (callbacks) {
                        if ($.isFunction(eventHandler)) {
                            callbacks.remove(eventHandler)
                        } else {
                            callbacks.empty()
                        }
                    }
                    return this
                },
                _disposeEvents: function() {
                    $.each(this._events, function() {
                        this.empty()
                    })
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************!*\
      !*** ./Scripts/core/guid.js ***!
      \******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var Class = __webpack_require__( /*! ./class */ 5);
            var Guid = Class.inherit({
                ctor: function(value) {
                    if (value) {
                        value = String(value)
                    }
                    this._value = this._normalize(value || this._generate())
                },
                _normalize: function(value) {
                    value = value.replace(/[^a-f0-9]/gi, "").toLowerCase();
                    while (value.length < 32) {
                        value += "0"
                    }
                    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
                },
                _generate: function() {
                    var value = "";
                    for (var i = 0; i < 32; i++) {
                        value += Math.round(15 * Math.random()).toString(16)
                    }
                    return value
                },
                toString: function() {
                    return this._value
                },
                valueOf: function() {
                    return this._value
                },
                toJSON: function() {
                    return this._value
                }
            });
            module.exports = Guid
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/data/query.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                arrayQueryImpl = __webpack_require__( /*! ./array_query */ 201),
                remoteQueryImpl = __webpack_require__( /*! ./remote_query */ 273);
            var queryImpl = {
                array: arrayQueryImpl,
                remote: remoteQueryImpl
            };
            var query = function() {
                var impl = $.isArray(arguments[0]) ? "array" : "remote";
                return queryImpl[impl].apply(this, arguments)
            };
            module.exports = query;
            module.exports.queryImpl = queryImpl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************!*\
      !*** ./Scripts/core/config.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                config = {
                    rtlEnabled: false,
                    defaultCurrency: "USD",
                    designMode: false
                };
            module.exports = function() {
                if (!arguments.length) {
                    return config
                }
                $.extend(config, arguments[0])
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/core/utils/console.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var logger = function() {
                var console = window.console;

                function info(text) {
                    if (!console || !$.isFunction(console.info)) {
                        return
                    }
                    console.info(text)
                }

                function warn(text) {
                    if (!console || !$.isFunction(console.warn)) {
                        return
                    }
                    console.warn(text)
                }

                function error(text) {
                    if (!console || !$.isFunction(console.error)) {
                        return
                    }
                    console.error(text)
                }
                return {
                    info: info,
                    warn: warn,
                    error: error
                }
            }();
            var debug = function() {
                function assert(condition, message) {
                    if (!condition) {
                        throw new Error(message)
                    }
                }

                function assertParam(parameter, message) {
                    assert(null !== parameter && void 0 !== parameter, message)
                }
                return {
                    assert: assert,
                    assertParam: assertParam
                }
            }();
            exports.logger = logger;
            exports.debug = debug
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/data/data_source/data_source.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                dataUtils = __webpack_require__( /*! ../utils */ 28),
                Store = __webpack_require__( /*! ../abstract_store */ 50),
                ArrayStore = __webpack_require__( /*! ../array_store */ 58),
                CustomStore = __webpack_require__( /*! ../custom_store */ 202),
                EventsMixin = __webpack_require__( /*! ../../core/events_mixin */ 32),
                errors = __webpack_require__( /*! ../errors */ 25).errors,
                array = __webpack_require__( /*! ../../core/utils/array */ 41),
                queue = __webpack_require__( /*! ../../core/utils/queue */ 143),
                __isString = commonUtils.isString,
                __isNumber = commonUtils.isNumber,
                __isBoolean = commonUtils.isBoolean,
                __isDefined = commonUtils.isDefined;
            var CANCELED_TOKEN = "canceled";

            function OperationManager() {
                this._counter = -1;
                this._deferreds = {}
            }
            OperationManager.prototype.constructor = OperationManager;
            OperationManager.prototype.add = function(deferred) {
                this._counter += 1;
                this._deferreds[this._counter] = deferred;
                return this._counter
            };
            OperationManager.prototype.remove = function(operationId) {
                return delete this._deferreds[operationId]
            };
            OperationManager.prototype.cancel = function(operationId) {
                if (operationId in this._deferreds) {
                    this._deferreds[operationId].reject(CANCELED_TOKEN);
                    return true
                }
                return false
            };
            var operationManager = new OperationManager;

            function isPending(deferred) {
                return "pending" === deferred.state()
            }

            function normalizeDataSourceOptions(options) {
                var store;

                function createCustomStoreFromLoadFunc() {
                    var storeConfig = {};
                    $.each(["useDefaultSearch", "key", "load", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
                        storeConfig[this] = options[this];
                        delete options[this]
                    });
                    return new CustomStore(storeConfig)
                }

                function createStoreFromConfig(storeConfig) {
                    var alias = storeConfig.type;
                    delete storeConfig.type;
                    return Store.create(alias, storeConfig)
                }

                function createCustomStoreFromUrl(url) {
                    return new CustomStore({
                        load: function() {
                            return $.getJSON(url)
                        }
                    })
                }
                if ("string" === typeof options) {
                    options = {
                        paginate: false,
                        store: createCustomStoreFromUrl(options)
                    }
                }
                if (void 0 === options) {
                    options = []
                }
                if ($.isArray(options) || options instanceof Store) {
                    options = {
                        store: options
                    }
                } else {
                    options = $.extend({}, options)
                }
                if (void 0 === options.store) {
                    options.store = []
                }
                store = options.store;
                if ("load" in options) {
                    store = createCustomStoreFromLoadFunc()
                } else {
                    if ($.isArray(store)) {
                        store = new ArrayStore(store)
                    } else {
                        if ($.isPlainObject(store)) {
                            store = createStoreFromConfig($.extend({}, store))
                        }
                    }
                }
                options.store = store;
                return options
            }

            function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
                switch (originalArguments.length) {
                    case 0:
                        return;
                    case 1:
                        return originalArguments[0]
                }
                return $.makeArray(originalArguments)
            }

            function generateStoreLoadOptionAccessor(optionName) {
                return function() {
                    var args = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (void 0 === args) {
                        return this._storeLoadOptions[optionName]
                    }
                    this._storeLoadOptions[optionName] = args
                }
            }

            function mapDataRespectingGrouping(items, mapper, groupInfo) {
                function mapRecursive(items, level) {
                    if (!commonUtils.isArray(items)) {
                        return items
                    }
                    return level ? mapGroup(items, level) : $.map(items, mapper)
                }

                function mapGroup(group, level) {
                    return $.map(group, function(item) {
                        var result = {
                            key: item.key,
                            items: mapRecursive(item.items, level - 1)
                        };
                        if ("aggregates" in item) {
                            result.aggregates = item.aggregates
                        }
                        return result
                    })
                }
                return mapRecursive(items, groupInfo ? dataUtils.normalizeSortingInfo(groupInfo).length : 0)
            }
            var DataSource = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    options = normalizeDataSourceOptions(options);
                    this._store = options.store;
                    this._storeLoadOptions = this._extractLoadOptions(options);
                    this._mapFunc = options.map;
                    this._postProcessFunc = options.postProcess;
                    this._pageIndex = void 0 !== options.pageIndex ? options.pageIndex : 0;
                    this._pageSize = void 0 !== options.pageSize ? options.pageSize : 20;
                    this._loadingCount = 0;
                    this._loadQueue = this._createLoadQueue();
                    this._searchValue = "searchValue" in options ? options.searchValue : null;
                    this._searchOperation = options.searchOperation || "contains";
                    this._searchExpr = options.searchExpr;
                    this._paginate = options.paginate;
                    $.each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], function(_, optionName) {
                        if (optionName in options) {
                            that.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName])
                        }
                    });
                    this._init()
                },
                _init: function() {
                    this._items = [];
                    this._userData = {};
                    this._totalCount = -1;
                    this._isLoaded = false;
                    if (!__isDefined(this._paginate)) {
                        this._paginate = !this.group()
                    }
                    this._isLastPage = !this._paginate
                },
                dispose: function() {
                    this._disposeEvents();
                    delete this._store;
                    if (this._delayedLoadTask) {
                        this._delayedLoadTask.abort()
                    }
                    this._disposed = true
                },
                _extractLoadOptions: function(options) {
                    var result = {},
                        names = ["sort", "filter", "select", "group", "requireTotalCount"],
                        customNames = this._store._customLoadOptions();
                    if (customNames) {
                        names = names.concat(customNames)
                    }
                    $.each(names, function() {
                        result[this] = options[this]
                    });
                    return result
                },
                loadOptions: function() {
                    return this._storeLoadOptions
                },
                items: function() {
                    return this._items
                },
                pageIndex: function(newIndex) {
                    if (!__isNumber(newIndex)) {
                        return this._pageIndex
                    }
                    this._pageIndex = newIndex;
                    this._isLastPage = !this._paginate
                },
                paginate: function(value) {
                    if (!__isBoolean(value)) {
                        return this._paginate
                    }
                    if (this._paginate !== value) {
                        this._paginate = value;
                        this.pageIndex(0)
                    }
                },
                pageSize: function(value) {
                    if (!__isNumber(value)) {
                        return this._pageSize
                    }
                    this._pageSize = value
                },
                isLastPage: function() {
                    return this._isLastPage
                },
                sort: generateStoreLoadOptionAccessor("sort"),
                filter: function() {
                    var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (void 0 === newFilter) {
                        return this._storeLoadOptions.filter
                    }
                    this._storeLoadOptions.filter = newFilter;
                    this.pageIndex(0)
                },
                group: generateStoreLoadOptionAccessor("group"),
                select: generateStoreLoadOptionAccessor("select"),
                requireTotalCount: function(value) {
                    if (!__isBoolean(value)) {
                        return this._storeLoadOptions.requireTotalCount
                    }
                    this._storeLoadOptions.requireTotalCount = value
                },
                searchValue: function(value) {
                    if (arguments.length < 1) {
                        return this._searchValue
                    }
                    this._searchValue = value;
                    this.pageIndex(0)
                },
                searchOperation: function(op) {
                    if (!__isString(op)) {
                        return this._searchOperation
                    }
                    this._searchOperation = op;
                    this.pageIndex(0)
                },
                searchExpr: function(expr) {
                    var argc = arguments.length;
                    if (0 === argc) {
                        return this._searchExpr
                    }
                    if (argc > 1) {
                        expr = $.makeArray(arguments)
                    }
                    this._searchExpr = expr;
                    this.pageIndex(0)
                },
                store: function() {
                    return this._store
                },
                key: function() {
                    return this._store && this._store.key()
                },
                totalCount: function() {
                    return this._totalCount
                },
                isLoaded: function() {
                    return this._isLoaded
                },
                isLoading: function() {
                    return this._loadingCount > 0
                },
                _createLoadQueue: function() {
                    return queue.create()
                },
                _changeLoadingCount: function(increment) {
                    var newLoading, oldLoading = this.isLoading();
                    this._loadingCount += increment;
                    newLoading = this.isLoading();
                    if (oldLoading ^ newLoading) {
                        this.fireEvent("loadingChanged", [newLoading])
                    }
                },
                _scheduleLoadCallbacks: function(deferred) {
                    var that = this;
                    that._changeLoadingCount(1);
                    deferred.always(function() {
                        that._changeLoadingCount(-1)
                    })
                },
                _scheduleFailCallbacks: function(deferred) {
                    var that = this;
                    deferred.fail(function() {
                        if (arguments[0] === CANCELED_TOKEN) {
                            return
                        }
                        that.fireEvent("loadError", arguments)
                    })
                },
                _scheduleChangedCallbacks: function(deferred) {
                    var that = this;
                    deferred.done(function() {
                        that.fireEvent("changed")
                    })
                },
                loadSingle: function(propName, propValue) {
                    var that = this;
                    var d = $.Deferred(),
                        key = this.key(),
                        store = this._store,
                        options = this._createStoreLoadOptions(),
                        handleDone = function(data) {
                            if (!__isDefined(data) || array.isEmpty(data)) {
                                d.reject(new errors.Error("E4009"))
                            } else {
                                d.resolve(that._applyMapFunction($.makeArray(data))[0])
                            }
                        };
                    this._scheduleFailCallbacks(d);
                    if (arguments.length < 2) {
                        propValue = propName;
                        propName = key
                    }
                    delete options.skip;
                    delete options.group;
                    delete options.refresh;
                    delete options.pageIndex;
                    delete options.searchString;
                    (function() {
                        if (propName === key || store instanceof CustomStore) {
                            return store.byKey(propValue, options)
                        }
                        options.take = 1;
                        options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
                        return store.load(options)
                    })().fail(d.reject).done(handleDone);
                    return d.promise()
                },
                load: function() {
                    var loadOperation, that = this,
                        d = $.Deferred();

                    function loadTask() {
                        if (that._disposed) {
                            return
                        }
                        if (!isPending(d)) {
                            return
                        }
                        return that._loadFromStore(loadOperation, d)
                    }
                    this._scheduleLoadCallbacks(d);
                    this._scheduleFailCallbacks(d);
                    this._scheduleChangedCallbacks(d);
                    loadOperation = this._createLoadOperation(d);
                    this.fireEvent("customizeStoreLoadOptions", [loadOperation]);
                    this._loadQueue.add(function() {
                        if ("number" === typeof loadOperation.delay) {
                            that._delayedLoadTask = commonUtils.executeAsync(loadTask, loadOperation.delay)
                        } else {
                            loadTask()
                        }
                        return d.promise()
                    });
                    return d.promise({
                        operationId: loadOperation.operationId
                    })
                },
                _createLoadOperation: function(deferred) {
                    var id = operationManager.add(deferred),
                        options = this._createStoreLoadOptions();
                    deferred.always(function() {
                        operationManager.remove(id)
                    });
                    return {
                        operationId: id,
                        storeLoadOptions: options
                    }
                },
                reload: function() {
                    this._init();
                    return this.load()
                },
                cancel: function(operationId) {
                    return operationManager.cancel(operationId)
                },
                _addSearchOptions: function(storeLoadOptions) {
                    if (this._disposed) {
                        return
                    }
                    if (this.store()._useDefaultSearch) {
                        this._addSearchFilter(storeLoadOptions)
                    } else {
                        storeLoadOptions.searchOperation = this._searchOperation;
                        storeLoadOptions.searchValue = this._searchValue;
                        storeLoadOptions.searchExpr = this._searchExpr
                    }
                },
                _createStoreLoadOptions: function() {
                    var result = $.extend({}, this._storeLoadOptions);
                    this._addSearchOptions(result);
                    if (this._paginate) {
                        if (this._pageSize) {
                            result.skip = this._pageIndex * this._pageSize;
                            result.take = this._pageSize
                        }
                    }
                    result.userData = this._userData;
                    return result
                },
                _addSearchFilter: function(storeLoadOptions) {
                    var value = this._searchValue,
                        op = this._searchOperation,
                        selector = this._searchExpr,
                        searchFilter = [];
                    if (!value) {
                        return
                    }
                    if (!selector) {
                        selector = "this"
                    }
                    if (!$.isArray(selector)) {
                        selector = [selector]
                    }
                    $.each(selector, function(i, item) {
                        if (searchFilter.length) {
                            searchFilter.push("or")
                        }
                        searchFilter.push([item, op, value])
                    });
                    if (storeLoadOptions.filter) {
                        storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter]
                    } else {
                        storeLoadOptions.filter = searchFilter
                    }
                },
                _loadFromStore: function(loadOptions, pendingDeferred) {
                    var that = this;

                    function handleSuccess(data, extra) {
                        function processResult() {
                            var loadResult;
                            if (data && !$.isArray(data) && data.data) {
                                extra = data;
                                data = data.data
                            }
                            loadResult = $.extend({
                                data: data,
                                extra: extra
                            }, loadOptions);
                            that.fireEvent("customizeLoadResult", [loadResult]);
                            $.when(loadResult.data).done(function(data) {
                                loadResult.data = data;
                                that._processStoreLoadResult(loadResult, pendingDeferred)
                            }).fail(pendingDeferred.reject)
                        }
                        if (that._disposed) {
                            return
                        }
                        if (!isPending(pendingDeferred)) {
                            return
                        }
                        processResult()
                    }
                    if (loadOptions.data) {
                        return $.Deferred().resolve(loadOptions.data).done(handleSuccess)
                    }
                    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
                },
                _processStoreLoadResult: function(loadResult, pendingDeferred) {
                    var that = this;
                    var data = $.makeArray(loadResult.data),
                        extra = loadResult.extra,
                        storeLoadOptions = loadResult.storeLoadOptions;

                    function resolvePendingDeferred() {
                        that._isLoaded = true;
                        that._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
                        return pendingDeferred.resolve(data, extra)
                    }

                    function proceedLoadingTotalCount() {
                        that.store().totalCount(storeLoadOptions).done(function(count) {
                            extra.totalCount = count;
                            resolvePendingDeferred()
                        }).fail(pendingDeferred.reject)
                    }
                    if (that._disposed) {
                        return
                    }
                    data = that._applyPostProcessFunction(that._applyMapFunction(data));
                    if (!$.isPlainObject(extra)) {
                        extra = {}
                    }
                    that._items = data;
                    if (!data.length || !that._paginate || that._pageSize && data.length < that._pageSize) {
                        that._isLastPage = true
                    }
                    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
                        proceedLoadingTotalCount()
                    } else {
                        resolvePendingDeferred()
                    }
                },
                _applyMapFunction: function(data) {
                    if (this._mapFunc) {
                        return mapDataRespectingGrouping(data, this._mapFunc, this.group())
                    }
                    return data
                },
                _applyPostProcessFunction: function(data) {
                    if (this._postProcessFunc) {
                        return this._postProcessFunc(data)
                    }
                    return data
                }
            }).include(EventsMixin);
            exports.DataSource = DataSource;
            exports.normalizeDataSourceOptions = normalizeDataSourceOptions
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/localization/number.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dependencyInjector = __webpack_require__( /*! ../core/utils/dependency_injector */ 80),
                errors = __webpack_require__( /*! ../core/errors */ 10);
            var MAX_LARGE_NUMBER_POWER = 4,
                DECIMAL_BASE = 10;
            var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
            var LargeNumberFormatPostfixes = {
                1: "K",
                2: "M",
                3: "B",
                4: "T"
            };
            var LargeNumberFormatPowers = {
                largenumber: "auto",
                thousands: 1,
                millions: 2,
                billions: 3,
                trillions: 4
            };
            var numberLocalization = dependencyInjector({
                numericFormats: NUMERIC_FORMATS,
                defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
                _parseNumberFormatString: function(formatType) {
                    var formatList, formatObject = {};
                    if (!formatType || "string" !== typeof formatType) {
                        return
                    }
                    formatList = formatType.split(" ");
                    $.each(formatList, function(index, value) {
                        if ($.inArray(value, NUMERIC_FORMATS) > -1) {
                            formatObject.formatType = value
                        } else {
                            if (value in LargeNumberFormatPowers) {
                                formatObject.power = LargeNumberFormatPowers[value]
                            }
                        }
                    });
                    if (formatObject.power && !formatObject.formatType) {
                        formatObject.formatType = "fixedpoint"
                    }
                    if (formatObject.formatType) {
                        return formatObject
                    }
                },
                _calculateNumberPower: function(value, base, minPower, maxPower) {
                    var number = Math.abs(value),
                        power = 0;
                    if (number > 1) {
                        while (number && number >= base && (void 0 === maxPower || power < maxPower)) {
                            power++;
                            number /= base
                        }
                    } else {
                        if (number > 0 && number < 1) {
                            while (number < 1 && (void 0 === minPower || power > minPower)) {
                                power--;
                                number *= base
                            }
                        }
                    }
                    return power
                },
                _getNumberByPower: function(number, power, base) {
                    var result = number;
                    while (power > 0) {
                        result /= base;
                        power--
                    }
                    while (power < 0) {
                        result *= base;
                        power++
                    }
                    return result
                },
                _formatNumber: function(value, formatObject, formatConfig) {
                    var powerPostfix;
                    if ("auto" === formatObject.power) {
                        formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER)
                    }
                    if (formatObject.power) {
                        value = this._getNumberByPower(value, formatObject.power, 1e3)
                    }
                    powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
                    return this._formatNumberCore(value, formatObject.formatType, formatConfig) + powerPostfix
                },
                _formatNumberExponential: function(value, formatConfig) {
                    var powString, power = this._calculateNumberPower(value, DECIMAL_BASE),
                        number = this._getNumberByPower(value, power, DECIMAL_BASE);
                    if (void 0 === formatConfig.precision) {
                        formatConfig.precision = 1
                    }
                    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
                        power++;
                        number /= DECIMAL_BASE
                    }
                    powString = (power >= 0 ? "+" : "") + power.toString();
                    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString
                },
                _addZeroes: function(value, precision) {
                    var multiplier = Math.pow(10, precision);
                    value = (value * multiplier >>> 0) / multiplier;
                    var result = value.toString();
                    while (result.length < precision) {
                        result = "0" + result
                    }
                    return result
                },
                _addGroupSeparators: function(value) {
                    var parts = value.toString().split(".");
                    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",") + (parts[1] ? "." + parts[1] : "")
                },
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("exponential" === format) {
                        return this._formatNumberExponential(value, formatConfig)
                    }
                    if ("percent" === format) {
                        formatConfig.precision = formatConfig.precision || 0;
                        value = 100 * value
                    }
                    if (void 0 !== formatConfig.precision) {
                        if ("decimal" === format) {
                            value = this._addZeroes(value, formatConfig.precision)
                        } else {
                            value = value.toFixed(formatConfig.precision)
                        }
                    }
                    if ("decimal" !== format) {
                        value = this._addGroupSeparators(value)
                    }
                    if ("percent" === format) {
                        value += "%"
                    }
                    return value.toString()
                },
                _normalizeFormat: function(format) {
                    if (!format) {
                        return {}
                    }
                    if ("function" === typeof format) {
                        return format
                    }
                    if (!$.isPlainObject(format)) {
                        format = {
                            type: format
                        }
                    }
                    if (format.type) {
                        format.type = format.type.toLowerCase()
                    }
                    return format
                },
                format: function(value, format) {
                    if ("number" !== typeof value) {
                        return value
                    }
                    if ("number" === typeof format) {
                        return value
                    }
                    format = format && format.formatter || format;
                    if ("function" === typeof format) {
                        return format(value)
                    }
                    format = this._normalizeFormat(format);
                    if (!format.type) {
                        format.type = "decimal"
                    }
                    var numberConfig = this._parseNumberFormatString(format.type);
                    if (!numberConfig) {
                        return
                    }
                    return this._formatNumber(value, numberConfig, format)
                },
                parse: function(text, format) {
                    if (!text) {
                        return
                    }
                    if (format && format.parser) {
                        return format.parser(text)
                    }
                    if (format) {
                        errors.log("W0011")
                    }
                    return parseFloat(text.replace(/^\D+|,+/g, ""))
                }
            });
            module.exports = numberLocalization
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/core/dom_component.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                config = __webpack_require__( /*! ./config */ 35),
                errors = __webpack_require__( /*! ./errors */ 10),
                windowResizeCallbacks = __webpack_require__( /*! ./utils/window */ 57).resizeCallbacks,
                commonUtils = __webpack_require__( /*! ./utils/common */ 2),
                publicComponentUtils = __webpack_require__( /*! ./utils/public_component */ 142),
                Component = __webpack_require__( /*! ./component */ 92),
                abstract = Component.abstract;
            var RTL_DIRECTION_CLASS = "dx-rtl",
                VISIBILITY_CHANGE_CLASS = "dx-visibility-change-handler",
                VISIBILITY_CHANGE_EVENTNAMESPACE = "VisibilityChange";
            var DOMComponent = Component.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        width: void 0,
                        height: void 0,
                        rtlEnabled: config().rtlEnabled,
                        disabled: false
                    })
                },
                ctor: function(element, options) {
                    this._$element = $(element);
                    publicComponentUtils.attachInstanceToElement(this._$element, this.constructor.publicName(), this, this._dispose);
                    this.callBase(options)
                },
                _visibilityChanged: abstract,
                _dimensionChanged: abstract,
                _init: function() {
                    this.callBase();
                    this._attachWindowResizeCallback()
                },
                _attachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported()) {
                        var windowResizeCallBack = this._windowResizeCallBack = $.proxy(this._dimensionChanged, this);
                        windowResizeCallbacks.add(windowResizeCallBack)
                    }
                },
                _isDimensionChangeSupported: function() {
                    return this._dimensionChanged !== abstract
                },
                _render: function() {
                    this._toggleRTLDirection(this.option("rtlEnabled"));
                    this._renderVisibilityChange();
                    this._renderDimensions()
                },
                _renderVisibilityChange: function() {
                    if (this._isDimensionChangeSupported()) {
                        this._attachDimensionChangeHandlers()
                    }
                    if (!this._isVisibilityChangeSupported()) {
                        return
                    }
                    this.element().addClass(VISIBILITY_CHANGE_CLASS);
                    this._attachVisibilityChangeHandlers()
                },
                _renderDimensions: function() {
                    var width = this.option("width"),
                        height = this.option("height"),
                        $element = this.element();
                    $element.outerWidth(width);
                    $element.outerHeight(height)
                },
                _attachDimensionChangeHandlers: function() {
                    var that = this;
                    var resizeEventName = "dxresize." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    that.element().off(resizeEventName).on(resizeEventName, function() {
                        that._dimensionChanged()
                    })
                },
                _attachVisibilityChangeHandlers: function() {
                    var that = this;
                    var hidingEventName = "dxhiding." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    var shownEventName = "dxshown." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    that._isHidden = !that._isVisible();
                    that.element().off(hidingEventName).on(hidingEventName, function() {
                        that._checkVisibilityChanged("hiding")
                    }).off(shownEventName).on(shownEventName, function() {
                        that._checkVisibilityChanged("shown")
                    })
                },
                _isVisible: function() {
                    return this.element().is(":visible")
                },
                _checkVisibilityChanged: function(event) {
                    if ("hiding" === event && this._isVisible() && !this._isHidden) {
                        this._visibilityChanged(false);
                        this._isHidden = true
                    } else {
                        if ("shown" === event && this._isVisible() && this._isHidden) {
                            this._isHidden = false;
                            this._visibilityChanged(true)
                        }
                    }
                },
                _isVisibilityChangeSupported: function() {
                    return this._visibilityChanged !== abstract
                },
                _clean: $.noop,
                _modelByElement: function() {
                    var modelByElement = this.option("modelByElement") || $.noop;
                    return modelByElement(this.element())
                },
                _invalidate: function() {
                    if (!this._updateLockCount) {
                        throw errors.Error("E0007")
                    }
                    this._requireRefresh = true
                },
                _refresh: function() {
                    this._clean();
                    this._render()
                },
                _dispose: function() {
                    this.callBase();
                    this._clean();
                    this._detachWindowResizeCallback()
                },
                _detachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported()) {
                        windowResizeCallbacks.remove(this._windowResizeCallBack)
                    }
                },
                _toggleRTLDirection: function(rtl) {
                    this.element().toggleClass(RTL_DIRECTION_CLASS, rtl)
                },
                _createComponent: function(element, component, config) {
                    var that = this;
                    config = config || {};
                    var synchronizableOptions = $.grep(["rtlEnabled", "disabled"], function(value) {
                        return !(value in config)
                    });
                    var nestedComponentOptions = that.option("nestedComponentOptions") || $.noop;
                    that._extendConfig(config, $.extend({
                        rtlEnabled: this.option("rtlEnabled"),
                        disabled: this.option("disabled")
                    }, nestedComponentOptions(this)));
                    var instance;
                    if (commonUtils.isString(component)) {
                        var $element = $(element)[component](config);
                        instance = $element[component]("instance")
                    } else {
                        if (element) {
                            instance = component.getInstance(element);
                            if (instance) {
                                instance.option(config)
                            } else {
                                instance = new component(element, config)
                            }
                        }
                    }
                    if (instance) {
                        var optionChangedHandler = function(args) {
                            if ($.inArray(args.name, synchronizableOptions) >= 0) {
                                instance.option(args.name, args.value)
                            }
                        };
                        that.on("optionChanged", optionChangedHandler);
                        instance.on("disposing", function() {
                            that.off("optionChanged", optionChangedHandler)
                        })
                    }
                    return instance
                },
                _extendConfig: function(config, extendConfig) {
                    $.each(extendConfig, function(key, value) {
                        config[key] = config.hasOwnProperty(key) ? config[key] : value
                    })
                },
                _defaultActionConfig: function() {
                    return $.extend(this.callBase(), {
                        context: this._modelByElement(this.element())
                    })
                },
                _defaultActionArgs: function() {
                    var element = this.element(),
                        model = this._modelByElement(this.element());
                    return $.extend(this.callBase(), {
                        element: element,
                        model: model
                    })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case "width":
                        case "height":
                            this._renderDimensions();
                            break;
                        case "rtlEnabled":
                            this._invalidate();
                            break;
                        case "disabled":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                endUpdate: function() {
                    var requireRender = !this._initializing && !this._initialized;
                    this.callBase.apply(this, arguments);
                    if (!this._updateLockCount) {
                        if (requireRender) {
                            this._render()
                        } else {
                            if (this._requireRefresh) {
                                this._requireRefresh = false;
                                this._refresh()
                            }
                        }
                    }
                },
                element: function() {
                    return this._$element
                }
            });
            DOMComponent.getInstance = function($element) {
                return publicComponentUtils.getInstanceByElement($element, this.publicName())
            };
            DOMComponent.defaultOptions = function(rule) {
                this.prototype._customRules = this.prototype._customRules || [];
                this.prototype._customRules.push(rule)
            };
            module.exports = DOMComponent
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************!*\
      !*** external "window.ko" ***!
      \****************************/
    function(module, exports) {
        module.exports = window.ko
    },
    /*!*************************************!*\
      !*** ./Scripts/core/utils/array.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ./common */ 2),
                objectUtils = __webpack_require__( /*! ./object */ 30);
            var isEmpty = function(entity) {
                return $.isArray(entity) && !entity.length
            };
            var wrapToArray = function(entity) {
                return $.isArray(entity) ? entity : [entity]
            };
            var intersection = function(a, b) {
                if (!$.isArray(a) || 0 === a.length || !$.isArray(b) || 0 === b.length) {
                    return []
                }
                var result = [];
                $.each(a, function(_, value) {
                    var index = $.inArray(value, b);
                    if (-1 !== index) {
                        result.push(value)
                    }
                });
                return result
            };
            var removeDuplicates = function(from, what) {
                if (!$.isArray(from) || 0 === from.length) {
                    return []
                }
                if (!$.isArray(what) || 0 === what.length) {
                    return from.slice()
                }
                var result = [];
                $.each(from, function(_, value) {
                    var index = $.inArray(value, what);
                    if (-1 === index) {
                        result.push(value)
                    }
                });
                return result
            };
            var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
                var indexedItems = {},
                    parameterIndex = 0;
                $.each(items, function(index, item) {
                    index = item[indexParameterName];
                    if (commonUtils.isDefined(index)) {
                        indexedItems[index] = indexedItems[index] || [];
                        if (item === currentItem) {
                            indexedItems[index].unshift(item)
                        } else {
                            indexedItems[index].push(item)
                        }
                        delete item[indexParameterName]
                    }
                });
                objectUtils.orderEach(indexedItems, function(index, items) {
                    $.each(items, function() {
                        if (index >= 0) {
                            this[indexParameterName] = parameterIndex++
                        }
                    })
                });
                $.each(items, function() {
                    if (!commonUtils.isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
                        this[indexParameterName] = parameterIndex++
                    }
                });
                return parameterIndex
            };
            exports.isEmpty = isEmpty;
            exports.wrapToArray = wrapToArray;
            exports.intersection = intersection;
            exports.removeDuplicates = removeDuplicates;
            exports.normalizeIndexes = normalizeIndexes
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!**************************************************!*\
      !*** ./Scripts/events/core/event_registrator.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                MemorizedCallbacks = __webpack_require__( /*! ../../core/memorized_callbacks */ 140);
            var eventNS = $.event,
                hooksNS = eventNS.fixHooks,
                specialNS = $.event.special;
            var DX_EVENT_HOOKS = {
                props: eventNS.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])
            };
            var callbacks = new MemorizedCallbacks;
            var registerEvent = function(name, eventObject) {
                var strategy = {};
                if ("noBubble" in eventObject) {
                    strategy.noBubble = eventObject.noBubble
                }
                if ("bindType" in eventObject) {
                    strategy.bindType = eventObject.bindType
                }
                if ("delegateType" in eventObject) {
                    strategy.delegateType = eventObject.delegateType
                }
                $.each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
                    if (!eventObject[methodName]) {
                        return
                    }
                    strategy[methodName] = function() {
                        var args = $.makeArray(arguments);
                        args.unshift(this);
                        return eventObject[methodName].apply(eventObject, args)
                    }
                });
                hooksNS[name] = DX_EVENT_HOOKS;
                callbacks.fire(name, strategy)
            };
            registerEvent.callbacks = callbacks;
            var registerJQueryEvent = function(name, eventObject) {
                specialNS[name] = eventObject
            };
            callbacks.add(registerJQueryEvent);
            module.exports = registerEvent
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/framework/errors.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errorUtils = __webpack_require__( /*! ../core/utils/error */ 94),
                errors = __webpack_require__( /*! ../core/errors */ 10);
            module.exports = errorUtils(errors.ERROR_MESSAGES, {
                E3001: "Routing rule is not found for the '{0}' URI.",
                E3002: "The passed object cannot be formatted into a URI string by the application's router. An appropriate route should be registered.",
                E3003: "Unable to navigate. Application is being initialized.",
                E3004: "Cannot execute the command: {0}.",
                E3005: "The '{0}' command {1} is not registered in the application's command mapping. Go to http://dxpr.es/1bTjfj1 for more details.",
                E3006: "Unknown navigation target: '{0}'. Use the 'current', 'back' or 'blank' values.",
                E3007: "Error while restoring the application state. The state has been cleared. Refresh the page.",
                E3008: "Unable to go back.",
                E3009: "Unable to go forward.",
                E3010: "The command's 'id' option should be specified.\r\nProcessed markup: {0}\n",
                E3011: "Layout controller cannot be resolved. There are no appropriate layout controllers for the current context. Check browser console for details.",
                E3012: "Layout controller cannot be resolved. Two or more layout controllers suit the current context. Check browser console for details.",
                E3013: "The '{0}' template with the '{1}' name is not found. Make sure the case is correct in the specified view name and the template fits the current context.",
                E3014: "All the children of the dxView element should be either of the dxCommand or dxContent type.\r\nProcessed markup: {0}",
                E3015: "The 'exec' method should be called before the 'finalize' method.",
                E3016: "Unknown transition type '{0}'.",
                E3018: "Unable to parse options.\nMessage: {0};\nOptions value: {1}.",
                E3019: "View templates should be updated according to the 13.1 changes. Go to http://dxpr.es/15ikrJA for more details.",
                E3020: "Concurrent templates are found:\r\n{0}Target device:\r\n{1}.",
                E3021: "Remote template cannot be loaded.\r\nUrl:{0}\r\nError:{1}.",
                E3022: "Cannot initialize the HtmlApplication component.",
                E3023: "Navigation item is not found",
                E3024: "Layout controller is not initialized",
                W3001: "A view with the '{0}' key doesn't exist.",
                W3002: "A view with the '{0}' key has already been released.",
                W3003: "Layout resolving context:\n{0}\nAvailable layout controller registrations:\n{1}\n",
                W3004: "Layout resolving context:\n{0}\nConcurent layout controller registrations for the context:\n{1}\n",
                W3005: 'Direct hash-based navigation is detected in a mobile application. Use data-bind="dxAction: url" instead of href="#url" to avoid navigation issues.\nFound markup:\n{0}\n'
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/framework/html/view_engine_components.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errors = __webpack_require__( /*! ../errors */ 44),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                MarkupComponent = __webpack_require__( /*! ./markup_component */ 149).MarkupComponent;
            __webpack_require__( /*! ../../integration/knockout */ 85);
            var View = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        name: null,
                        title: null
                    })
                },
                ctor: function() {
                    this._id = domUtils.uniqueId();
                    this.callBase.apply(this, arguments)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-view");
                    this.element().attr("dx-data-template-id", this._id)
                },
                getId: function() {
                    return this._id
                }
            });
            var Layout = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        name: null
                    })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-layout")
                }
            });
            var ViewPlaceholder = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        viewName: null
                    })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-view-placeholder")
                }
            });
            var setupTransitionElement = function($element, transitionType, transitionName, contentCssPosition) {
                if ("absolute" === contentCssPosition) {
                    $element.addClass("dx-transition-absolute")
                } else {
                    $element.addClass("dx-transition-static")
                }
                $element.addClass("dx-transition").addClass("dx-transition-" + transitionName).addClass("dx-transition-" + transitionType).attr("data-dx-transition-type", transitionType).attr("data-dx-transition-name", transitionName)
            };
            var setupTransitionInnerElement = function($element) {
                $element.addClass("dx-transition-inner-wrapper")
            };
            var Transition = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        name: null,
                        type: void 0,
                        animation: "slide"
                    })
                },
                _render: function() {
                    this.callBase();
                    var element = this.element();
                    setupTransitionElement(element, this.option("type") || this.option("animation"), this.option("name"), "absolute");
                    element.wrapInner("<div/>");
                    setupTransitionInnerElement(element.children());
                    if (this.option("type")) {
                        errors.log("W0003", "dxTransition", "type", "15.1", "Use the 'animation' property instead")
                    }
                },
                _clean: function() {
                    this.callBase();
                    this.element().empty()
                }
            });
            var ContentPlaceholder = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        name: null,
                        transition: void 0,
                        animation: "none",
                        contentCssPosition: "absolute"
                    })
                },
                _render: function() {
                    this.callBase();
                    var $element = this.element();
                    $element.addClass("dx-content-placeholder").addClass("dx-content-placeholder-" + this.option("name"));
                    $element.attr("data-dx-content-placeholder-name", this.option("name"));
                    setupTransitionElement($element, this.option("transition") || this.option("animation"), this.option("name"), this.option("contentCssPosition"));
                    if (this.option("transition")) {
                        errors.log("W0003", "dxContentPlaceholder", "transition", "15.1", "Use the 'animation' property instead")
                    }
                }
            });
            var Content = MarkupComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        targetPlaceholder: null
                    })
                },
                _optionChanged: function() {
                    this._refresh()
                },
                _clean: function() {
                    this.callBase();
                    this.element().removeClass(this._currentClass)
                },
                _render: function() {
                    this.callBase();
                    var element = this.element();
                    element.addClass("dx-content");
                    this._currentClass = "dx-content-" + this.option("targetPlaceholder");
                    element.attr("data-dx-target-placeholder-id", this.option("targetPlaceholder"));
                    element.addClass(this._currentClass);
                    setupTransitionInnerElement(element)
                }
            });
            registerComponent("dxView", View);
            registerComponent("dxLayout", Layout);
            registerComponent("dxViewPlaceholder", ViewPlaceholder);
            registerComponent("dxContentPlaceholder", ContentPlaceholder);
            registerComponent("dxTransition", Transition);
            registerComponent("dxContent", Content);
            exports.dxView = View;
            exports.dxLayout = Layout;
            exports.dxViewPlaceholder = ViewPlaceholder;
            exports.dxContentPlaceholder = ContentPlaceholder;
            exports.dxTransition = Transition;
            exports.dxContent = Content
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** external "window.Globalize" ***!
      \***********************************/
    function(module, exports) {
        module.exports = window.Globalize
    },
    /*!***********************************************!*\
      !*** ./Scripts/ui/widget/ui.template_base.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                triggerShownEvent = __webpack_require__( /*! ../../core/utils/dom */ 11).triggerShownEvent,
                Class = __webpack_require__( /*! ../../core/class */ 5),
                abstract = Class.abstract;
            var renderedCallbacks = $.Callbacks();
            var TemplateBase = Class.inherit({
                ctor: function(element, owner) {
                    this._element = $(element);
                    this._owner = owner
                },
                owner: function() {
                    return this._owner
                },
                render: function(data, $container, index) {
                    if (data instanceof $) {
                        $container = data;
                        data = void 0
                    }
                    if ($container) {
                        data = this._prepareDataForContainer(data, $container)
                    }
                    var $result = this._renderCore(data, index, $container);
                    this._ensureResultInContainer($result, $container);
                    renderedCallbacks.fire($result, $container);
                    return $result
                },
                _ensureResultInContainer: function($result, $container) {
                    if (!$container) {
                        return
                    }
                    var resultInContainer = $.contains($container.get(0), $result.get(0));
                    $container.append($result);
                    if (resultInContainer) {
                        return
                    }
                    var resultInBody = $.contains(document.body, $container.get(0));
                    if (!resultInBody) {
                        return
                    }
                    triggerShownEvent($result)
                },
                source: function() {
                    return this._element.clone()
                },
                _prepareDataForContainer: function(data) {
                    return data
                },
                _renderCore: abstract,
                dispose: function() {
                    this._owner = null
                }
            });
            module.exports = TemplateBase;
            module.exports.renderedCallbacks = renderedCallbacks
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!*******************************!*\
      !*** ./Scripts/ui/overlay.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                fx = __webpack_require__( /*! ../animation/fx */ 21),
                translator = __webpack_require__( /*! ../animation/translator */ 15),
                compareVersions = __webpack_require__( /*! ../core/utils/version */ 56).compare,
                viewPortUtils = __webpack_require__( /*! ../core/utils/view_port */ 52),
                viewPort = viewPortUtils.value,
                viewPortChanged = viewPortUtils.changeCallback,
                hideTopOverlayCallback = __webpack_require__( /*! ../mobile/hide_top_overlay */ 100).hideCallback,
                positionUtils = __webpack_require__( /*! ../animation/position */ 65),
                fitIntoRange = __webpack_require__( /*! ../core/utils/math */ 66).fitIntoRange,
                domUtils = __webpack_require__( /*! ../core/utils/dom */ 11),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                Widget = __webpack_require__( /*! ./widget/ui.widget */ 19),
                KeyboardProcessor = __webpack_require__( /*! ./widget/ui.keyboard_processor */ 175),
                selectors = __webpack_require__( /*! ./widget/jquery.selectors */ 98),
                dragEvents = __webpack_require__( /*! ../events/drag */ 62),
                eventUtils = __webpack_require__( /*! ../events/utils */ 4),
                pointerEvents = __webpack_require__( /*! ../events/pointer */ 13),
                Resizable = __webpack_require__( /*! ./resizable */ 177);
            var OVERLAY_CLASS = "dx-overlay",
                OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper",
                OVERLAY_CONTENT_CLASS = "dx-overlay-content",
                OVERLAY_SHADER_CLASS = "dx-overlay-shader",
                OVERLAY_MODAL_CLASS = "dx-overlay-modal",
                INVISIBLE_STATE_CLASS = "dx-state-invisible",
                ANONYMOUS_TEMPLATE_NAME = "content",
                RTL_DIRECTION_CLASS = "dx-rtl",
                ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"],
                FIRST_Z_INDEX = 1500,
                OVERLAY_STACK = [],
                DISABLED_STATE_CLASS = "dx-state-disabled",
                TAB_KEY = 9;
            var realDevice = devices.real(),
                realVersion = realDevice.version,
                iOS = "ios" === realDevice.platform,
                iOS7_0andBelow = iOS && compareVersions(realVersion, [7, 1]) < 0,
                android4_0nativeBrowser = "android" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && -1 === navigator.userAgent.indexOf("Chrome");
            var forceRepaint = function($element) {
                if (iOS7_0andBelow) {
                    $element.width()
                }
                if (android4_0nativeBrowser) {
                    var $parents = $element.parents(),
                        inScrollView = $parents.is(".dx-scrollable-native");
                    if (!inScrollView) {
                        $parents.css("backface-visibility", "hidden");
                        $parents.css("backface-visibility");
                        $parents.css("backface-visibility", "visible")
                    }
                }
            };
            var getElement = function(value) {
                return value && $(value instanceof $.Event ? value.target : value)
            };
            $(document).on(pointerEvents.down, function(e) {
                for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
                    if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
                        return
                    }
                }
            });
            var Overlay = Widget.inherit({
                _supportedKeys: function() {
                    var offsetSize = 5,
                        move = function(top, left, e) {
                            if (!this.option("dragEnabled")) {
                                return
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            var allowedOffsets = this._allowedOffsets();
                            var offset = {
                                top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
                                left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
                            };
                            this._changePosition(offset)
                        };
                    return $.extend(this.callBase(), {
                        escape: function(e) {
                            this.hide()
                        },
                        upArrow: $.proxy(move, this, -offsetSize, 0),
                        downArrow: $.proxy(move, this, offsetSize, 0),
                        leftArrow: $.proxy(move, this, 0, -offsetSize),
                        rightArrow: $.proxy(move, this, 0, offsetSize)
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        activeStateEnabled: false,
                        visible: false,
                        deferRendering: true,
                        shading: true,
                        shadingColor: "",
                        position: {
                            my: "center",
                            at: "center"
                        },
                        width: function() {
                            return .8 * $(window).width()
                        },
                        minWidth: null,
                        maxWidth: null,
                        height: function() {
                            return .8 * $(window).height()
                        },
                        minHeight: null,
                        maxHeight: null,
                        animation: {
                            show: {
                                type: "pop",
                                duration: 300,
                                from: {
                                    scale: .55
                                }
                            },
                            hide: {
                                type: "pop",
                                duration: 300,
                                to: {
                                    opacity: 0,
                                    scale: .55
                                },
                                from: {
                                    opacity: 1,
                                    scale: 1
                                }
                            }
                        },
                        closeOnOutsideClick: false,
                        closeOnBackButton: true,
                        onShowing: null,
                        onShown: null,
                        onHiding: null,
                        onHidden: null,
                        contentTemplate: "content",
                        dragEnabled: false,
                        resizeEnabled: false,
                        onResizeStart: null,
                        onResize: null,
                        onResizeEnd: null,
                        onContentReady: null,
                        target: void 0,
                        container: void 0,
                        hideTopOverlayHandler: void 0,
                        closeOnTargetScroll: false,
                        onPositioned: null,
                        boundaryOffset: {
                            h: 0,
                            v: 0
                        },
                        propagateOutsideClick: false
                    })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                        device: function(device) {
                            var realDevice = devices.real(),
                                realPlatform = realDevice.platform,
                                realVersion = realDevice.version;
                            return "android" === realPlatform && compareVersions(realVersion, [4, 2]) < 0
                        },
                        options: {
                            animation: {
                                show: {
                                    type: "fade",
                                    duration: 400
                                },
                                hide: {
                                    type: "fade",
                                    duration: 400,
                                    to: {
                                        opacity: 0
                                    },
                                    from: {
                                        opacity: 1
                                    }
                                }
                            }
                        }
                    }])
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {
                        animation: true
                    })
                },
                _getAnonymousTemplateName: function() {
                    return ANONYMOUS_TEMPLATE_NAME
                },
                _wrapper: function() {
                    return this._$wrapper
                },
                _container: function() {
                    return this._$content
                },
                _eventBindingTarget: function() {
                    return this._$content
                },
                _init: function() {
                    this.callBase();
                    this._initActions();
                    this._initCloseOnOutsideClickHandler();
                    this._initTabTerminatorHandler();
                    this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
                    this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
                    var $element = this.element();
                    this._$wrapper.addClass($element.attr("class"));
                    $element.addClass(OVERLAY_CLASS);
                    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
                    this._$wrapper.on("MSPointerDown", $.noop);
                    this._$wrapper.on("focusin", function(e) {
                        e.stopPropagation()
                    });
                    this._toggleViewPortSubscription(true)
                },
                _initOptions: function(options) {
                    this._initTarget(options.target);
                    this._initContainer(options.container);
                    this._initHideTopOverlayHandler(options.hideTopOverlayHandler);
                    this.callBase(options)
                },
                _initTarget: function(target) {
                    if (!commonUtils.isDefined(target)) {
                        return
                    }
                    var options = this.option();
                    $.each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
                        var pathParts = path.split(".");
                        var option = options;
                        while (option) {
                            if (1 === pathParts.length) {
                                if ($.isPlainObject(option)) {
                                    option[pathParts.shift()] = target
                                }
                                break
                            } else {
                                option = option[pathParts.shift()]
                            }
                        }
                    })
                },
                _initContainer: function(container) {
                    container = void 0 === container ? viewPort() : container;
                    var $element = this.element(),
                        $container = $element.closest(container);
                    if (!$container.length) {
                        $container = $(container).first()
                    }
                    this._$container = $container.length ? $container : $element.parent()
                },
                _initHideTopOverlayHandler: function(handler) {
                    this._hideTopOverlayHandler = void 0 !== handler ? handler : $.proxy(this._defaultHideTopOverlayHandler, this)
                },
                _defaultHideTopOverlayHandler: function() {
                    this.hide()
                },
                _initActions: function() {
                    this._actions = {};
                    $.each(ACTIONS, $.proxy(function(_, action) {
                        this._actions[action] = this._createActionByOption(action, {
                            excludeValidators: ["disabled", "readOnly"]
                        }) || $.noop
                    }, this))
                },
                _initCloseOnOutsideClickHandler: function() {
                    var that = this;
                    this._proxiedDocumentDownHandler = function() {
                        return that._documentDownHandler.apply(that, arguments)
                    }
                },
                _documentDownHandler: function(e) {
                    if (this._showAnimationProcessing) {
                        this._stopAnimation();
                        return
                    }
                    var closeOnOutsideClick = this.option("closeOnOutsideClick");
                    if ($.isFunction(closeOnOutsideClick)) {
                        closeOnOutsideClick = closeOnOutsideClick(e)
                    }
                    if (closeOnOutsideClick) {
                        var $container = this._$content,
                            outsideClick = !$container.is(e.target) && !$.contains($container.get(0), e.target);
                        if (outsideClick) {
                            if (this.option("shading")) {
                                e.preventDefault()
                            }
                            this.hide()
                        }
                    }
                    return this.option("propagateOutsideClick")
                },
                _isTopOverlay: function() {
                    var overlayStack = this._overlayStack();
                    return overlayStack[overlayStack.length - 1] === this
                },
                _overlayStack: function() {
                    return OVERLAY_STACK
                },
                _zIndexInitValue: function() {
                    return FIRST_Z_INDEX
                },
                _toggleViewPortSubscription: function(toggle) {
                    viewPortChanged.remove(this._viewPortChangeHandle);
                    if (toggle) {
                        this._viewPortChangeHandle = $.proxy(this._viewPortChangeHandler, this);
                        viewPortChanged.add(this._viewPortChangeHandle)
                    }
                },
                _viewPortChangeHandler: function() {
                    this._initContainer(this.option("container"));
                    this._refresh()
                },
                _renderVisibilityAnimate: function(visible) {
                    this._stopAnimation();
                    return visible ? this._show() : this._hide()
                },
                _normalizePosition: function() {
                    this._position = this.option("position")
                },
                _getAnimationConfig: function() {
                    var animation = this.option("animation");
                    if ($.isFunction(animation)) {
                        animation = animation.call(this)
                    }
                    return animation
                },
                _show: function() {
                    var that = this,
                        deferred = $.Deferred();
                    this._parentHidden = this._isParentHidden();
                    deferred.done(function() {
                        delete that._parentHidden
                    });
                    if (this._parentHidden) {
                        return deferred.resolve()
                    }
                    if (this._currentVisible) {
                        return $.when().promise()
                    }
                    this._currentVisible = true;
                    this._normalizePosition();
                    var animation = that._getAnimationConfig() || {},
                        showAnimation = this._normalizeAnimation(animation.show, "to"),
                        startShowAnimation = showAnimation && showAnimation.start || $.noop,
                        completeShowAnimation = showAnimation && showAnimation.complete || $.noop;
                    if (this._isHidingActionCanceled) {
                        delete this._isHidingActionCanceled;
                        deferred.resolve()
                    } else {
                        var show = function() {
                            this._renderVisibility(true);
                            this._animate(showAnimation, function() {
                                if (that.option("focusStateEnabled")) {
                                    that._focusTarget().focus()
                                }
                                completeShowAnimation.apply(this, arguments);
                                that._showAnimationProcessing = false;
                                that._actions.onShown();
                                deferred.resolve()
                            }, function() {
                                startShowAnimation.apply(this, arguments);
                                that._showAnimationProcessing = true
                            })
                        }.bind(this);
                        if (this.option("templatesRenderAsynchronously")) {
                            this._asyncShowTimeout = setTimeout(show)
                        } else {
                            show()
                        }
                    }
                    return deferred.promise()
                },
                _normalizeAnimation: function(animation, prop) {
                    if (animation && animation[prop]) {
                        animation = $.extend({
                            type: "slide"
                        }, animation);
                        $.extend(animation[prop], {
                            position: this._position
                        })
                    }
                    return animation
                },
                _hide: function() {
                    if (!this._currentVisible) {
                        return $.when().promise()
                    }
                    this._currentVisible = false;
                    var that = this,
                        deferred = $.Deferred(),
                        animation = that._getAnimationConfig() || {},
                        hideAnimation = this._normalizeAnimation(animation.hide, "from"),
                        completeHideAnimation = hideAnimation && hideAnimation.complete || $.noop,
                        hidingArgs = {
                            cancel: false
                        };
                    this._actions.onHiding(hidingArgs);
                    if (hidingArgs.cancel) {
                        this._isHidingActionCanceled = true;
                        this.option("visible", true);
                        deferred.resolve()
                    } else {
                        this._forceFocusLost();
                        this._toggleShading(false);
                        this._toggleSubscriptions(false);
                        this._animate(hideAnimation, function() {
                            that._renderVisibility(false);
                            completeHideAnimation.apply(this, arguments);
                            that._actions.onHidden();
                            deferred.resolve()
                        })
                    }
                    return deferred.promise()
                },
                _forceFocusLost: function() {
                    document.activeElement && this._$content.find(document.activeElement).length && document.activeElement.blur()
                },
                _animate: function(animation, completeCallback, startCallback) {
                    if (animation) {
                        startCallback = startCallback || animation.start || $.noop;
                        var $content = this._$content;
                        fx.animate(this._$content, $.extend({}, animation, {
                            start: function() {
                                $content.css("pointer-events", "none");
                                startCallback.apply(this, arguments)
                            },
                            complete: function() {
                                $content.css("pointer-events", "");
                                completeCallback.apply(this, arguments)
                            }
                        }))
                    } else {
                        completeCallback()
                    }
                },
                _stopAnimation: function() {
                    fx.stop(this._$content, true)
                },
                _renderVisibility: function(visible) {
                    if (visible && this._isParentHidden()) {
                        return
                    }
                    this._currentVisible = visible;
                    this._stopAnimation();
                    clearTimeout(this._asyncShowTimeout);
                    if (!visible) {
                        domUtils.triggerHidingEvent(this._$content)
                    }
                    this._toggleVisibility(visible);
                    this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
                    this._updateZIndexStackPosition(visible);
                    if (visible) {
                        this._renderContent();
                        this._actions.onShowing();
                        this._moveToContainer();
                        this._renderGeometry();
                        domUtils.triggerShownEvent(this._$content);
                        domUtils.triggerResizeEvent(this._$content)
                    } else {
                        this._moveFromContainer()
                    }
                    this._toggleShading(visible);
                    this._toggleSubscriptions(visible)
                },
                _updateZIndexStackPosition: function(pushToStack) {
                    var overlayStack = this._overlayStack(),
                        index = $.inArray(this, overlayStack);
                    if (pushToStack) {
                        if (-1 === index) {
                            var length = overlayStack.length;
                            this._zIndex = (length ? overlayStack[length - 1]._zIndex : this._zIndexInitValue()) + 1;
                            overlayStack.push(this)
                        }
                        this._$wrapper.css("z-index", this._zIndex);
                        this._$content.css("z-index", this._zIndex)
                    } else {
                        if (-1 !== index) {
                            overlayStack.splice(index, 1)
                        }
                    }
                },
                _toggleShading: function(visible) {
                    this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
                    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
                    this._$wrapper.css("background-color", this.option("shading") ? this.option("shadingColor") : "");
                    this._toggleTabTerminator(visible && this.option("shading"))
                },
                _initTabTerminatorHandler: function() {
                    var that = this;
                    this._proxiedTabTerminatorHandler = function() {
                        that._tabKeyHandler.apply(that, arguments)
                    }
                },
                _toggleTabTerminator: function(enabled) {
                    var eventName = eventUtils.addNamespace("keydown", this.NAME);
                    if (enabled) {
                        $(document).on(eventName, this._proxiedTabTerminatorHandler)
                    } else {
                        $(document).off(eventName, this._proxiedTabTerminatorHandler)
                    }
                },
                _tabKeyHandler: function(e) {
                    if (e.keyCode !== TAB_KEY || !this._isTopOverlay()) {
                        return
                    }
                    var tabbableElements = this._$wrapper.find(selectors.tabbable),
                        $firstTabbable = tabbableElements.first(),
                        $lastTabbable = tabbableElements.last(),
                        isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),
                        isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),
                        isEmptyTabList = 0 === tabbableElements.length,
                        isOutsideTarget = -1 === $.inArray(e.target, tabbableElements);
                    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
                        e.preventDefault();
                        (e.shiftKey ? $lastTabbable : $firstTabbable).focusin().focus()
                    }
                },
                _toggleSubscriptions: function(enabled) {
                    this._toggleHideTopOverlayCallback(enabled);
                    this._toggleParentsScrollSubscription(enabled)
                },
                _toggleHideTopOverlayCallback: function(subscribe) {
                    if (!this._hideTopOverlayHandler) {
                        return
                    }
                    if (subscribe && this.option("closeOnBackButton")) {
                        hideTopOverlayCallback.add(this._hideTopOverlayHandler)
                    } else {
                        hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
                    }
                },
                _toggleParentsScrollSubscription: function(subscribe) {
                    if (!this._position) {
                        return
                    }
                    var target = this._position.of || $(),
                        closeOnScroll = this.option("closeOnTargetScroll"),
                        $parents = getElement(target).parents(),
                        scrollEvent = eventUtils.addNamespace("scroll", this.NAME);
                    if ("generic" === devices.real().platform) {
                        $parents = $parents.add(window)
                    }
                    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || $.proxy(function(e) {
                        this._targetParentsScrollHandler(e)
                    }, this);
                    $().add(this._$prevTargetParents).off(scrollEvent, this._proxiedTargetParentsScrollHandler);
                    if (subscribe && closeOnScroll) {
                        $parents.on(scrollEvent, this._proxiedTargetParentsScrollHandler);
                        this._$prevTargetParents = $parents
                    }
                },
                _targetParentsScrollHandler: function(e) {
                    var closeHandled = false,
                        closeOnScroll = this.option("closeOnTargetScroll");
                    if ($.isFunction(closeOnScroll)) {
                        closeHandled = closeOnScroll(e)
                    }
                    if (!closeHandled && !this._showAnimationProcessing) {
                        this.hide()
                    }
                },
                _render: function() {
                    this.callBase();
                    this._$content.appendTo(this.element());
                    this._renderVisibilityAnimate(this.option("visible"))
                },
                _renderContent: function() {
                    var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
                    var isParentHidden = this.option("visible") && this._isParentHidden();
                    if (isParentHidden) {
                        this._isHidden = true;
                        return
                    }
                    if (this._contentAlreadyRendered || shouldDeferRendering) {
                        return
                    }
                    this._contentAlreadyRendered = true;
                    this.callBase()
                },
                _isParentHidden: function() {
                    if (void 0 !== this._parentHidden) {
                        return this._parentHidden
                    }
                    var $parent = this.element().parent();
                    if ($parent.is(":visible")) {
                        return false
                    }
                    var isHidden = false;
                    $parent.add($parent.parents()).each(function() {
                        var $element = $(this);
                        if ("none" === $element.css("display")) {
                            isHidden = true;
                            return false
                        }
                    });
                    return isHidden || !$.contains(document, $parent.get(0))
                },
                _renderContentImpl: function() {
                    var $element = this.element();
                    this._$content.appendTo($element);
                    var contentTemplate = this._getTemplate(this.option("contentTemplate"));
                    contentTemplate && contentTemplate.render(this.content());
                    this._renderDrag();
                    this._renderResize();
                    this._renderScrollTerminator()
                },
                _renderDrag: function() {
                    var $dragTarget = this._getDragTarget();
                    if (!$dragTarget) {
                        return
                    }
                    var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME),
                        updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
                    $dragTarget.off(startEventName).off(updateEventName);
                    if (!this.option("dragEnabled")) {
                        return
                    }
                    $dragTarget.on(startEventName, $.proxy(this._dragStartHandler, this)).on(updateEventName, $.proxy(this._dragUpdateHandler, this))
                },
                _renderResize: function() {
                    this._createComponent(this._$content, Resizable, {
                        handles: this.option("resizeEnabled") ? "all" : "none",
                        onResizeEnd: $.proxy(this._resizeEndHandler, this),
                        onResize: $.proxy(this._actions.onResize, this),
                        onResizeStart: $.proxy(this._actions.onResizeStart, this),
                        minHeight: 100,
                        minWidth: 100,
                        area: this._$container
                    })
                },
                _resizeEndHandler: function() {
                    this._positionChangeHandled = true;
                    this._dimensionChangeHandled = true;
                    this._actions.onResizeEnd()
                },
                _renderScrollTerminator: function() {
                    var $scrollTerminator = this._wrapper();
                    var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
                    $scrollTerminator.off(terminatorEventName).on(terminatorEventName, {
                        validate: function() {
                            return true
                        },
                        getDirection: function() {
                            return "both"
                        },
                        _toggleGestureCover: $.noop,
                        _clearSelection: $.noop,
                        isNative: true
                    }, function(e) {
                        if ("mousemove" !== e.originalEvent.originalEvent.type) {
                            e.preventDefault()
                        }
                    })
                },
                _getDragTarget: function() {
                    return this.content()
                },
                _dragStartHandler: function(e) {
                    e.targetElements = [];
                    this._prevOffset = {
                        x: 0,
                        y: 0
                    };
                    var allowedOffsets = this._allowedOffsets();
                    e.maxTopOffset = allowedOffsets.top;
                    e.maxBottomOffset = allowedOffsets.bottom;
                    e.maxLeftOffset = allowedOffsets.left;
                    e.maxRightOffset = allowedOffsets.right
                },
                _deltaSize: function() {
                    var $content = this._$content,
                        $container = this._$container;
                    var contentWidth = $content.outerWidth(),
                        contentHeight = $content.outerHeight(),
                        containerWidth = $container.width(),
                        containerHeight = $container.height();
                    return {
                        width: containerWidth - contentWidth,
                        height: containerHeight - contentHeight
                    }
                },
                _dragUpdateHandler: function(e) {
                    var offset = e.offset,
                        prevOffset = this._prevOffset,
                        targetOffset = {
                            top: offset.y - prevOffset.y,
                            left: offset.x - prevOffset.x
                        };
                    this._changePosition(targetOffset);
                    this._prevOffset = offset
                },
                _changePosition: function(offset) {
                    var position = translator.locate(this._$content);
                    translator.move(this._$content, {
                        left: position.left + offset.left,
                        top: position.top + offset.top
                    });
                    this._positionChangeHandled = true
                },
                _allowedOffsets: function() {
                    var position = translator.locate(this._$content),
                        deltaSize = this._deltaSize(),
                        isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,
                        boundaryOffset = this.option("boundaryOffset");
                    return {
                        top: isAllowedDrag ? position.top + boundaryOffset.v : 0,
                        bottom: isAllowedDrag ? -position.top + deltaSize.height - boundaryOffset.v : 0,
                        left: isAllowedDrag ? position.left + boundaryOffset.h : 0,
                        right: isAllowedDrag ? -position.left + deltaSize.width - boundaryOffset.h : 0
                    }
                },
                _fireContentReadyAction: function() {
                    if (this.option("visible")) {
                        this._moveToContainer()
                    }
                    this.callBase.apply(this, arguments)
                },
                _moveFromContainer: function() {
                    this._$content.appendTo(this.element());
                    this._detachWrapperToContainer()
                },
                _detachWrapperToContainer: function() {
                    this._$wrapper.detach()
                },
                _moveToContainer: function() {
                    this._attachWrapperToContainer();
                    this._$content.appendTo(this._$wrapper)
                },
                _attachWrapperToContainer: function() {
                    var $element = this.element();
                    if (this._$container && this._$container[0] !== $element.parent()[0]) {
                        this._$wrapper.appendTo(this._$container)
                    } else {
                        this._$wrapper.appendTo($element)
                    }
                },
                _renderGeometry: function() {
                    if (this.option("visible")) {
                        this._renderGeometryImpl()
                    }
                },
                _renderGeometryImpl: function() {
                    this._stopAnimation();
                    this._normalizePosition();
                    this._renderShading();
                    this._renderDimensions();
                    var resultPosition = this._renderPosition();
                    this._actions.onPositioned({
                        position: resultPosition
                    })
                },
                _renderShading: function() {
                    var $wrapper = this._$wrapper,
                        $container = this._getContainer();
                    $wrapper.css("position", this._isWindow($container) && !iOS ? "fixed" : "absolute");
                    this._renderShadingDimensions();
                    this._renderShadingPosition()
                },
                _renderShadingPosition: function() {
                    if (this.option("shading")) {
                        var $container = this._getContainer();
                        positionUtils.setup(this._$wrapper, {
                            my: "top left",
                            at: "top left",
                            of: $container
                        })
                    }
                },
                _renderShadingDimensions: function() {
                    if (this.option("shading")) {
                        var $container = this._getContainer(),
                            wrapperWidth = this._isWindow($container) ? "100%" : $container.outerWidth(),
                            wrapperHeight = this._isWindow($container) ? "100%" : $container.outerHeight();
                        this._$wrapper.css({
                            width: wrapperWidth,
                            height: wrapperHeight
                        })
                    }
                },
                _isWindow: function($element) {
                    return !!$element && $.isWindow($element.get(0))
                },
                _getContainer: function() {
                    var position = this._position,
                        container = this.option("container"),
                        positionOf = position ? position.of || window : null;
                    return getElement(container || positionOf)
                },
                _renderDimensions: function() {
                    this._$content.css({
                        minWidth: this.option("minWidth"),
                        maxWidth: this.option("maxWidth"),
                        minHeight: this.option("minHeight"),
                        maxHeight: this.option("maxHeight")
                    });
                    if (this._dimensionChangeHandled) {
                        var $content = this._$content,
                            $container = this._$container;
                        $content.outerWidth(Math.min($content.outerWidth(), $container.width())).outerHeight(Math.min($content.outerHeight(), $container.height()))
                    } else {
                        this._$content.outerWidth(this.option("width")).outerHeight(this.option("height"))
                    }
                },
                _renderPosition: function() {
                    if (this._positionChangeHandled) {
                        var allowedOffsets = this._allowedOffsets();
                        this._changePosition({
                            top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
                            left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
                        })
                    } else {
                        this._renderOverlayBoundaryOffset();
                        translator.resetPosition(this._$content);
                        var resultPosition = positionUtils.setup(this._$content, this._position);
                        forceRepaint(this._$content);
                        this._actions.onPositioning();
                        return resultPosition
                    }
                },
                _renderOverlayBoundaryOffset: function() {
                    var boundaryOffset = this.option("boundaryOffset");
                    this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
                },
                _focusTarget: function() {
                    return this._$content
                },
                _attachKeyboardEvents: function() {
                    this._keyboardProcessor = new KeyboardProcessor({
                        element: this._$content,
                        handler: this._keyboardHandler,
                        context: this
                    })
                },
                _keyboardHandler: function(options) {
                    var e = options.originalEvent,
                        $target = $(e.target);
                    if ($target.is(this._$content)) {
                        this.callBase.apply(this, arguments)
                    }
                },
                _isVisible: function() {
                    return this.option("visible")
                },
                _visibilityChanged: function(visible) {
                    if (visible) {
                        if (this.option("visible")) {
                            this._renderVisibilityAnimate(visible)
                        }
                    } else {
                        this._renderVisibilityAnimate(visible)
                    }
                },
                _dimensionChanged: function() {
                    this._renderGeometry()
                },
                _clean: function() {
                    if (!this._contentAlreadyRendered) {
                        this.content().empty()
                    }
                    this._renderVisibility(false);
                    this._cleanFocusState()
                },
                _dispose: function() {
                    fx.stop(this._$content, false);
                    clearTimeout(this._deferShowTimer);
                    this._toggleViewPortSubscription(false);
                    this._toggleSubscriptions(false);
                    this._updateZIndexStackPosition(false);
                    this._toggleTabTerminator(false);
                    this._actions = null;
                    this.callBase();
                    this._$wrapper.remove();
                    this._$content.remove()
                },
                _toggleDisabledState: function(value) {
                    this.callBase.apply(this, arguments);
                    this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
                },
                _toggleRTLDirection: function(rtl) {
                    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    if ($.inArray(args.name, ACTIONS) > -1) {
                        this._initActions();
                        return
                    }
                    switch (args.name) {
                        case "dragEnabled":
                            this._renderDrag();
                            this._renderGeometry();
                            break;
                        case "resizeEnabled":
                            this._renderResize();
                            this._renderGeometry();
                            break;
                        case "shading":
                        case "shadingColor":
                            this._toggleShading(this.option("visible"));
                            break;
                        case "width":
                        case "minWidth":
                        case "maxWidth":
                        case "height":
                        case "minHeight":
                        case "maxHeight":
                        case "position":
                        case "boundaryOffset":
                            this._renderGeometry();
                            break;
                        case "visible":
                            this._renderVisibilityAnimate(value).done($.proxy(function() {
                                if (!this._animateDeferred) {
                                    return
                                }
                                this._animateDeferred.resolveWith(this)
                            }, this));
                            break;
                        case "target":
                            this._initTarget(value);
                            this._invalidate();
                            break;
                        case "container":
                            this._initContainer(value);
                            this._invalidate();
                            break;
                        case "deferRendering":
                        case "contentTemplate":
                            this._contentAlreadyRendered = false;
                            this._invalidate();
                            break;
                        case "closeOnBackButton":
                            this._toggleHideTopOverlayCallback(this.option("visible"));
                            break;
                        case "closeOnTargetScroll":
                            this._toggleParentsScrollSubscription(this.option("visible"));
                            break;
                        case "closeOnOutsideClick":
                        case "animation":
                        case "propagateOutsideClick":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                toggle: function(showing) {
                    showing = void 0 === showing ? !this.option("visible") : showing;
                    if (showing === this.option("visible")) {
                        return $.Deferred().resolve().promise()
                    }
                    var animateDeferred = $.Deferred();
                    this._animateDeferred = animateDeferred;
                    this.option("visible", showing);
                    return animateDeferred.promise().done($.proxy(function() {
                        delete this._animateDeferred
                    }, this))
                },
                show: function() {
                    return this.toggle(true)
                },
                hide: function() {
                    return this.toggle(false)
                },
                content: function() {
                    return this._$content
                },
                repaint: function() {
                    this._renderGeometry()
                }
            });
            Overlay.baseZIndex = function(zIndex) {
                FIRST_Z_INDEX = zIndex
            };
            registerComponent("dxOverlay", Overlay);
            module.exports = Overlay
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/data/abstract_store.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                abstract = Class.abstract,
                EventsMixin = __webpack_require__( /*! ../core/events_mixin */ 32),
                errorsModule = __webpack_require__( /*! ./errors */ 25),
                dataUtils = __webpack_require__( /*! ./utils */ 28),
                normalizeSortingInfo = dataUtils.normalizeSortingInfo,
                compileGetter = __webpack_require__( /*! ../core/utils/data */ 16).compileGetter,
                Query = __webpack_require__( /*! ./query */ 34),
                storeImpl = {};

            function multiLevelGroup(query, groupInfo) {
                query = query.groupBy(groupInfo[0].selector);
                if (groupInfo.length > 1) {
                    query = query.select(function(g) {
                        return $.extend({}, g, {
                            items: multiLevelGroup(Query(g.items), groupInfo.slice(1)).toArray()
                        })
                    })
                }
                return query
            }

            function arrangeSortingInfo(groupInfo, sortInfo) {
                var filteredGroup = [];
                $.each(groupInfo, function(_, group) {
                    var collision = $.grep(sortInfo, function(sort) {
                        return group.selector === sort.selector
                    });
                    if (collision.length < 1) {
                        filteredGroup.push(group)
                    }
                });
                return filteredGroup.concat(sortInfo)
            }
            var Store = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    options = options || {};
                    $.each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
                        if (optionName in options) {
                            that.on(optionName.slice(2).toLowerCase(), options[optionName])
                        }
                    });
                    this._key = options.key;
                    this._errorHandler = options.errorHandler;
                    this._useDefaultSearch = true
                },
                _customLoadOptions: function() {
                    return null
                },
                key: function() {
                    return this._key
                },
                keyOf: function(obj) {
                    if (!this._keyGetter) {
                        this._keyGetter = compileGetter(this.key())
                    }
                    return this._keyGetter(obj)
                },
                _requireKey: function() {
                    if (!this.key()) {
                        throw errorsModule.errors.Error("E4005")
                    }
                },
                load: function(options) {
                    var that = this;
                    options = options || {};
                    this.fireEvent("loading", [options]);
                    return this._withLock(this._loadImpl(options)).done(function(result, extra) {
                        that.fireEvent("loaded", [result, options])
                    })
                },
                _loadImpl: function(options) {
                    var filter = options.filter,
                        sort = options.sort,
                        select = options.select,
                        group = options.group,
                        skip = options.skip,
                        take = options.take,
                        q = this.createQuery(options);
                    if (filter) {
                        q = q.filter(filter)
                    }
                    if (group) {
                        group = normalizeSortingInfo(group)
                    }
                    if (sort || group) {
                        sort = normalizeSortingInfo(sort || []);
                        if (group) {
                            sort = arrangeSortingInfo(group, sort)
                        }
                        $.each(sort, function(index) {
                            q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
                        })
                    }
                    if (select) {
                        q = q.select(select)
                    }
                    if (group) {
                        q = multiLevelGroup(q, group)
                    }
                    if (take || skip) {
                        q = q.slice(skip || 0, take)
                    }
                    return q.enumerate()
                },
                _withLock: function(task) {
                    var result = $.Deferred();
                    task.done(function() {
                        var that = this,
                            args = arguments;
                        dataUtils.processRequestResultLock.promise().done(function() {
                            result.resolveWith(that, args)
                        })
                    }).fail(function() {
                        result.rejectWith(this, arguments)
                    });
                    return result
                },
                createQuery: abstract,
                totalCount: function(options) {
                    return this._totalCountImpl(options)
                },
                _totalCountImpl: function(options) {
                    options = options || {};
                    var q = this.createQuery(),
                        group = options.group,
                        filter = options.filter;
                    if (filter) {
                        q = q.filter(filter)
                    }
                    if (group) {
                        group = normalizeSortingInfo(group);
                        q = multiLevelGroup(q, group)
                    }
                    return q.count()
                },
                byKey: function(key, extraOptions) {
                    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)))
                },
                _byKeyImpl: abstract,
                insert: function(values) {
                    var that = this;
                    that.fireEvent("modifying");
                    that.fireEvent("inserting", [values]);
                    return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
                        that.fireEvent("inserted", [callbackValues, callbackKey]);
                        that.fireEvent("modified")
                    }))
                },
                _insertImpl: abstract,
                update: function(key, values) {
                    var that = this;
                    that.fireEvent("modifying");
                    that.fireEvent("updating", [key, values]);
                    return that._addFailHandlers(that._updateImpl(key, values).done(function(callbackKey, callbackValues) {
                        that.fireEvent("updated", [callbackKey, callbackValues]);
                        that.fireEvent("modified")
                    }))
                },
                _updateImpl: abstract,
                remove: function(key) {
                    var that = this;
                    that.fireEvent("modifying");
                    that.fireEvent("removing", [key]);
                    return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
                        that.fireEvent("removed", [callbackKey]);
                        that.fireEvent("modified")
                    }))
                },
                _removeImpl: abstract,
                _addFailHandlers: function(deferred) {
                    return deferred.fail(this._errorHandler, errorsModule._errorHandler)
                }
            }).include(EventsMixin);
            Store.create = function(alias, options) {
                if (!(alias in storeImpl)) {
                    throw errorsModule.errors.Error("E4020", alias)
                }
                return new storeImpl[alias](options)
            };
            Store.inherit = function(inheritor) {
                return function(members, alias) {
                    var type = inheritor.apply(this, [members]);
                    if (alias) {
                        storeImpl[alias] = type
                    }
                    return type
                }
            }(Store.inherit);
            module.exports = Store;
            module.exports.multiLevelGroup = multiLevelGroup;
            module.exports.arrangeSortingInfo = arrangeSortingInfo
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/tree_map/tree_map.base.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var common = __webpack_require__( /*! ./common */ 90),
                Node = __webpack_require__( /*! ./node */ 168),
                _getTilingAlgorithm = __webpack_require__( /*! ./tiling */ 107).getAlgorithm,
                _getColorizer = __webpack_require__( /*! ./colorizing */ 106).getColorizer,
                _patchFontOptions = __webpack_require__( /*! ../core/utils */ 6).patchFontOptions,
                _buildRectAppearance = common.buildRectAppearance,
                _buildTextAppearance = common.buildTextAppearance,
                _noop = __webpack_require__( /*! jquery */ 1).noop,
                _max = Math.max,
                directions = {
                    lefttoprightbottom: [1, 1],
                    leftbottomrighttop: [1, -1],
                    righttopleftbottom: [-1, 1],
                    rightbottomlefttop: [-1, -1]
                };
            __webpack_require__( /*! ./tiling.squarified */ 346);
            __webpack_require__( /*! ./tiling */ 107).setDefaultAlgorithm("squarified");
            __webpack_require__( /*! ./colorizing.discrete */ 342);
            __webpack_require__( /*! ./colorizing */ 106).setDefaultColorizer("discrete");

            function pickPositiveInteger(val) {
                return val > 0 ? Math.round(val) : 0
            }
            var dxTreeMap = __webpack_require__( /*! ../core/base_widget */ 109).inherit({
                _handlers: {
                    beginBuildNodes: _noop,
                    buildNode: _noop,
                    endBuildNodes: _noop,
                    setTrackerData: _noop,
                    calculateState: function(options) {
                        return _buildRectAppearance(options)
                    }
                },
                _rootClass: "dxtm-tree-map",
                _rootClassPrefix: "dxtm",
                _getDefaultSize: function() {
                    return {
                        width: 400,
                        height: 400
                    }
                },
                _createThemeManager: function() {
                    return new ThemeManager
                },
                _init: function() {
                    var that = this;
                    that._rectOffsets = {};
                    that._context = {
                        suspend: function() {
                            if (!that._applyingChanges) {
                                that._suspendChanges()
                            }
                        },
                        resume: function() {
                            if (!that._applyingChanges) {
                                that._resumeChanges()
                            }
                        },
                        change: function(codes) {
                            that._change(codes)
                        },
                        settings: [{}, {}],
                        calculateState: that._handlers.calculateState,
                        calculateLabelState: _buildTextAppearance
                    };
                    that._root = that._topNode = {
                        nodes: []
                    };
                    that.callBase.apply(that, arguments)
                },
                _initialChanges: ["DATA_SOURCE"],
                _initCore: function() {
                    var that = this,
                        renderer = that._renderer;
                    that._createProxyType();
                    that._tilesGroup = renderer.g().linkOn(renderer.root, "tiles").linkAppend();
                    that._labelsGroup = renderer.g().attr({
                        align: "left"
                    }).linkOn(renderer.root, "labels").linkAppend()
                },
                _createProxyType: _noop,
                _disposeCore: function() {
                    var that = this;
                    that._filter && that._filter.dispose();
                    that._labelsGroup.linkOff();
                    that._tilesGroup.linkOff()
                },
                _applySize: function(rect) {
                    this._tilingRect = rect.slice();
                    this._change(["TILING"])
                },
                _optionChangesMap: {
                    dataSource: "DATA_SOURCE",
                    valueField: "NODES_CREATE",
                    childrenField: "NODES_CREATE",
                    colorField: "TILES",
                    colorizer: "TILES",
                    labelField: "LABELS",
                    tile: "TILE_SETTINGS",
                    group: "GROUP_SETTINGS",
                    maxDepth: "MAX_DEPTH",
                    layoutAlgorithm: "TILING",
                    layoutDirection: "TILING"
                },
                _themeDependentChanges: ["TILE_SETTINGS", "GROUP_SETTINGS", "MAX_DEPTH"],
                _changeDataSource: function() {
                    var that = this;
                    that._isDataExpected = that._isSyncData = true;
                    that._updateDataSource();
                    that._isSyncData = false;
                    if (that._isDataExpected) {
                        that._suspendChanges()
                    }
                },
                _dataSourceChangedHandler: function() {
                    var that = this;
                    if (that._isDataExpected) {
                        that._isDataExpected = false;
                        that._change(["NODES_CREATE"]);
                        if (!that._isSyncData) {
                            that._resumeChanges()
                        }
                    } else {
                        that._requestChange(["NODES_CREATE"])
                    }
                },
                _optionChangesOrder: ["DATA_SOURCE", "TILE_SETTINGS", "GROUP_SETTINGS", "MAX_DEPTH"],
                _change_DATA_SOURCE: function() {
                    this._changeDataSource()
                },
                _change_TILE_SETTINGS: function() {
                    this._changeTileSettings()
                },
                _change_GROUP_SETTINGS: function() {
                    this._changeGroupSettings()
                },
                _change_MAX_DEPTH: function() {
                    this._changeMaxDepth()
                },
                _customChangesOrder: ["NODES_CREATE", "NODES_RESET", "TILES", "LABELS", "TILING", "LABELS_LAYOUT"],
                _change_NODES_CREATE: function() {
                    this._buildNodes()
                },
                _change_NODES_RESET: function() {
                    this._resetNodes()
                },
                _change_TILES: function() {
                    this._applyTilesAppearance()
                },
                _change_LABELS: function() {
                    this._applyLabelsAppearance()
                },
                _change_TILING: function() {
                    this._performTiling()
                },
                _change_LABELS_LAYOUT: function() {
                    this._performLabelsLayout()
                },
                _applyChanges: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    if (!that._isDataExpected) {
                        that._drawn()
                    }
                    that._context.forceReset = false
                },
                _buildNodes: function() {
                    var processedData, that = this,
                        root = that._root = that._topNode = new Node;
                    root._id = 0;
                    root.parent = {};
                    root.data = {};
                    root.level = root.index = -1;
                    root.ctx = that._context;
                    root.label = null;
                    that._nodes = [root];
                    that._handlers.beginBuildNodes();
                    processedData = that._processDataSourceItems(that._dataSource.items() || []);
                    traverseDataItems(root, processedData.items, 0, {
                        itemsField: !processedData.isPlain && that._getOption("childrenField", true) || "items",
                        valueField: that._getOption("valueField", true) || "value",
                        buildNode: that._handlers.buildNode,
                        ctx: that._context,
                        nodes: that._nodes
                    });
                    that._onNodesCreated();
                    that._handlers.endBuildNodes();
                    that._change(["NODES_RESET"])
                },
                _onNodesCreated: common.empty,
                _processDataSourceItems: function(items) {
                    return {
                        items: items,
                        isPlain: false
                    }
                },
                _changeTileSettings: function() {
                    var that = this,
                        options = that._getOption("tile"),
                        offsets = that._rectOffsets,
                        borderWidth = pickPositiveInteger(options.border.width),
                        edgeOffset = borderWidth / 2,
                        innerOffset = 1 & borderWidth ? .5 : 0,
                        labelOptions = options.label,
                        settings = that._context.settings[0];
                    that._change(["TILES", "LABELS"]);
                    settings.state = that._handlers.calculateState(options);
                    that._filter = that._filter || that._renderer.shadowFilter("-50%", "-50%", "200%", "200%");
                    that._filter.attr(labelOptions.shadow);
                    that._calculateLabelSettings(settings, labelOptions, that._filter.ref);
                    if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {
                        offsets.tileEdge = edgeOffset;
                        offsets.tileInner = innerOffset;
                        that._change(["TILING"])
                    }
                },
                _changeGroupSettings: function() {
                    var that = this,
                        options = that._getOption("group"),
                        labelOptions = options.label,
                        offsets = that._rectOffsets,
                        borderWidth = pickPositiveInteger(options.border.width),
                        edgeOffset = borderWidth / 2,
                        innerOffset = 1 & borderWidth ? .5 : 0,
                        headerHeight = 0,
                        groupPadding = pickPositiveInteger(options.padding),
                        settings = that._context.settings[1];
                    that._change(["TILES", "LABELS"]);
                    settings.state = that._handlers.calculateState(options);
                    that._calculateLabelSettings(settings, labelOptions);
                    if (options.headerHeight >= 0) {
                        headerHeight = pickPositiveInteger(options.headerHeight)
                    } else {
                        headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom)
                    }
                    if (that._headerHeight !== headerHeight) {
                        that._headerHeight = headerHeight;
                        that._change(["TILING"])
                    }
                    if (that._groupPadding !== groupPadding) {
                        that._groupPadding = groupPadding;
                        that._change(["TILING"])
                    }
                    if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {
                        offsets.headerEdge = edgeOffset;
                        offsets.headerInner = innerOffset;
                        that._change(["TILING"])
                    }
                },
                _calculateLabelSettings: function(settings, options, filter) {
                    var bbox = this._getTextBBox(options.font),
                        paddingLeftRight = pickPositiveInteger(options.paddingLeftRight),
                        paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);
                    settings.labelState = _buildTextAppearance(options, filter);
                    settings.labelState.visible = !("visible" in options) || !!options.visible;
                    settings.labelParams = {
                        unitWidth: bbox.width,
                        height: bbox.height,
                        hOffset: paddingLeftRight,
                        vOffset: -bbox.y + paddingTopBottom,
                        rtlEnabled: this._getOption("rtlEnabled", true),
                        paddingTopBottom: paddingTopBottom,
                        paddingLeftRight: paddingLeftRight
                    }
                },
                _changeMaxDepth: function() {
                    var maxDepth = this._getOption("maxDepth", true);
                    maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : 1 / 0;
                    if (this._maxDepth !== maxDepth) {
                        this._maxDepth = maxDepth;
                        this._change(["NODES_RESET"])
                    }
                },
                _resetNodes: function() {
                    var that = this;
                    that._tilesGroup.clear();
                    that._renderer.initHatching();
                    that._context.forceReset = true;
                    that._context.minLevel = that._topNode.level + 1;
                    that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;
                    that._change(["TILES", "LABELS", "TILING"])
                },
                _processNodes: function(context, process) {
                    processNodes(context, this._topNode, process)
                },
                _applyTilesAppearance: function() {
                    var that = this,
                        colorizer = _getColorizer(that._getOption("colorizer"), that._themeManager, that._topNode);
                    that._processNodes({
                        renderer: that._renderer,
                        group: that._tilesGroup,
                        setTrackerData: that._handlers.setTrackerData,
                        colorField: that._getOption("colorField", true) || "color",
                        getColor: colorizer
                    }, processTileAppearance)
                },
                _applyLabelsAppearance: function() {
                    var that = this;
                    that._labelsGroup.clear();
                    that._processNodes({
                        renderer: that._renderer,
                        group: that._labelsGroup,
                        setTrackerData: that._handlers.setTrackerData,
                        labelField: that._getOption("labelField", true) || "name"
                    }, processLabelAppearance);
                    that._change(["LABELS_LAYOUT"])
                },
                _performTiling: function() {
                    var that = this,
                        context = {
                            algorithm: _getTilingAlgorithm(that._getOption("layoutAlgorithm", true)),
                            directions: directions[String(that._getOption("layoutDirection", true)).toLowerCase()] || directions.lefttoprightbottom,
                            headerHeight: that._headerHeight,
                            groupPadding: that._groupPadding,
                            rectOffsets: that._rectOffsets
                        };
                    that._topNode.innerRect = that._tilingRect;
                    calculateRects(context, that._topNode);
                    that._processNodes(context, processTiling);
                    that._change(["LABELS_LAYOUT"]);
                    that._onTilingPerformed()
                },
                _onTilingPerformed: common.empty,
                _performLabelsLayout: function() {
                    this._processNodes(null, processLabelsLayout)
                },
                _getTextBBox: function(fontOptions) {
                    var bbox, renderer = this._renderer,
                        text = this._textForCalculations || renderer.text("0", 0, 0);
                    this._textForCalculations = text;
                    text.css(_patchFontOptions(fontOptions)).append(renderer.root);
                    bbox = text.getBBox();
                    text.remove();
                    return bbox
                }
            });

            function traverseDataItems(root, dataItems, level, params) {
                var node, i, dataItem, items, nodes = [],
                    allNodes = params.nodes,
                    ii = dataItems.length,
                    totalValue = 0;
                for (i = 0; i < ii; ++i) {
                    dataItem = dataItems[i];
                    node = new Node;
                    node._id = allNodes.length;
                    node.ctx = params.ctx;
                    node.parent = root;
                    node.level = level;
                    node.index = nodes.length;
                    node.data = dataItem;
                    params.buildNode(node);
                    allNodes.push(node);
                    nodes.push(node);
                    items = dataItem[params.itemsField];
                    if (items && items.length) {
                        traverseDataItems(node, items, level + 1, params)
                    }
                    if (dataItem[params.valueField] > 0) {
                        node.value = Number(dataItem[params.valueField])
                    }
                    totalValue += node.value
                }
                root.nodes = nodes;
                root.value = totalValue
            }

            function processNodes(context, root, process) {
                var node, i, nodes = root.nodes,
                    ii = nodes.length;
                for (i = 0; i < ii; ++i) {
                    node = nodes[i];
                    process(context, node);
                    if (node.isNode()) {
                        processNodes(context, node, process)
                    }
                }
            }

            function processTileAppearance(context, node) {
                node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;
                node.updateStyles();
                node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);
                node.applyState()
            }
            var createTile = [createLeaf, createGroup];

            function createLeaf(context, node) {
                var tile = context.renderer.simpleRect().append(context.group);
                context.setTrackerData(node, tile);
                return tile
            }

            function createGroup(context, node) {
                var outer = context.renderer.simpleRect().append(context.group),
                    inner = context.renderer.simpleRect().append(context.group);
                context.setTrackerData(node, inner);
                return {
                    outer: outer,
                    inner: inner
                }
            }

            function processLabelAppearance(context, node) {
                node.updateLabelStyle();
                if (node.labelState.visible) {
                    createLabel(context, node, node.labelState, node.labelParams)
                }
            }

            function createLabel(context, currentNode, settings, params) {
                var textData = currentNode.data[context.labelField];
                currentNode.label = textData ? String(textData) : null;
                textData = currentNode.customLabel || currentNode.label;
                if (textData) {
                    currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);
                    context.setTrackerData(currentNode, currentNode.text);
                    currentNode.textWidth = params.unitWidth * textData.length
                }
            }
            var emptyRect = [0, 0, 0, 0];

            function calculateRects(context, root) {
                var i, nodes = root.nodes,
                    items = [],
                    rects = [],
                    sum = 0,
                    ii = items.length = rects.length = nodes.length;
                for (i = 0; i < ii; ++i) {
                    sum += nodes[i].value;
                    items[i] = {
                        value: nodes[i].value,
                        i: i
                    }
                }
                if (sum > 0) {
                    context.algorithm({
                        items: items.slice(),
                        sum: sum,
                        rect: root.innerRect.slice(),
                        isRotated: 1 & nodes[0].level,
                        directions: context.directions
                    })
                }
                for (i = 0; i < ii; ++i) {
                    rects[i] = items[i].rect || emptyRect
                }
                root.rects = rects
            }

            function processTiling(context, node) {
                var headerHeight, rect = node.parent.rects[node.index],
                    rectOffsets = context.rectOffsets;
                if (node.isNode()) {
                    setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));
                    rect = marginateRect(rect, context.groupPadding);
                    headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);
                    node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];
                    setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));
                    rect[1] += headerHeight;
                    node.innerRect = rect;
                    calculateRects(context, node)
                } else {
                    node.rect = rect;
                    setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner))
                }
            }

            function marginateRect(rect, margin) {
                return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin]
            }

            function buildTileRect(rect, outer, edgeOffset, innerOffset) {
                return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)]
            }

            function setRectAttrs(element, rect) {
                element.attr({
                    x: rect[0],
                    y: rect[1],
                    width: _max(rect[2] - rect[0], 0),
                    height: _max(rect[3] - rect[1], 0)
                })
            }

            function processLabelsLayout(context, node) {
                if (node.text && node.labelState.visible) {
                    layoutTextNode(node, node.labelParams)
                }
            }

            function layoutTextNode(node, params) {
                var rect = node.rect,
                    hOffset = params.hOffset;
                node.text.attr({
                    x: params.rtlEnabled ? rect[2] - hOffset : rect[0] + hOffset,
                    y: rect[1] + params.vOffset,
                    visibility: node.textWidth + params.paddingLeftRight < rect[2] - rect[0] && params.height + params.paddingTopBottom < rect[3] - rect[1] ? "visible" : "hidden"
                })
            }
            var ThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager.inherit({
                _themeSection: "treeMap",
                _fontFields: ["tile.label.font", "group.label.font", "loadingIndicator.font", "title.font", "title.subtitle.font", "tooltip.font"]
            });
            __webpack_require__( /*! ../../core/component_registrator */ 3)("dxTreeMap", dxTreeMap);
            module.exports = dxTreeMap;
            dxTreeMap.addPlugin(__webpack_require__( /*! ../core/data_source */ 161).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/core/utils/view_port.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                changeCallback = $.Callbacks(),
                $originalViewPort = $();
            var value = function() {
                var $current;
                return function(element) {
                    if (!arguments.length) {
                        return $current
                    }
                    var $element = $(element);
                    $originalViewPort = $element;
                    var isNewViewportFound = !!$element.length;
                    var prevViewPort = value();
                    $current = isNewViewportFound ? $element : $("body");
                    changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort)
                }
            }();
            $(function() {
                value(".dx-viewport")
            });
            exports.value = value;
            exports.changeCallback = changeCallback;
            exports.originalViewPort = function() {
                return $originalViewPort
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!********************************!*\
      !*** ./Scripts/core/action.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                config = __webpack_require__( /*! ./config */ 35),
                Class = __webpack_require__( /*! ./class */ 5);
            var Action = Class.inherit({
                ctor: function(action, config) {
                    config = config || {};
                    this._action = action;
                    this._context = config.context || window;
                    this._beforeExecute = config.beforeExecute;
                    this._afterExecute = config.afterExecute;
                    this._component = config.component;
                    this._validatingTargetName = config.validatingTargetName;
                    var excludeValidators = this._excludeValidators = {};
                    if (config.excludeValidators) {
                        for (var i = 0; i < config.excludeValidators.length; i++) {
                            excludeValidators[config.excludeValidators[i]] = true
                        }
                    }
                },
                execute: function() {
                    var e = {
                        action: this._action,
                        args: Array.prototype.slice.call(arguments),
                        context: this._context,
                        component: this._component,
                        validatingTargetName: this._validatingTargetName,
                        cancel: false,
                        handled: false
                    };
                    var beforeExecute = this._beforeExecute,
                        afterExecute = this._afterExecute;
                    if (!this._validateAction(e)) {
                        return
                    }
                    beforeExecute && beforeExecute.call(this._context, e);
                    if (e.cancel) {
                        return
                    }
                    var result = this._executeAction(e);
                    var argsBag = e.args[0];
                    if (argsBag && argsBag.cancel) {
                        return
                    }
                    afterExecute && afterExecute.call(this._context, e);
                    return result
                },
                _validateAction: function(e) {
                    var excludeValidators = this._excludeValidators,
                        executors = Action.executors;
                    for (var name in executors) {
                        if (!excludeValidators[name]) {
                            var executor = executors[name];
                            if (executor.validate) {
                                executor.validate(e)
                            }
                            if (e.cancel) {
                                return false
                            }
                        }
                    }
                    return true
                },
                _executeAction: function(e) {
                    var result, executors = Action.executors;
                    for (var name in executors) {
                        var executor = executors[name];
                        if (executor.execute) {
                            executor.execute(e)
                        }
                        if (e.handled) {
                            result = e.result;
                            break
                        }
                    }
                    return result
                }
            });
            Action.executors = {};
            Action.registerExecutor = function(name, executor) {
                if ($.isPlainObject(name)) {
                    $.each(name, Action.registerExecutor);
                    return
                }
                Action.executors[name] = executor
            };
            Action.unregisterExecutor = function() {
                var args = $.makeArray(arguments);
                $.each(args, function() {
                    delete Action.executors[this]
                })
            };
            Action.registerExecutor({
                undefined: {
                    execute: function(e) {
                        if (!e.action) {
                            e.result = void 0;
                            e.handled = true
                        }
                    }
                },
                func: {
                    execute: function(e) {
                        if ($.isFunction(e.action)) {
                            e.result = e.action.call(e.context, e.args[0]);
                            e.handled = true
                        }
                    }
                }
            });
            var createValidatorByTargetElement = function(condition) {
                return function(e) {
                    if (!e.args.length) {
                        return
                    }
                    var args = e.args[0],
                        element = args[e.validatingTargetName] || args.element;
                    if (element && condition(element)) {
                        e.cancel = true
                    }
                }
            };
            Action.registerExecutor({
                designMode: {
                    validate: function(e) {
                        if (config().designMode) {
                            e.cancel = true
                        }
                    }
                },
                disabled: {
                    validate: createValidatorByTargetElement(function($target) {
                        return $target.is(".dx-state-disabled, .dx-state-disabled *")
                    })
                },
                readOnly: {
                    validate: createValidatorByTargetElement(function($target) {
                        return $target.is(".dx-state-readonly, .dx-state-readonly *")
                    })
                }
            });
            module.exports = Action
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************!*\
      !*** ./Scripts/color.js ***!
      \**************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var standardColorNames = {
                aliceblue: "f0f8ff",
                antiquewhite: "faebd7",
                aqua: "00ffff",
                aquamarine: "7fffd4",
                azure: "f0ffff",
                beige: "f5f5dc",
                bisque: "ffe4c4",
                black: "000000",
                blanchedalmond: "ffebcd",
                blue: "0000ff",
                blueviolet: "8a2be2",
                brown: "a52a2a",
                burlywood: "deb887",
                cadetblue: "5f9ea0",
                chartreuse: "7fff00",
                chocolate: "d2691e",
                coral: "ff7f50",
                cornflowerblue: "6495ed",
                cornsilk: "fff8dc",
                crimson: "dc143c",
                cyan: "00ffff",
                darkblue: "00008b",
                darkcyan: "008b8b",
                darkgoldenrod: "b8860b",
                darkgray: "a9a9a9",
                darkgreen: "006400",
                darkkhaki: "bdb76b",
                darkmagenta: "8b008b",
                darkolivegreen: "556b2f",
                darkorange: "ff8c00",
                darkorchid: "9932cc",
                darkred: "8b0000",
                darksalmon: "e9967a",
                darkseagreen: "8fbc8f",
                darkslateblue: "483d8b",
                darkslategray: "2f4f4f",
                darkturquoise: "00ced1",
                darkviolet: "9400d3",
                deeppink: "ff1493",
                deepskyblue: "00bfff",
                dimgray: "696969",
                dodgerblue: "1e90ff",
                feldspar: "d19275",
                firebrick: "b22222",
                floralwhite: "fffaf0",
                forestgreen: "228b22",
                fuchsia: "ff00ff",
                gainsboro: "dcdcdc",
                ghostwhite: "f8f8ff",
                gold: "ffd700",
                goldenrod: "daa520",
                gray: "808080",
                green: "008000",
                greenyellow: "adff2f",
                honeydew: "f0fff0",
                hotpink: "ff69b4",
                indianred: "cd5c5c",
                indigo: "4b0082",
                ivory: "fffff0",
                khaki: "f0e68c",
                lavender: "e6e6fa",
                lavenderblush: "fff0f5",
                lawngreen: "7cfc00",
                lemonchiffon: "fffacd",
                lightblue: "add8e6",
                lightcoral: "f08080",
                lightcyan: "e0ffff",
                lightgoldenrodyellow: "fafad2",
                lightgrey: "d3d3d3",
                lightgreen: "90ee90",
                lightpink: "ffb6c1",
                lightsalmon: "ffa07a",
                lightseagreen: "20b2aa",
                lightskyblue: "87cefa",
                lightslateblue: "8470ff",
                lightslategray: "778899",
                lightsteelblue: "b0c4de",
                lightyellow: "ffffe0",
                lime: "00ff00",
                limegreen: "32cd32",
                linen: "faf0e6",
                magenta: "ff00ff",
                maroon: "800000",
                mediumaquamarine: "66cdaa",
                mediumblue: "0000cd",
                mediumorchid: "ba55d3",
                mediumpurple: "9370d8",
                mediumseagreen: "3cb371",
                mediumslateblue: "7b68ee",
                mediumspringgreen: "00fa9a",
                mediumturquoise: "48d1cc",
                mediumvioletred: "c71585",
                midnightblue: "191970",
                mintcream: "f5fffa",
                mistyrose: "ffe4e1",
                moccasin: "ffe4b5",
                navajowhite: "ffdead",
                navy: "000080",
                oldlace: "fdf5e6",
                olive: "808000",
                olivedrab: "6b8e23",
                orange: "ffa500",
                orangered: "ff4500",
                orchid: "da70d6",
                palegoldenrod: "eee8aa",
                palegreen: "98fb98",
                paleturquoise: "afeeee",
                palevioletred: "d87093",
                papayawhip: "ffefd5",
                peachpuff: "ffdab9",
                peru: "cd853f",
                pink: "ffc0cb",
                plum: "dda0dd",
                powderblue: "b0e0e6",
                purple: "800080",
                rebeccapurple: "663399",
                red: "ff0000",
                rosybrown: "bc8f8f",
                royalblue: "4169e1",
                saddlebrown: "8b4513",
                salmon: "fa8072",
                sandybrown: "f4a460",
                seagreen: "2e8b57",
                seashell: "fff5ee",
                sienna: "a0522d",
                silver: "c0c0c0",
                skyblue: "87ceeb",
                slateblue: "6a5acd",
                slategray: "708090",
                snow: "fffafa",
                springgreen: "00ff7f",
                steelblue: "4682b4",
                tan: "d2b48c",
                teal: "008080",
                thistle: "d8bfd8",
                tomato: "ff6347",
                turquoise: "40e0d0",
                violet: "ee82ee",
                violetred: "d02090",
                wheat: "f5deb3",
                white: "ffffff",
                whitesmoke: "f5f5f5",
                yellow: "ffff00",
                yellowgreen: "9acd32"
            };
            var standardColorTypes = [{
                re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                process: function(colorString) {
                    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
                }
            }, {
                re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
                process: function(colorString) {
                    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
                }
            }, {
                re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
                process: function(colorString) {
                    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
                }
            }, {
                re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
                process: function(colorString) {
                    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
                }
            }, {
                re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                process: function(colorString) {
                    var h = parseInt(colorString[1], 10),
                        s = parseInt(colorString[2], 10),
                        v = parseInt(colorString[3], 10),
                        rgb = hsvToRgb(h, s, v);
                    return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
                }
            }, {
                re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                process: function(colorString) {
                    var h = parseInt(colorString[1], 10),
                        s = parseInt(colorString[2], 10),
                        l = parseInt(colorString[3], 10),
                        rgb = hslToRgb(h, s, l);
                    return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
                }
            }];

            function Color(value) {
                this.baseColor = value;
                var color;
                if (value) {
                    color = String(value).toLowerCase().replace(/ /g, "");
                    color = standardColorNames[color] ? "#" + standardColorNames[color] : color;
                    color = parseColor(color)
                }
                if (!color) {
                    this.colorIsInvalid = true
                }
                color = color || {};
                this.r = normalize(color[0]);
                this.g = normalize(color[1]);
                this.b = normalize(color[2]);
                this.a = normalize(color[3], 1, 1);
                if (color[4]) {
                    this.hsv = {
                        h: color[4][0],
                        s: color[4][1],
                        v: color[4][2]
                    }
                } else {
                    this.hsv = toHsvFromRgb(this.r, this.g, this.b)
                }
                if (color[5]) {
                    this.hsl = {
                        h: color[5][0],
                        s: color[5][1],
                        l: color[5][2]
                    }
                } else {
                    this.hsl = toHslFromRgb(this.r, this.g, this.b)
                }
            }

            function parseColor(color) {
                if ("transparent" === color) {
                    return [0, 0, 0, 0]
                }
                var str, i = 0,
                    ii = standardColorTypes.length;
                for (; i < ii; ++i) {
                    str = standardColorTypes[i].re.exec(color);
                    if (str) {
                        return standardColorTypes[i].process(str)
                    }
                }
                return null
            }

            function normalize(colorComponent, def, max) {
                def = def || 0;
                max = max || 255;
                return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
            }

            function toHexFromRgb(r, g, b) {
                return "#" + (16777216 | r << 16 | g << 8 | b).toString(16).slice(1)
            }

            function toHsvFromRgb(r, g, b) {
                var H, S, V, max = Math.max(r, g, b),
                    min = Math.min(r, g, b),
                    delta = max - min;
                V = max;
                S = 0 === max ? 0 : 1 - min / max;
                if (max === min) {
                    H = 0
                } else {
                    switch (max) {
                        case r:
                            H = 60 * ((g - b) / delta);
                            if (g < b) {
                                H += 360
                            }
                            break;
                        case g:
                            H = 60 * ((b - r) / delta) + 120;
                            break;
                        case b:
                            H = 60 * ((r - g) / delta) + 240
                    }
                }
                S *= 100;
                V *= 100 / 255;
                return {
                    h: Math.round(H),
                    s: Math.round(S),
                    v: Math.round(V)
                }
            }

            function hsvToRgb(h, s, v) {
                var Vdec, Vinc, Vmin, Hi, a, r, g, b;
                Hi = Math.floor(h % 360 / 60);
                Vmin = (100 - s) * v / 100;
                a = (v - Vmin) * (h % 60 / 60);
                Vinc = Vmin + a;
                Vdec = v - a;
                switch (Hi) {
                    case 0:
                        r = v;
                        g = Vinc;
                        b = Vmin;
                        break;
                    case 1:
                        r = Vdec;
                        g = v;
                        b = Vmin;
                        break;
                    case 2:
                        r = Vmin;
                        g = v;
                        b = Vinc;
                        break;
                    case 3:
                        r = Vmin;
                        g = Vdec;
                        b = v;
                        break;
                    case 4:
                        r = Vinc;
                        g = Vmin;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = Vmin;
                        b = Vdec
                }
                return [Math.round(2.55 * r), Math.round(2.55 * g), Math.round(2.55 * b)]
            }

            function calculateHue(r, g, b, delta) {
                var max = Math.max(r, g, b);
                switch (max) {
                    case r:
                        return (g - b) / delta + (g < b ? 6 : 0);
                    case g:
                        return (b - r) / delta + 2;
                    case b:
                        return (r - g) / delta + 4
                }
            }

            function toHslFromRgb(r, g, b) {
                r = convertTo01Bounds(r, 255);
                g = convertTo01Bounds(g, 255);
                b = convertTo01Bounds(b, 255);
                var h, s, max = Math.max(r, g, b),
                    min = Math.min(r, g, b),
                    maxMinSum = max + min,
                    l = maxMinSum / 2;
                if (max === min) {
                    h = s = 0
                } else {
                    var delta = max - min;
                    if (l > .5) {
                        s = delta / (2 - maxMinSum)
                    } else {
                        s = delta / maxMinSum
                    }
                    h = calculateHue(r, g, b, delta);
                    h /= 6
                }
                return {
                    h: _round(360 * h),
                    s: _round(100 * s),
                    l: _round(100 * l)
                }
            }

            function makeTc(colorPart, h) {
                var Tc = h;
                if ("r" === colorPart) {
                    Tc = h + 1 / 3
                }
                if ("b" === colorPart) {
                    Tc = h - 1 / 3
                }
                return Tc
            }

            function modifyTc(Tc) {
                if (Tc < 0) {
                    Tc += 1
                }
                if (Tc > 1) {
                    Tc -= 1
                }
                return Tc
            }

            function hueToRgb(p, q, Tc) {
                Tc = modifyTc(Tc);
                if (Tc < 1 / 6) {
                    return p + 6 * (q - p) * Tc
                }
                if (Tc < .5) {
                    return q
                }
                if (Tc < 2 / 3) {
                    return p + (q - p) * (2 / 3 - Tc) * 6
                }
                return p
            }

            function hslToRgb(h, s, l) {
                var r, g, b;
                h = convertTo01Bounds(h, 360), s = convertTo01Bounds(s, 100), l = convertTo01Bounds(l, 100);
                if (0 === s) {
                    r = g = b = l
                } else {
                    var q = l < .5 ? l * (1 + s) : l + s - l * s,
                        p = 2 * l - q;
                    r = hueToRgb(p, q, makeTc("r", h));
                    g = hueToRgb(p, q, makeTc("g", h));
                    b = hueToRgb(p, q, makeTc("b", h))
                }
                return [_round(255 * r), _round(255 * g), _round(255 * b)]
            }

            function convertTo01Bounds(n, max) {
                n = Math.min(max, Math.max(0, parseFloat(n)));
                if (Math.abs(n - max) < 1e-6) {
                    return 1
                }
                return n % max / parseFloat(max)
            }

            function isIntegerBtwMinAndMax(number, min, max) {
                min = min || 0;
                max = max || 255;
                if (number % 1 !== 0 || number < min || number > max || "number" !== typeof number || isNaN(number)) {
                    return false
                }
                return true
            }
            var _round = Math.round;
            Color.prototype = {
                constructor: Color,
                highlight: function(step) {
                    step = step || 10;
                    return this.alter(step).toHex()
                },
                darken: function(step) {
                    step = step || 10;
                    return this.alter(-step).toHex()
                },
                alter: function(step) {
                    var result = new Color;
                    result.r = normalize(this.r + step);
                    result.g = normalize(this.g + step);
                    result.b = normalize(this.b + step);
                    return result
                },
                blend: function(blendColor, opacity) {
                    var other = blendColor instanceof Color ? blendColor : new Color(blendColor),
                        result = new Color;
                    result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
                    result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
                    result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
                    return result
                },
                toHex: function() {
                    return toHexFromRgb(this.r, this.g, this.b)
                },
                getPureColor: function() {
                    var rgb = hsvToRgb(this.hsv.h, 100, 100);
                    return new Color("rgb(" + rgb.join(",") + ")")
                },
                isValidHex: function(hex) {
                    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
                },
                isValidRGB: function(r, g, b) {
                    if (!isIntegerBtwMinAndMax(r) || !isIntegerBtwMinAndMax(g) || !isIntegerBtwMinAndMax(b)) {
                        return false
                    }
                    return true
                },
                isValidAlpha: function(a) {
                    if (isNaN(a) || a < 0 || a > 1 || "number" !== typeof a) {
                        return false
                    }
                    return true
                },
                colorIsInvalid: false
            };
            module.exports = Color
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/core/utils/version.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var compare = function(x, y, maxLevel) {
                function normalizeArg(value) {
                    if ("string" === typeof value) {
                        return value.split(".")
                    }
                    if ("number" === typeof value) {
                        return [value]
                    }
                    return value
                }
                x = normalizeArg(x);
                y = normalizeArg(y);
                var length = Math.max(x.length, y.length);
                if (isFinite(maxLevel)) {
                    length = Math.min(length, maxLevel)
                }
                for (var i = 0; i < length; i++) {
                    var xItem = parseInt(x[i] || 0, 10),
                        yItem = parseInt(y[i] || 0, 10);
                    if (xItem < yItem) {
                        return -1
                    }
                    if (xItem > yItem) {
                        return 1
                    }
                }
                return 0
            };
            exports.compare = compare
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/utils/window.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var resizeCallbacks = function() {
                var prevSize, callbacks = $.Callbacks(),
                    jqWindow = $(window),
                    resizeEventHandlerAttached = false,
                    originalCallbacksAdd = callbacks.add,
                    originalCallbacksRemove = callbacks.remove;
                var formatSize = function() {
                    return [jqWindow.width(), jqWindow.height()].join()
                };
                var handleResize = function() {
                    var now = formatSize();
                    if (now === prevSize) {
                        return
                    }
                    prevSize = now;
                    setTimeout(callbacks.fire)
                };
                prevSize = formatSize();
                callbacks.add = function() {
                    var result = originalCallbacksAdd.apply(callbacks, arguments);
                    if (!resizeEventHandlerAttached && callbacks.has()) {
                        jqWindow.on("resize", handleResize);
                        resizeEventHandlerAttached = true
                    }
                    return result
                };
                callbacks.remove = function() {
                    var result = originalCallbacksRemove.apply(callbacks, arguments);
                    if (!callbacks.has() && resizeEventHandlerAttached) {
                        jqWindow.off("resize", handleResize);
                        resizeEventHandlerAttached = false
                    }
                    return result
                };
                return callbacks
            }();
            var defaultScreenFactorFunc = function(width) {
                if (width < 768) {
                    return "xs"
                } else {
                    if (width < 992) {
                        return "sm"
                    } else {
                        if (width < 1200) {
                            return "md"
                        } else {
                            return "lg"
                        }
                    }
                }
            };
            var getCurrentScreenFactor = function(screenFactorCallback) {
                var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
                return screenFactorFunc($(window).width())
            };
            exports.resizeCallbacks = resizeCallbacks;
            exports.defaultScreenFactorFunc = defaultScreenFactorFunc;
            exports.getCurrentScreenFactor = getCurrentScreenFactor
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/array_store.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Guid = __webpack_require__( /*! ../core/guid */ 33),
                objectUtils = __webpack_require__( /*! ../core/utils/object */ 30),
                keysEqual = __webpack_require__( /*! ./utils */ 28).keysEqual,
                Query = __webpack_require__( /*! ./query */ 34),
                errors = __webpack_require__( /*! ./errors */ 25).errors,
                Store = __webpack_require__( /*! ./abstract_store */ 50);
            var hasKey = function(target, keyOrKeys) {
                var key, keys = $.makeArray(keyOrKeys);
                while (keys.length) {
                    key = keys.shift();
                    if (key in target) {
                        return true
                    }
                }
                return false
            };
            var trivialPromise = function() {
                var d = $.Deferred();
                return d.resolve.apply(d, arguments).promise()
            };
            var rejectedPromise = function() {
                var d = $.Deferred();
                return d.reject.apply(d, arguments).promise()
            };
            var ArrayStore = Store.inherit({
                ctor: function(options) {
                    if ($.isArray(options)) {
                        options = {
                            data: options
                        }
                    } else {
                        options = options || {}
                    }
                    this.callBase(options);
                    var initialArray = options.data;
                    if (initialArray && !$.isArray(initialArray)) {
                        throw errors.Error("E4006")
                    }
                    this._array = initialArray || []
                },
                createQuery: function() {
                    return Query(this._array, {
                        errorHandler: this._errorHandler
                    })
                },
                _byKeyImpl: function(key) {
                    var index = this._indexByKey(key);
                    if (-1 === index) {
                        return rejectedPromise(errors.Error("E4009"))
                    }
                    return trivialPromise(this._array[index])
                },
                _insertImpl: function(values) {
                    var keyValue, obj, keyExpr = this.key();
                    if ($.isPlainObject(values)) {
                        obj = $.extend({}, values)
                    } else {
                        obj = values
                    }
                    if (keyExpr) {
                        keyValue = this.keyOf(obj);
                        if (void 0 === keyValue || "object" === typeof keyValue && $.isEmptyObject(keyValue)) {
                            if ($.isArray(keyExpr)) {
                                throw errors.Error("E4007")
                            }
                            keyValue = obj[keyExpr] = String(new Guid)
                        } else {
                            if (void 0 !== this._array[this._indexByKey(keyValue)]) {
                                return rejectedPromise(errors.Error("E4008"))
                            }
                        }
                    } else {
                        keyValue = obj
                    }
                    this._array.push(obj);
                    return trivialPromise(values, keyValue)
                },
                _updateImpl: function(key, values) {
                    var index, target, keyExpr = this.key();
                    if (keyExpr) {
                        if (hasKey(values, keyExpr) && !keysEqual(keyExpr, key, this.keyOf(values))) {
                            return rejectedPromise(errors.Error("E4017"))
                        }
                        index = this._indexByKey(key);
                        if (index < 0) {
                            return rejectedPromise(errors.Error("E4009"))
                        }
                        target = this._array[index]
                    } else {
                        target = key
                    }
                    objectUtils.deepExtendArraySafe(target, values);
                    return trivialPromise(key, values)
                },
                _removeImpl: function(key) {
                    var index = this._indexByKey(key);
                    if (index > -1) {
                        this._array.splice(index, 1)
                    }
                    return trivialPromise(key)
                },
                _indexByKey: function(key) {
                    for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++) {
                        if (keysEqual(this.key(), this.keyOf(this._array[i]), key)) {
                            return i
                        }
                    }
                    return -1
                },
                clear: function() {
                    this.fireEvent("modifying");
                    this._array = [];
                    this.fireEvent("modified")
                }
            }, "array");
            module.exports = ArrayStore
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/framework/view_cache.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                EventsMixin = __webpack_require__( /*! ../core/events_mixin */ 32);
            var ViewCache = Class.inherit({
                ctor: function() {
                    this._cache = {}
                },
                setView: function(key, viewInfo) {
                    this._cache[key] = viewInfo
                },
                getView: function(key) {
                    return this._cache[key]
                },
                removeView: function(key) {
                    var result = this._cache[key];
                    if (result) {
                        delete this._cache[key];
                        this.fireEvent("viewRemoved", [{
                            viewInfo: result
                        }])
                    }
                    return result
                },
                clear: function() {
                    var that = this;
                    $.each(this._cache, function(key) {
                        that.removeView(key)
                    })
                },
                hasView: function(key) {
                    return key in this._cache
                }
            }).include(EventsMixin);
            var NullViewCache = ViewCache.inherit({
                setView: function(key, viewInfo) {
                    this.callBase(key, viewInfo);
                    this.removeView(key)
                }
            });
            var ConditionalViewCacheDecorator = Class.inherit({
                ctor: function(options) {
                    this._filter = options.filter;
                    this._viewCache = options.viewCache;
                    this.viewRemoved = this._viewCache.viewRemoved;
                    this._events = this._viewCache._events
                },
                setView: function(key, viewInfo) {
                    this._viewCache.setView(key, viewInfo);
                    if (!this._filter(key, viewInfo)) {
                        this._viewCache.removeView(key)
                    }
                },
                getView: function(key) {
                    return this._viewCache.getView(key)
                },
                removeView: function(key) {
                    return this._viewCache.removeView(key)
                },
                clear: function() {
                    return this._viewCache.clear()
                },
                hasView: function(key) {
                    return this._viewCache.hasView(key)
                }
            }).include(EventsMixin);
            var DEFAULT_VIEW_CACHE_CAPACITY = 5;
            var CapacityViewCacheDecorator = Class.inherit({
                ctor: function(options) {
                    this._keys = [];
                    this._size = options.size || DEFAULT_VIEW_CACHE_CAPACITY;
                    this._viewCache = options.viewCache;
                    this.viewRemoved = this._viewCache.viewRemoved;
                    this._events = this._viewCache._events
                },
                setView: function(key, viewInfo) {
                    if (!this.hasView(key)) {
                        if (this._keys.length === this._size) {
                            this.removeView(this._keys[0])
                        }
                        this._keys.push(key)
                    }
                    this._viewCache.setView(key, viewInfo)
                },
                getView: function(key) {
                    var index = $.inArray(key, this._keys);
                    if (index < 0) {
                        return null
                    }
                    this._keys.push(key);
                    this._keys.splice(index, 1);
                    return this._viewCache.getView(key)
                },
                removeView: function(key) {
                    var index = $.inArray(key, this._keys);
                    if (index > -1) {
                        this._keys.splice(index, 1)
                    }
                    return this._viewCache.removeView(key)
                },
                clear: function() {
                    this._keys = [];
                    return this._viewCache.clear()
                },
                hasView: function(key) {
                    return this._viewCache.hasView(key)
                }
            }).include(EventsMixin);
            var HistoryDependentViewCacheDecorator = Class.inherit({
                ctor: function(options) {
                    this._viewCache = options.viewCache || new ViewCache;
                    this._navigationManager = options.navigationManager;
                    this._navigationManager.on("itemRemoved", $.proxy(this._onNavigationItemRemoved, this));
                    this.viewRemoved = this._viewCache.viewRemoved;
                    this._events = this._viewCache._events
                },
                _onNavigationItemRemoved: function(item) {
                    this.removeView(item.key)
                },
                setView: function(key, viewInfo) {
                    this._viewCache.setView(key, viewInfo)
                },
                getView: function(key) {
                    return this._viewCache.getView(key)
                },
                removeView: function(key) {
                    return this._viewCache.removeView(key)
                },
                clear: function() {
                    return this._viewCache.clear()
                },
                hasView: function(key) {
                    return this._viewCache.hasView(key)
                }
            }).include(EventsMixin);
            module.exports = ViewCache;
            module.exports.NullViewCache = NullViewCache;
            module.exports.ConditionalViewCacheDecorator = ConditionalViewCacheDecorator;
            module.exports.CapacityViewCacheDecorator = CapacityViewCacheDecorator;
            module.exports.HistoryDependentViewCacheDecorator = HistoryDependentViewCacheDecorator
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!****************************************************!*\
      !*** ./Scripts/events/core/emitter_registrator.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                registerEvent = __webpack_require__( /*! ./event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ../utils */ 4),
                pointerEvents = __webpack_require__( /*! ../pointer */ 13),
                wheelEvent = __webpack_require__( /*! ./wheel */ 78);
            var MANAGER_EVENT = "dxEventManager",
                EMITTER_DATA = "dxEmitter";
            var EventManager = Class.inherit({
                ctor: function() {
                    this._attachHandlers();
                    this.reset();
                    this._proxiedCancelHandler = $.proxy(this._cancelHandler, this);
                    this._proxiedAcceptHandler = $.proxy(this._acceptHandler, this)
                },
                _attachHandlers: function() {
                    $(document).on(eventUtils.addNamespace(pointerEvents.down, MANAGER_EVENT), $.proxy(this._pointerDownHandler, this)).on(eventUtils.addNamespace(pointerEvents.move, MANAGER_EVENT), $.proxy(this._pointerMoveHandler, this)).on(eventUtils.addNamespace([pointerEvents.up, pointerEvents.cancel].join(" "), MANAGER_EVENT), $.proxy(this._pointerUpHandler, this)).on(eventUtils.addNamespace(wheelEvent.name, MANAGER_EVENT), $.proxy(this._mouseWheelHandler, this))
                },
                _eachEmitter: function(callback) {
                    var activeEmitters = this._activeEmitters || [];
                    var i = 0;
                    while (activeEmitters.length > i) {
                        var emitter = activeEmitters[i];
                        if (false === callback(emitter)) {
                            break
                        }
                        if (activeEmitters[i] === emitter) {
                            i++
                        }
                    }
                },
                _applyToEmitters: function(method, arg) {
                    this._eachEmitter(function(emitter) {
                        emitter[method].call(emitter, arg)
                    })
                },
                reset: function() {
                    this._eachEmitter(this._proxiedCancelHandler);
                    this._activeEmitters = []
                },
                resetEmitter: function(emitter) {
                    this._proxiedCancelHandler(emitter)
                },
                _pointerDownHandler: function(e) {
                    if (eventUtils.isMouseEvent(e) && e.which > 1) {
                        return
                    }
                    this._updateEmitters(e)
                },
                _updateEmitters: function(e) {
                    if (!this._isSetChanged(e)) {
                        return
                    }
                    this._cleanEmitters(e);
                    this._fetchEmitters(e)
                },
                _isSetChanged: function(e) {
                    var currentSet = this._closestEmitter(e);
                    var previousSet = this._emittersSet || [];
                    var setChanged = currentSet.length !== previousSet.length;
                    $.each(currentSet, function(index, emitter) {
                        setChanged = setChanged || previousSet[index] !== emitter;
                        return !setChanged
                    });
                    this._emittersSet = currentSet;
                    return setChanged
                },
                _closestEmitter: function(e) {
                    var that = this,
                        result = [],
                        $element = $(e.target);

                    function handleEmitter(_, emitter) {
                        if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                            emitter.addCancelCallback(that._proxiedCancelHandler);
                            emitter.addAcceptCallback(that._proxiedAcceptHandler);
                            result.push(emitter)
                        }
                    }
                    while ($element.length) {
                        var emitters = $.data($element.get(0), EMITTER_DATA) || [];
                        $.each(emitters, handleEmitter);
                        $element = $element.parent()
                    }
                    return result
                },
                _acceptHandler: function(acceptedEmitter, e) {
                    var that = this;
                    this._eachEmitter(function(emitter) {
                        if (emitter !== acceptedEmitter) {
                            that._cancelEmitter(emitter, e)
                        }
                    })
                },
                _cancelHandler: function(canceledEmitter, e) {
                    this._cancelEmitter(canceledEmitter, e)
                },
                _cancelEmitter: function(emitter, e) {
                    var activeEmitters = this._activeEmitters;
                    if (e) {
                        emitter.cancel(e)
                    } else {
                        emitter.reset()
                    }
                    emitter.removeCancelCallback();
                    emitter.removeAcceptCallback();
                    var emitterIndex = $.inArray(emitter, activeEmitters);
                    if (emitterIndex > -1) {
                        activeEmitters.splice(emitterIndex, 1)
                    }
                },
                _cleanEmitters: function(e) {
                    this._applyToEmitters("end", e);
                    this.reset(e)
                },
                _fetchEmitters: function(e) {
                    this._activeEmitters = this._emittersSet.slice();
                    this._applyToEmitters("start", e)
                },
                _pointerMoveHandler: function(e) {
                    this._applyToEmitters("move", e)
                },
                _pointerUpHandler: function(e) {
                    this._updateEmitters(e)
                },
                _mouseWheelHandler: function(e) {
                    if (!this._allowInterruptionByMousewheel()) {
                        return
                    }
                    e.pointers = [null];
                    this._pointerDownHandler(e);
                    this._adjustWheelEvent(e);
                    this._pointerMoveHandler(e);
                    e.pointers = [];
                    this._pointerUpHandler(e)
                },
                _allowInterruptionByMousewheel: function() {
                    var allowInterruption = true;
                    this._eachEmitter(function(emitter) {
                        allowInterruption = emitter.allowInterruptionByMousewheel() && allowInterruption;
                        return allowInterruption
                    });
                    return allowInterruption
                },
                _adjustWheelEvent: function(e) {
                    var closestGestureEmitter = null;
                    this._eachEmitter(function(emitter) {
                        if (!emitter.gesture) {
                            return
                        }
                        var direction = emitter.getDirection(e);
                        if ("horizontal" !== direction && !e.shiftKey || "vertical" !== direction && e.shiftKey) {
                            closestGestureEmitter = emitter;
                            return false
                        }
                    });
                    if (!closestGestureEmitter) {
                        return
                    }
                    var direction = closestGestureEmitter.getDirection(e),
                        verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction,
                        prop = verticalGestureDirection ? "pageY" : "pageX";
                    e[prop] += e.delta
                },
                isActive: function(element) {
                    var result = false;
                    this._eachEmitter(function(emitter) {
                        result = result || emitter.getElement().is(element)
                    });
                    return result
                }
            });
            var eventManager = new EventManager;
            var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
            var registerEmitter = function(emitterConfig) {
                var emitterClass = emitterConfig.emitter,
                    emitterName = emitterConfig.events[0],
                    emitterEvents = emitterConfig.events;
                $.each(emitterEvents, function(_, eventName) {
                    registerEvent(eventName, {
                        noBubble: !emitterConfig.bubble,
                        setup: function(element, data) {
                            var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA) || {},
                                emitters = $.data(element, EMITTER_DATA) || {},
                                emitter = emitters[emitterName] || new emitterClass(element);
                            subscriptions[eventName] = true;
                            emitters[emitterName] = emitter;
                            $.data(element, EMITTER_DATA, emitters);
                            $.data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions)
                        },
                        add: function(element, handleObj) {
                            var emitters = $.data(element, EMITTER_DATA),
                                emitter = emitters[emitterName];
                            emitter.configurate($.extend({
                                delegateSelector: handleObj.selector
                            }, handleObj.data), handleObj.type)
                        },
                        teardown: function(element) {
                            var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA),
                                emitters = $.data(element, EMITTER_DATA),
                                emitter = emitters[emitterName];
                            delete subscriptions[eventName];
                            var disposeEmitter = true;
                            $.each(emitterEvents, function(_, eventName) {
                                disposeEmitter = disposeEmitter && !subscriptions[eventName];
                                return disposeEmitter
                            });
                            if (disposeEmitter) {
                                if (eventManager.isActive(element)) {
                                    eventManager.resetEmitter(emitter)
                                }
                                emitter && emitter.dispose();
                                delete emitters[emitterName]
                            }
                        }
                    })
                })
            };
            module.exports = registerEmitter
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************!*\
      !*** ./Scripts/events/drag.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                wrapToArray = __webpack_require__( /*! ../core/utils/array */ 41).wrapToArray,
                registerEvent = __webpack_require__( /*! ./core/event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                GestureEmitter = __webpack_require__( /*! ./gesture/emitter.gesture */ 120),
                registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 61);
            var DRAG_START_EVENT = "dxdragstart",
                DRAG_EVENT = "dxdrag",
                DRAG_END_EVENT = "dxdragend",
                DRAG_ENTER_EVENT = "dxdragenter",
                DRAG_LEAVE_EVENT = "dxdragleave",
                DROP_EVENT = "dxdrop";
            var knownDropTargets = [],
                knownDropTargetSelectors = [],
                knownDropTargetConfigs = [];
            var dropTargetRegistration = {
                setup: function(element, data) {
                    var knownDropTarget = -1 !== $.inArray(element, knownDropTargets);
                    if (!knownDropTarget) {
                        knownDropTargets.push(element);
                        knownDropTargetSelectors.push([]);
                        knownDropTargetConfigs.push(data || {})
                    }
                },
                add: function(element, handleObj) {
                    var index = $.inArray(element, knownDropTargets);
                    var selector = handleObj.selector;
                    if (-1 === $.inArray(selector, knownDropTargetSelectors[index])) {
                        knownDropTargetSelectors[index].push(selector)
                    }
                },
                teardown: function(element, data) {
                    var elementEvents = $._data(element, "events"),
                        handlersCount = 0;
                    $.each([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT], function(_, eventName) {
                        var eventHandlers = elementEvents[eventName];
                        if (eventHandlers) {
                            handlersCount += eventHandlers.length
                        }
                    });
                    if (!handlersCount) {
                        var index = $.inArray(element, knownDropTargets);
                        knownDropTargets.splice(index, 1);
                        knownDropTargetSelectors.splice(index, 1);
                        knownDropTargetConfigs.splice(index, 1)
                    }
                }
            };
            registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
            registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
            registerEvent(DROP_EVENT, dropTargetRegistration);
            var getItemDelegatedTargets = function($element) {
                var dropTargetIndex = $.inArray($element.get(0), knownDropTargets),
                    dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex];
                var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
                if (-1 !== $.inArray(void 0, dropTargetSelectors)) {
                    $delegatedTargets = $delegatedTargets.addBack()
                }
                return $delegatedTargets
            };
            var getItemConfig = function($element) {
                var dropTargetIndex = $.inArray($element.get(0), knownDropTargets);
                return knownDropTargetConfigs[dropTargetIndex]
            };
            var getItemPosition = function(dropTargetConfig, $element) {
                if (dropTargetConfig.itemPositionFunc) {
                    return dropTargetConfig.itemPositionFunc($element)
                } else {
                    return $element.offset()
                }
            };
            var getItemSize = function(dropTargetConfig, $element) {
                if (dropTargetConfig.itemSizeFunc) {
                    return dropTargetConfig.itemSizeFunc($element)
                }
                return {
                    width: $element.width(),
                    height: $element.height()
                }
            };
            var DragEmitter = GestureEmitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "both"
                },
                _init: function(e) {
                    this._initEvent = e
                },
                _start: function(e) {
                    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
                    this._maxLeftOffset = e.maxLeftOffset;
                    this._maxRightOffset = e.maxRightOffset;
                    this._maxTopOffset = e.maxTopOffset;
                    this._maxBottomOffset = e.maxBottomOffset;
                    var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
                    this._dropTargets = $.map(dropTargets, function(element) {
                        return $(element).get(0)
                    })
                },
                _move: function(e) {
                    var eventData = eventUtils.eventData(e),
                        dragOffset = this._calculateOffset(eventData);
                    this._fireEvent(DRAG_EVENT, e, {
                        offset: dragOffset
                    });
                    this._processDropTargets(e, dragOffset);
                    e.preventDefault()
                },
                _calculateOffset: function(eventData) {
                    return {
                        x: this._calculateXOffset(eventData),
                        y: this._calculateYOffset(eventData)
                    }
                },
                _calculateXOffset: function(eventData) {
                    if ("vertical" !== this.direction) {
                        var offset = eventData.x - this._startEventData.x;
                        return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
                    }
                    return 0
                },
                _calculateYOffset: function(eventData) {
                    if ("horizontal" !== this.direction) {
                        var offset = eventData.y - this._startEventData.y;
                        return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
                    }
                    return 0
                },
                _fitOffset: function(offset, minOffset, maxOffset) {
                    if (null != minOffset) {
                        offset = Math.max(offset, -minOffset)
                    }
                    if (null != maxOffset) {
                        offset = Math.min(offset, maxOffset)
                    }
                    return offset
                },
                _processDropTargets: function(e, dragOffset) {
                    var target = this._findDropTarget(e),
                        sameTarget = target === this._currentDropTarget;
                    if (!sameTarget) {
                        this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
                        this._currentDropTarget = target;
                        this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
                    }
                },
                _fireDropTargetEvent: function(event, eventName) {
                    if (!this._currentDropTarget) {
                        return
                    }
                    var eventData = {
                        type: eventName,
                        originalEvent: event,
                        draggingElement: this._$element.get(0),
                        target: this._currentDropTarget
                    };
                    eventUtils.fireEvent(eventData)
                },
                _findDropTarget: function(e) {
                    var result, that = this;
                    $.each(knownDropTargets, function(_, target) {
                        if (!that._checkDropTargetActive(target)) {
                            return
                        }
                        var $target = $(target);
                        $.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
                            var $delegatedTarget = $(delegatedTarget);
                            if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, e)) {
                                result = delegatedTarget
                            }
                        })
                    });
                    return result
                },
                _checkDropTargetActive: function(target) {
                    var active = false;
                    $.each(this._dropTargets, function(_, activeTarget) {
                        active = active || activeTarget === target || $.contains(activeTarget, target);
                        return !active
                    });
                    return active
                },
                _checkDropTarget: function(config, $target, e) {
                    var isDraggingElement = $target.get(0) === this._$element.get(0);
                    if (isDraggingElement) {
                        return false
                    }
                    var targetPosition = getItemPosition(config, $target);
                    if (e.pageX < targetPosition.left) {
                        return false
                    }
                    if (e.pageY < targetPosition.top) {
                        return false
                    }
                    var targetSize = getItemSize(config, $target);
                    if (e.pageX > targetPosition.left + targetSize.width) {
                        return false
                    }
                    if (e.pageY > targetPosition.top + targetSize.height) {
                        return false
                    }
                    return $target
                },
                _end: function(e) {
                    var eventData = eventUtils.eventData(e);
                    this._fireEvent(DRAG_END_EVENT, e, {
                        offset: this._calculateOffset(eventData)
                    });
                    this._fireDropTargetEvent(e, DROP_EVENT);
                    delete this._currentDropTarget
                }
            });
            registerEmitter({
                emitter: DragEmitter,
                events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
            });
            exports.dropTargets = knownDropTargets;
            exports.move = DRAG_EVENT;
            exports.start = DRAG_START_EVENT;
            exports.end = DRAG_END_EVENT;
            exports.enter = DRAG_ENTER_EVENT;
            exports.leave = DRAG_LEAVE_EVENT;
            exports.drop = DROP_EVENT
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************!*\
      !*** ./Scripts/events/hold.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                Emitter = __webpack_require__( /*! ./core/emitter */ 81),
                registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 61),
                abs = Math.abs;
            var HOLD_EVENT_NAME = "dxhold",
                HOLD_TIMEOUT = 750,
                TOUCH_BOUNDARY = 5;
            var HoldEmitter = Emitter.inherit({
                start: function(e) {
                    this._startEventData = eventUtils.eventData(e);
                    this._startTimer(e)
                },
                _startTimer: function(e) {
                    var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
                    this._holdTimer = setTimeout($.proxy(function() {
                        this._requestAccept(e);
                        this._fireEvent(HOLD_EVENT_NAME, e, {
                            target: e.target
                        });
                        this._forgetAccept()
                    }, this), holdTimeout)
                },
                move: function(e) {
                    if (this._touchWasMoved(e)) {
                        this._cancel(e)
                    }
                },
                _touchWasMoved: function(e) {
                    var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
                },
                end: function() {
                    this._stopTimer()
                },
                _stopTimer: function() {
                    clearTimeout(this._holdTimer)
                },
                cancel: function() {
                    this._stopTimer()
                }
            });
            registerEmitter({
                emitter: HoldEmitter,
                bubble: true,
                events: [HOLD_EVENT_NAME]
            });
            module.exports = {
                name: HOLD_EVENT_NAME
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/ui/validation_engine.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                EventsMixin = __webpack_require__( /*! ../core/events_mixin */ 32),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                numberLocalization = __webpack_require__( /*! ../localization/number */ 38),
                messageLocalization = __webpack_require__( /*! ../localization/message */ 8);
            var rulesValidators = {
                required: {
                    validate: function(value, rule) {
                        if (!commonUtils.isDefined(value)) {
                            return false
                        }
                        if (false === value) {
                            return false
                        }
                        value = String(value);
                        if (rule.trim || !commonUtils.isDefined(rule.trim)) {
                            value = $.trim(value)
                        }
                        return "" !== value
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-required")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-required-formatted")(value)
                    }
                },
                numeric: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {})) {
                            return true
                        }
                        if (rule.useCultureSettings && commonUtils.isString(value)) {
                            return !isNaN(numberLocalization.parse(value))
                        } else {
                            return $.isNumeric(value)
                        }
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-numeric")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-numeric-formatted")(value)
                    }
                },
                range: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {})) {
                            return true
                        }
                        var validNumber = rulesValidators.numeric.validate(value, rule),
                            validValue = commonUtils.isDefined(value),
                            number = validNumber ? parseFloat(value) : validValue && value.valueOf(),
                            min = rule.min,
                            max = rule.max;
                        if (!(validNumber || commonUtils.isDate(value)) && !validValue) {
                            return false
                        }
                        if (commonUtils.isDefined(min)) {
                            if (commonUtils.isDefined(max)) {
                                return number >= min && number <= max
                            }
                            return number >= min
                        } else {
                            if (commonUtils.isDefined(max)) {
                                return number <= max
                            } else {
                                throw errors.Error("E0101")
                            }
                        }
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-range")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-range-formatted")(value)
                    }
                },
                stringLength: {
                    validate: function(value, rule) {
                        value = commonUtils.isDefined(value) ? String(value) : "";
                        if (rule.trim || !commonUtils.isDefined(rule.trim)) {
                            value = $.trim(value)
                        }
                        return rulesValidators.range.validate(value.length, $.extend({}, rule))
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-stringLength")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-stringLength-formatted")(value)
                    }
                },
                custom: {
                    validate: function(value, rule) {
                        return rule.validationCallback({
                            value: value,
                            validator: rule.validator,
                            rule: rule
                        })
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-custom")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-custom-formatted")(value)
                    }
                },
                compare: {
                    validate: function(value, rule) {
                        if (!rule.comparisonTarget) {
                            throw errors.Error("E0102")
                        }
                        $.extend(rule, {
                            reevaluate: true
                        });
                        var otherValue = rule.comparisonTarget(),
                            type = rule.comparisonType || "==";
                        switch (type) {
                            case "==":
                                return value == otherValue;
                            case "!=":
                                return value != otherValue;
                            case "===":
                                return value === otherValue;
                            case "!==":
                                return value !== otherValue;
                            case ">":
                                return value > otherValue;
                            case ">=":
                                return value >= otherValue;
                            case "<":
                                return value < otherValue;
                            case "<=":
                                return value <= otherValue
                        }
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-compare")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-compare-formatted")(value)
                    }
                },
                pattern: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {})) {
                            return true
                        }
                        var pattern = rule.pattern;
                        if (commonUtils.isString(pattern)) {
                            pattern = new RegExp(pattern)
                        }
                        return pattern.test(value)
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-pattern")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-pattern-formatted")(value)
                    }
                },
                email: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {})) {
                            return true
                        }
                        return rulesValidators.pattern.validate(value, $.extend({}, rule, {
                            pattern: /^[\d\w\._\-]+@([\d\w\._\-]+\.)+[\w]+$/i
                        }))
                    },
                    defaultMessage: function(value) {
                        return messageLocalization.getFormatter("validation-email")(value)
                    },
                    defaultFormattedMessage: function(value) {
                        return messageLocalization.getFormatter("validation-email-formatted")(value)
                    }
                }
            };
            var GroupConfig = Class.inherit({
                ctor: function(group) {
                    this.group = group;
                    this.validators = []
                },
                validate: function() {
                    var result = {
                        isValid: true,
                        brokenRules: [],
                        validators: []
                    };
                    $.each(this.validators, function(_, validator) {
                        var validatorResult = validator.validate();
                        result.isValid = result.isValid && validatorResult.isValid;
                        if (validatorResult.brokenRule) {
                            result.brokenRules.push(validatorResult.brokenRule)
                        }
                        result.validators.push(validator)
                    });
                    this.fireEvent("validated", [{
                        validators: result.validators,
                        brokenRules: result.brokenRules,
                        isValid: result.isValid
                    }]);
                    return result
                },
                reset: function() {
                    $.each(this.validators, function(_, validator) {
                        validator.reset()
                    })
                }
            }).include(EventsMixin);
            var ValidationEngine = {
                groups: [],
                getGroupConfig: function(group) {
                    var result = $.grep(this.groups, function(config) {
                        return config.group === group
                    });
                    if (result.length) {
                        return result[0]
                    }
                },
                initGroups: function() {
                    this.groups = [];
                    this.addGroup()
                },
                addGroup: function(group) {
                    var config = this.getGroupConfig(group);
                    if (!config) {
                        config = new GroupConfig(group);
                        this.groups.push(config)
                    }
                    return config
                },
                removeGroup: function(group) {
                    var config = this.getGroupConfig(group),
                        index = $.inArray(config, this.groups);
                    if (index > -1) {
                        this.groups.splice(index, 1)
                    }
                    return config
                },
                _setDefaultMessage: function(rule, validator, name) {
                    if (!commonUtils.isDefined(rule.message)) {
                        if (validator.defaultFormattedMessage && commonUtils.isDefined(name)) {
                            rule.message = validator.defaultFormattedMessage(name)
                        } else {
                            rule.message = validator.defaultMessage()
                        }
                    }
                },
                validate: function(value, rules, name) {
                    var result = {
                            name: name,
                            value: value,
                            brokenRule: null,
                            isValid: true,
                            validationRules: rules
                        },
                        that = this;
                    $.each(rules || [], function(_, rule) {
                        var ruleValidationResult, ruleValidator = rulesValidators[rule.type];
                        if (ruleValidator) {
                            if (commonUtils.isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {
                                if (!rule.isValid) {
                                    result.isValid = false;
                                    result.brokenRule = rule;
                                    return false
                                }
                                return true
                            }
                            rule.value = value;
                            ruleValidationResult = ruleValidator.validate(value, rule);
                            rule.isValid = ruleValidationResult;
                            if (!ruleValidationResult) {
                                result.isValid = false;
                                that._setDefaultMessage(rule, ruleValidator, name);
                                result.brokenRule = rule
                            }
                            if (!rule.isValid) {
                                return false
                            }
                        } else {
                            throw errors.Error("E0100")
                        }
                    });
                    return result
                },
                registerValidatorInGroup: function(group, validator) {
                    var groupConfig = ValidationEngine.addGroup(group);
                    if ($.inArray(validator, groupConfig.validators) < 0) {
                        groupConfig.validators.push(validator)
                    }
                },
                removeRegisteredValidator: function(group, validator) {
                    var config = ValidationEngine.getGroupConfig(group),
                        validatorsInGroup = config && config.validators;
                    var index = $.inArray(validator, validatorsInGroup);
                    if (index > -1) {
                        validatorsInGroup.splice(index, 1)
                    }
                },
                validateGroup: function(group) {
                    var groupConfig = ValidationEngine.getGroupConfig(group);
                    if (!groupConfig) {
                        throw errors.Error("E0110")
                    }
                    return groupConfig.validate()
                },
                resetGroup: function(group) {
                    var groupConfig = ValidationEngine.getGroupConfig(group);
                    if (!groupConfig) {
                        throw errors.Error("E0110")
                    }
                    return groupConfig.reset()
                }
            };
            ValidationEngine.initGroups();
            module.exports = ValidationEngine
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/animation/position.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                stringUtils = __webpack_require__( /*! ../core/utils/string */ 26),
                translator = __webpack_require__( /*! ./translator */ 15),
                support = __webpack_require__( /*! ../core/utils/support */ 18);
            var horzRe = /left|right/,
                vertRe = /top|bottom/,
                collisionRe = /fit|flip|none/;
            var normalizeAlign = function(raw) {
                var result = {
                    h: "center",
                    v: "center"
                };
                var pair = commonUtils.splitPair(raw);
                if (pair) {
                    $.each(pair, function() {
                        var w = String(this).toLowerCase();
                        if (horzRe.test(w)) {
                            result.h = w
                        } else {
                            if (vertRe.test(w)) {
                                result.v = w
                            }
                        }
                    })
                }
                return result
            };
            var normalizeOffset = function(raw) {
                return stringUtils.pairToObject(raw)
            };
            var normalizeCollision = function(raw) {
                var pair = commonUtils.splitPair(raw),
                    h = String(pair && pair[0]).toLowerCase(),
                    v = String(pair && pair[1]).toLowerCase();
                if (!collisionRe.test(h)) {
                    h = "none"
                }
                if (!collisionRe.test(v)) {
                    v = h
                }
                return {
                    h: h,
                    v: v
                }
            };
            var getAlignFactor = function(align) {
                switch (align) {
                    case "center":
                        return .5;
                    case "right":
                    case "bottom":
                        return 1;
                    default:
                        return 0
                }
            };
            var inverseAlign = function(align) {
                switch (align) {
                    case "left":
                        return "right";
                    case "right":
                        return "left";
                    case "top":
                        return "bottom";
                    case "bottom":
                        return "top";
                    default:
                        return align
                }
            };
            var calculateOversize = function(data, bounds) {
                var oversize = 0;
                if (data.myLocation < bounds.min) {
                    oversize += bounds.min - data.myLocation
                }
                if (data.myLocation > bounds.max) {
                    oversize += data.myLocation - bounds.max
                }
                return oversize
            };
            var collisionSide = function(direction, data, bounds) {
                if (data.myLocation < bounds.min) {
                    return "h" === direction ? "left" : "top"
                }
                if (data.myLocation > bounds.max) {
                    return "h" === direction ? "right" : "bottom"
                }
                return "none"
            };
            var initMyLocation = function(data) {
                data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
            };
            var decolliders = {
                fit: function(data, bounds) {
                    var result = false;
                    if (data.myLocation > bounds.max) {
                        data.myLocation = bounds.max;
                        result = true
                    }
                    if (data.myLocation < bounds.min) {
                        data.myLocation = bounds.min;
                        result = true
                    }
                    data.fit = result
                },
                flip: function(data, bounds) {
                    data.flip = false;
                    if ("center" === data.myAlign && "center" === data.atAlign) {
                        return
                    }
                    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                        var inverseData = $.extend({}, data, {
                            myAlign: inverseAlign(data.myAlign),
                            atAlign: inverseAlign(data.atAlign),
                            offset: -data.offset
                        });
                        initMyLocation(inverseData);
                        inverseData.oversize = calculateOversize(inverseData, bounds);
                        if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
                            data.myLocation = inverseData.myLocation;
                            data.oversize = inverseData.oversize;
                            data.flip = true
                        }
                    }
                },
                flipfit: function(data, bounds) {
                    this.flip(data, bounds);
                    this.fit(data, bounds)
                },
                none: function(data, bounds) {
                    data.oversize = 0
                }
            };
            var scrollbarWidth;
            var calculateScrollbarWidth = function() {
                var $scrollDiv = $("<div>").css({
                        width: 100,
                        height: 100,
                        overflow: "scroll",
                        position: "absolute",
                        top: -9999
                    }).appendTo($("body")),
                    result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
                $scrollDiv.remove();
                scrollbarWidth = result
            };
            var defaultPositionResult = {
                h: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                },
                v: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                }
            };
            var calculatePosition = function(what, options) {
                var $what = $(what),
                    currentOffset = $what.offset(),
                    result = $.extend(true, {}, defaultPositionResult, {
                        h: {
                            location: currentOffset.left
                        },
                        v: {
                            location: currentOffset.top
                        }
                    });
                if (!options) {
                    return result
                }
                var my = normalizeAlign(options.my),
                    at = normalizeAlign(options.at),
                    of = options.of || window,
                    offset = normalizeOffset(options.offset),
                    collision = normalizeCollision(options.collision),
                    boundary = options.boundary,
                    boundaryOffset = normalizeOffset(options.boundaryOffset);
                var h = {
                    mySize: $what.outerWidth(),
                    myAlign: my.h,
                    atAlign: at.h,
                    offset: offset.h,
                    collision: collision.h,
                    boundaryOffset: boundaryOffset.h
                };
                var v = {
                    mySize: $what.outerHeight(),
                    myAlign: my.v,
                    atAlign: at.v,
                    offset: offset.v,
                    collision: collision.v,
                    boundaryOffset: boundaryOffset.v
                };
                if (of.preventDefault) {
                    h.atLocation = of.pageX;
                    v.atLocation = of.pageY;
                    h.atSize = 0;
                    v.atSize = 0
                } else {
                    of = $(of);
                    if ($.isWindow(of[0])) {
                        h.atLocation = of.scrollLeft();
                        v.atLocation = of.scrollTop();
                        h.atSize = of.width();
                        v.atSize = of.height()
                    } else {
                        if (9 === of[0].nodeType) {
                            h.atLocation = 0;
                            v.atLocation = 0;
                            h.atSize = of.width();
                            v.atSize = of.height()
                        } else {
                            var o = of.offset();
                            h.atLocation = o.left;
                            v.atLocation = o.top;
                            h.atSize = of.outerWidth();
                            v.atSize = of.outerHeight()
                        }
                    }
                }
                initMyLocation(h);
                initMyLocation(v);
                var bounds = function() {
                    var win = $(window),
                        windowWidth = win.width(),
                        windowHeight = win.height(),
                        left = win.scrollLeft(),
                        top = win.scrollTop(),
                        hScrollbar = document.width > document.documentElement.clientWidth,
                        vScrollbar = document.height > document.documentElement.clientHeight,
                        hZoomLevel = support.touch ? document.documentElement.clientWidth / (vScrollbar ? windowWidth - scrollbarWidth : windowWidth) : 1,
                        vZoomLevel = support.touch ? document.documentElement.clientHeight / (hScrollbar ? windowHeight - scrollbarWidth : windowHeight) : 1;
                    if (void 0 === scrollbarWidth) {
                        calculateScrollbarWidth()
                    }
                    var boundaryWidth = windowWidth,
                        boundaryHeight = windowHeight;
                    if (boundary) {
                        var $boundary = $(boundary),
                            boundaryPosition = $boundary.offset();
                        left = boundaryPosition.left;
                        top = boundaryPosition.top;
                        boundaryWidth = $boundary.width();
                        boundaryHeight = $boundary.height()
                    }
                    return {
                        h: {
                            min: left + h.boundaryOffset,
                            max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
                        },
                        v: {
                            min: top + v.boundaryOffset,
                            max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
                        }
                    }
                }();
                h.oversize = calculateOversize(h, bounds.h);
                v.oversize = calculateOversize(v, bounds.v);
                h.collisionSide = collisionSide("h", h, bounds.h);
                v.collisionSide = collisionSide("v", v, bounds.v);
                if (decolliders[h.collision]) {
                    decolliders[h.collision](h, bounds.h)
                }
                if (decolliders[v.collision]) {
                    decolliders[v.collision](v, bounds.v)
                }
                var preciser = function(number) {
                    return options.precise ? number : Math.round(number)
                };
                $.extend(true, result, {
                    h: {
                        location: preciser(h.myLocation),
                        oversize: preciser(h.oversize),
                        fit: h.fit,
                        flip: h.flip,
                        collisionSide: h.collisionSide
                    },
                    v: {
                        location: preciser(v.myLocation),
                        oversize: preciser(v.oversize),
                        fit: v.fit,
                        flip: v.flip,
                        collisionSide: v.collisionSide
                    },
                    precise: options.precise
                });
                return result
            };
            var position = function(what, options) {
                var $what = $(what);
                if (!options) {
                    return $what.offset()
                }
                translator.resetPosition($what);
                var offset = $what.offset(),
                    targetPosition = options.h && options.v ? options : calculatePosition($what, options);
                var preciser = function(number) {
                    return options.precise ? number : Math.round(number)
                };
                translator.move($what, {
                    left: targetPosition.h.location - preciser(offset.left),
                    top: targetPosition.v.location - preciser(offset.top)
                });
                return targetPosition
            };
            $.extend(position, {
                inverseAlign: inverseAlign,
                normalizeAlign: normalizeAlign
            });
            module.exports = {
                calculateScrollbarWidth: calculateScrollbarWidth,
                calculate: calculatePosition,
                setup: position
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/core/utils/math.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var sign = function(value) {
                if (0 === value) {
                    return 0
                }
                return value / Math.abs(value)
            };
            var fitIntoRange = function(value, minValue, maxValue) {
                return Math.min(Math.max(value, minValue), maxValue)
            };
            exports.sign = sign;
            exports.fitIntoRange = fitIntoRange
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!**********************************!*\
      !*** ./Scripts/format_helper.js ***!
      \**********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ./core/utils/common */ 2),
                dateUtils = __webpack_require__( /*! ./core/utils/date */ 12),
                numberLocalization = __webpack_require__( /*! ./localization/number */ 38),
                dateLocalization = __webpack_require__( /*! ./localization/date */ 14),
                dependencyInjector = __webpack_require__( /*! ./core/utils/dependency_injector */ 80),
                logger = __webpack_require__( /*! ./core/utils/console */ 36).logger;
            __webpack_require__( /*! ./localization/currency */ 117);
            module.exports = dependencyInjector({
                _addFormatSeparator: function(format1, format2) {
                    var separator = " ";
                    if (format2) {
                        return format1 + separator + format2
                    }
                    return format1
                },
                _getDateTimeFormatPattern: function(dateTimeFormat) {
                    return dateLocalization.getPatternByFormat(dateTimeFormat)
                },
                format: function(value, format, precision) {
                    var formatIsValid = commonUtils.isString(format) && "" !== format || $.isPlainObject(format) || commonUtils.isFunction(format),
                        valueIsValid = commonUtils.isNumber(value) || commonUtils.isDate(value);
                    if (!formatIsValid || !valueIsValid) {
                        return commonUtils.isDefined(value) ? value.toString() : ""
                    }
                    if (commonUtils.isFunction(format)) {
                        return format(value)
                    }
                    if (void 0 !== precision) {
                        logger.warn("Option 'precision' is deprecated. Use field 'precision' of a format object instead.")
                    }
                    if (commonUtils.isString(format)) {
                        format = {
                            type: format,
                            precision: precision
                        }
                    }
                    if (commonUtils.isNumber(value)) {
                        return numberLocalization.format(value, format)
                    }
                    if (commonUtils.isDate(value)) {
                        return dateLocalization.format(value, format)
                    }
                },
                getTimeFormat: function(showSecond) {
                    if (showSecond) {
                        return this._getDateTimeFormatPattern("longtime")
                    }
                    return this._getDateTimeFormatPattern("shorttime")
                },
                getDateFormatByDifferences: function(dateDifferences) {
                    var resultFormat = "";
                    if (dateDifferences.millisecond) {
                        resultFormat = dateLocalization.getPatternByFormat("millisecond")
                    }
                    if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second) {
                        resultFormat = this._addFormatSeparator(this.getTimeFormat(dateDifferences.second), resultFormat)
                    }
                    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
                        return this._addFormatSeparator(this._getDateTimeFormatPattern("shortdate"), resultFormat)
                    }
                    if (dateDifferences.year && dateDifferences.month) {
                        return dateLocalization.getPatternByFormat("monthandyear")
                    }
                    if (dateDifferences.year && dateDifferences.quarter) {
                        return dateLocalization.getPatternByFormat("quarterandyear")
                    }
                    if (dateDifferences.year) {
                        return dateLocalization.getPatternByFormat("year")
                    }
                    if (dateDifferences.quarter) {
                        return dateLocalization.getPatternByFormat("quarter")
                    }
                    if (dateDifferences.month && dateDifferences.day) {
                        return this._addFormatSeparator(this._getDateTimeFormatPattern("monthandday"), resultFormat)
                    }
                    if (dateDifferences.month) {
                        return dateLocalization.getPatternByFormat("month")
                    }
                    if (dateDifferences.day) {
                        var dayPattern = dateLocalization.getPatternByFormat("dayofweek") + ", " + dateLocalization.getPatternByFormat("day");
                        return this._addFormatSeparator(dayPattern, resultFormat)
                    }
                    return resultFormat
                },
                getDateFormatByTicks: function(ticks) {
                    var resultFormat, maxDif, currentDif, i;
                    if (ticks.length > 1) {
                        maxDif = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
                        for (i = 1; i < ticks.length - 1; i++) {
                            currentDif = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
                            if (maxDif.count < currentDif.count) {
                                maxDif = currentDif
                            }
                        }
                    } else {
                        maxDif = {
                            year: true,
                            month: true,
                            day: true,
                            hour: ticks[0].getHours() > 0,
                            minute: ticks[0].getMinutes() > 0,
                            second: ticks[0].getSeconds() > 0
                        }
                    }
                    resultFormat = this.getDateFormatByDifferences(maxDif);
                    return resultFormat
                },
                getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
                    var resultFormat, dateDifferences, dateUnitInterval, dateDifferencesConverter = {
                            week: "day"
                        },
                        correctDateDifferences = function(dateDifferences, tickInterval, value) {
                            switch (tickInterval) {
                                case "year":
                                case "quarter":
                                    dateDifferences.month = value;
                                case "month":
                                    dateDifferences.day = value;
                                case "week":
                                case "day":
                                    dateDifferences.hour = value;
                                case "hour":
                                    dateDifferences.minute = value;
                                case "minute":
                                    dateDifferences.second = value;
                                case "second":
                                    dateDifferences.millisecond = value
                            }
                        },
                        correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                            if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                                if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                                    differences.millisecond = true;
                                    differences.second = false
                                }
                            } else {
                                if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                                    if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                                        differences.second = true;
                                        differences.minute = false
                                    }
                                } else {
                                    if (!maxDate.getMinutes() && maxDate.getHours()) {
                                        if (maxDate.getHours() - minDate.getHours() === 1) {
                                            differences.minute = true;
                                            differences.hour = false
                                        }
                                    } else {
                                        if (!maxDate.getHours() && maxDate.getDate() > 1) {
                                            if (maxDate.getDate() - minDate.getDate() === 1) {
                                                differences.hour = true;
                                                differences.day = false
                                            }
                                        } else {
                                            if (1 === maxDate.getDate() && maxDate.getMonth()) {
                                                if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                                    differences.day = true;
                                                    differences.month = false
                                                }
                                            } else {
                                                if (!maxDate.getMonth() && maxDate.getFullYear()) {
                                                    if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                                        differences.month = true;
                                                        differences.year = false
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        };
                    tickInterval = commonUtils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
                    dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
                    if (startValue !== endValue) {
                        correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue)
                    }
                    dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
                    correctDateDifferences(dateDifferences, dateUnitInterval, true);
                    dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || "second");
                    correctDateDifferences(dateDifferences, dateUnitInterval, false);
                    dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
                    resultFormat = this.getDateFormatByDifferences(dateDifferences);
                    return resultFormat
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/viz/themes.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ./core/utils */ 6),
                themes = {},
                themesMapping = {},
                themesSchemeMapping = {},
                _extend = $.extend,
                _each = $.each,
                _normalizeEnum = vizUtils.normalizeEnum,
                currentThemeName = null,
                nextCacheUid = 0,
                widgetsCache = {};

            function findTheme(themeName) {
                var name = _normalizeEnum(themeName);
                return themes[name] || themes[themesMapping[name] || currentThemeName]
            }

            function findThemeNameByName(name, scheme) {
                return themesMapping[name + "." + scheme] || themesSchemeMapping[name + "." + scheme] || themesMapping[name]
            }

            function findThemeNameByPlatform(platform, version, scheme) {
                return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme)
            }

            function currentTheme(themeName, colorScheme) {
                if (!arguments.length) {
                    return currentThemeName
                }
                var scheme = _normalizeEnum(colorScheme);
                currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform(_normalizeEnum(themeName.platform), themeName.version, scheme) : findThemeNameByName(_normalizeEnum(themeName), scheme)) || currentThemeName;
                return this
            }

            function getThemeInfo(themeName, splitter) {
                var k = themeName.indexOf(splitter);
                return k > 0 ? {
                    name: themeName.substring(0, k),
                    scheme: themeName.substring(k + 1)
                } : null
            }

            function registerThemeName(themeName, targetThemeName) {
                var themeInfo = getThemeInfo(themeName, ".") || getThemeInfo(themeName, "-") || {
                        name: themeName
                    },
                    name = themeInfo.name,
                    scheme = themeInfo.scheme;
                if (scheme) {
                    themesMapping[name] = themesMapping[name] || targetThemeName;
                    themesMapping[name + "." + scheme] = themesMapping[name + "-" + scheme] = targetThemeName
                } else {
                    themesMapping[name] = targetThemeName
                }
            }

            function registerTheme(theme, baseThemeName) {
                var themeName = _normalizeEnum(theme && theme.name);
                if (themeName) {
                    registerThemeName(themeName, themeName);
                    themes[themeName] = _extend(true, {}, findTheme(baseThemeName), patchTheme(theme))
                }
            }

            function registerThemeAlias(alias, theme) {
                registerThemeName(_normalizeEnum(alias), _normalizeEnum(theme))
            }

            function registerThemeSchemeAlias(from, to) {
                themesSchemeMapping[from] = to
            }

            function mergeScalar(target, field, source, sourceValue) {
                var _value = source ? source[field] : sourceValue;
                if (void 0 !== _value && void 0 === target[field]) {
                    target[field] = _value
                }
            }

            function mergeObject(target, field, source, sourceValue) {
                var _value = source ? source[field] : sourceValue;
                if (void 0 !== _value) {
                    target[field] = _extend(true, {}, _value, target[field])
                }
            }

            function patchTheme(theme) {
                theme = _extend(true, {
                    loadingIndicator: {
                        font: {}
                    },
                    "export": {
                        font: {}
                    },
                    legend: {
                        font: {},
                        border: {}
                    },
                    title: {
                        font: {}
                    },
                    tooltip: {
                        font: {}
                    },
                    "chart:common": {},
                    "chart:common:axis": {
                        grid: {},
                        minorGrid: {},
                        tick: {},
                        minorTick: {},
                        title: {
                            font: {}
                        },
                        label: {
                            font: {}
                        }
                    },
                    chart: {
                        commonSeriesSettings: {
                            candlestick: {}
                        }
                    },
                    pie: {},
                    polar: {},
                    gauge: {
                        scale: {
                            tick: {},
                            minorTick: {},
                            label: {
                                font: {}
                            }
                        }
                    },
                    barGauge: {},
                    map: {
                        background: {}
                    },
                    treeMap: {
                        tile: {
                            selectionStyle: {
                                border: {}
                            }
                        },
                        group: {
                            border: {},
                            selectionStyle: {
                                border: {}
                            },
                            label: {
                                font: {}
                            }
                        }
                    },
                    rangeSelector: {
                        scale: {
                            tick: {},
                            minorTick: {},
                            label: {
                                font: {}
                            }
                        },
                        chart: {}
                    },
                    sparkline: {},
                    bullet: {}
                }, theme);
                mergeScalar(theme.loadingIndicator, "backgroundColor", theme);
                mergeScalar(theme.chart.commonSeriesSettings.candlestick, "innerColor", null, theme.backgroundColor);
                mergeScalar(theme.map.background, "color", null, theme.backgroundColor);
                mergeScalar(theme.title.font, "color", null, theme.primaryTitleColor);
                mergeObject(theme.title, "subtitle", null, theme.title);
                mergeScalar(theme.legend.font, "color", null, theme.secondaryTitleColor);
                mergeScalar(theme.legend.border, "color", null, theme.axisColor);
                patchAxes(theme);
                _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector", "sparkline", "bullet"], function(_, section) {
                    mergeScalar(theme[section], "redrawOnResize", theme);
                    mergeScalar(theme[section], "containerBackgroundColor", null, theme.backgroundColor);
                    mergeObject(theme[section], "tooltip", theme)
                });
                _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector"], function(_, section) {
                    mergeObject(theme[section], "loadingIndicator", theme);
                    mergeObject(theme[section], "export", theme);
                    mergeObject(theme[section], "legend", theme);
                    mergeObject(theme[section], "title", theme)
                });
                _each(["chart", "pie", "polar"], function(_, section) {
                    mergeObject(theme, section, null, theme["chart:common"])
                });
                _each(["chart", "polar"], function(_, section) {
                    theme[section] = theme[section] || {};
                    mergeObject(theme[section], "commonAxisSettings", null, theme["chart:common:axis"])
                });
                mergeObject(theme.rangeSelector.chart, "commonSeriesSettings", theme.chart);
                mergeObject(theme.rangeSelector.chart, "dataPrepareSettings", theme.chart);
                mergeScalar(theme.treeMap.group.border, "color", null, theme.axisColor);
                mergeScalar(theme.treeMap.tile.selectionStyle.border, "color", null, theme.primaryTitleColor);
                mergeScalar(theme.treeMap.group.selectionStyle.border, "color", null, theme.primaryTitleColor);
                mergeScalar(theme.treeMap.group.label.font, "color", null, theme.secondaryTitleColor);
                mergeScalar(theme.map.legend, "backgroundColor", theme);
                patchMapLayers(theme);
                return theme
            }

            function patchAxes(theme) {
                var commonAxisSettings = theme["chart:common:axis"],
                    colorFieldName = "color";
                _each([commonAxisSettings, commonAxisSettings.grid, commonAxisSettings.minorGrid, commonAxisSettings.tick, commonAxisSettings.minorTick], function(_, obj) {
                    mergeScalar(obj, colorFieldName, null, theme.axisColor)
                });
                mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
                mergeScalar(commonAxisSettings.label.font, colorFieldName, null, theme.axisLabelColor);
                mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisLabelColor);
                mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
                mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
                mergeScalar(theme.rangeSelector.scale.tick, colorFieldName, null, theme.axisColor);
                mergeScalar(theme.rangeSelector.scale.minorTick, colorFieldName, null, theme.axisColor);
                mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisLabelColor)
            }

            function patchMapLayers(theme) {
                var map = theme.map;
                _each(["area", "line", "marker"], function(_, section) {
                    mergeObject(map, "layer:" + section, null, map.layer)
                });
                _each(["dot", "bubble", "pie", "image"], function(_, section) {
                    mergeObject(map, "layer:marker:" + section, null, map["layer:marker"])
                })
            }

            function addCacheItem(target) {
                var cacheUid = ++nextCacheUid;
                target._cache = cacheUid;
                widgetsCache[cacheUid] = target
            }

            function removeCacheItem(target) {
                delete widgetsCache[target._cache]
            }

            function refreshAll() {
                _each(widgetsCache, function() {
                    this.refresh()
                });
                return this
            }
            _extend(exports, {
                currentTheme: currentTheme,
                registerTheme: registerTheme,
                findTheme: findTheme,
                registerThemeAlias: registerThemeAlias,
                registerThemeSchemeAlias: registerThemeSchemeAlias,
                refreshAll: refreshAll,
                addCacheItem: addCacheItem,
                removeCacheItem: removeCacheItem
            });
            _extend(exports, {
                themes: themes,
                themesMapping: themesMapping,
                themesSchemeMapping: themesSchemeMapping,
                widgetsCache: widgetsCache,
                resetCurrentTheme: function() {
                    currentThemeName = null
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/events/core/emitter.feedback.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                eventUtils = __webpack_require__( /*! ../utils */ 4),
                pointerEvents = __webpack_require__( /*! ../pointer */ 13),
                Emitter = __webpack_require__( /*! ./emitter */ 81),
                registerEmitter = __webpack_require__( /*! ./emitter_registrator */ 61);
            var ACTIVE_EVENT_NAME = "dxactive",
                INACTIVE_EVENT_NAME = "dxinactive",
                ACTIVE_TIMEOUT = 30,
                INACTIVE_TIMEOUT = 400;
            var FeedbackEvent = Class.inherit({
                ctor: function(timeout, fire) {
                    this._timeout = timeout;
                    this._fire = fire
                },
                start: function() {
                    var that = this;
                    this._schedule(function() {
                        that.force()
                    })
                },
                _schedule: function(fn) {
                    this._timer = window.setTimeout(fn, this._timeout)
                },
                stop: function() {
                    clearTimeout(this._timer)
                },
                force: function() {
                    if (this._fired) {
                        return
                    }
                    this.stop();
                    this._fire();
                    this._fired = true
                },
                fired: function() {
                    return this._fired
                }
            });
            var activeFeedback;
            var FeedbackEmitter = Emitter.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._active = new FeedbackEvent(0, $.noop);
                    this._inactive = new FeedbackEvent(0, $.noop)
                },
                configurate: function(data, eventName) {
                    switch (eventName) {
                        case ACTIVE_EVENT_NAME:
                            data.activeTimeout = data.timeout;
                            break;
                        case INACTIVE_EVENT_NAME:
                            data.inactiveTimeout = data.timeout
                    }
                    this.callBase(data)
                },
                start: function(e) {
                    if (activeFeedback) {
                        var activeChildExists = $.contains(this.getElement().get(0), activeFeedback.getElement().get(0));
                        var childJustActivated = !activeFeedback._active.fired();
                        if (activeChildExists && childJustActivated) {
                            this._cancel();
                            return
                        }
                        activeFeedback._inactive.force()
                    }
                    activeFeedback = this;
                    this._initEvents(e);
                    this._active.start()
                },
                _initEvents: function(e) {
                    var that = this,
                        eventTarget = this._getEmitterTarget(e),
                        mouseEvent = eventUtils.isMouseEvent(e),
                        isSimulator = devices.isSimulator(),
                        deferFeedback = isSimulator || !mouseEvent,
                        activeTimeout = commonUtils.ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT),
                        inactiveTimeout = commonUtils.ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
                    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
                        that._fireEvent(ACTIVE_EVENT_NAME, e, {
                            target: eventTarget
                        })
                    });
                    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
                        that._fireEvent(INACTIVE_EVENT_NAME, e, {
                            target: eventTarget
                        });
                        activeFeedback = null
                    })
                },
                cancel: function(e) {
                    this.end(e)
                },
                end: function(e) {
                    var skipTimers = e.type !== pointerEvents.up;
                    if (skipTimers) {
                        this._active.stop()
                    } else {
                        this._active.force()
                    }
                    this._inactive.start();
                    if (skipTimers) {
                        this._inactive.force()
                    }
                },
                dispose: function() {
                    this._active.stop();
                    this._inactive.stop();
                    this.callBase()
                },
                lockInactive: function() {
                    this._active.force();
                    this._inactive.stop();
                    activeFeedback = null;
                    this._cancel();
                    return $.proxy(this._inactive.force, this._inactive)
                }
            });
            FeedbackEmitter.lock = function(deferred) {
                var lockInactive = activeFeedback ? activeFeedback.lockInactive() : $.noop;
                $.when(deferred).always(lockInactive)
            };
            registerEmitter({
                emitter: FeedbackEmitter,
                events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
            });
            exports.lock = FeedbackEmitter.lock;
            exports.active = ACTIVE_EVENT_NAME;
            exports.inactive = INACTIVE_EVENT_NAME
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/odata/utils.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                Guid = __webpack_require__( /*! ../../core/guid */ 33),
                isDefined = commonUtils.isDefined,
                errors = __webpack_require__( /*! ../errors */ 25).errors,
                dataUtils = __webpack_require__( /*! ../utils */ 28);
            var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
            var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
            var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;
            var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";

            function formatISO8601(date, skipZeroTime, skipTimezone) {
                var ret = [];
                var pad = function(n) {
                    if (n < 10) {
                        return "0".concat(n)
                    }
                    return String(n)
                };
                var isZeroTime = function() {
                    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
                };
                ret.push(date.getFullYear());
                ret.push("-");
                ret.push(pad(date.getMonth() + 1));
                ret.push("-");
                ret.push(pad(date.getDate()));
                if (!(skipZeroTime && isZeroTime())) {
                    ret.push("T");
                    ret.push(pad(date.getHours()));
                    ret.push(":");
                    ret.push(pad(date.getMinutes()));
                    ret.push(":");
                    ret.push(pad(date.getSeconds()));
                    if (date.getMilliseconds()) {
                        ret.push(".");
                        ret.push(date.getMilliseconds())
                    }
                    if (!skipTimezone) {
                        ret.push("Z")
                    }
                }
                return ret.join("")
            }

            function parseISO8601(isoString) {
                var result = new Date(60 * new Date(0).getTimezoneOffset() * 1e3),
                    chunks = isoString.replace("Z", "").split("T"),
                    date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]),
                    time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
                result.setFullYear(Number(date[1]));
                result.setMonth(Number(date[2]) - 1);
                result.setDate(Number(date[3]));
                if ($.isArray(time) && time.length) {
                    result.setHours(Number(time[1]));
                    result.setMinutes(Number(time[2]));
                    result.setSeconds(Number(time[3]));
                    result.setMilliseconds(Number(String(time[4]).substr(0, 3)) || 0)
                }
                return result
            }

            function isAbsoluteUrl(url) {
                return /^(?:[a-z]+:)?\/\//i.test(url)
            }

            function toAbsoluteUrl(basePath, relativePath) {
                var part;
                var baseParts = stripParams(basePath).split("/");
                var relativeParts = relativePath.split("/");

                function stripParams(url) {
                    var index = url.indexOf("?");
                    if (index > -1) {
                        return url.substr(0, index)
                    }
                    return url
                }
                baseParts.pop();
                while (relativeParts.length) {
                    part = relativeParts.shift();
                    if (".." === part) {
                        baseParts.pop()
                    } else {
                        baseParts.push(part)
                    }
                }
                return baseParts.join("/")
            }
            var ajaxOptionsForRequest = function(protocolVersion, request, requestOptions) {
                request = $.extend({
                    async: true,
                    method: "get",
                    url: "",
                    params: {},
                    payload: null,
                    headers: {},
                    timeout: 3e4
                }, request);
                requestOptions = requestOptions || {};
                var beforeSend = requestOptions.beforeSend;
                if (beforeSend) {
                    beforeSend(request)
                }
                var method = (request.method || "get").toLowerCase(),
                    isGet = "get" === method,
                    useJsonp = isGet && requestOptions.jsonp,
                    params = $.extend({}, request.params),
                    ajaxData = isGet ? params : formatPayload(request.payload),
                    qs = !isGet && $.param(params),
                    url = request.url,
                    contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
                if (qs) {
                    url += (url.indexOf("?") > -1 ? "&" : "?") + qs
                }
                if (useJsonp) {
                    ajaxData.$format = "json"
                }
                return {
                    url: url,
                    data: ajaxData,
                    dataType: useJsonp ? "jsonp" : "json",
                    jsonp: useJsonp && "$callback",
                    type: method,
                    async: request.async,
                    timeout: request.timeout,
                    headers: request.headers,
                    contentType: contentType,
                    accepts: {
                        json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()
                    },
                    xhrFields: {
                        withCredentials: requestOptions.withCredentials
                    }
                };

                function formatPayload(payload) {
                    return JSON.stringify(payload, function(key, value) {
                        if (!(this[key] instanceof Date)) {
                            return value
                        }
                        value = formatISO8601(this[key]);
                        switch (protocolVersion) {
                            case 2:
                                return value.substr(0, value.length - 1);
                            case 3:
                            case 4:
                                return value;
                            default:
                                throw errors.Error("E4002")
                        }
                    })
                }
            };
            var sendRequest = function(protocolVersion, request, requestOptions, deserializeDates) {
                var d = $.Deferred();
                var options = ajaxOptionsForRequest(protocolVersion, request, requestOptions);
                $.ajax(options).always(function(obj, textStatus) {
                    var extra, tuplet = interpretJsonFormat(obj, textStatus, deserializeDates),
                        error = tuplet.error,
                        data = tuplet.data,
                        nextUrl = tuplet.nextUrl;
                    if (error) {
                        d.reject(error)
                    } else {
                        if (requestOptions.countOnly) {
                            if (isFinite(tuplet.count)) {
                                d.resolve(tuplet.count)
                            } else {
                                d.reject(new errors.Error("E4018"))
                            }
                        } else {
                            if (nextUrl) {
                                if (!isAbsoluteUrl(nextUrl)) {
                                    nextUrl = toAbsoluteUrl(options.url, nextUrl)
                                }
                                sendRequest(protocolVersion, {
                                    url: nextUrl
                                }, requestOptions, deserializeDates).fail(d.reject).done(function(nextData) {
                                    d.resolve(data.concat(nextData))
                                })
                            } else {
                                if (isFinite(tuplet.count)) {
                                    extra = {
                                        totalCount: tuplet.count
                                    }
                                }
                                d.resolve(data, extra)
                            }
                        }
                    }
                });
                return d.promise()
            };
            var formatDotNetError = function(errorObj) {
                var message, currentError = errorObj;
                if ("message" in errorObj) {
                    if (errorObj.message.value) {
                        message = errorObj.message.value
                    } else {
                        message = errorObj.message
                    }
                }
                while (currentError = currentError.innererror || currentError.internalexception) {
                    message = currentError.message;
                    if (currentError.internalexception && -1 === message.indexOf("inner exception")) {
                        break
                    }
                }
                return message
            };
            var errorFromResponse = function(obj, textStatus) {
                if ("nocontent" === textStatus) {
                    return null
                }
                var httpStatus = 200,
                    message = "Unknown error",
                    response = obj;
                if ("success" !== textStatus) {
                    httpStatus = obj.status;
                    message = dataUtils.errorMessageFromXhr(obj, textStatus);
                    try {
                        response = $.parseJSON(obj.responseText)
                    } catch (x) {}
                }
                var errorObj = response && (response.error || response["odata.error"] || response["@odata.error"]);
                if (errorObj) {
                    message = formatDotNetError(errorObj) || message;
                    if (200 === httpStatus) {
                        httpStatus = 500
                    }
                    if (errorObj.code) {
                        httpStatus = Number(errorObj.code)
                    }
                    return $.extend(Error(message), {
                        httpStatus: httpStatus,
                        errorDetails: errorObj
                    })
                } else {
                    if (200 !== httpStatus) {
                        return $.extend(Error(message), {
                            httpStatus: httpStatus
                        })
                    }
                }
            };
            var interpretJsonFormat = function(obj, textStatus, deserializeDates) {
                var value, error = errorFromResponse(obj, textStatus);
                if (error) {
                    return {
                        error: error
                    }
                }
                if (!$.isPlainObject(obj)) {
                    return {
                        data: obj
                    }
                }
                if ("d" in obj && (commonUtils.isArray(obj.d) || commonUtils.isObject(obj.d))) {
                    value = interpretVerboseJsonFormat(obj, textStatus)
                } else {
                    value = interpretLightJsonFormat(obj, textStatus)
                }
                transformTypes(value, deserializeDates);
                return value
            };
            var interpretVerboseJsonFormat = function(obj) {
                var data = obj.d;
                if (!isDefined(data)) {
                    return {
                        error: Error("Malformed or unsupported JSON response received")
                    }
                }
                data = data;
                if (isDefined(data.results)) {
                    data = data.results
                }
                return {
                    data: data,
                    nextUrl: obj.d.__next,
                    count: parseInt(obj.d.__count, 10)
                }
            };
            var interpretLightJsonFormat = function(obj) {
                var data = obj;
                if (isDefined(data.value)) {
                    data = data.value
                }
                return {
                    data: data,
                    nextUrl: obj["@odata.nextLink"],
                    count: parseInt(obj["@odata.count"], 10)
                }
            };
            var EdmLiteral = Class.inherit({
                ctor: function(value) {
                    this._value = value
                },
                valueOf: function() {
                    return this._value
                }
            });
            var transformTypes = function(obj, deserializeDates) {
                $.each(obj, function(key, value) {
                    if (null !== value && "object" === typeof value) {
                        if ("results" in value) {
                            obj[key] = value.results
                        }
                        transformTypes(obj[key], deserializeDates)
                    } else {
                        if ("string" === typeof value) {
                            if (GUID_REGEX.test(value)) {
                                obj[key] = new Guid(value)
                            }
                            if (false !== deserializeDates) {
                                if (value.match(VERBOSE_DATE_REGEX)) {
                                    var date = new Date(Number(RegExp.$1) + 60 * RegExp.$2 * 1e3);
                                    obj[key] = new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
                                } else {
                                    if (ISO8601_DATE_REGEX.test(value)) {
                                        obj[key] = new Date(parseISO8601(obj[key]).valueOf())
                                    }
                                }
                            }
                        }
                    }
                })
            };
            var serializeDate = function(date) {
                return "datetime'" + formatISO8601(date, true, true) + "'"
            };
            var serializeString = function(value) {
                return "'" + value.replace(/'/g, "''") + "'"
            };
            var serializePropName = function(propName) {
                if (propName instanceof EdmLiteral) {
                    return propName.valueOf()
                }
                return propName.replace(/\./g, "/")
            };
            var serializeValueV4 = function(value) {
                if (value instanceof Date) {
                    return formatISO8601(value, false, false)
                }
                if (value instanceof Guid) {
                    return value.valueOf()
                }
                return serializeValueV2(value)
            };
            var serializeValueV2 = function(value) {
                if (value instanceof Date) {
                    return serializeDate(value)
                }
                if (value instanceof Guid) {
                    return "guid'" + value + "'"
                }
                if (value instanceof EdmLiteral) {
                    return value.valueOf()
                }
                if ("string" === typeof value) {
                    return serializeString(value)
                }
                return String(value)
            };
            var serializeValue = function(value, protocolVersion) {
                switch (protocolVersion) {
                    case 2:
                    case 3:
                        return serializeValueV2(value);
                    case 4:
                        return serializeValueV4(value);
                    default:
                        throw errors.Error("E4002")
                }
            };
            var serializeKey = function(key, protocolVersion) {
                if ($.isPlainObject(key)) {
                    var parts = [];
                    $.each(key, function(k, v) {
                        parts.push(serializePropName(k) + "=" + serializeValue(v, protocolVersion))
                    });
                    return parts.join()
                }
                return serializeValue(key, protocolVersion)
            };
            var keyConverters = {
                String: function(value) {
                    return value + ""
                },
                Int32: function(value) {
                    return Math.floor(value)
                },
                Int64: function(value) {
                    if (value instanceof EdmLiteral) {
                        return value
                    }
                    return new EdmLiteral(value + "L")
                },
                Guid: function(value) {
                    if (value instanceof Guid) {
                        return value
                    }
                    return new Guid(value)
                },
                Boolean: function(value) {
                    return !!value
                },
                Single: function(value) {
                    if (value instanceof EdmLiteral) {
                        return value
                    }
                    return new EdmLiteral(value + "f")
                },
                Decimal: function(value) {
                    if (value instanceof EdmLiteral) {
                        return value
                    }
                    return new EdmLiteral(value + "m")
                }
            };
            exports.sendRequest = sendRequest;
            exports.serializePropName = serializePropName;
            exports.serializeValue = serializeValue;
            exports.serializeKey = serializeKey;
            exports.keyConverters = keyConverters;
            exports.EdmLiteral = EdmLiteral;
            exports.OData__internals = {
                interpretJsonFormat: interpretJsonFormat
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!************************************************!*\
      !*** ./Scripts/core/utils/variable_wrapper.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var logger = __webpack_require__( /*! ./console */ 36).logger,
                dependencyInjector = __webpack_require__( /*! ./dependency_injector */ 80);
            module.exports = dependencyInjector({
                isWrapped: function(value) {
                    return false
                },
                isWritableWrapped: function(value) {
                    return false
                },
                wrap: function(value) {
                    return value
                },
                unwrap: function(value) {
                    return value
                },
                assign: function(variable, value) {
                    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for enshuring.")
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!************************************!*\
      !*** ./Scripts/animation/frame.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                FRAME_ANIMATION_STEP_TIME = 1e3 / 60,
                requestAnimationFrame = function(callback) {
                    return this.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
                },
                cancelAnimationFrame = function(requestID) {
                    this.clearTimeout(requestID)
                },
                nativeRequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
                nativeCancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
            if (nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                requestAnimationFrame = nativeRequestAnimationFrame;
                cancelAnimationFrame = nativeCancelAnimationFrame
            }
            if (nativeRequestAnimationFrame && !nativeCancelAnimationFrame) {
                var canceledRequests = {};
                requestAnimationFrame = function(callback) {
                    var requestId = nativeRequestAnimationFrame.call(window, function() {
                        try {
                            if (requestId in canceledRequests) {
                                return
                            }
                            callback.apply(this, arguments)
                        } finally {
                            delete canceledRequests[requestId]
                        }
                    });
                    return requestId
                };
                cancelAnimationFrame = function(requestId) {
                    canceledRequests[requestId] = true
                }
            }
            requestAnimationFrame = $.proxy(requestAnimationFrame, window);
            cancelAnimationFrame = $.proxy(cancelAnimationFrame, window);
            exports.requestAnimationFrame = requestAnimationFrame;
            exports.cancelAnimationFrame = cancelAnimationFrame
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!************************************!*\
      !*** ./Scripts/core/utils/icon.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var getImageSourceType = function(source) {
                if (!source || "string" !== typeof source) {
                    return false
                }
                if (/data:.*base64|\.|\//.test(source)) {
                    return "image"
                }
                if (/^[\w-_]+$/.test(source)) {
                    return "dxIcon"
                }
                return "fontIcon"
            };
            var getImageContainer = function(source) {
                var imageType = getImageSourceType(source),
                    ICON_CLASS = "dx-icon";
                switch (imageType) {
                    case "image":
                        return $("<img>", {
                            src: source
                        }).addClass(ICON_CLASS);
                    case "fontIcon":
                        return $("<i>", {
                            "class": ICON_CLASS + " " + source
                        });
                    case "dxIcon":
                        return $("<i>", {
                            "class": ICON_CLASS + " " + ICON_CLASS + "-" + source
                        });
                    default:
                        return null
                }
            };
            exports.getImageSourceType = getImageSourceType;
            exports.getImageContainer = getImageContainer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/events/core/wheel.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                registerEvent = __webpack_require__( /*! ./event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ../utils */ 4);
            var EVENT_NAME = "dxmousewheel",
                EVENT_NAMESPACE = "dxWheel";
            $.event.fixHooks.wheel = $.event.mouseHooks;
            var wheelEvent = void 0 !== document.onwheel ? "wheel" : "mousewheel";
            var wheel = {
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(eventUtils.addNamespace(wheelEvent, EVENT_NAMESPACE), $.proxy(wheel._wheelHandler, wheel))
                },
                teardown: function(element) {
                    var $element = $(element);
                    $element.off("." + EVENT_NAMESPACE)
                },
                _wheelHandler: function(e) {
                    var delta = this._getWheelDelta(e.originalEvent);
                    eventUtils.fireEvent({
                        type: EVENT_NAME,
                        originalEvent: e,
                        delta: delta,
                        pointerType: "mouse"
                    });
                    e.stopPropagation()
                },
                _getWheelDelta: function(event) {
                    return event.wheelDelta ? event.wheelDelta : 30 * -event.deltaY
                }
            };
            registerEvent(EVENT_NAME, wheel);
            exports.name = EVENT_NAME
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!***************************************************!*\
      !*** ./Scripts/core/utils/dependency_injector.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = function(object) {
                var $ = __webpack_require__( /*! jquery */ 1),
                    Class = __webpack_require__( /*! ../class */ 5);
                var BaseClass = Class.inherit(object),
                    InjectedClass = BaseClass,
                    instance = new InjectedClass(object),
                    initialFields = {};
                var injectFields = function(injectionObject, initial) {
                    $.each(injectionObject, function(key) {
                        if ($.isFunction(instance[key])) {
                            if (initial || !object[key]) {
                                object[key] = function() {
                                    return instance[key].apply(object, arguments)
                                }
                            }
                        } else {
                            if (initial) {
                                initialFields[key] = object[key]
                            }
                            object[key] = instance[key]
                        }
                    })
                };
                injectFields(object, true);
                object.inject = function(injectionObject) {
                    InjectedClass = InjectedClass.inherit(injectionObject);
                    instance = new InjectedClass;
                    injectFields(injectionObject)
                };
                object.resetInjection = function() {
                    $.extend(object, initialFields);
                    InjectedClass = BaseClass;
                    instance = new BaseClass
                };
                return object
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/events/core/emitter.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                eventUtils = __webpack_require__( /*! ../utils */ 4);
            var Emitter = Class.inherit({
                ctor: function(element) {
                    this._$element = $(element);
                    this._cancelCallback = $.Callbacks();
                    this._acceptCallback = $.Callbacks()
                },
                getElement: function() {
                    return this._$element
                },
                validate: function(e) {
                    return "dxmousewheel" !== e.type
                },
                validatePointers: function(e) {
                    return 1 === eventUtils.hasTouches(e)
                },
                allowInterruptionByMousewheel: function() {
                    return true
                },
                configurate: function(data) {
                    $.extend(this, data)
                },
                addCancelCallback: function(callback) {
                    this._cancelCallback.add(callback)
                },
                removeCancelCallback: function() {
                    this._cancelCallback.empty()
                },
                _cancel: function(e) {
                    this._cancelCallback.fire(this, e)
                },
                addAcceptCallback: function(callback) {
                    this._acceptCallback.add(callback)
                },
                removeAcceptCallback: function() {
                    this._acceptCallback.empty()
                },
                _accept: function(e) {
                    this._acceptCallback.fire(this, e)
                },
                _requestAccept: function(e) {
                    this._acceptRequestEvent = e
                },
                _forgetAccept: function() {
                    this._accept(this._acceptRequestEvent);
                    this._acceptRequestEvent = null
                },
                start: $.noop,
                move: $.noop,
                end: $.noop,
                cancel: $.noop,
                reset: function() {
                    if (this._acceptRequestEvent) {
                        this._accept(this._acceptRequestEvent)
                    }
                },
                _fireEvent: function(eventName, e, params) {
                    var eventData = $.extend({
                        type: eventName,
                        originalEvent: e,
                        target: this._getEmitterTarget(e),
                        delegateTarget: this.getElement().get(0)
                    }, params);
                    e = eventUtils.fireEvent(eventData);
                    if (e.cancel) {
                        this._cancel(e)
                    }
                    return e
                },
                _getEmitterTarget: function(e) {
                    return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
                },
                dispose: $.noop
            });
            module.exports = Emitter
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/events/swipe.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var eventUtils = __webpack_require__( /*! ./utils */ 4),
                GestureEmitter = __webpack_require__( /*! ./gesture/emitter.gesture */ 120),
                registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 61);
            var SWIPE_START_EVENT = "dxswipestart",
                SWIPE_EVENT = "dxswipe",
                SWIPE_END_EVENT = "dxswipeend";
            var HorizontalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().width()
                },
                getBounds: function() {
                    return [this._maxLeftOffset, this._maxRightOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
                }
            };
            var VerticalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().height()
                },
                getBounds: function() {
                    return [this._maxTopOffset, this._maxBottomOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
                }
            };
            var STRATEGIES = {
                horizontal: HorizontalStrategy,
                vertical: VerticalStrategy
            };
            var SwipeEmitter = GestureEmitter.inherit({
                TICK_INTERVAL: 300,
                FAST_SWIPE_SPEED_LIMIT: 10,
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "horizontal";
                    this.elastic = true
                },
                _getStrategy: function() {
                    return STRATEGIES[this.direction]
                },
                _defaultItemSizeFunc: function() {
                    return this._getStrategy().defaultItemSizeFunc.call(this)
                },
                _itemSizeFunc: function() {
                    return this.itemSizeFunc || this._defaultItemSizeFunc
                },
                _init: function(e) {
                    this._tickData = eventUtils.eventData(e)
                },
                _start: function(e) {
                    this._savedEventData = eventUtils.eventData(e);
                    e = this._fireEvent(SWIPE_START_EVENT, e);
                    if (!e.cancel) {
                        this._maxLeftOffset = e.maxLeftOffset;
                        this._maxRightOffset = e.maxRightOffset;
                        this._maxTopOffset = e.maxTopOffset;
                        this._maxBottomOffset = e.maxBottomOffset
                    }
                },
                _move: function(e) {
                    var strategy = this._getStrategy(),
                        moveEventData = eventUtils.eventData(e),
                        offset = strategy.calcOffsetRatio.call(this, e);
                    offset = this._fitOffset(offset, this.elastic);
                    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
                        this._tickData = moveEventData
                    }
                    this._fireEvent(SWIPE_EVENT, e, {
                        offset: offset
                    });
                    e.preventDefault()
                },
                _end: function(e) {
                    var strategy = this._getStrategy(),
                        offsetRatio = strategy.calcOffsetRatio.call(this, e),
                        isFast = strategy.isFastSwipe.call(this, e),
                        startOffset = offsetRatio,
                        targetOffset = this._calcTargetOffset(offsetRatio, isFast);
                    startOffset = this._fitOffset(startOffset, this.elastic);
                    targetOffset = this._fitOffset(targetOffset, false);
                    this._fireEvent(SWIPE_END_EVENT, e, {
                        offset: startOffset,
                        targetOffset: targetOffset
                    })
                },
                _fitOffset: function(offset, elastic) {
                    var strategy = this._getStrategy(),
                        bounds = strategy.getBounds.call(this);
                    if (offset < -bounds[0]) {
                        return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0]
                    }
                    if (offset > bounds[1]) {
                        return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1]
                    }
                    return offset
                },
                _calcTargetOffset: function(offsetRatio, isFast) {
                    var result;
                    if (isFast) {
                        result = Math.ceil(Math.abs(offsetRatio));
                        if (offsetRatio < 0) {
                            result = -result
                        }
                    } else {
                        result = Math.round(offsetRatio)
                    }
                    return result
                }
            });
            registerEmitter({
                emitter: SwipeEmitter,
                events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
            });
            exports.swipe = SWIPE_EVENT;
            exports.start = SWIPE_START_EVENT;
            exports.end = SWIPE_END_EVENT
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/framework/navigation_manager.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                navigationDevices = __webpack_require__( /*! ./navigation_devices */ 115),
                EventsMixin = __webpack_require__( /*! ../core/events_mixin */ 32),
                errors = __webpack_require__( /*! ./errors */ 44),
                hardwareBackButton = __webpack_require__( /*! ../mobile/process_hardware_back_button */ 219).processCallback,
                hideTopOverlay = __webpack_require__( /*! ../mobile/hide_top_overlay */ 100);
            var NAVIGATION_TARGETS = {
                    current: "current",
                    blank: "blank",
                    back: "back"
                },
                STORAGE_HISTORY_KEY = "__history";
            var HistoryBasedNavigationManager = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._currentItem = void 0;
                    this._previousItem = void 0;
                    this._createNavigationDevice(options)
                },
                _createNavigationDevice: function(options) {
                    this._navigationDevice = options.navigationDevice || new navigationDevices.HistoryBasedNavigationDevice;
                    this._navigationDevice.uriChanged.add($.proxy(this._uriChangedHandler, this))
                },
                _uriChangedHandler: function(uri) {
                    while (hideTopOverlay()) {}
                    this.navigate(uri)
                },
                _syncUriWithCurrentNavigationItem: function() {
                    var currentUri = this._currentItem && this._currentItem.uri;
                    this._navigationDevice.setUri(currentUri, true)
                },
                _cancelNavigation: function(args) {
                    this._syncUriWithCurrentNavigationItem();
                    this.fireEvent("navigationCanceled", [args])
                },
                _getDefaultOptions: function() {
                    return {
                        direction: "none",
                        target: NAVIGATION_TARGETS.blank
                    }
                },
                _updateHistory: function(uri, options) {
                    this._previousItem = this._currentItem;
                    this._currentItem = {
                        uri: uri,
                        key: uri
                    };
                    this._navigationDevice.setUri(uri, options.target === NAVIGATION_TARGETS.current)
                },
                _setCurrentItem: function(item) {
                    this._currentItem = item
                },
                navigate: function(uri, options) {
                    options = options || {};
                    var args, that = this,
                        isFirstNavigate = !that._currentItem,
                        currentItem = that._currentItem || {},
                        targetItem = options.item || {},
                        currentUri = currentItem.uri,
                        currentKey = currentItem.key,
                        targetKey = targetItem.key;
                    if (void 0 === uri) {
                        uri = that._navigationDevice.getUri()
                    }
                    if (/^_back$/.test(uri)) {
                        that.back();
                        return
                    }
                    options = $.extend(that._getDefaultOptions(), options || {});
                    if (isFirstNavigate) {
                        options.target = NAVIGATION_TARGETS.current
                    }
                    args = {
                        currentUri: currentUri,
                        uri: uri,
                        cancel: false,
                        navigateWhen: [],
                        options: options
                    };
                    that.fireEvent("navigating", [args]);
                    uri = args.uri;
                    if (args.cancel || currentUri === uri && (void 0 === targetKey || targetKey === currentKey) && !that._forceNavigate) {
                        that._cancelNavigation(args)
                    } else {
                        that._forceNavigate = false;
                        $.when.apply($, args.navigateWhen).done(function() {
                            commonUtils.executeAsync(function() {
                                that._updateHistory(uri, options);
                                that.fireEvent("navigated", [{
                                    uri: uri,
                                    previousUri: currentUri,
                                    options: options,
                                    item: that._currentItem
                                }])
                            })
                        })
                    }
                },
                back: function() {
                    return this._navigationDevice.back()
                },
                previousItem: function() {
                    return this._previousItem
                },
                currentItem: function(item) {
                    if (arguments.length > 0) {
                        if (!item) {
                            throw errors.Error("E3023")
                        }
                        this._setCurrentItem(item)
                    } else {
                        return this._currentItem
                    }
                },
                rootUri: function() {
                    return this._currentItem && this._currentItem.uri
                },
                canBack: function() {
                    return true
                },
                saveState: $.noop,
                restoreState: $.noop,
                removeState: $.noop
            }).include(EventsMixin);
            var StackBasedNavigationManager = HistoryBasedNavigationManager.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.callBase(options);
                    this._createNavigationStacks(options);
                    hardwareBackButton.add($.proxy(this._deviceBackInitiated, this));
                    this._stateStorageKey = options.stateStorageKey || STORAGE_HISTORY_KEY
                },
                init: function() {
                    return this._navigationDevice.init()
                },
                _createNavigationDevice: function(options) {
                    if (!options.navigationDevice) {
                        options.navigationDevice = new navigationDevices.StackBasedNavigationDevice
                    }
                    this.callBase(options);
                    this._navigationDevice.backInitiated.add($.proxy(this._deviceBackInitiated, this))
                },
                _uriChangedHandler: function(uri) {
                    this.navigate(uri)
                },
                _createNavigationStacks: function(options) {
                    this.navigationStacks = {};
                    this._keepPositionInStack = options.keepPositionInStack;
                    this.currentStack = new NavigationStack
                },
                _deviceBackInitiated: function() {
                    if (!hideTopOverlay()) {
                        this.back({
                            isHardwareButton: true
                        })
                    } else {
                        this._syncUriWithCurrentNavigationItem()
                    }
                },
                _getDefaultOptions: function() {
                    return {
                        target: NAVIGATION_TARGETS.blank
                    }
                },
                _createNavigationStack: function() {
                    var result = new NavigationStack;
                    result.itemsRemoved.add($.proxy(this._removeItems, this));
                    return result
                },
                _setCurrentItem: function(item) {
                    this._setCurrentStack(item.stack);
                    this.currentStack.currentItem(item);
                    this.callBase(item);
                    this._syncUriWithCurrentNavigationItem()
                },
                _setCurrentStack: function(stackOrStackKey) {
                    var stack, stackKey;
                    if ("string" === typeof stackOrStackKey) {
                        stackKey = stackOrStackKey;
                        if (!(stackKey in this.navigationStacks)) {
                            this.navigationStacks[stackKey] = this._createNavigationStack()
                        }
                        stack = this.navigationStacks[stackKey]
                    } else {
                        stack = stackOrStackKey;
                        stackKey = $.map(this.navigationStacks, function(stack, key) {
                            if (stack === stackOrStackKey) {
                                return key
                            }
                            return null
                        })[0]
                    }
                    this.currentStack = stack;
                    this.currentStackKey = stackKey
                },
                _getViewTargetStackKey: function(uri, isRoot) {
                    var result;
                    if (isRoot) {
                        if (void 0 !== this.navigationStacks[uri]) {
                            result = uri
                        } else {
                            for (var stackKey in this.navigationStacks) {
                                if (this.navigationStacks[stackKey].items[0].uri === uri) {
                                    result = stackKey;
                                    break
                                }
                            }
                            result = result || uri
                        }
                    } else {
                        result = this.currentStackKey || uri
                    }
                    return result
                },
                _updateHistory: function(uri, options) {
                    var isRoot = options.root,
                        forceIsRoot = isRoot,
                        forceToRoot = false,
                        previousStack = this.currentStack,
                        keepPositionInStack = void 0 !== options.keepPositionInStack ? options.keepPositionInStack : this._keepPositionInStack;
                    options.stack = options.stack || this._getViewTargetStackKey(uri, isRoot);
                    this._setCurrentStack(options.stack);
                    if (isRoot || !this.currentStack.items.length) {
                        forceToRoot = this.currentStack === previousStack;
                        forceIsRoot = true
                    }
                    if (isRoot && this.currentStack.items.length) {
                        if (!keepPositionInStack || forceToRoot) {
                            this.currentStack.currentIndex = 0;
                            if (this.currentItem().uri !== uri) {
                                this.currentStack.navigate(uri, true)
                            }
                        }
                        options.direction = options.direction || "none"
                    } else {
                        var prevIndex = this.currentStack.currentIndex,
                            prevItem = this.currentItem() || {};
                        switch (options.target) {
                            case NAVIGATION_TARGETS.blank:
                                this.currentStack.navigate(uri);
                                break;
                            case NAVIGATION_TARGETS.current:
                                this.currentStack.navigate(uri, true);
                                break;
                            case NAVIGATION_TARGETS.back:
                                if (this.currentStack.currentIndex > 0) {
                                    this.currentStack.back(uri)
                                } else {
                                    this.currentStack.navigate(uri, true)
                                }
                                break;
                            default:
                                throw errors.Error("E3006", options.target)
                        }
                        if (void 0 === options.direction) {
                            var indexDelta = this.currentStack.currentIndex - prevIndex;
                            if (indexDelta < 0) {
                                options.direction = this.currentStack.currentItem().backDirection || "backward"
                            } else {
                                if (indexDelta > 0 && this.currentStack.currentIndex > 0) {
                                    options.direction = "forward"
                                } else {
                                    options.direction = "none"
                                }
                            }
                        }
                        prevItem.backDirection = "forward" === options.direction ? "backward" : "none"
                    }
                    options.root = forceIsRoot;
                    this._currentItem = this.currentStack.currentItem();
                    this._syncUriWithCurrentNavigationItem()
                },
                _removeItems: function(items) {
                    var that = this;
                    $.each(items, function(index, item) {
                        that.fireEvent("itemRemoved", [item])
                    })
                },
                back: function(options) {
                    options = options || {};
                    var navigatingBackArgs = $.extend({
                        cancel: false
                    }, options);
                    this.fireEvent("navigatingBack", [navigatingBackArgs]);
                    if (navigatingBackArgs.cancel) {
                        this._syncUriWithCurrentNavigationItem();
                        return
                    }
                    var item = this.previousItem(navigatingBackArgs.stack);
                    if (item) {
                        this.navigate(item.uri, {
                            stack: navigatingBackArgs.stack,
                            target: NAVIGATION_TARGETS.back,
                            item: item
                        })
                    } else {
                        this.callBase()
                    }
                },
                rootUri: function() {
                    return this.currentStack.items.length ? this.currentStack.items[0].uri : this.callBase()
                },
                canBack: function(stackKey) {
                    var stack = stackKey ? this.navigationStacks[stackKey] : this.currentStack;
                    return stack.canBack()
                },
                saveState: function(storage) {
                    if (this.currentStack.items.length) {
                        var state = {
                            navigationStacks: {},
                            currentStackKey: this.currentStackKey
                        };
                        $.each(this.navigationStacks, function(stackKey, stack) {
                            var stackState = {};
                            state.navigationStacks[stackKey] = stackState;
                            stackState.currentIndex = stack.currentIndex;
                            stackState.items = $.map(stack.items, function(item) {
                                return {
                                    key: item.key,
                                    uri: item.uri
                                }
                            })
                        });
                        var json = JSON.stringify(state);
                        storage.setItem(this._stateStorageKey, json)
                    } else {
                        this.removeState(storage)
                    }
                },
                restoreState: function(storage) {
                    if (this.disableRestoreState) {
                        return
                    }
                    var json = storage.getItem(this._stateStorageKey);
                    if (json) {
                        try {
                            var that = this,
                                state = JSON.parse(json);
                            $.each(state.navigationStacks, function(stackKey, stackState) {
                                var stack = that._createNavigationStack();
                                that.navigationStacks[stackKey] = stack;
                                stack.currentIndex = stackState.currentIndex;
                                stack.items = $.map(stackState.items, function(item) {
                                    item.stack = stack;
                                    return item
                                })
                            });
                            this.currentStackKey = state.currentStackKey;
                            this.currentStack = this.navigationStacks[this.currentStackKey];
                            this._currentItem = this.currentStack.currentItem();
                            this._navigationDevice.setUri(this.currentItem().uri);
                            this._forceNavigate = true
                        } catch (e) {
                            this.removeState(storage);
                            throw errors.Error("E3007")
                        }
                    }
                },
                removeState: function(storage) {
                    storage.removeItem(this._stateStorageKey)
                },
                currentIndex: function() {
                    return this.currentStack.currentIndex
                },
                previousItem: function(stackKey) {
                    var stack = this.navigationStacks[stackKey] || this.currentStack;
                    return stack.previousItem()
                },
                getItemByIndex: function(index) {
                    return this.currentStack.items[index]
                },
                clearHistory: function() {
                    this._createNavigationStacks({
                        keepPositionInStack: this._keepPositionInStack
                    })
                },
                itemByKey: function(itemKey) {
                    var result;
                    $.each(this.navigationStacks, function(stackKey, stack) {
                        var item = stack.itemByKey(itemKey);
                        if (item) {
                            result = item;
                            return false
                        }
                    });
                    return result
                },
                currentItem: function(itemOrItemKey) {
                    var item;
                    if (arguments.length > 0) {
                        if ("string" === typeof itemOrItemKey) {
                            item = this.itemByKey(itemOrItemKey)
                        } else {
                            if ($.isPlainObject(itemOrItemKey)) {
                                item = itemOrItemKey
                            }
                        }
                        this.callBase(item)
                    } else {
                        return this.callBase()
                    }
                }
            });
            var NavigationStack = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.itemsRemoved = $.Callbacks();
                    this.clear()
                },
                currentItem: function(item) {
                    if (item) {
                        for (var i = 0; i < this.items.length; i++) {
                            if (item === this.items[i]) {
                                this.currentIndex = i;
                                break
                            }
                        }
                    } else {
                        return this.items[this.currentIndex]
                    }
                },
                previousItem: function() {
                    return this.items.length > 1 ? this.items[this.currentIndex - 1] : void 0
                },
                canBack: function() {
                    return this.currentIndex > 0
                },
                clear: function() {
                    this._deleteItems(this.items);
                    this.items = [];
                    this.currentIndex = -1
                },
                back: function(uri) {
                    this.currentIndex--;
                    if (this.currentIndex < 0) {
                        throw errors.Error("E3008")
                    }
                    var currentItem = this.currentItem();
                    if (currentItem.uri !== uri) {
                        this._updateItem(this.currentIndex, uri)
                    }
                },
                forward: function() {
                    this.currentIndex++;
                    if (this.currentIndex >= this.items.length) {
                        throw errors.Error("E3009")
                    }
                },
                navigate: function(uri, replaceCurrent) {
                    if (this.currentIndex < this.items.length && this.currentIndex > -1 && this.items[this.currentIndex].uri === uri) {
                        return
                    }
                    if (replaceCurrent && this.currentIndex > -1) {
                        this.currentIndex--
                    }
                    if (this.currentIndex + 1 < this.items.length && this.items[this.currentIndex + 1].uri === uri) {
                        this.currentIndex++
                    } else {
                        var toDelete = this.items.splice(this.currentIndex + 1, this.items.length - this.currentIndex - 1);
                        this.items.push({
                            stack: this
                        });
                        this.currentIndex++;
                        this._updateItem(this.currentIndex, uri);
                        this._deleteItems(toDelete)
                    }
                    return this.currentItem()
                },
                itemByKey: function(key) {
                    for (var i = 0; i < this.items.length; i++) {
                        var item = this.items[i];
                        if (item.key === key) {
                            return item
                        }
                    }
                },
                _updateItem: function(index, uri) {
                    var item = this.items[index];
                    item.uri = uri;
                    item.key = this.items[0].uri + "_" + index + "_" + uri
                },
                _deleteItems: function(items) {
                    if (items) {
                        this.itemsRemoved.fire(items)
                    }
                }
            });
            HistoryBasedNavigationManager.NAVIGATION_TARGETS = NAVIGATION_TARGETS;
            exports.HistoryBasedNavigationManager = HistoryBasedNavigationManager;
            exports.StackBasedNavigationManager = StackBasedNavigationManager;
            exports.NavigationStack = NavigationStack
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/framework/utils.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                KoTemplateProvider = __webpack_require__( /*! ../integration/knockout/template_provider */ 216);
            var mergeWithReplace = function(targetArray, arrayToMerge, needReplaceFn) {
                var result = [];
                for (var i = 0, length = targetArray.length; i < length; i++) {
                    if (!needReplaceFn(targetArray[i], arrayToMerge)) {
                        result.push(targetArray[i])
                    }
                }
                result.push.apply(result, arrayToMerge);
                return result
            };
            var prepareCommandToReplace = function(targetCommand, commandsToMerge) {
                var needToReplace = false;
                $.each(commandsToMerge, function(_, commandToMerge) {
                    var idEqual = targetCommand.option("id") === commandToMerge.option("id") && commandToMerge.option("id"),
                        behaviorEqual = targetCommand.option("behavior") === commandToMerge.option("behavior") && targetCommand.option("behavior");
                    needToReplace = idEqual || behaviorEqual;
                    if (behaviorEqual && null === commandToMerge.option("onExecute")) {
                        commandToMerge.option("onExecute", targetCommand.option("onExecute"))
                    }
                    if (needToReplace) {
                        targetCommand.element().remove();
                        return false
                    }
                });
                return needToReplace
            };
            var mergeCommands = function(targetCommands, commandsToMerge) {
                return mergeWithReplace(targetCommands, commandsToMerge, prepareCommandToReplace)
            };
            var resolvePropertyValue = function(command, containerOptions, propertyName, defaultValue) {
                var containerOption = containerOptions ? containerOptions[propertyName] : void 0,
                    defaultOption = void 0 === containerOption ? defaultValue : containerOption,
                    commandOption = command.option(propertyName);
                return void 0 === commandOption || commandOption === defaultValue ? defaultOption : commandOption
            };
            var resolveTextValue = function(command, containerOptions) {
                var showText = resolvePropertyValue(command, containerOptions, "showText"),
                    hasIcon = !!command.option("icon"),
                    titleValue = resolvePropertyValue(command, containerOptions, "title", "");
                return showText || !hasIcon ? titleValue : ""
            };
            var resolveIconValue = function(command, containerOptions) {
                var showIcon = resolvePropertyValue(command, containerOptions, "showIcon"),
                    hasText = !!command.option("title"),
                    iconValue = resolvePropertyValue(command, containerOptions, "icon", "");
                return showIcon || !hasText ? iconValue : ""
            };
            exports.utils = {
                mergeCommands: mergeCommands,
                commandToContainer: {
                    resolveIconValue: resolveIconValue,
                    resolveTextValue: resolveTextValue,
                    resolvePropertyValue: resolvePropertyValue
                }
            };
            exports.templateProvider = KoTemplateProvider
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/integration/knockout.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var ko = __webpack_require__( /*! knockout */ 40),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                compareVersion = __webpack_require__( /*! ../core/utils/version */ 56).compare;
            if (!ko) {
                return
            }
            if (compareVersion(ko.version, [2, 3]) < 0) {
                throw errors.Error("E0013")
            }
            __webpack_require__( /*! ./knockout/component_registrator */ 289);
            __webpack_require__( /*! ./knockout/event_registrator */ 292);
            __webpack_require__( /*! ./knockout/components */ 290);
            __webpack_require__( /*! ./knockout/validation */ 294);
            __webpack_require__( /*! ./knockout/variable_wrapper_utils */ 295);
            __webpack_require__( /*! ./knockout/clean_node */ 287);
            __webpack_require__( /*! ./knockout/clean_node_old */ 288)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/localization/globalize/core.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var Globalize = __webpack_require__( /*! globalize */ 46);
            if (!Globalize || !Globalize.load) {
                return
            }
            var likelySubtags = {
                supplemental: {
                    version: {
                        _cldrVersion: "28",
                        _unicodeVersion: "8.0.0",
                        _number: "$Revision: 11965 $"
                    },
                    likelySubtags: {
                        en: "en-Latn-US",
                        de: "de-Latn-DE",
                        ru: "ru-Cyrl-RU",
                        ja: "ja-Jpan-JP"
                    }
                }
            };
            Globalize.load(likelySubtags);
            Globalize.locale("en")
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!**********************************************!*\
      !*** ./Scripts/viz/series/scatter_series.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 167),
                _each = $.each,
                _extend = $.extend,
                _noop = $.noop,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _isString = commonUtils.isString,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _map = vizUtils.map,
                _normalizeEnum = vizUtils.normalizeEnum,
                math = Math,
                _floor = math.floor,
                _abs = math.abs,
                _sqrt = math.sqrt,
                _min = math.min,
                _max = math.max,
                DEFAULT_SYMBOL_POINT_SIZE = 2,
                DEFAULT_TRACKER_WIDTH = 12,
                DEFAULT_DURATION = 400,
                HIGH_ERROR = "highError",
                LOW_ERROR = "lowError",
                ORIGINAL = "original",
                VARIANCE = "variance",
                STANDARD_DEVIATION = "stddeviation",
                STANDARD_ERROR = "stderror",
                PERCENT = "percent",
                FIXED = "fixed",
                UNDEFINED = "undefined",
                DISCRETE = "discrete",
                LOGARITHMIC = "logarithmic",
                DATETIME = "datetime";
            exports.chart = {};
            exports.polar = {};

            function sum(array) {
                var result = 0;
                _each(array, function(_, value) {
                    result += value
                });
                return result
            }

            function isErrorBarTypeCorrect(type) {
                return -1 !== $.inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR])
            }

            function variance(array, expectedValue) {
                return sum(_map(array, function(value) {
                    return (value - expectedValue) * (value - expectedValue)
                })) / array.length
            }
            var baseScatterMethods = {
                _defaultDuration: DEFAULT_DURATION,
                _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
                _applyStyle: _noop,
                _updateOptions: _noop,
                _parseStyle: _noop,
                _prepareSegment: _noop,
                _drawSegment: _noop,
                _generateDefaultSegments: _noop,
                _prepareSeriesToDrawing: function() {
                    var that = this;
                    that._deleteOldAnimationMethods();
                    that._disposePoints(that._oldPoints);
                    that._oldPoints = null
                },
                _appendInGroup: function() {
                    this._group.append(this._extGroups.seriesGroup)
                },
                _createLegendState: function(styleOptions, defaultColor) {
                    return {
                        fill: styleOptions.color || defaultColor,
                        hatching: styleOptions.hatching
                    }
                },
                updateTemplateFieldNames: function() {
                    var that = this,
                        options = that._options;
                    options.valueField = that.getValueFields()[0] + that.name;
                    options.tagField = that.getTagField() + that.name
                },
                _applyElementsClipRect: function(settings) {
                    settings.clipId = this._paneClipRectID
                },
                _applyMarkerClipRect: function(settings) {
                    settings.clipId = this._forceClipping ? this._paneClipRectID : null
                },
                _createGroup: function(groupName, parent, target, settings) {
                    var group = parent[groupName] = parent[groupName] || this._renderer.g();
                    target && group.append(target);
                    settings && group.attr(settings)
                },
                _applyClearingSettings: function(settings) {
                    settings.opacity = null;
                    settings.scale = null;
                    if (this._options.rotated) {
                        settings.translateX = null
                    } else {
                        settings.translateY = null
                    }
                },
                _createGroups: function() {
                    var that = this;
                    that._createGroup("_markersGroup", that, that._group);
                    that._createGroup("_labelsGroup", that)
                },
                _setMarkerGroupSettings: function() {
                    var that = this,
                        settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
                    settings.class = "dxc-markers";
                    settings.opacity = 1;
                    that._applyMarkerClipRect(settings);
                    that._markersGroup.attr(settings)
                },
                _applyVisibleArea: function() {
                    var that = this,
                        visibleX = that.translators.x.getCanvasVisibleArea(),
                        visibleY = that.translators.y.getCanvasVisibleArea();
                    that._visibleArea = {
                        minX: visibleX.min,
                        maxX: visibleX.max,
                        minY: visibleY.min,
                        maxY: visibleY.max
                    }
                },
                areErrorBarsVisible: function() {
                    var errorBarOptions = this._options.valueErrorBar;
                    return errorBarOptions && this._errorBarsEnabled() && "none" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))
                },
                _createErrorBarGroup: function(animationEnabled) {
                    var settings, that = this,
                        errorBarOptions = that._options.valueErrorBar;
                    if (that.areErrorBarsVisible()) {
                        settings = {
                            "class": "dxc-error-bars",
                            stroke: errorBarOptions.color,
                            "stroke-width": errorBarOptions.lineWidth,
                            opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,
                            "stroke-linecap": "square",
                            sharp: true,
                            clipId: that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
                        };
                        that._createGroup("_errorBarGroup", that, that._group, settings)
                    }
                },
                _setGroupsSettings: function(animationEnabled) {
                    var that = this;
                    that._setMarkerGroupSettings();
                    that._setLabelGroupSettings(animationEnabled);
                    that._createErrorBarGroup(animationEnabled)
                },
                _getCreatingPointOptions: function() {
                    var defaultPointOptions, normalStyle, that = this,
                        creatingPointOptions = that._predefinedPointOptions;
                    if (!creatingPointOptions) {
                        defaultPointOptions = that._getPointOptions();
                        that._predefinedPointOptions = creatingPointOptions = _extend(true, {
                            styles: {}
                        }, defaultPointOptions);
                        normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
                        creatingPointOptions.styles = creatingPointOptions.styles || {};
                        creatingPointOptions.styles.normal = {
                            "stroke-width": normalStyle["stroke-width"],
                            r: normalStyle.r,
                            opacity: normalStyle.opacity
                        }
                    }
                    return creatingPointOptions
                },
                _getSpecialColor: function(mainSeriesColor) {
                    return mainSeriesColor
                },
                _getPointOptions: function() {
                    return this._parsePointOptions(this._preparePointOptions(), this._options.label)
                },
                _getOptionsForPoint: function() {
                    return this._options.point
                },
                _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                    var border = style.border || {};
                    return {
                        fill: style.color || defaultColor,
                        stroke: border.color || defaultBorderColor,
                        "stroke-width": border.visible ? border.width : 0,
                        r: style.size / 2 + (border.visible && 0 !== style.size ? ~~(border.width / 2) || 0 : 0)
                    }
                },
                _createPointStyles: function(pointOptions) {
                    var that = this,
                        mainPointColor = pointOptions.color || that._options.mainSeriesColor,
                        containerColor = that._options.containerBackgroundColor,
                        normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
                    normalStyle.visibility = pointOptions.visible ? "visible" : "hidden";
                    return {
                        normal: normalStyle,
                        hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor),
                        selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor)
                    }
                },
                _checkData: function(data) {
                    return _isDefined(data.argument) && void 0 !== data.value
                },
                getErrorBarRangeCorrector: function() {
                    var mode, func;
                    if (this.areErrorBarsVisible()) {
                        mode = _normalizeEnum(this._options.valueErrorBar.displayMode);
                        func = function(point) {
                            var lowError = point.lowError,
                                highError = point.highError;
                            switch (mode) {
                                case "low":
                                    return [lowError];
                                case "high":
                                    return [highError];
                                case "none":
                                    return [];
                                default:
                                    return [lowError, highError]
                            }
                        }
                    }
                    return func
                },
                _processRange: function(point, prevPoint, errorBarCorrector) {
                    rangeCalculator.processRange(this, point, prevPoint, errorBarCorrector)
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(this);
                    return this._rangeData
                },
                _getPointData: function(data, options) {
                    var pointData = {
                        value: data[options.valueField || "val"],
                        argument: data[options.argumentField || "arg"],
                        tag: data[options.tagField || "tag"]
                    };
                    this._fillErrorBars(data, pointData, options);
                    return pointData
                },
                _errorBarsEnabled: function() {
                    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME
                },
                _fillErrorBars: function(data, pointData, options) {
                    var errorBars = options.valueErrorBar;
                    if (this.areErrorBarsVisible()) {
                        pointData.lowError = data[errorBars.lowValueField || LOW_ERROR];
                        pointData.highError = data[errorBars.highValueField || HIGH_ERROR]
                    }
                },
                _drawPoint: function(options) {
                    var point = options.point;
                    if (point.isInVisibleArea()) {
                        point.clearVisibility();
                        point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);
                        this._drawnPoints.push(point)
                    } else {
                        point.setInvisibility()
                    }
                },
                _clearingAnimation: function(translators, drawComplete) {
                    var that = this,
                        params = {
                            opacity: .001
                        },
                        options = {
                            duration: that._defaultDuration,
                            partitionDuration: .5
                        };
                    that._labelsGroup && that._labelsGroup.animate(params, options, function() {
                        that._markersGroup && that._markersGroup.animate(params, options, drawComplete)
                    })
                },
                _animateComplete: function() {
                    var that = this,
                        animationSettings = {
                            duration: that._defaultDuration
                        };
                    that._labelsGroup && that._labelsGroup.animate({
                        opacity: 1
                    }, animationSettings);
                    that._errorBarGroup && that._errorBarGroup.animate({
                        opacity: that._options.valueErrorBar.opacity || 1
                    }, animationSettings)
                },
                _animate: function() {
                    var that = this,
                        lastPointIndex = that._drawnPoints.length - 1;
                    _each(that._drawnPoints || [], function(i, p) {
                        p.animate(i === lastPointIndex ? function() {
                            that._animateComplete()
                        } : void 0, {
                            translateX: p.x,
                            translateY: p.y
                        })
                    })
                },
                _getPointSize: function() {
                    return this._options.point.visible ? this._options.point.size : DEFAULT_SYMBOL_POINT_SIZE
                },
                _calcMedianValue: function(fusionPoints, valueField) {
                    var result, allValue = _map(fusionPoints, function(point) {
                        return _isDefined(point[valueField]) ? point[valueField] : null
                    });
                    allValue.sort(function(a, b) {
                        return a - b
                    });
                    result = allValue[_floor(allValue.length / 2)];
                    return _isDefined(result) ? result : null
                },
                _calcErrorBarValues: function(fusionPoints) {
                    if (!fusionPoints.length) {
                        return {}
                    }
                    var lowError, highError, lowValue = fusionPoints[0].lowError,
                        highValue = fusionPoints[0].highError,
                        i = 1,
                        length = fusionPoints.length;
                    for (i; i < length; i++) {
                        lowError = fusionPoints[i].lowError;
                        highError = fusionPoints[i].highError;
                        if (_isDefined(lowError) && _isDefined(highError)) {
                            lowValue = _min(lowError, lowValue);
                            highValue = _max(highError, highValue)
                        }
                    }
                    return {
                        low: lowValue,
                        high: highValue
                    }
                },
                _fusionPoints: function(fusionPoints, tick, index) {
                    var errorBarValues = this._calcErrorBarValues(fusionPoints);
                    return {
                        value: this._calcMedianValue(fusionPoints, "value"),
                        argument: tick,
                        tag: null,
                        index: index,
                        seriesName: this.name,
                        lowError: errorBarValues.low,
                        highError: errorBarValues.high
                    }
                },
                _endUpdateData: function() {
                    delete this._predefinedPointOptions
                },
                getArgumentField: function() {
                    return this._options.argumentField || "arg"
                },
                getValueFields: function() {
                    var lowValueField, highValueField, options = this._options,
                        errorBarsOptions = options.valueErrorBar,
                        valueFields = [options.valueField || "val"];
                    if (errorBarsOptions) {
                        lowValueField = errorBarsOptions.lowValueField;
                        highValueField = errorBarsOptions.highValueField;
                        _isString(lowValueField) && valueFields.push(lowValueField);
                        _isString(highValueField) && valueFields.push(highValueField)
                    }
                    return valueFields
                },
                _calculateErrorBars: function(data) {
                    if (!this.areErrorBarsVisible()) {
                        return
                    }
                    var value, valueArray, valueArrayLength, meanValue, processDataItem, that = this,
                        options = that._options,
                        errorBarsOptions = options.valueErrorBar,
                        errorBarType = _normalizeEnum(errorBarsOptions.type),
                        floatErrorValue = parseFloat(errorBarsOptions.value),
                        valueField = that.getValueFields()[0],
                        lowValueField = errorBarsOptions.lowValueField || LOW_ERROR,
                        highValueField = errorBarsOptions.highValueField || HIGH_ERROR,
                        addSubError = function(_i, item) {
                            value = item[valueField];
                            item[lowValueField] = value - floatErrorValue;
                            item[highValueField] = value + floatErrorValue
                        };
                    switch (errorBarType) {
                        case FIXED:
                            processDataItem = addSubError;
                            break;
                        case PERCENT:
                            processDataItem = function(_, item) {
                                value = item[valueField];
                                var error = value * floatErrorValue / 100;
                                item[lowValueField] = value - error;
                                item[highValueField] = value + error
                            };
                            break;
                        case UNDEFINED:
                            processDataItem = function(_, item) {
                                item[lowValueField] = item[ORIGINAL + lowValueField];
                                item[highValueField] = item[ORIGINAL + highValueField]
                            };
                            break;
                        default:
                            valueArray = _map(data, function(item) {
                                return _isDefined(item[valueField]) ? item[valueField] : null
                            });
                            valueArrayLength = valueArray.length;
                            floatErrorValue = floatErrorValue || 1;
                            switch (errorBarType) {
                                case VARIANCE:
                                    floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
                                    processDataItem = addSubError;
                                    break;
                                case STANDARD_DEVIATION:
                                    meanValue = sum(valueArray) / valueArrayLength;
                                    floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
                                    processDataItem = function(_, item) {
                                        item[lowValueField] = meanValue - floatErrorValue;
                                        item[highValueField] = meanValue + floatErrorValue
                                    };
                                    break;
                                case STANDARD_ERROR:
                                    floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
                                    processDataItem = addSubError
                            }
                    }
                    processDataItem && _each(data, processDataItem)
                },
                _beginUpdateData: function(data) {
                    this._calculateErrorBars(data)
                }
            };
            exports.chart = _extend({}, baseScatterMethods, {
                drawTrackers: function() {
                    var trackers, trackersGroup, that = this,
                        segments = that._segments || [],
                        rotated = that._options.rotated,
                        cat = [];
                    if (!that.isVisible()) {
                        return
                    }
                    if (segments.length) {
                        trackers = that._trackers = that._trackers || [];
                        trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
                            fill: "gray",
                            opacity: .001,
                            stroke: "gray",
                            "class": "dxc-trackers"
                        })).attr({
                            clipId: this._paneClipRectID || null
                        }).append(that._group);
                        _each(segments, function(i, segment) {
                            if (!trackers[i]) {
                                trackers[i] = that._drawTrackerElement(segment).data({
                                    "chart-data-series": that
                                }).append(trackersGroup)
                            } else {
                                that._updateTrackerElement(segment, trackers[i])
                            }
                        })
                    }
                    that._trackersTranslator = cat;
                    _each(that.getVisiblePoints(), function(_, p) {
                        var pointCoord = parseInt(rotated ? p.vy : p.vx);
                        if (!cat[pointCoord]) {
                            cat[pointCoord] = p
                        } else {
                            $.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]
                        }
                    })
                },
                getNeighborPoint: function(x, y) {
                    var minDistance, pCoord = this._options.rotated ? y : x,
                        nCoord = pCoord,
                        cat = this._trackersTranslator,
                        point = null,
                        oppositeCoord = this._options.rotated ? x : y,
                        oppositeCoordName = this._options.rotated ? "vx" : "vy";
                    if (this.isVisible() && cat) {
                        point = cat[pCoord];
                        do {
                            point = cat[nCoord] || cat[pCoord];
                            pCoord--;
                            nCoord++
                        } while ((pCoord >= 0 || nCoord < cat.length) && !point);
                        if ($.isArray(point)) {
                            minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
                            _each(point, function(i, p) {
                                var distance = _abs(p[oppositeCoordName] - oppositeCoord);
                                if (minDistance >= distance) {
                                    minDistance = distance;
                                    point = p
                                }
                            })
                        }
                    }
                    return point
                }
            });
            exports.polar = _extend({}, baseScatterMethods, {
                drawTrackers: function() {
                    exports.chart.drawTrackers.call(this);
                    var index, cat = this._trackersTranslator;
                    if (!this.isVisible()) {
                        return
                    }
                    _each(cat, function(i, category) {
                        if (category) {
                            index = i;
                            return false
                        }
                    });
                    cat[index + 360] = cat[index]
                },
                getNeighborPoint: function(x, y) {
                    var pos = this.translators.untranslate(x, y);
                    return exports.chart.getNeighborPoint.call(this, pos.phi, pos.r)
                },
                _applyVisibleArea: function() {
                    var that = this,
                        canvas = that.translators.canvas;
                    that._visibleArea = {
                        minX: canvas.left,
                        maxX: canvas.width - canvas.right,
                        minY: canvas.top,
                        maxY: canvas.height - canvas.bottom
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/translators/range.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _Range, $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _isDate = commonUtils.isDate,
                unique = __webpack_require__( /*! ../core/utils */ 6).unique,
                minSelector = "min",
                maxSelector = "max",
                minVisibleSelector = "minVisible",
                maxVisibleSelector = "maxVisible",
                baseSelector = "base",
                axisTypeSelector = "axisType";

            function otherLessThan(thisValue, otherValue) {
                return otherValue < thisValue
            }

            function otherGreaterThan(thisValue, otherValue) {
                return otherValue > thisValue
            }

            function compareAndReplace(thisValue, otherValue, setValue, compare) {
                var otherValueDefined = _isDefined(otherValue);
                if (_isDefined(thisValue)) {
                    if (otherValueDefined && compare(thisValue, otherValue)) {
                        setValue(otherValue)
                    }
                } else {
                    if (otherValueDefined) {
                        setValue(otherValue)
                    }
                }
            }
            _Range = exports.Range = function(range) {
                range && $.extend(this, range)
            };
            _Range.prototype = {
                constructor: _Range,
                addRange: function(otherRange) {
                    var that = this,
                        categories = that.categories,
                        otherCategories = otherRange.categories;
                    var compareAndReplaceByField = function(field, compare) {
                        compareAndReplace(that[field], otherRange[field], function(value) {
                            that[field] = value
                        }, compare)
                    };
                    var controlValuesByVisibleBounds = function(valueField, visibleValueField, compare) {
                        compareAndReplace(that[valueField], that[visibleValueField], function(value) {
                            _isDefined(that[valueField]) && (that[valueField] = value)
                        }, compare)
                    };
                    var checkField = function(field) {
                        that[field] = that[field] || otherRange[field]
                    };
                    if (commonUtils.isDefined(otherRange.stick)) {
                        that.stick = otherRange.stick
                    }
                    checkField("addSpiderCategory");
                    checkField("percentStick");
                    checkField("minSpaceCorrection");
                    checkField("maxSpaceCorrection");
                    checkField("invert");
                    checkField(axisTypeSelector);
                    checkField("dataType");
                    if ("logarithmic" === that[axisTypeSelector]) {
                        checkField(baseSelector)
                    } else {
                        that[baseSelector] = void 0
                    }
                    compareAndReplaceByField(minSelector, otherLessThan);
                    compareAndReplaceByField(maxSelector, otherGreaterThan);
                    if ("discrete" === that[axisTypeSelector]) {
                        checkField(minVisibleSelector);
                        checkField(maxVisibleSelector)
                    } else {
                        compareAndReplaceByField(minVisibleSelector, otherLessThan);
                        compareAndReplaceByField(maxVisibleSelector, otherGreaterThan)
                    }
                    compareAndReplaceByField("interval", otherLessThan);
                    controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
                    controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
                    controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
                    controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
                    if (void 0 === categories) {
                        that.categories = otherCategories
                    } else {
                        that.categories = otherCategories ? unique(categories.concat(otherCategories)) : categories
                    }
                    return that
                },
                isDefined: function() {
                    return _isDefined(this[minSelector]) && _isDefined(this[maxSelector]) || this.categories && this.categories.length
                },
                setStubData: function(dataType) {
                    var that = this,
                        year = (new Date).getYear() - 1,
                        isDate = "datetime" === dataType,
                        isCategories = "discrete" === that[axisTypeSelector];
                    if (isCategories) {
                        that.categories = ["0", "1", "2"]
                    } else {
                        that[minSelector] = isDate ? new Date(year, 0, 1) : 0;
                        that[maxSelector] = isDate ? new Date(year, 11, 31) : 10
                    }
                    that.stubData = true;
                    return that
                },
                correctValueZeroLevel: function() {
                    var that = this;
                    if ("logarithmic" === that[axisTypeSelector] || _isDate(that[maxSelector]) || _isDate(that[minSelector])) {
                        return that
                    }

                    function setZeroLevel(min, max) {
                        that[min] < 0 && that[max] < 0 && (that[max] = 0);
                        that[min] > 0 && that[max] > 0 && (that[min] = 0)
                    }
                    setZeroLevel(minSelector, maxSelector);
                    setZeroLevel(minVisibleSelector, maxVisibleSelector);
                    return that
                },
                checkZeroStick: function() {
                    var that = this;
                    if (that.min >= 0 && that.max >= 0) {
                        that.minStickValue = 0
                    } else {
                        if (that.min <= 0 && that.max <= 0) {
                            that.maxStickValue = 0
                        }
                    }
                    return that
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/viz/tree_map/common.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _patchFontOptions = __webpack_require__( /*! ../core/utils */ 6).patchFontOptions;

            function empty() {}
            exports.empty = empty;

            function createChainExecutor() {
                var chain = [];
                executeChain.add = function(item) {
                    chain.push(item)
                };
                return executeChain;

                function executeChain() {
                    var i, ii = chain.length;
                    for (i = 0; i < ii; ++i) {
                        chain[i].apply(this, arguments)
                    }
                }
            }
            exports.expand = function(target, name, expander) {
                var current = target[name];
                if (current.add) {
                    current.add(expander)
                } else {
                    if (current === empty) {
                        current = expander
                    } else {
                        current = createChainExecutor();
                        current.add(target[name]);
                        current.add(expander)
                    }
                }
                target[name] = current
            };
            exports.buildRectAppearance = function(option) {
                var border = option.border || {};
                return {
                    fill: option.color,
                    opacity: option.opacity,
                    stroke: border.color,
                    "stroke-width": border.width,
                    "stroke-opacity": border.opacity,
                    hatching: option.hatching
                }
            };
            exports.buildTextAppearance = function(options, filter) {
                return {
                    attr: options["stroke-width"] ? {
                        stroke: options.stroke,
                        "stroke-width": options["stroke-width"],
                        "stroke-opacity": options["stroke-opacity"],
                        filter: filter
                    } : {},
                    css: _patchFontOptions(options.font)
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************************!*\
      !*** ./Scripts/animation/transition_executor/transition_executor.js ***!
      \**********************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                fx = __webpack_require__( /*! ../fx */ 21),
                animationPresetsModule = __webpack_require__( /*! ../presets/presets */ 110);
            var directionPostfixes = {
                    forward: " dx-forward",
                    backward: " dx-backward",
                    none: " dx-no-direction",
                    undefined: " dx-no-direction"
                },
                DX_ANIMATING_CLASS = "dx-animating";
            var TransitionExecutor = Class.inherit({
                ctor: function() {
                    this._accumulatedDelays = {
                        enter: 0,
                        leave: 0
                    };
                    this._animations = [];
                    this.reset()
                },
                _createAnimations: function($elements, initialConfig, configModifier, type) {
                    var animationConfig, that = this,
                        result = [];
                    configModifier = configModifier || {};
                    animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
                    if (animationConfig) {
                        $elements.each(function() {
                            var animation = that._createAnimation($(this), animationConfig, configModifier);
                            if (animation) {
                                animation.element.addClass(DX_ANIMATING_CLASS);
                                animation.setup();
                                result.push(animation)
                            }
                        })
                    }
                    return result
                },
                _prepareElementAnimationConfig: function(config, configModifier, type) {
                    var result;
                    if ("string" === typeof config) {
                        var presetName = config;
                        config = animationPresetsModule.presets.getPreset(presetName)
                    }
                    if (!config) {
                        result = void 0
                    } else {
                        if ($.isFunction(config[type])) {
                            result = config[type]
                        } else {
                            result = $.extend({
                                skipElementInitialStyles: true,
                                cleanupWhen: this._completePromise
                            }, config, configModifier);
                            if (!result.type || "css" === result.type) {
                                var cssClass = "dx-" + type,
                                    extraCssClasses = (result.extraCssClasses ? " " + result.extraCssClasses : "") + directionPostfixes[result.direction];
                                result.type = "css";
                                result.from = (result.from || cssClass) + extraCssClasses;
                                result.to = result.to || cssClass + "-active"
                            }
                            result.staggerDelay = result.staggerDelay || 0;
                            result.delay = result.delay || 0;
                            if (result.staggerDelay) {
                                result.delay += this._accumulatedDelays[type];
                                this._accumulatedDelays[type] += result.staggerDelay
                            }
                        }
                    }
                    return result
                },
                _createAnimation: function($element, animationConfig, configModifier) {
                    var result;
                    if ($.isPlainObject(animationConfig)) {
                        result = fx.createAnimation($element, animationConfig)
                    } else {
                        if ($.isFunction(animationConfig)) {
                            result = animationConfig($element, configModifier)
                        }
                    }
                    return result
                },
                _startAnimations: function() {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++) {
                        animations[i].start()
                    }
                },
                _stopAnimations: function(jumpToEnd) {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++) {
                        animations[i].stop(jumpToEnd)
                    }
                },
                _clearAnimations: function() {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++) {
                        animations[i].element.removeClass(DX_ANIMATING_CLASS)
                    }
                    this._animations.length = 0
                },
                reset: function() {
                    this._accumulatedDelays.enter = 0;
                    this._accumulatedDelays.leave = 0;
                    this._clearAnimations();
                    this._completeDeferred = $.Deferred();
                    this._completePromise = this._completeDeferred.promise()
                },
                enter: function($elements, animationConfig, configModifier) {
                    var animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
                    this._animations.push.apply(this._animations, animations)
                },
                leave: function($elements, animationConfig, configModifier) {
                    var animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
                    this._animations.push.apply(this._animations, animations)
                },
                start: function() {
                    var result, that = this;
                    if (!this._animations.length) {
                        that.reset();
                        result = $.Deferred().resolve().promise()
                    } else {
                        var animationDeferreds = $.map(this._animations, function(animation) {
                            var result = $.Deferred();
                            animation.deferred.always(function() {
                                result.resolve()
                            });
                            return result.promise()
                        });
                        result = $.when.apply($, animationDeferreds).always(function() {
                            that._completeDeferred.resolve();
                            that.reset()
                        });
                        commonUtils.executeAsync(function() {
                            that._startAnimations()
                        })
                    }
                    return result
                },
                stop: function(jumpToEnd) {
                    this._stopAnimations(jumpToEnd)
                }
            });
            exports.TransitionExecutor = TransitionExecutor
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/core/component.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ./class */ 5),
                Action = __webpack_require__( /*! ./action */ 54),
                errors = __webpack_require__( /*! ./errors */ 10),
                coreDataUtils = __webpack_require__( /*! ./utils/data */ 16),
                commonUtils = __webpack_require__( /*! ./utils/common */ 2),
                EventsMixin = __webpack_require__( /*! ./events_mixin */ 32),
                publicComponentUtils = __webpack_require__( /*! ./utils/public_component */ 142),
                devices = __webpack_require__( /*! ./devices */ 7);
            var cachedGetters = {};
            var cachedSetters = {};
            var Component = Class.inherit({
                _setDeprecatedOptions: function() {
                    this._deprecatedOptions = {}
                },
                _getDeprecatedOptions: function() {
                    return this._deprecatedOptions
                },
                _getOptionAliasesByName: function(optionName) {
                    return $.map(this._deprecatedOptions, function(deprecate, aliasName) {
                        return optionName === deprecate.alias ? aliasName : void 0
                    })
                },
                _getDefaultOptions: function() {
                    return {
                        onInitialized: null,
                        onOptionChanged: null,
                        onDisposing: null,
                        defaultOptionsRules: null
                    }
                },
                _setDefaultOptions: function() {
                    this._options = this._getDefaultOptions()
                },
                _defaultOptionsRules: function() {
                    return []
                },
                _setOptionsByDevice: function(userRules) {
                    var rules = this._defaultOptionsRules();
                    if (this._customRules) {
                        rules = rules.concat(this._customRules)
                    }
                    if ($.isArray(userRules)) {
                        rules = rules.concat(userRules)
                    }
                    var rulesOptions = this._convertRulesToOptions(rules);
                    $.extend(true, this._options, rulesOptions);
                    for (var fieldName in this._optionsByReference) {
                        if (rulesOptions.hasOwnProperty(fieldName)) {
                            this._options[fieldName] = rulesOptions[fieldName]
                        }
                    }
                },
                _convertRulesToOptions: function(rules) {
                    var options = {};
                    var currentDevice = devices.current();
                    var deviceMatch = function(device, filter) {
                        filter = $.makeArray(filter);
                        return 1 === filter.length && $.isEmptyObject(filter[0]) || commonUtils.findBestMatches(device, filter).length > 0
                    };
                    for (var i = 0; i < rules.length; i++) {
                        var match, rule = rules[i],
                            deviceFilter = rule.device || {};
                        if ($.isFunction(deviceFilter)) {
                            match = deviceFilter(currentDevice)
                        } else {
                            match = deviceMatch(currentDevice, deviceFilter)
                        }
                        if (match) {
                            $.extend(options, rule.options)
                        }
                    }
                    return options
                },
                _isInitialOptionValue: function(name) {
                    var isCustomOption = this._customRules && this._convertRulesToOptions(this._customRules).hasOwnProperty(name);
                    var optionValue = this.option(name);
                    var initialOptionValue = this.initialOption(name);
                    var isInitialOption = $.isFunction(optionValue) && $.isFunction(optionValue) ? optionValue.toString() === initialOptionValue.toString() : optionValue === initialOptionValue;
                    return !isCustomOption && isInitialOption
                },
                _setOptionsByReference: function() {
                    this._optionsByReference = {}
                },
                _getOptionsByReference: function() {
                    return this._optionsByReference
                },
                ctor: function(options) {
                    this.NAME = this.constructor.publicName();
                    options = options || {};
                    this._options = {};
                    this._updateLockCount = 0;
                    this._optionChangedCallbacks = options._optionChangedCallbacks || $.Callbacks();
                    this._disposingCallbacks = options._disposingCallbacks || $.Callbacks();
                    this.beginUpdate();
                    try {
                        this._suppressDeprecatedWarnings();
                        this._setOptionsByReference();
                        this._setDeprecatedOptions();
                        this._setDefaultOptions();
                        this._setOptionsByDevice(options.defaultOptionsRules);
                        this._resumeDeprecatedWarnings();
                        this._initOptions(options)
                    } finally {
                        this.endUpdate()
                    }
                },
                _initOptions: function(options) {
                    this.option(options)
                },
                _optionValuesEqual: function(name, oldValue, newValue) {
                    oldValue = coreDataUtils.toComparable(oldValue, true);
                    newValue = coreDataUtils.toComparable(newValue, true);
                    if (oldValue && newValue && oldValue.jquery && newValue.jquery) {
                        return newValue.is(oldValue)
                    }
                    var oldValueIsNaN = oldValue !== oldValue,
                        newValueIsNaN = newValue !== newValue;
                    if (oldValueIsNaN && newValueIsNaN) {
                        return true
                    }
                    if (null === oldValue || "object" !== typeof oldValue) {
                        return oldValue === newValue
                    }
                    return false
                },
                _init: function() {
                    this._createOptionChangedAction();
                    this.on("disposing", function(args) {
                        this._disposingCallbacks.fireWith(this, [args])
                    })
                },
                _createOptionChangedAction: function() {
                    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
                        excludeValidators: ["disabled", "readOnly", "designMode"]
                    })
                },
                _createDisposingAction: function() {
                    this._disposingAction = this._createActionByOption("onDisposing", {
                        excludeValidators: ["disabled", "readOnly", "designMode"]
                    })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case "onDisposing":
                        case "onInitialized":
                            break;
                        case "onOptionChanged":
                            this._createOptionChangedAction();
                            break;
                        case "defaultOptionsRules":
                    }
                },
                _dispose: function() {
                    this._optionChangedCallbacks.empty();
                    this._createDisposingAction();
                    this._disposingAction();
                    this._disposeEvents();
                    this._disposed = true
                },
                instance: function() {
                    return this
                },
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
                    if (!this._updateLockCount) {
                        if (!this._initializing && !this._initialized) {
                            this._initializing = true;
                            try {
                                this._init()
                            } finally {
                                this._initializing = false;
                                this._updateLockCount++;
                                this._createActionByOption("onInitialized", {
                                    excludeValidators: ["disabled", "readOnly", "designMode"]
                                })();
                                this._updateLockCount--;
                                this._initialized = true
                            }
                        }
                    }
                },
                _logWarningIfDeprecated: function(option) {
                    var info = this._deprecatedOptions[option];
                    if (info && !this._deprecatedOptionsSuppressed) {
                        this._logDeprecatedWarning(option, info)
                    }
                },
                _logDeprecatedWarningCount: 0,
                _logDeprecatedWarning: function(option, info) {
                    var message = info.message || "Use the '" + info.alias + "' option instead";
                    errors.log("W0001", this.NAME, option, info.since, message);
                    ++this._logDeprecatedWarningCount
                },
                _suppressDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = true
                },
                _resumeDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = false
                },
                _optionChanging: $.noop,
                _notifyOptionChanged: function(option, value, previousValue) {
                    var that = this;
                    if (this._initialized) {
                        var optionNames = [option].concat(that._getOptionAliasesByName(option));
                        for (var i = 0; i < optionNames.length; i++) {
                            var name = optionNames[i],
                                args = {
                                    name: name.split(/[.\[]/)[0],
                                    fullName: name,
                                    value: value,
                                    previousValue: previousValue
                                };
                            that._optionChangedCallbacks.fireWith(that, [$.extend(that._defaultActionArgs(), args)]);
                            that._optionChangedAction($.extend({}, args));
                            if (!that._disposed) {
                                that._optionChanged(args)
                            }
                        }
                    }
                },
                initialOption: function(optionName) {
                    var currentOptions, currentInitialized = this._initialized;
                    if (!this._initialOptions) {
                        currentOptions = this._options;
                        this._options = {};
                        this._initialized = false;
                        this._setDefaultOptions();
                        this._setOptionsByDevice(currentOptions.defaultOptionsRules);
                        this._initialOptions = this._options;
                        this._options = currentOptions;
                        this._initialized = currentInitialized
                    }
                    return this._initialOptions[optionName]
                },
                _defaultActionConfig: function() {
                    return {
                        context: this,
                        component: this
                    }
                },
                _defaultActionArgs: function() {
                    return {
                        component: this
                    }
                },
                _createAction: function(actionSource, config) {
                    var action, that = this;
                    return function(e) {
                        if (!arguments.length) {
                            e = {}
                        }
                        if (e instanceof $.Event) {
                            throw Error("Action must be executed with jQuery.Event like action({ jQueryEvent: event })")
                        }
                        if (!$.isPlainObject(e)) {
                            e = {
                                actionValue: e
                            }
                        }
                        action = action || new Action(actionSource, $.extend(config, that._defaultActionConfig()));
                        return action.execute.call(action, $.extend(e, that._defaultActionArgs()))
                    }
                },
                _createActionByOption: function(optionName, config) {
                    var action, eventName, actionFunc, that = this;
                    var result = function() {
                        if (!eventName) {
                            config = config || {};
                            if ("string" !== typeof optionName) {
                                throw errors.Error("E0008")
                            }
                            if (0 === optionName.indexOf("on")) {
                                eventName = optionName.charAt(2).toLowerCase() + optionName.substr(3)
                            } else {
                                throw Error("The '" + optionName + "' option name should start with 'on' prefix")
                            }
                            actionFunc = that.option(optionName)
                        }
                        if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !that.hasEvent(eventName)) {
                            return
                        }
                        if (!action) {
                            var beforeExecute = config.beforeExecute;
                            config.beforeExecute = function(args) {
                                that.fireEvent(eventName, args.args);
                                beforeExecute && beforeExecute.apply(that, arguments)
                            };
                            that._suppressDeprecatedWarnings();
                            action = that._createAction(actionFunc, config);
                            that._resumeDeprecatedWarnings()
                        }
                        return action.apply(that, arguments)
                    };
                    var onActionCreated = that.option("onActionCreated") || $.noop;
                    result = onActionCreated(that, result, config) || result;
                    return result
                },
                isOptionDeprecated: function(name) {
                    var deprecatedOptions = this._getDeprecatedOptions();
                    return deprecatedOptions.hasOwnProperty(name)
                },
                option: function() {
                    var normalizeOptionName = function(that, name) {
                        var deprecate;
                        if (name) {
                            if (!that._cachedDeprecateNames) {
                                that._cachedDeprecateNames = [];
                                for (var optionName in that._deprecatedOptions) {
                                    that._cachedDeprecateNames.push(optionName)
                                }
                            }
                            for (var i = 0; i < that._cachedDeprecateNames.length; i++) {
                                if (that._cachedDeprecateNames[i] === name) {
                                    deprecate = that._deprecatedOptions[name];
                                    break
                                }
                            }
                            if (deprecate) {
                                that._logWarningIfDeprecated(name);
                                var alias = deprecate.alias;
                                if (alias) {
                                    name = alias
                                }
                            }
                        }
                        return name
                    };
                    var getPreviousName = function(fullName) {
                        var splittedNames = fullName.split(".");
                        splittedNames.pop();
                        return splittedNames.join(".")
                    };
                    var getFieldName = function(fullName) {
                        var splittedNames = fullName.split(".");
                        return splittedNames[splittedNames.length - 1]
                    };
                    var getOptionValue = function(options, name, unwrapObservables) {
                        var getter = cachedGetters[name];
                        if (!getter) {
                            getter = cachedGetters[name] = coreDataUtils.compileGetter(name)
                        }
                        return getter(options, {
                            functionsAsIs: true,
                            unwrapObservables: unwrapObservables
                        })
                    };
                    var clearOptionsField = function(options, name) {
                        delete options[name];
                        var previousFieldName = getPreviousName(name),
                            fieldName = getFieldName(name),
                            fieldObject = previousFieldName ? getOptionValue(options, previousFieldName, false) : options;
                        if (fieldObject) {
                            delete fieldObject[fieldName]
                        }
                    };
                    var setOptionsField = function(options, fullName, value) {
                        var fieldObject, fieldName = "";
                        do {
                            if (fieldName) {
                                fieldName = "." + fieldName
                            }
                            fieldName = getFieldName(fullName) + fieldName;
                            fullName = getPreviousName(fullName);
                            fieldObject = fullName ? getOptionValue(options, fullName, false) : options
                        } while (!fieldObject);
                        fieldObject[fieldName] = value
                    };
                    var normalizeOptionValue = function(that, options, name, value) {
                        if (name) {
                            var alias = normalizeOptionName(that, name);
                            if (alias && alias !== name) {
                                setOptionsField(options, alias, value);
                                clearOptionsField(options, name)
                            }
                        }
                    };
                    var prepareOption = function(that, options, name, value) {
                        if ($.isPlainObject(value)) {
                            for (var valueName in value) {
                                prepareOption(that, options, name + "." + valueName, value[valueName])
                            }
                        }
                        normalizeOptionValue(that, options, name, value)
                    };
                    var setOptionValue = function(that, name, value) {
                        if (!cachedSetters[name]) {
                            cachedSetters[name] = coreDataUtils.compileSetter(name)
                        }
                        cachedSetters[name](that._options, value, {
                            functionsAsIs: true,
                            merge: !that._getOptionsByReference()[name],
                            unwrapObservables: false
                        })
                    };
                    var setOption = function(that, name, value) {
                        var previousValue = getOptionValue(that._options, name, false);
                        if (that._optionValuesEqual(name, previousValue, value)) {
                            return
                        }
                        if (that._initialized) {
                            that._optionChanging(name, previousValue, value)
                        }
                        setOptionValue(that, name, value);
                        that._notifyOptionChanged(name, value, previousValue)
                    };
                    return function(options, value) {
                        var that = this,
                            name = options;
                        if (arguments.length < 2 && "object" !== $.type(name)) {
                            name = normalizeOptionName(that, name);
                            return getOptionValue(that._options, name)
                        }
                        if ("string" === typeof name) {
                            options = {};
                            options[name] = value
                        }
                        that.beginUpdate();
                        try {
                            var optionName;
                            for (optionName in options) {
                                prepareOption(that, options, optionName, options[optionName])
                            }
                            for (optionName in options) {
                                setOption(that, optionName, options[optionName])
                            }
                        } finally {
                            that.endUpdate()
                        }
                    }
                }()
            }).include(EventsMixin);
            Component.publicName = publicComponentUtils.getName;
            module.exports = Component
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!*************************************!*\
      !*** ./Scripts/core/utils/error.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                consoleUtils = __webpack_require__( /*! ./console */ 36),
                stringUtils = __webpack_require__( /*! ./string */ 26),
                version = __webpack_require__( /*! ../version */ 123);
            var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
            module.exports = function(baseErrors, errors) {
                var exports = {
                    ERROR_MESSAGES: $.extend(errors, baseErrors),
                    Error: function() {
                        return makeError($.makeArray(arguments))
                    },
                    log: function(id) {
                        var method = "log";
                        if (/^E\d+$/.test(id)) {
                            method = "error"
                        } else {
                            if (/^W\d+$/.test(id)) {
                                method = "warn"
                            }
                        }
                        consoleUtils.logger[method]("log" === method ? id : combineMessage($.makeArray(arguments)))
                    }
                };
                var combineMessage = function(args) {
                    var id = args[0];
                    args = args.slice(1);
                    return formatMessage(id, formatDetails(id, args))
                };
                var formatDetails = function(id, args) {
                    args = [exports.ERROR_MESSAGES[id]].concat(args);
                    return stringUtils.format.apply(this, args).replace(/\.*\s*?$/, "")
                };
                var formatMessage = function(id, details) {
                    return stringUtils.format.apply(this, ["{0} - {1}. See:\n{2}", id, details, ERROR_URL + id])
                };
                var makeError = function(args) {
                    var id, details, message;
                    id = args[0];
                    args = args.slice(1);
                    details = formatDetails(id, args);
                    message = formatMessage(id, details);
                    return $.extend(new Error(message), {
                        __id: id,
                        __details: details
                    })
                };
                return exports
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , ,
    /*!*****************************************!*\
      !*** ./Scripts/bundles/modules/core.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var DevExpress = window.DevExpress = window.DevExpress || {};
            DevExpress.clientExporter = __webpack_require__( /*! ../../client_exporter */ 138);
            DevExpress.VERSION = __webpack_require__( /*! ../../core/version */ 123);
            DevExpress.Class = __webpack_require__( /*! ../../core/class */ 5);
            DevExpress.DOMComponent = __webpack_require__( /*! ../../core/dom_component */ 39);
            DevExpress.Component = __webpack_require__( /*! ../../core/component */ 92);
            DevExpress.registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3);
            DevExpress.devices = __webpack_require__( /*! ../../core/devices */ 7);
            var errors = DevExpress.errors = __webpack_require__( /*! ../../core/errors */ 10);
            DevExpress.Color = __webpack_require__( /*! ../../color */ 55);
            var $ = __webpack_require__( /*! jquery */ 1);
            var compareVersions = __webpack_require__( /*! ../../core/utils/version */ 56).compare;
            if (compareVersions($.fn.jquery, [1, 10]) < 0) {
                throw errors.Error("E0012")
            }
            var animationFrame = __webpack_require__( /*! ../../animation/frame */ 75);
            /**
             * @name requestAnimationFrame
             * @publicName requestAnimationFrame(callback)
             * @type method
             * @deprecated utils_requestAnimationFrame
             */
            DevExpress.requestAnimationFrame = function() {
                errors.log("W0000", "DevExpress.requestAnimationFrame", "15.2", "Use the 'DevExpress.utils.requestAnimationFrame' method instead.");
                return animationFrame.requestAnimationFrame.apply(animationFrame, arguments)
            };
            DevExpress.cancelAnimationFrame = function() {
                errors.log("W0000", "DevExpress.cancelAnimationFrame", "15.2", "Use the 'DevExpress.utils.cancelAnimationFrame' method instead.");
                return animationFrame.cancelAnimationFrame.apply(animationFrame, arguments)
            };
            DevExpress.EventsMixin = __webpack_require__( /*! ../../core/events_mixin */ 32);
            DevExpress.utils = {};
            DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
            DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
            DevExpress.utils.initMobileViewport = __webpack_require__( /*! ../../mobile/init_mobile_viewport/init_mobile_viewport */ 218).initMobileViewport;
            DevExpress.utils.extendFromObject = __webpack_require__( /*! ../../core/utils/object */ 30).extendFromObject;
            DevExpress.utils.createComponents = __webpack_require__( /*! ../../core/utils/dom */ 11).createComponents;
            DevExpress.utils.triggerShownEvent = __webpack_require__( /*! ../../core/utils/dom */ 11).triggerShownEvent;
            DevExpress.utils.triggerHidingEvent = __webpack_require__( /*! ../../core/utils/dom */ 11).triggerHidingEvent;
            DevExpress.utils.resetActiveElement = __webpack_require__( /*! ../../core/utils/dom */ 11).resetActiveElement;
            DevExpress.utils.findBestMatches = __webpack_require__( /*! ../../core/utils/common */ 2).findBestMatches;
            DevExpress.createQueue = __webpack_require__( /*! ../../core/utils/queue */ 143).create;
            DevExpress.utils.dom = __webpack_require__( /*! ../../core/utils/dom */ 11);
            DevExpress.utils.common = __webpack_require__( /*! ../../core/utils/common */ 2);
            DevExpress.utils.date = __webpack_require__( /*! ../../core/utils/date */ 12);
            DevExpress.utils.browser = __webpack_require__( /*! ../../core/utils/browser */ 22);
            DevExpress.utils.inflector = __webpack_require__( /*! ../../core/utils/inflector */ 29);
            DevExpress.utils.resizeCallbacks = __webpack_require__( /*! ../../core/utils/window */ 57).resizeCallbacks;
            DevExpress.utils.console = __webpack_require__( /*! ../../core/utils/console */ 36);
            DevExpress.utils.string = __webpack_require__( /*! ../../core/utils/string */ 26);
            DevExpress.utils.support = __webpack_require__( /*! ../../core/utils/support */ 18);
            DevExpress.processHardwareBackButton = __webpack_require__( /*! ../../mobile/process_hardware_back_button */ 219);
            DevExpress.viewPort = __webpack_require__( /*! ../../core/utils/view_port */ 52).value;
            DevExpress.hideTopOverlay = __webpack_require__( /*! ../../mobile/hide_top_overlay */ 100);
            DevExpress.formatHelper = __webpack_require__( /*! ../../format_helper */ 68);
            var config = DevExpress.config = __webpack_require__( /*! ../../core/config */ 35);
            Object.defineProperty(DevExpress, "rtlEnabled", {
                get: function() {
                    errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
                    return config().rtlEnabled
                },
                set: function(value) {
                    errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
                    config({
                        rtlEnabled: value
                    })
                }
            });
            Object.defineProperty(DevExpress, "designMode", {
                get: function() {
                    return config().designMode
                },
                set: function(value) {
                    config({
                        designMode: value
                    })
                }
            });
            DevExpress.animationPresets = __webpack_require__( /*! ../../animation/presets/presets */ 110).presets;
            DevExpress.fx = __webpack_require__( /*! ../../animation/fx */ 21);
            DevExpress.TransitionExecutor = __webpack_require__( /*! ../../animation/transition_executor/transition_executor */ 91).TransitionExecutor;
            DevExpress.AnimationPresetCollection = __webpack_require__( /*! ../../animation/presets/presets */ 110).PresetCollection;
            module.exports = DevExpress.events = {};
            DevExpress.events.click = __webpack_require__( /*! ../../events/click */ 9);
            DevExpress.events.utils = __webpack_require__( /*! ../../events/utils */ 4);
            DevExpress.events.GestureEmitter = __webpack_require__( /*! ../../events/gesture/emitter.gesture */ 120);
            DevExpress.localization = {};
            DevExpress.localization.message = __webpack_require__( /*! ../../localization/message */ 8);
            DevExpress.localization.number = __webpack_require__( /*! ../../localization/number */ 38);
            DevExpress.localization.date = __webpack_require__( /*! ../../localization/date */ 14);
            __webpack_require__( /*! ../../localization/currency */ 117);
            module.exports = DevExpress
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/ui/widget/jquery.selectors.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__( /*! jquery */ 1)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {
            var focusable = function(element, tabIndex) {
                var nodeName = element.nodeName.toLowerCase(),
                    isTabIndexNotNaN = !isNaN(tabIndex),
                    isVisible = visible(element),
                    isDisabled = element.disabled,
                    isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName),
                    isHyperlink = "a" === nodeName,
                    isFocusable = true;
                if (isDefaultFocus) {
                    isFocusable = !isDisabled
                } else {
                    if (isHyperlink) {
                        isFocusable = element.href || isTabIndexNotNaN
                    } else {
                        isFocusable = isTabIndexNotNaN
                    }
                }
                return isVisible ? isFocusable : false
            };
            var visible = function(element) {
                var $element = $(element);
                return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility")
            };
            var icontains = function(elem, text) {
                var result = false;
                $.each($(elem).contents(), function(index, content) {
                    if (3 === content.nodeType && (content.textContent || content.nodeValue || "").toLowerCase().indexOf((text || "").toLowerCase()) > -1) {
                        result = true;
                        return false
                    }
                });
                return result
            };
            $.extend($.expr[":"], {
                "dx-focusable": function(element) {
                    return focusable(element, $.attr(element, "tabindex"))
                },
                "dx-tabbable": function(element) {
                    var tabIndex = $.attr(element, "tabindex");
                    return (isNaN(tabIndex) || tabIndex >= 0) && focusable(element, tabIndex)
                },
                "dx-icontains": $.expr.createPseudo(function(text) {
                    return function(elem) {
                        return icontains(elem, text)
                    }
                })
            });
            return {
                focusable: ":dx-focusable",
                tabbable: ":dx-tabbable",
                icontains: ":dx-icontains"
            }
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/ui/widget/ui.template.function.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
            var FunctionTemplate = TemplateBase.inherit({
                ctor: function(render, owner) {
                    this.callBase($(), owner);
                    this._render = render
                },
                _renderCore: function(data, index, container) {
                    return domUtils.normalizeTemplateElement(this._render(data, index, container))
                }
            });
            module.exports = FunctionTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/mobile/hide_top_overlay.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var hideCallback = function() {
                var callbacks = [];
                return {
                    add: function(callback) {
                        var indexOfCallback = $.inArray(callback, callbacks);
                        if (-1 === indexOfCallback) {
                            callbacks.push(callback)
                        }
                    },
                    remove: function(callback) {
                        var indexOfCallback = $.inArray(callback, callbacks);
                        if (-1 !== indexOfCallback) {
                            callbacks.splice(indexOfCallback, 1)
                        }
                    },
                    fire: function() {
                        var callback = callbacks.pop(),
                            result = !!callback;
                        if (result) {
                            callback()
                        }
                        return result
                    },
                    hasCallback: function() {
                        return callbacks.length > 0
                    },
                    reset: function() {
                        callbacks = []
                    }
                }
            }();
            module.exports = function() {
                return hideCallback.fire()
            };
            module.exports.hideCallback = hideCallback
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , ,
    /*!************************************************!*\
      !*** ./Scripts/viz/core/base_theme_manager.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                paletteModule = __webpack_require__( /*! ../palette */ 121),
                _isString = commonUtils.isString,
                _parseScalar = __webpack_require__( /*! ./utils */ 6).parseScalar,
                themeModule = __webpack_require__( /*! ../themes */ 69),
                _findTheme = themeModule.findTheme,
                _addCacheItem = themeModule.addCacheItem,
                _removeCacheItem = themeModule.removeCacheItem,
                _extend = $.extend,
                _each = $.each;
            __webpack_require__( /*! ./default */ 513);
            __webpack_require__( /*! ./ios */ 516);
            __webpack_require__( /*! ./android */ 512);
            __webpack_require__( /*! ./win */ 520);

            function getThemePart(theme, path) {
                var _theme = theme;
                path && _each(path.split("."), function(_, pathItem) {
                    return _theme = _theme[pathItem]
                });
                return _theme
            }
            exports.BaseThemeManager = Class.inherit({
                ctor: function() {
                    _addCacheItem(this)
                },
                dispose: function() {
                    var that = this;
                    _removeCacheItem(that);
                    that._callback = that._theme = that._font = null;
                    return that
                },
                setCallback: function(callback) {
                    this._callback = callback;
                    return this
                },
                setTheme: function(theme, rtl) {
                    this._current = theme;
                    this._rtl = rtl;
                    return this.refresh()
                },
                refresh: function() {
                    var that = this,
                        current = that._current || {},
                        theme = _findTheme(current.name || current);
                    that._themeName = theme.name;
                    that._defaultPalette = theme.defaultPalette;
                    that._font = _extend({}, theme.font, current.font);
                    that._themeSection && _each(that._themeSection.split("."), function(_, path) {
                        theme = _extend(true, {}, theme[path], that._IE8 ? theme[path + "IE8"] : {})
                    });
                    that._theme = _extend(true, {}, theme, _isString(current) ? {} : current);
                    that._initializeTheme();
                    if (_parseScalar(that._rtl, that._theme.rtlEnabled)) {
                        _extend(true, that._theme, that._theme._rtl)
                    }
                    that._callback();
                    return that
                },
                theme: function(path) {
                    return getThemePart(this._theme, path)
                },
                themeName: function() {
                    return this._themeName
                },
                createPalette: function(palette, options) {
                    return new paletteModule.Palette(palette || this._defaultPalette, options)
                },
                createDiscretePalette: function(palette, count) {
                    return new paletteModule.DiscretePalette(palette || this._defaultPalette, count)
                },
                createGradientPalette: function(palette) {
                    return new paletteModule.GradientPalette(palette || this._defaultPalette)
                },
                _initializeTheme: function() {
                    var that = this;
                    _each(that._fontFields || [], function(_, path) {
                        that._initializeFont(getThemePart(that._theme, path))
                    })
                },
                _initializeFont: function(font) {
                    _extend(font, this._font, _extend({}, font))
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/series/points/symbol_point.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                labelModule = __webpack_require__( /*! ./label */ 336),
                _extend = $.extend,
                _isDefined = commonUtils.isDefined,
                _normalizeEnum = __webpack_require__( /*! ../../core/utils */ 6).normalizeEnum,
                _math = Math,
                _round = _math.round,
                _floor = _math.floor,
                _ceil = _math.ceil,
                DEFAULT_IMAGE_WIDTH = 20,
                DEFAULT_IMAGE_HEIGHT = 20,
                LABEL_OFFSET = 10,
                CANVAS_POSITION_DEFAULT = "canvas_position_default";

            function getSquareMarkerCoords(radius) {
                return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius]
            }

            function getPolygonMarkerCoords(radius) {
                var r = _ceil(radius);
                return [-r, 0, 0, -r, r, 0, 0, r, -r, 0]
            }

            function getCrossMarkerCoords(radius) {
                var r = _ceil(radius),
                    floorHalfRadius = _floor(r / 2),
                    ceilHalfRadius = _ceil(r / 2);
                return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0]
            }

            function getTriangleDownMarkerCoords(radius) {
                return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius]
            }

            function getTriangleUpMarkerCoords(radius) {
                return [-radius, radius, radius, radius, 0, -radius, -radius, radius]
            }
            module.exports = {
                deleteLabel: function() {
                    this._label.dispose();
                    this._label = null
                },
                _hasGraphic: function() {
                    return this.graphic
                },
                clearVisibility: function() {
                    var that = this,
                        graphic = that.graphic;
                    if (graphic && graphic.attr("visibility")) {
                        graphic.attr({
                            visibility: null
                        })
                    }
                    that._label.clearVisibility()
                },
                isVisible: function() {
                    return this.inVisibleArea && this.series.isVisible()
                },
                setInvisibility: function() {
                    var that = this,
                        graphic = that.graphic;
                    if (graphic && "hidden" !== graphic.attr("visibility")) {
                        graphic.attr({
                            visibility: "hidden"
                        })
                    }
                    that._errorBar && that._errorBar.attr({
                        visibility: "hidden"
                    });
                    that._label.hide()
                },
                clearMarker: function() {
                    var graphic = this.graphic;
                    graphic && graphic.attr(this._emptySettings)
                },
                _createLabel: function() {
                    this._label = new labelModule.Label({
                        renderer: this.series._renderer,
                        labelsGroup: this.series._labelsGroup,
                        point: this
                    })
                },
                _updateLabelData: function() {
                    this._label.setData(this._getLabelFormatObject())
                },
                _updateLabelOptions: function() {
                    !this._label && this._createLabel();
                    this._label.setOptions(this._options.label)
                },
                _checkImage: function(image) {
                    return _isDefined(image) && ("string" === typeof image || _isDefined(image.url))
                },
                _fillStyle: function() {
                    this._styles = this._options.styles
                },
                _checkSymbol: function(oldOptions, newOptions) {
                    var oldSymbol = oldOptions.symbol,
                        newSymbol = newOptions.symbol,
                        symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol,
                        imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
                    return !!(symbolChanged || imageChanged)
                },
                _populatePointShape: function(symbol, radius) {
                    switch (symbol) {
                        case "square":
                            return getSquareMarkerCoords(radius);
                        case "polygon":
                            return getPolygonMarkerCoords(radius);
                        case "triangle":
                        case "triangleDown":
                            return getTriangleDownMarkerCoords(radius);
                        case "triangleUp":
                            return getTriangleUpMarkerCoords(radius);
                        case "cross":
                            return getCrossMarkerCoords(radius)
                    }
                },
                correctValue: function(correction) {
                    var that = this;
                    if (that.hasValue()) {
                        that.value = that.initialValue + correction;
                        that.minValue = correction;
                        that.translate()
                    }
                },
                resetCorrection: function() {
                    this.value = this.initialValue;
                    this.minValue = CANVAS_POSITION_DEFAULT
                },
                resetValue: function() {
                    var that = this;
                    if (that.hasValue()) {
                        that.value = that.initialValue = 0;
                        that.minValue = 0;
                        that.translate();
                        that._label.setDataField("value", that.value)
                    }
                },
                _getTranslates: function(animationEnabled) {
                    var translateX = this.x,
                        translateY = this.y;
                    if (animationEnabled) {
                        if (this._options.rotated) {
                            translateX = this.defaultX
                        } else {
                            translateY = this.defaultY
                        }
                    }
                    return {
                        x: translateX,
                        y: translateY
                    }
                },
                _createImageMarker: function(renderer, settings, options) {
                    var width = options.width || DEFAULT_IMAGE_WIDTH,
                        height = options.height || DEFAULT_IMAGE_HEIGHT;
                    return renderer.image(-_round(.5 * width), -_round(.5 * height), width, height, options.url ? options.url.toString() : options.toString(), "center").attr({
                        translateX: settings.translateX,
                        translateY: settings.translateY,
                        visibility: settings.visibility
                    })
                },
                _createSymbolMarker: function(renderer, pointSettings) {
                    var marker, symbol = this._options.symbol;
                    if ("circle" === symbol) {
                        delete pointSettings.points;
                        marker = renderer.circle().attr(pointSettings)
                    } else {
                        if ("square" === symbol || "polygon" === symbol || "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol || "cross" === symbol) {
                            marker = renderer.path([], "area").attr(pointSettings).sharp()
                        }
                    }
                    return marker
                },
                _createMarker: function(renderer, group, image, settings, animationEnabled) {
                    var that = this,
                        marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);
                    if (marker) {
                        marker.data({
                            "chart-data-point": that
                        }).append(group)
                    }
                    return marker
                },
                _getSymbolBbox: function(x, y, r) {
                    return {
                        x: x - r,
                        y: y - r,
                        width: 2 * r,
                        height: 2 * r
                    }
                },
                _getImageBbox: function(x, y) {
                    var image = this._options.image,
                        width = image.width || DEFAULT_IMAGE_WIDTH,
                        height = image.height || DEFAULT_IMAGE_HEIGHT;
                    return {
                        x: x - _round(width / 2),
                        y: y - _round(height / 2),
                        width: width,
                        height: height
                    }
                },
                _getGraphicBbox: function() {
                    var bbox, that = this,
                        options = that._options,
                        x = that.x,
                        y = that.y;
                    if (options.visible) {
                        bbox = that._checkImage(options.image) ? that._getImageBbox(x, y) : that._getSymbolBbox(x, y, options.styles.normal.r)
                    } else {
                        bbox = {
                            x: x,
                            y: y,
                            width: 0,
                            height: 0
                        }
                    }
                    return bbox
                },
                _isLabelInsidePoint: $.noop,
                _getShiftLabelCoords: function(label) {
                    var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));
                    return this._checkLabelPosition(label, coord)
                },
                _drawLabel: function() {
                    var that = this,
                        customVisibility = that._getCustomLabelVisibility(),
                        label = that._label;
                    if ((that.series.getLabelVisibility() || customVisibility) && that._showForZeroValues() && that.hasValue()) {
                        label.show()
                    } else {
                        label.hide()
                    }
                },
                correctLabelPosition: function(label) {
                    var coord, that = this;
                    if (!that._isLabelInsidePoint(label)) {
                        coord = that._getShiftLabelCoords(label);
                        label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
                        label.shift(_round(coord.x), _round(coord.y))
                    }
                },
                _showForZeroValues: function() {
                    return true
                },
                _getLabelConnector: function(pointPosition) {
                    var bbox = this._getGraphicBbox(pointPosition),
                        w2 = bbox.width / 2,
                        h2 = bbox.height / 2;
                    return {
                        x: bbox.x + w2,
                        y: bbox.y + h2,
                        r: this._options.visible ? Math.max(w2, h2) : 0
                    }
                },
                _getPositionFromLocation: function() {
                    return {
                        x: this.x,
                        y: this.y
                    }
                },
                _isPointInVisibleArea: function(visibleArea, graphicBbox) {
                    return visibleArea.minX <= graphicBbox.x + graphicBbox.width && visibleArea.maxX >= graphicBbox.x && visibleArea.minY <= graphicBbox.y + graphicBbox.height && visibleArea.maxY >= graphicBbox.y
                },
                _checkLabelPosition: function(label, coord) {
                    var that = this,
                        visibleArea = that._getVisibleArea(),
                        labelBbox = label.getBoundingRect(),
                        graphicBbox = that._getGraphicBbox(label.pointPosition),
                        offset = LABEL_OFFSET;
                    if (that._isPointInVisibleArea(visibleArea, graphicBbox)) {
                        if (!that._options.rotated) {
                            if (visibleArea.minX > coord.x) {
                                coord.x = visibleArea.minX
                            }
                            if (visibleArea.maxX < coord.x + labelBbox.width) {
                                coord.x = visibleArea.maxX - labelBbox.width
                            }
                            if (visibleArea.minY > coord.y) {
                                coord.y = graphicBbox.y + graphicBbox.height + offset
                            }
                            if (visibleArea.maxY < coord.y + labelBbox.height) {
                                coord.y = graphicBbox.y - labelBbox.height - offset
                            }
                        } else {
                            if (visibleArea.minX > coord.x) {
                                coord.x = graphicBbox.x + graphicBbox.width + offset
                            }
                            if (visibleArea.maxX < coord.x + labelBbox.width) {
                                coord.x = graphicBbox.x - offset - labelBbox.width
                            }
                            if (visibleArea.minY > coord.y) {
                                coord.y = visibleArea.minY
                            }
                            if (visibleArea.maxY < coord.y + labelBbox.height) {
                                coord.y = visibleArea.maxY - labelBbox.height
                            }
                        }
                    }
                    return coord
                },
                _addLabelAlignmentAndOffset: function(label, coord) {
                    var labelBBox = label.getBoundingRect(),
                        labelOptions = label.getLayoutOptions();
                    if (!this._options.rotated) {
                        if ("left" === labelOptions.alignment) {
                            coord.x += labelBBox.width / 2
                        } else {
                            if ("right" === labelOptions.alignment) {
                                coord.x -= labelBBox.width / 2
                            }
                        }
                    }
                    coord.x += labelOptions.horizontalOffset;
                    coord.y += labelOptions.verticalOffset;
                    return coord
                },
                _getLabelCoords: function(label) {
                    return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition))
                },
                _getLabelCoordOfPosition: function(label, position) {
                    var that = this,
                        labelBBox = label.getBoundingRect(),
                        graphicBbox = that._getGraphicBbox(label.pointPosition),
                        offset = LABEL_OFFSET,
                        centerY = graphicBbox.height / 2 - labelBBox.height / 2,
                        centerX = graphicBbox.width / 2 - labelBBox.width / 2,
                        x = graphicBbox.x,
                        y = graphicBbox.y;
                    switch (position) {
                        case "left":
                            x -= labelBBox.width + offset;
                            y += centerY;
                            break;
                        case "right":
                            x += graphicBbox.width + offset;
                            y += centerY;
                            break;
                        case "top":
                            x += centerX;
                            y -= labelBBox.height + offset;
                            break;
                        case "bottom":
                            x += centerX;
                            y += graphicBbox.height + offset;
                            break;
                        case "inside":
                            x += centerX;
                            y += centerY
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _drawMarker: function(renderer, group, animationEnabled) {
                    var that = this,
                        options = that._options,
                        translates = that._getTranslates(animationEnabled),
                        style = that._getStyle();
                    that.graphic = that._createMarker(renderer, group, options.image, _extend({
                        translateX: translates.x,
                        translateY: translates.y,
                        points: that._populatePointShape(options.symbol, style.r)
                    }, style), animationEnabled)
                },
                _getErrorBarSettings: function() {
                    return {
                        visibility: "visible"
                    }
                },
                _drawErrorBar: function(renderer, group) {
                    if (!this._options.errorBars) {
                        return
                    }
                    var settings, that = this,
                        options = that._options,
                        errorBarOptions = options.errorBars,
                        points = [],
                        pos = that._errorBarPos,
                        high = that._highErrorCoord,
                        low = that._lowErrorCoord,
                        displayMode = _normalizeEnum(errorBarOptions.displayMode),
                        isHighDisplayMode = "high" === displayMode,
                        isLowDisplayMode = "low" === displayMode,
                        edgeLength = _floor(parseInt(errorBarOptions.edgeLength) / 2),
                        highErrorOnly = (isHighDisplayMode || !_isDefined(low)) && _isDefined(high) && !isLowDisplayMode,
                        lowErrorOnly = (isLowDisplayMode || !_isDefined(high)) && _isDefined(low) && !isHighDisplayMode;
                    highErrorOnly && (low = that._baseErrorBarPos);
                    lowErrorOnly && (high = that._baseErrorBarPos);
                    if ("none" !== displayMode && _isDefined(high) && _isDefined(low) && _isDefined(pos)) {
                        !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
                        points.push([pos, high, pos, low]);
                        !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
                        options.rotated && $.each(points, function(_, p) {
                            p.reverse()
                        });
                        settings = that._getErrorBarSettings(errorBarOptions);
                        if (!that._errorBar) {
                            that._errorBar = renderer.path(points, "line").attr(settings).append(group)
                        } else {
                            settings.points = points;
                            that._errorBar.attr(settings)
                        }
                    } else {
                        that._errorBar && that._errorBar.attr({
                            visibility: "hidden"
                        })
                    }
                },
                getTooltipParams: function() {
                    var that = this,
                        graphic = that.graphic;
                    return {
                        x: that.x,
                        y: that.y,
                        offset: graphic ? graphic.getBBox().height / 2 : 0
                    }
                },
                setPercentValue: function(total, fullStacked, leftHoleTotal, rightHoleTotal) {
                    var that = this,
                        valuePercent = that.value / total || 0,
                        minValuePercent = that.minValue / total || 0,
                        percent = valuePercent - minValuePercent;
                    that._label.setDataField("percent", percent);
                    that._label.setDataField("total", total);
                    if (that.series.isFullStackedSeries() && that.hasValue()) {
                        if (that.leftHole) {
                            that.leftHole /= total - leftHoleTotal;
                            that.minLeftHole /= total - leftHoleTotal
                        }
                        if (that.rightHole) {
                            that.rightHole /= total - rightHoleTotal;
                            that.minRightHole /= total - rightHoleTotal
                        }
                        that.value = valuePercent;
                        that.minValue = !minValuePercent ? that.minValue : minValuePercent;
                        that.translate()
                    }
                },
                _storeTrackerR: function() {
                    var minTrackerSize, that = this,
                        navigator = window.navigator,
                        r = that._options.styles.normal.r;
                    navigator = that.__debug_navigator || navigator;
                    that.__debug_browserNavigator = navigator;
                    minTrackerSize = "ontouchstart" in window || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
                    that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
                    return that._options.trackerR
                },
                _translateErrorBars: function(valueTranslator) {
                    var that = this,
                        options = that._options,
                        rotated = options.rotated,
                        errorBars = options.errorBars;
                    if (!errorBars) {
                        return
                    }
                    _isDefined(that.lowError) && (that._lowErrorCoord = valueTranslator.translate(that.lowError));
                    _isDefined(that.highError) && (that._highErrorCoord = valueTranslator.translate(that.highError));
                    that._errorBarPos = _floor(rotated ? that.vy : that.vx);
                    that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy
                },
                _translate: function(translators) {
                    var valueTranslator, that = this;
                    if (that._options.rotated) {
                        valueTranslator = translators.x;
                        that.vx = that.x = valueTranslator.translate(that.value);
                        that.vy = that.y = translators.y.translate(that.argument);
                        that.minX = valueTranslator.translate(that.minValue);
                        that.defaultX = valueTranslator.translate(CANVAS_POSITION_DEFAULT);
                        that._translateErrorBars(valueTranslator)
                    } else {
                        valueTranslator = translators.y;
                        that.vy = that.y = valueTranslator.translate(that.value);
                        that.vx = that.x = translators.x.translate(that.argument);
                        that.minY = valueTranslator.translate(that.minValue);
                        that.defaultY = valueTranslator.translate(CANVAS_POSITION_DEFAULT);
                        that._translateErrorBars(valueTranslator)
                    }
                    that._calculateVisibility(that.x, that.y)
                },
                _updateData: function(data) {
                    var that = this;
                    that.value = that.initialValue = that.originalValue = data.value;
                    that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT
                },
                _getImageSettings: function(image) {
                    return {
                        href: image.url || image.toString(),
                        width: image.width || DEFAULT_IMAGE_WIDTH,
                        height: image.height || DEFAULT_IMAGE_HEIGHT
                    }
                },
                getCrosshairData: function() {
                    var that = this,
                        r = that._options.rotated,
                        value = that.value,
                        argument = that.argument;
                    return {
                        x: that.vx,
                        y: that.vy,
                        xValue: r ? value : argument,
                        yValue: r ? argument : value,
                        axis: that.series.axis
                    }
                },
                getPointRadius: function() {
                    var extraSpace, style = this._getStyle(),
                        options = this._options,
                        r = style.r,
                        symbol = options.symbol,
                        isSquare = "square" === symbol,
                        isTriangle = "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol;
                    if (options.visible && !options.image && r) {
                        extraSpace = style["stroke-width"] / 2;
                        return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace
                    }
                    return 0
                },
                _updateMarker: function(animationEnabled, style) {
                    var settings, that = this,
                        options = that._options,
                        image = options.image,
                        visibility = !that.isVisible() ? {
                            visibility: "hidden"
                        } : {};
                    style = style || that._getStyle();
                    if (that._checkImage(image)) {
                        settings = _extend({}, {
                            visibility: style.visibility
                        }, visibility, that._getImageSettings(image))
                    } else {
                        settings = _extend({}, style, visibility, {
                            points: that._populatePointShape(options.symbol, style.r)
                        })
                    }
                    if (!animationEnabled) {
                        settings.translateX = that.x;
                        settings.translateY = that.y
                    }
                    that.graphic.attr(settings).sharp()
                },
                _getLabelFormatObject: function() {
                    var that = this;
                    return {
                        argument: that.initialArgument,
                        value: that.initialValue,
                        originalArgument: that.originalArgument,
                        originalValue: that.originalValue,
                        seriesName: that.series.name,
                        lowErrorValue: that.lowError,
                        highErrorValue: that.highError,
                        point: that
                    }
                },
                _getLabelPosition: function() {
                    var rotated = this._options.rotated;
                    if (this.initialValue > 0) {
                        return rotated ? "right" : "top"
                    } else {
                        return rotated ? "left" : "bottom"
                    }
                },
                _getFormatObject: function(tooltip) {
                    var that = this,
                        labelFormatObject = that._label.getData();
                    return _extend({}, labelFormatObject, {
                        argumentText: tooltip.formatValue(that.initialArgument, "argument"),
                        valueText: tooltip.formatValue(that.initialValue)
                    }, _isDefined(labelFormatObject.percent) ? {
                        percentText: tooltip.formatValue(labelFormatObject.percent, "percent")
                    } : {}, _isDefined(labelFormatObject.total) ? {
                        totalText: tooltip.formatValue(labelFormatObject.total)
                    } : {})
                },
                _getMarkerVisibility: function() {
                    return this._options.visible
                },
                coordsIn: function(x, y) {
                    var trackerRadius = this._storeTrackerR();
                    return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/translators/translator2d.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _Translator2d, $ = __webpack_require__( /*! jquery */ 1),
                numericTranslator = __webpack_require__( /*! ./numeric_translator */ 237),
                categoryTranslator = __webpack_require__( /*! ./category_translator */ 554),
                intervalTranslator = __webpack_require__( /*! ./interval_translator */ 556),
                datetimeTranslator = __webpack_require__( /*! ./datetime_translator */ 555),
                logarithmicTranslator = __webpack_require__( /*! ./logarithmic_translator */ 557),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                getLog = vizUtils.getLog,
                getPower = vizUtils.getPower,
                isDefined = commonUtils.isDefined,
                _abs = Math.abs,
                CANVAS_PROP = ["width", "height", "left", "top", "bottom", "right"],
                NUMBER_EQUALITY_CORRECTION = 1,
                DATETIME_EQUALITY_CORRECTION = 6e4,
                _noop = $.noop,
                addInterval = __webpack_require__( /*! ../../core/utils/date */ 12).addInterval;
            var validateCanvas = function(canvas) {
                $.each(CANVAS_PROP, function(_, prop) {
                    canvas[prop] = parseInt(canvas[prop]) || 0
                });
                return canvas
            };
            var makeCategoriesToPoints = function(categories) {
                var categoriesToPoints = {},
                    length = categories.length,
                    i = 0;
                for (; i < length; i++) {
                    categoriesToPoints[categories[i]] = i
                }
                return categoriesToPoints
            };
            var validateBusinessRange = function(businessRange) {
                function validate(valueSelector, baseValueSelector) {
                    if (!isDefined(businessRange[valueSelector]) && isDefined(businessRange[baseValueSelector])) {
                        businessRange[valueSelector] = businessRange[baseValueSelector]
                    }
                }
                validate("minVisible", "min");
                validate("maxVisible", "max");
                return businessRange
            };

            function valuesIsDefinedAndEqual(val1, val2) {
                return isDefined(val1) && isDefined(val2) && val1.valueOf() === val2.valueOf()
            }

            function getCanvasBounds(range) {
                var newMin, newMax, min = range.min,
                    max = range.max,
                    minVisible = range.minVisible,
                    maxVisible = range.maxVisible,
                    base = range.base,
                    isDateTime = commonUtils.isDate(max) || commonUtils.isDate(min),
                    correction = isDateTime ? DATETIME_EQUALITY_CORRECTION : NUMBER_EQUALITY_CORRECTION,
                    isLogarithmic = "logarithmic" === range.axisType;
                if (isLogarithmic) {
                    maxVisible = getLog(maxVisible, base);
                    minVisible = getLog(minVisible, base);
                    min = getLog(min, base);
                    max = getLog(max, base)
                }
                if (valuesIsDefinedAndEqual(min, max)) {
                    newMin = min.valueOf() - correction;
                    newMax = max.valueOf() + correction;
                    if (isDateTime) {
                        min = new Date(newMin);
                        max = new Date(newMax)
                    } else {
                        min = 0 !== min || isLogarithmic ? newMin : 0;
                        max = newMax
                    }
                }
                if (valuesIsDefinedAndEqual(minVisible, maxVisible)) {
                    newMin = minVisible.valueOf() - correction;
                    newMax = maxVisible.valueOf() + correction;
                    if (isDateTime) {
                        minVisible = newMin < min.valueOf() ? min : new Date(newMin);
                        maxVisible = newMax > max.valueOf() ? max : new Date(newMax)
                    } else {
                        if (0 !== minVisible || isLogarithmic) {
                            minVisible = newMin < min ? min : newMin
                        }
                        maxVisible = newMax > max ? max : newMax
                    }
                }
                return {
                    base: base,
                    rangeMin: min,
                    rangeMax: max,
                    rangeMinVisible: minVisible,
                    rangeMaxVisible: maxVisible
                }
            }
            exports.Translator2D = _Translator2d = function(businessRange, canvas, options) {
                this.update(businessRange, canvas, options)
            };
            _Translator2d.prototype = {
                constructor: _Translator2d,
                reinit: function() {
                    var that = this,
                        range = that._businessRange,
                        categories = range.categories || [],
                        script = {},
                        canvasOptions = that._prepareCanvasOptions(),
                        visibleCategories = vizUtils.getCategoriesInfo(categories, range.minVisible, range.maxVisible).categories,
                        categoriesLength = (visibleCategories || categories).length;
                    switch (range.axisType) {
                        case "logarithmic":
                            script = logarithmicTranslator;
                            break;
                        case "semidiscrete":
                            script = intervalTranslator;
                            canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (addInterval(canvasOptions.rangeMaxVisible, that._options.interval) - canvasOptions.rangeMinVisible);
                            break;
                        case "discrete":
                            script = categoryTranslator;
                            that._categories = categories;
                            canvasOptions.interval = that._getDiscreteInterval(range.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
                            that._categoriesToPoints = makeCategoriesToPoints(categories, canvasOptions.invert);
                            if (visibleCategories && categoriesLength) {
                                canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0]];
                                that.visibleCategories = visibleCategories
                            }
                            break;
                        default:
                            if ("datetime" === range.dataType) {
                                script = datetimeTranslator
                            } else {
                                script = numericTranslator
                            }
                    }
                    $.extend(that, script);
                    that._conversionValue = that._options.conversionValue ? function(value) {
                        return value
                    } : function(value) {
                        return Math.round(value)
                    };
                    that._calculateSpecialValues()
                },
                _getDiscreteInterval: function(categoriesLength, canvasOptions) {
                    var correctedCategoriesCount = categoriesLength - (this._businessRange.stick ? 1 : 0);
                    return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength
                },
                _prepareCanvasOptions: function() {
                    var length, that = this,
                        businessRange = that._businessRange,
                        canvasOptions = that._canvasOptions = getCanvasBounds(businessRange),
                        canvas = that._canvas;
                    if (that._options.isHorizontal) {
                        canvasOptions.startPoint = canvas.left;
                        length = canvas.width;
                        canvasOptions.endPoint = canvas.width - canvas.right;
                        canvasOptions.invert = businessRange.invert
                    } else {
                        canvasOptions.startPoint = canvas.top;
                        length = canvas.height;
                        canvasOptions.endPoint = canvas.height - canvas.bottom;
                        canvasOptions.invert = !businessRange.invert
                    }
                    that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
                    canvasOptions.rangeDoubleError = Math.pow(10, getPower(canvasOptions.rangeMax - canvasOptions.rangeMin) - getPower(length) - 2);
                    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
                    return canvasOptions
                },
                updateCanvas: function(canvas) {
                    this._canvas = validateCanvas(canvas);
                    this.reinit()
                },
                updateBusinessRange: function(businessRange) {
                    this._businessRange = validateBusinessRange(businessRange);
                    this.reinit()
                },
                update: function(businessRange, canvas, options) {
                    var that = this;
                    that._options = $.extend(that._options || {}, options);
                    that._canvas = validateCanvas(canvas);
                    that.updateBusinessRange(businessRange)
                },
                getBusinessRange: function() {
                    return this._businessRange
                },
                getCanvasVisibleArea: function() {
                    return {
                        min: this._canvasOptions.startPoint,
                        max: this._canvasOptions.endPoint
                    }
                },
                _calculateSpecialValues: function() {
                    var invert, canvas_position_default, canvas_position_center_middle, that = this,
                        canvasOptions = that._canvasOptions,
                        startPoint = canvasOptions.startPoint,
                        endPoint = canvasOptions.endPoint,
                        range = that._businessRange,
                        minVisible = range.minVisible,
                        maxVisible = range.maxVisible;
                    if (minVisible <= 0 && maxVisible >= 0) {
                        that.sc = {};
                        canvas_position_default = that.translate(0)
                    } else {
                        invert = range.invert ^ (minVisible <= 0 && maxVisible <= 0);
                        if (that._options.isHorizontal) {
                            canvas_position_default = invert ? endPoint : startPoint
                        } else {
                            canvas_position_default = invert ? startPoint : endPoint
                        }
                    }
                    canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
                    that.sc = {
                        canvas_position_default: canvas_position_default,
                        canvas_position_left: startPoint,
                        canvas_position_top: startPoint,
                        canvas_position_center: canvas_position_center_middle,
                        canvas_position_middle: canvas_position_center_middle,
                        canvas_position_right: endPoint,
                        canvas_position_bottom: endPoint,
                        canvas_position_start: canvasOptions.invert ? endPoint : startPoint,
                        canvas_position_end: canvasOptions.invert ? startPoint : endPoint
                    }
                },
                translateSpecialCase: function(value) {
                    return this.sc[value]
                },
                _calculateProjection: function(distance) {
                    var canvasOptions = this._canvasOptions;
                    return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance
                },
                _calculateUnProjection: function(distance) {
                    var canvasOptions = this._canvasOptions;
                    return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance
                },
                getVisibleCategories: function() {
                    return this.visibleCategories
                },
                getMinBarSize: function(minBarSize) {
                    var visibleArea = this.getCanvasVisibleArea(),
                        minValue = this.untranslate(visibleArea.min + minBarSize);
                    return _abs(this.untranslate(visibleArea.min) - (!isDefined(minValue) ? this.untranslate(visibleArea.max) : minValue))
                },
                translate: _noop,
                untranslate: _noop,
                getInterval: _noop,
                zoom: _noop,
                getMinScale: _noop,
                getRange: function() {
                    return [this.untranslate(this._canvasOptions.startPoint, -1), this.untranslate(this._canvasOptions.endPoint, 1)]
                },
                isEmptyValueRange: function() {
                    return this._businessRange.stubData
                },
                getScreenRange: function() {
                    return [this._canvasOptions.startPoint, this._canvasOptions.endPoint]
                },
                add: function(value, diff, dir) {
                    return this._add(value, diff, (this._businessRange.invert ? -1 : 1) * dir)
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/viz/tree_map/colorizing.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var defaultColorizerName, _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _noop = __webpack_require__( /*! jquery */ 1).noop,
                colorizers = {};

            function wrapLeafColorGetter(getter) {
                return function(node) {
                    return !node.isNode() ? getter(node) : void 0
                }
            }

            function wrapGroupColorGetter(getter) {
                return function(node) {
                    var parent = !node.isNode() && node.parent;
                    return parent ? parent._groupColor = parent._groupColor || getter(parent) : void 0
                }
            }
            exports.getColorizer = function(options, themeManager, root) {
                var type = _normalizeEnum(options.type || defaultColorizerName),
                    colorizer = colorizers[type] && colorizers[type](options, themeManager, root);
                return colorizer ? (options.colorizeGroups ? wrapGroupColorGetter : wrapLeafColorGetter)(colorizer) : _noop
            };
            exports.addColorizer = function(name, colorizer) {
                colorizers[name] = colorizer
            };
            exports.setDefaultColorizer = function(name) {
                defaultColorizerName = name
            };

            function getValueAsColorCode(node) {
                return node.value
            }

            function createColorCodeGetter(colorCodeField) {
                return function(node) {
                    return Number(node.data[colorCodeField])
                }
            }
            exports.createColorCodeGetter = function(options) {
                return options.colorCodeField ? createColorCodeGetter(options.colorCodeField) : getValueAsColorCode
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/viz/tree_map/tiling.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var defaultAlgorithm, _isFunction = __webpack_require__( /*! ../../core/utils/common */ 2).isFunction,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _round = Math.round,
                algorithms = {};
            exports.getAlgorithm = function(value) {
                return algorithms[_normalizeEnum(value)] || _isFunction(value) && value || defaultAlgorithm
            };
            exports.addAlgorithm = function(name, callback) {
                algorithms[name] = callback
            };
            exports.setDefaultAlgorithm = function(name) {
                defaultAlgorithm = algorithms[name]
            };
            var directionToIndexOffsets = {};
            directionToIndexOffsets[-1] = [2, 0];
            directionToIndexOffsets[1] = [0, 2];
            exports.buildSidesData = function(rect, directions, _staticSideIndex) {
                var sides = [rect[2] - rect[0], rect[3] - rect[1]],
                    staticSideIndex = void 0 !== _staticSideIndex ? _staticSideIndex : sides[0] < sides[1] ? 0 : 1,
                    variedSideIndex = 1 - staticSideIndex,
                    staticSideDirection = directions[staticSideIndex],
                    variedSideDirection = directions[variedSideIndex],
                    staticSideIndexOffsets = directionToIndexOffsets[staticSideDirection],
                    variedSideIndexOffsets = directionToIndexOffsets[variedSideDirection];
                return {
                    staticSide: sides[staticSideIndex],
                    variedSide: sides[variedSideIndex],
                    static1: staticSideIndex + staticSideIndexOffsets[0],
                    static2: staticSideIndex + staticSideIndexOffsets[1],
                    varied1: variedSideIndex + variedSideIndexOffsets[0],
                    varied2: variedSideIndex + variedSideIndexOffsets[1],
                    staticDir: staticSideDirection,
                    variedDir: variedSideDirection
                }
            };
            exports.calculateRectangles = function(nodes, head, totalRect, sidesData, rowData) {
                var i, ii, rect, delta, variedSidePart = [0, 0, 0, 0],
                    static1 = sidesData.static1,
                    static2 = sidesData.static2,
                    position = totalRect[static1],
                    dir = sidesData.staticDir,
                    side = sidesData.staticSide,
                    sum = rowData.sum;
                variedSidePart[sidesData.varied1] = totalRect[sidesData.varied1];
                variedSidePart[sidesData.varied2] = totalRect[sidesData.varied1] + sidesData.variedDir * rowData.side;
                for (i = head, ii = head + rowData.count; i < ii; ++i) {
                    rect = variedSidePart.slice();
                    rect[static1] = position;
                    delta = _round(side * nodes[i].value / sum) || 0;
                    sum -= nodes[i].value;
                    side -= delta;
                    position += dir * delta;
                    rect[static2] = position;
                    nodes[i].rect = rect
                }
                totalRect[sidesData.varied1] = variedSidePart[sidesData.varied2]
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!*****************************************!*\
      !*** ./Scripts/viz/core/base_widget.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                version = __webpack_require__( /*! ../../core/version */ 123),
                _windowResizeCallbacks = __webpack_require__( /*! ../../core/utils/window */ 57).resizeCallbacks,
                _stringFormat = __webpack_require__( /*! ../../core/utils/string */ 26).format,
                _isObject = __webpack_require__( /*! ../../core/utils/common */ 2).isObject,
                _Number = Number,
                DOMComponent = __webpack_require__( /*! ../../core/dom_component */ 39),
                helpers = __webpack_require__( /*! ./helpers */ 515),
                _parseScalar = __webpack_require__( /*! ./utils */ 6).parseScalar,
                errors = __webpack_require__( /*! ./errors_warnings */ 514),
                _log = errors.log,
                rendererModule = __webpack_require__( /*! ./renderers/renderer */ 176),
                _Layout = __webpack_require__( /*! ./layout */ 517),
                OPTION_RTL_ENABLED = "rtlEnabled",
                _option = DOMComponent.prototype.option;

            function getTrue() {
                return true
            }

            function getFalse() {
                return false
            }

            function areCanvasesDifferent(canvas1, canvas2) {
                return !(canvas1.width === canvas2.width && canvas1.height === canvas2.height && canvas1.left === canvas2.left && canvas1.top === canvas2.top && canvas1.right === canvas2.right && canvas1.bottom === canvas2.bottom)
            }

            function createResizeHandler(callback) {
                var timeout, handler = function() {
                    clearTimeout(timeout);
                    timeout = setTimeout(callback, 100)
                };
                handler.dispose = function() {
                    clearTimeout(timeout);
                    return this
                };
                return handler
            }

            function defaultOnIncidentOccurred(e) {
                _log.apply(null, [e.target.id].concat(e.target.args || []))
            }
            var createIncidentOccurred = function(widgetName, eventTrigger) {
                return incidentOccurred;

                function incidentOccurred(id, args) {
                    eventTrigger("incidentOccurred", {
                        target: {
                            id: id,
                            type: "E" === id[0] ? "error" : "warning",
                            args: args,
                            text: _stringFormat.apply(null, [errors.ERROR_MESSAGES[id]].concat(args || [])),
                            widget: widgetName,
                            version: version
                        }
                    })
                }
            };

            function pickPositiveValue(value, defaultValue) {
                return _Number(value > 0 ? value : defaultValue || 0)
            }
            module.exports = DOMComponent.inherit({
                _eventsMap: {
                    onIncidentOccurred: {
                        name: "incidentOccurred"
                    },
                    onDrawn: {
                        name: "drawn",
                        config: {
                            category: "rendering"
                        }
                    }
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        onIncidentOccurred: defaultOnIncidentOccurred
                    })
                },
                _useLinks: true,
                _init: function() {
                    var linkTarget, that = this;
                    that.callBase.apply(that, arguments);
                    that._changesLocker = 0;
                    that._changes = helpers.changes();
                    that._suspendChanges();
                    that._themeManager = that._createThemeManager();
                    that._themeManager.setCallback(function() {
                        that._requestChange(that._themeDependentChanges)
                    });
                    that._initRenderer();
                    linkTarget = that._useLinks && that._renderer.root;
                    linkTarget && linkTarget.enableLinks().virtualLink("core").virtualLink("peripheral");
                    that._renderVisibilityChange();
                    that._initEventTrigger();
                    that._incidentOccurred = createIncidentOccurred(that.NAME, that._eventTrigger);
                    that._layout = new _Layout;
                    linkTarget && linkTarget.linkAfter("core");
                    that._initPlugins();
                    that._initCore();
                    linkTarget && linkTarget.linkAfter();
                    that._change(that._initialChanges);
                    that._resumeChanges()
                },
                _initialChanges: ["LAYOUT", "RESIZE_HANDLER", "THEME"],
                _initPlugins: function() {
                    var that = this;
                    $.each(that._plugins, function(_, plugin) {
                        plugin.init.call(that)
                    })
                },
                _disposePlugins: function() {
                    var that = this;
                    $.each(that._plugins.slice().reverse(), function(_, plugin) {
                        plugin.dispose.call(that)
                    })
                },
                _change: function(codes) {
                    this._changes.add(codes)
                },
                _suspendChanges: function() {
                    ++this._changesLocker
                },
                _resumeChanges: function() {
                    var that = this;
                    if (0 === --that._changesLocker && that._changes.count() > 0) {
                        that._renderer.lock();
                        that._applyingChanges = true;
                        that._applyChanges();
                        that._changes.reset();
                        that._applyingChanges = false;
                        that._renderer.unlock();
                        if (that._optionsQueue) {
                            that._applyQueuedOptions()
                        }
                    }
                },
                _applyQueuedOptions: function() {
                    var that = this,
                        queue = that._optionsQueue;
                    that._optionsQueue = null;
                    that.beginUpdate();
                    $.each(queue, function(_, args) {
                        _option.apply(that, args)
                    });
                    that.endUpdate()
                },
                _requestChange: function(codes) {
                    var applyingChanges = this._applyingChanges;
                    if (!applyingChanges) {
                        this._suspendChanges()
                    }
                    this._change(codes);
                    if (!applyingChanges) {
                        this._resumeChanges()
                    }
                },
                _applyChanges: function() {
                    var i, that = this,
                        changes = that._changes,
                        order = that._totalChangesOrder,
                        ii = order.length;
                    for (i = 0; i < ii; ++i) {
                        if (changes.has(order[i])) {
                            that["_change_" + order[i]]()
                        }
                    }
                },
                _optionChangesOrder: ["EVENTS", "THEME", "RENDERER", "RESIZE_HANDLER"],
                _layoutChangesOrder: ["CONTAINER_SIZE", "LAYOUT"],
                _customChangesOrder: [],
                _change_EVENTS: function() {
                    this._eventTrigger.applyChanges()
                },
                _change_THEME: function() {
                    this._setThemeAndRtl()
                },
                _change_RENDERER: function() {
                    this._setRendererOptions()
                },
                _change_RESIZE_HANDLER: function() {
                    this._setupResizeHandler()
                },
                _change_CONTAINER_SIZE: function() {
                    this._updateSize()
                },
                _change_LAYOUT: function() {
                    this._setContentSize()
                },
                _themeDependentChanges: ["RENDERER"],
                _initRenderer: function() {
                    var that = this;
                    that._canvas = that._calculateCanvas();
                    that._renderer = new rendererModule.Renderer({
                        cssClass: that._rootClassPrefix + " " + that._rootClass,
                        pathModified: that.option("pathModified"),
                        container: that._$element[0]
                    });
                    that._renderer.resize(that._canvas.width, that._canvas.height)
                },
                _disposeRenderer: function() {
                    this._useLinks && this._renderer.root.checkLinks();
                    this._renderer.dispose()
                },
                _getAnimationOptions: $.noop,
                render: function() {
                    this._requestChange(["CONTAINER_SIZE"]);
                    this._onRender()
                },
                _onRender: $.noop,
                _dispose: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._removeResizeHandler();
                    that._layout.dispose();
                    that._eventTrigger.dispose();
                    that._disposeCore();
                    that._disposePlugins();
                    that._disposeRenderer();
                    that._themeManager.dispose();
                    that._themeManager = that._renderer = that._eventTrigger = null
                },
                _initEventTrigger: function() {
                    var that = this;
                    that._eventTrigger = createEventTrigger(that._eventsMap, function(name, config) {
                        return that._createActionByOption(name, config)
                    })
                },
                _calculateCanvas: function() {
                    var that = this,
                        size = that.option("size") || {},
                        margin = that.option("margin") || {},
                        defaultCanvas = that._getDefaultSize() || {},
                        canvas = {
                            width: size.width <= 0 ? 0 : pickPositiveValue(size.width, that._$element.width() || defaultCanvas.width),
                            height: size.height <= 0 ? 0 : pickPositiveValue(size.height, that._$element.height() || defaultCanvas.height),
                            left: pickPositiveValue(margin.left, defaultCanvas.left || 0),
                            top: pickPositiveValue(margin.top, defaultCanvas.top || 0),
                            right: pickPositiveValue(margin.right, defaultCanvas.right || 0),
                            bottom: pickPositiveValue(margin.bottom, defaultCanvas.bottom || 0)
                        };
                    if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
                        canvas = {
                            width: 0,
                            height: 0
                        }
                    }
                    return canvas
                },
                _updateSize: function() {
                    var that = this,
                        canvas = that._calculateCanvas();
                    if (areCanvasesDifferent(that._canvas, canvas) || that.__forceRender) {
                        that._canvas = canvas;
                        that._renderer.resize(canvas.width, canvas.height);
                        that._change(["LAYOUT"])
                    }
                },
                _setContentSize: function() {
                    var nextRect, canvas = this._canvas,
                        layout = this._layout,
                        rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
                    rect = layout.forward(rect);
                    nextRect = this._applySize(rect) || rect;
                    layout.backward(nextRect)
                },
                DEBUG_getCanvas: function() {
                    return this._canvas
                },
                DEBUG_getEventTrigger: function() {
                    return this._eventTrigger
                },
                _getOption: function(name, isScalar) {
                    var theme = this._themeManager.theme(name),
                        option = this.option(name);
                    return isScalar ? void 0 !== option ? option : theme : $.extend(true, {}, theme, option)
                },
                _setupResizeHandler: function() {
                    if (_parseScalar(this._getOption("redrawOnResize", true), true)) {
                        this._addResizeHandler()
                    } else {
                        this._removeResizeHandler()
                    }
                },
                _addResizeHandler: function() {
                    var that = this;
                    if (!that._resizeHandler) {
                        that._resizeHandler = createResizeHandler(function() {
                            that._requestChange(["CONTAINER_SIZE"])
                        });
                        _windowResizeCallbacks.add(that._resizeHandler)
                    }
                },
                _removeResizeHandler: function() {
                    if (this._resizeHandler) {
                        _windowResizeCallbacks.remove(this._resizeHandler);
                        this._resizeHandler.dispose();
                        this._resizeHandler = null
                    }
                },
                _onBeginUpdate: $.noop,
                beginUpdate: function() {
                    var that = this;
                    if (that._initialized && 0 === that._updateLockCount) {
                        that._onBeginUpdate();
                        that._suspendChanges()
                    }
                    that.callBase.apply(that, arguments);
                    return that
                },
                endUpdate: function() {
                    var that = this,
                        initialized = that._initialized;
                    that.callBase.apply(that, arguments);
                    if (initialized && 0 === that._updateLockCount) {
                        that._resumeChanges()
                    }
                    return that
                },
                option: function(name) {
                    var that = this;
                    if (that._initialized && that._applyingChanges && (arguments.length > 1 || _isObject(name))) {
                        that._optionsQueue = that._optionsQueue || [];
                        that._optionsQueue.push(arguments)
                    } else {
                        return _option.apply(that, arguments)
                    }
                },
                _clean: $.noop,
                _render: $.noop,
                _optionChanged: function(arg) {
                    var that = this;
                    if (that._eventTrigger.change(arg.name)) {
                        that._change(["EVENTS"])
                    } else {
                        if (that._optionChangesMap[arg.name]) {
                            that._change([that._optionChangesMap[arg.name]])
                        } else {
                            that.callBase.apply(that, arguments)
                        }
                    }
                },
                _optionChangesMap: {
                    size: "CONTAINER_SIZE",
                    margin: "CONTAINER_SIZE",
                    redrawOnResize: "RESIZE_HANDLER",
                    theme: "THEME",
                    rtlEnabled: "THEME",
                    encodeHtml: "THEME"
                },
                _visibilityChanged: function() {
                    this.render()
                },
                _setThemeAndRtl: function() {
                    this._themeManager.setTheme(this.option("theme"), this.option(OPTION_RTL_ENABLED))
                },
                _getRendererOptions: function() {
                    return {
                        rtl: this.option(OPTION_RTL_ENABLED),
                        encodeHtml: this.option("encodeHtml"),
                        animation: this._getAnimationOptions()
                    }
                },
                _setRendererOptions: function() {
                    this._renderer.setOptions(this._getRendererOptions())
                },
                _normalizeHtml: function(html) {
                    var re = /xmlns="[\s\S]*?"/gi,
                        first = true;
                    html = html.replace(re, function(match) {
                        if (!first) {
                            return ""
                        }
                        first = false;
                        return match
                    });
                    return html.replace(/xmlns:NS1="[\s\S]*?"/gi, "").replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"')
                },
                svg: function() {
                    return this._normalizeHtml(this._renderer.svg())
                },
                isReady: getFalse,
                _dataIsReady: getTrue,
                _resetIsReady: function() {
                    this.isReady = getFalse
                },
                _drawn: function() {
                    var that = this;
                    that.isReady = getFalse;
                    if (that._dataIsReady()) {
                        that._renderer.onEndAnimation(function() {
                            that.isReady = getTrue
                        })
                    }
                    that._eventTrigger("drawn", {})
                }
            });
            helpers.replaceInherit(module.exports);

            function createEventTrigger(eventsMap, callbackGetter) {
                var triggers = {};
                $.each(eventsMap, function(name, info) {
                    if (info.name) {
                        createEvent(name)
                    }
                });
                var changes;
                triggerEvent.change = function(name) {
                    var eventInfo = eventsMap[name];
                    if (eventInfo) {
                        (changes = changes || {})[name] = eventInfo
                    }
                    return !!eventInfo
                };
                triggerEvent.applyChanges = function() {
                    if (changes) {
                        $.each(changes, function(name, eventInfo) {
                            createEvent(eventInfo.newName || name)
                        });
                        changes = null
                    }
                };
                triggerEvent.dispose = function() {
                    eventsMap = callbackGetter = triggers = null
                };
                return triggerEvent;

                function createEvent(name) {
                    var eventInfo = eventsMap[name];
                    triggers[eventInfo.name] = callbackGetter(name, eventInfo.config)
                }

                function triggerEvent(name, arg, complete) {
                    triggers[name](arg);
                    complete && complete()
                }
            }
            module.exports.DEBUG_createEventTrigger = createEventTrigger;
            module.exports.DEBUG_createIncidentOccurred = createIncidentOccurred;
            module.exports.DEBUG_stub_createIncidentOccurred = function(stub) {
                createIncidentOccurred = stub
            };
            module.exports.DEBUG_restore_createIncidentOccurred = function() {
                createIncidentOccurred = module.exports.DEBUG_createIncidentOccurred
            };
            module.exports.DEBUG_createResizeHandler = createResizeHandler
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/animation/presets/presets.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Component = __webpack_require__( /*! ../../core/component */ 92),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                fx = __webpack_require__( /*! ../fx */ 21);
            var directionPostfixes = {
                forward: " dx-forward",
                backward: " dx-backward",
                none: " dx-no-direction",
                undefined: " dx-no-direction"
            };
            var optionPrefix = "preset_";
            var AnimationPresetCollection = Component.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._customRules = [];
                    this._registeredPresets = [];
                    this.resetToDefaults()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        defaultAnimationDuration: 400,
                        defaultAnimationDelay: 0,
                        defaultStaggerAnimationDuration: 300,
                        defaultStaggerAnimationDelay: 40,
                        defaultStaggerAnimationStartDelay: 500
                    })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                        device: function(device) {
                            return device.phone
                        },
                        options: {
                            defaultStaggerAnimationDuration: 350,
                            defaultStaggerAnimationDelay: 50,
                            defaultStaggerAnimationStartDelay: 0
                        }
                    }, {
                        device: function() {
                            return devices.current().android || devices.real.android
                        },
                        options: {
                            defaultAnimationDelay: 100
                        }
                    }])
                },
                _getPresetOptionName: function(animationName) {
                    return optionPrefix + animationName
                },
                _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
                    var that = this;
                    var createBaseConfig = function(configModifier) {
                        return {
                            type: "slide",
                            delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                            duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
                        }
                    };
                    return {
                        enter: function($element, configModifier) {
                            var width = $element.parent().width() * widthMultiplier,
                                direction = configModifier.direction,
                                config = createBaseConfig(configModifier);
                            config.to = {
                                left: 0,
                                opacity: 1
                            };
                            if ("forward" === direction) {
                                config.from = {
                                    left: width,
                                    opacity: throughOpacity
                                }
                            } else {
                                if ("backward" === direction) {
                                    config.from = {
                                        left: -width,
                                        opacity: throughOpacity
                                    }
                                } else {
                                    config.from = {
                                        left: 0,
                                        opacity: 0
                                    }
                                }
                            }
                            return fx.createAnimation($element, config)
                        },
                        leave: function($element, configModifier) {
                            var width = $element.parent().width() * widthMultiplier,
                                direction = configModifier.direction,
                                config = createBaseConfig(configModifier);
                            config.from = {
                                left: 0,
                                opacity: 1
                            };
                            if ("forward" === direction) {
                                config.to = {
                                    left: -width,
                                    opacity: throughOpacity
                                }
                            } else {
                                if ("backward" === direction) {
                                    config.to = {
                                        left: width,
                                        opacity: throughOpacity
                                    }
                                } else {
                                    config.to = {
                                        left: 0,
                                        opacity: 0
                                    }
                                }
                            }
                            return fx.createAnimation($element, config)
                        }
                    }
                },
                _createOpenDoorConfig: function() {
                    var that = this;
                    var createBaseConfig = function(configModifier) {
                        return {
                            type: "css",
                            extraCssClasses: "dx-opendoor-animation",
                            delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                            duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
                        }
                    };
                    return {
                        enter: function($element, configModifier) {
                            var direction = configModifier.direction,
                                config = createBaseConfig(configModifier);
                            config.delay = "none" === direction ? config.delay : config.duration;
                            config.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
                            config.to = "dx-enter-active";
                            return fx.createAnimation($element, config)
                        },
                        leave: function($element, configModifier) {
                            var direction = configModifier.direction,
                                config = createBaseConfig(configModifier);
                            config.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
                            config.to = "dx-leave-active";
                            return fx.createAnimation($element, config)
                        }
                    }
                },
                _createWinPopConfig: function() {
                    var that = this,
                        baseConfig = {
                            type: "css",
                            extraCssClasses: "dx-win-pop-animation",
                            duration: that.option("defaultAnimationDuration")
                        };
                    return {
                        enter: function($element, configModifier) {
                            var config = baseConfig,
                                direction = configModifier.direction;
                            config.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
                            config.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
                            config.to = "dx-enter-active";
                            return fx.createAnimation($element, config)
                        },
                        leave: function($element, configModifier) {
                            var config = baseConfig,
                                direction = configModifier.direction;
                            config.delay = that.option("defaultAnimationDelay");
                            config.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
                            config.to = "dx-leave-active";
                            return fx.createAnimation($element, config)
                        }
                    }
                },
                resetToDefaults: function() {
                    this.clear();
                    this.registerDefaultPresets();
                    this.applyChanges()
                },
                clear: function(name) {
                    var that = this,
                        newRegisteredPresets = [];
                    $.each(this._registeredPresets, function(index, preset) {
                        if (!name || name === preset.name) {
                            that.option(that._getPresetOptionName(preset.name), void 0)
                        } else {
                            newRegisteredPresets.push(preset)
                        }
                    });
                    this._registeredPresets = newRegisteredPresets;
                    this.applyChanges()
                },
                registerPreset: function(name, config) {
                    this._registeredPresets.push({
                        name: name,
                        config: config
                    })
                },
                applyChanges: function() {
                    var that = this;
                    this._customRules.length = 0;
                    $.each(this._registeredPresets, function(index, preset) {
                        var rule = {
                            device: preset.config.device,
                            options: {}
                        };
                        rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
                        that._customRules.push(rule)
                    });
                    this._setOptionsByDevice()
                },
                getPreset: function(name) {
                    var result = name;
                    while ("string" === typeof result) {
                        result = this.option(this._getPresetOptionName(result))
                    }
                    return result
                },
                registerDefaultPresets: function() {
                    this.registerPreset("pop", {
                        animation: {
                            extraCssClasses: "dx-android-pop-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("openDoor", {
                        animation: this._createOpenDoorConfig()
                    });
                    this.registerPreset("win-pop", {
                        animation: this._createWinPopConfig()
                    });
                    this.registerPreset("fade", {
                        animation: {
                            extraCssClasses: "dx-fade-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("slide", {
                        device: function() {
                            return devices.current().android || devices.real.android
                        },
                        animation: this._createAndroidSlideAnimationConfig(1, 1)
                    });
                    this.registerPreset("slide", {
                        device: function() {
                            return !devices.current().android && !devices.real.android
                        },
                        animation: {
                            extraCssClasses: "dx-slide-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("ios7-slide", {
                        animation: {
                            extraCssClasses: "dx-ios7-slide-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("overflow", {
                        animation: {
                            extraCssClasses: "dx-overflow-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("ios7-toolbar", {
                        device: function() {
                            return !devices.current().android && !devices.real.android
                        },
                        animation: {
                            extraCssClasses: "dx-ios7-toolbar-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("ios7-toolbar", {
                        device: function() {
                            return devices.current().android || devices.real.android
                        },
                        animation: this._createAndroidSlideAnimationConfig(0, .4)
                    });
                    this.registerPreset("stagger-fade", {
                        animation: {
                            extraCssClasses: "dx-fade-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-slide", {
                        animation: {
                            extraCssClasses: "dx-slide-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-fade-slide", {
                        animation: {
                            extraCssClasses: "dx-fade-slide-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-drop", {
                        animation: {
                            extraCssClasses: "dx-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-fade-drop", {
                        animation: {
                            extraCssClasses: "dx-fade-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-fade-rise", {
                        animation: {
                            extraCssClasses: "dx-fade-rise-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-3d-drop", {
                        animation: {
                            extraCssClasses: "dx-3d-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    });
                    this.registerPreset("stagger-fade-zoom", {
                        animation: {
                            extraCssClasses: "dx-fade-zoom-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }
                    })
                }
            });
            exports.PresetCollection = AnimationPresetCollection;
            var animationPresets = new AnimationPresetCollection;
            exports.presets = animationPresets
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/client_exporter/excel_creator.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                stringUtils = __webpack_require__( /*! ../core/utils/string */ 26),
                JSZip = __webpack_require__( /*! jszip */ 351),
                numberFormatter = __webpack_require__( /*! ../localization/number */ 38),
                fileSaver = __webpack_require__( /*! ./file_saver */ 197),
                XML_TAG = '<?xml version="1.0" encoding="utf-8"?>',
                GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>',
                SINGLE_SHEET_PR_XML = "<sheetPr/>",
                BASE_STYLE_XML = '<fonts count="2"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="1"><fill><patternFill patternType="none"/></fill></fills><borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin"><color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/></bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>',
                OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
                RELATIONSHIP_PART_NAME = "rels",
                XL_FOLDER_NAME = "xl",
                WORKBOOK_FILE_NAME = "workbook.xml",
                CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
                SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
                STYLE_FILE_NAME = "styles.xml",
                WORKSHEETS_FOLDER = "worksheets",
                WORKSHEET_FILE_NAME = "sheet1.xml",
                DEFINED_DATE_FORMATS = {
                    longDate: "d MMMM yyyy",
                    longTime: "H:mm:ss",
                    monthAndDay: "MMMM dd",
                    monthAndYear: "MMMM yyyy",
                    quarterAndYear: "dd.MM.yyyy",
                    shortDate: "dd.MM.yyyy",
                    shortTime: "H:mm",
                    millisecond: "H:mm:ss",
                    day: "dd",
                    month: "MMMM",
                    quarter: "dd.MM.yyyy",
                    year: "yyyy"
                },
                DEFAULT_DATE_FORMAT = "shortTime",
                DEFINED_NUMBER_FORMTATS = {
                    thousands: "#,##0{0},&quot;K&quot;",
                    millions: "#,##0{0},,&quot;M&quot;",
                    billions: "#,##0{0},,,&quot;B&quot;",
                    trillions: "#,##0{0},,,,&quot;T&quot;",
                    percent: "0{0}%",
                    decimal: "#{0}",
                    fixedPoint: "#,##0{0}",
                    exponential: "0{0}E+00",
                    currency: " "
                },
                VALID_TYPES = {
                    "boolean": "b",
                    date: "d",
                    number: "n",
                    string: "s"
                },
                EXCEL_START_TIME = Date.UTC(1899, 11, 30),
                DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
                BOLD_STYLES_COUNT = 4,
                MAX_DIGIT_WIDTH_IN_PIXELS = 7,
                CUSTOM_FORMAT_START_INDEX = 165;
            __webpack_require__( /*! ../localization/currency */ 117);
            exports.excelFormatConverter = {
                _applyPrecision: function(format, precision) {
                    var result, i;
                    if (precision > 0) {
                        result = "decimal" !== format ? "." : "";
                        for (i = 0; i < precision; i++) {
                            result += "0"
                        }
                        return result
                    }
                    return ""
                },
                _getCurrencyFormat: function(currency) {
                    return numberFormatter.getOpenXmlCurrencyFormat(currency)
                },
                _convertDateFormat: function(format) {
                    return DEFINED_DATE_FORMATS[format] || DEFINED_DATE_FORMATS[DEFAULT_DATE_FORMAT]
                },
                _convertNumberFormat: function(format, precision) {
                    var result, excelFormat = "currency" === format ? this._getCurrencyFormat() : DEFINED_NUMBER_FORMTATS[format];
                    if (excelFormat) {
                        result = stringUtils.format(excelFormat, this._applyPrecision(format, precision))
                    }
                    return result
                },
                convertFormat: function(format, precision, type) {
                    if (commonUtils.isDefined(format)) {
                        if ("date" === type) {
                            return exports.excelFormatConverter._convertDateFormat(format)
                        } else {
                            if (DEFINED_NUMBER_FORMTATS[format]) {
                                return exports.excelFormatConverter._convertNumberFormat(format, precision)
                            }
                        }
                    }
                }
            };
            exports.ExcelCreator = Class.inherit({
                _getXMLTag: function(tagName, attributes, content) {
                    var i, attr, result = "<" + tagName,
                        length = attributes.length;
                    for (i = 0; i < length; i++) {
                        attr = attributes[i];
                        result = result + " " + attr.name + '="' + attr.value + '"'
                    }
                    return commonUtils.isDefined(content) ? result + ">" + content + "</" + tagName + ">" : result + " />"
                },
                _getDataProviderRowIndex: function(dpRowIndex) {
                    var correctRowIndex = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 0;
                    return dpRowIndex - correctRowIndex
                },
                _getExcelRowIndex: function(exRowIndex) {
                    var correctRowIndex = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 0;
                    return exRowIndex + correctRowIndex
                },
                _getCellIndex: function(rowIndex, cellIndex) {
                    var charCode, sheetIndex = "",
                        max = 26;
                    if (this._maxIndex[0] < Number(rowIndex)) {
                        this._maxIndex[0] = Number(rowIndex)
                    }
                    if (this._maxIndex[1] < Number(cellIndex)) {
                        this._maxIndex[1] = Number(cellIndex)
                    }
                    while (true) {
                        charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
                        sheetIndex = String.fromCharCode(charCode) + sheetIndex;
                        if (cellIndex >= max) {
                            cellIndex = Math.floor(cellIndex / max) - 1
                        } else {
                            break
                        }
                    }
                    return sheetIndex + rowIndex
                },
                _getDataType: function(dataType) {
                    return VALID_TYPES[dataType] || "s"
                },
                _appendFormat: function(format, precision, dataType) {
                    format = exports.excelFormatConverter.convertFormat(format, precision, dataType);
                    if (format) {
                        if (-1 === $.inArray(format, this._styleFormat)) {
                            this._styleFormat.push(format)
                        }
                        return $.inArray(format, this._styleFormat) + 1
                    }
                },
                _appendString: function(value) {
                    if (commonUtils.isDefined(value)) {
                        value = String(value);
                        if (value.length) {
                            value = stringUtils.encodeHtml(value);
                            if (void 0 === this._stringHash[value]) {
                                this._stringHash[value] = this._stringArray.length;
                                this._stringArray.push(value)
                            }
                            return this._stringHash[value]
                        }
                    }
                },
                _getExcelDateValue: function(date) {
                    var days, totalTime;
                    if (commonUtils.isDate(date)) {
                        days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / 864e5);
                        if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
                            days--
                        }
                        totalTime = (3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()) / 86400;
                        return days + totalTime
                    }
                },
                _prepareValue: function(rowIndex, cellIndex) {
                    var dataProvider = this._dataProvider,
                        value = dataProvider.getCellValue(rowIndex, cellIndex),
                        type = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex)),
                        formatID = this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID,
                        format = commonUtils.isNumber(formatID) ? this._styleFormat[formatID - 1] : null;
                    if ("d" === type && !commonUtils.isDate(value)) {
                        type = "s"
                    }
                    switch (type) {
                        case "s":
                            value = this._appendString(value);
                            break;
                        case "d":
                            value = this._getExcelDateValue(value, format);
                            type = "n"
                    }
                    return {
                        value: value,
                        type: type
                    }
                },
                _getHeadersArray: function() {
                    var i, j, column, columns = this._dataProvider.getColumns(true),
                        result = [];
                    for (i = 0; i < columns.length - 1; i++) {
                        result.push([]);
                        for (j = 0; j < columns[i].length; j++) {
                            column = columns[i][j];
                            result[i].push({
                                style: 0,
                                type: "s",
                                value: this._appendString(column.caption)
                            })
                        }
                    }
                    return result
                },
                _getDataArray: function() {
                    var rowIndex, cellIndex, cellsArray, cellData, cellsLength, type, styleID, result = [],
                        rowsLength = this._dataProvider.getRowsCount(),
                        columns = this._dataProvider.getColumns();
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        cellsArray = [];
                        cellsLength = columns.length;
                        for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
                            cellData = this._prepareValue(rowIndex, cellIndex);
                            type = cellData.type;
                            if (!this._dataProvider.isGroupRow(rowIndex) && commonUtils.isDefined(this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID) && "s" !== cellData.type) {
                                type = "n"
                            }
                            styleID = cellIndex + BOLD_STYLES_COUNT;
                            if (this._dataProvider.isGroupRow(rowIndex)) {
                                styleID = BOLD_STYLES_COUNT - 1
                            }
                            if (this._dataProvider.isTotalCell(rowIndex, cellIndex)) {
                                styleID = this._getBoldStyleID(columns[cellIndex].alignment)
                            }
                            cellsArray.push({
                                style: styleID,
                                value: cellData.value,
                                type: type
                            })
                        }
                        if (rowIndex && !this._needSheetPr && this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) > 0) {
                            this._needSheetPr = true
                        }
                        result.push(cellsArray)
                    }
                    return result
                },
                _getBoldStyleID: function(alignment) {
                    for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++) {
                        if (this._styleArray[i].alignment === alignment) {
                            return i
                        }
                    }
                },
                _calculateWidth: function(pixelsWidth) {
                    pixelsWidth = parseInt(pixelsWidth, 10);
                    if (!pixelsWidth || pixelsWidth < 5) {
                        pixelsWidth = 100
                    }
                    return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + .5) / 100)
                },
                _prepareStyleData: function() {
                    var i, column, wrapText = Number(!!this._options.wrapTextEnabled),
                        alignments = ["center", "left", "right"],
                        columns = this._dataProvider.getColumns();
                    for (i = 0; i < alignments.length; i++) {
                        this._styleArray.push({
                            bold: true,
                            alignment: alignments[i],
                            wrapText: 1
                        })
                    }
                    this._styleArray.push({
                        bold: true,
                        alignment: commonUtils.getDefaultAlignment(this._rtlEnabled),
                        wrapText: 0
                    });
                    for (i = 0; i < columns.length; i++) {
                        column = columns[i];
                        this._styleArray.push({
                            alignment: commonUtils.isDefined(column.alignment) ? column.alignment : "left",
                            formatID: this._appendFormat(column.format, column.precision, column.dataType),
                            wrapText: wrapText
                        });
                        this._colsArray.push(this._calculateWidth(column.width))
                    }
                },
                _prepareCellData: function() {
                    if (this._dataProvider.isHeadersVisible()) {
                        this._cellsArray = this._cellsArray.concat(this._getHeadersArray())
                    }
                    this._cellsArray = this._cellsArray.concat(this._getDataArray())
                },
                _createXMLRelationships: function(xmlRelationships) {
                    return this._getXMLTag("Relationships", [{
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
                    }], xmlRelationships)
                },
                _createXMLRelationship: function(id, type, target) {
                    return this._getXMLTag("Relationship", [{
                        name: "Id",
                        value: "rId" + id
                    }, {
                        name: "Type",
                        value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type
                    }, {
                        name: "Target",
                        value: target
                    }])
                },
                _getWorkbookContent: function() {
                    var content = '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/></bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames><definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName><definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>';
                    return XML_TAG + this._getXMLTag("workbook", [{
                        name: "xmlns:r",
                        value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
                    }, {
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }], content)
                },
                _getContentTypesContent: function() {
                    return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>'
                },
                _generateStylesXML: function() {
                    var styleIndex, style, formatIndex, xlFolder = this._zip.folder(XL_FOLDER_NAME),
                        stylesLength = this._styleArray.length,
                        xmlStyles = [],
                        XML = "";
                    for (formatIndex = 0; formatIndex < this._styleFormat.length; formatIndex++) {
                        this._styleFormat[formatIndex] = this._getXMLTag("numFmt", [{
                            name: "numFmtId",
                            value: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX
                        }, {
                            name: "formatCode",
                            value: this._styleFormat[formatIndex]
                        }])
                    }
                    XML = XML + this._getXMLTag("numFmts", [{
                        name: "count",
                        value: this._styleFormat.length
                    }], this._styleFormat.join("")) + BASE_STYLE_XML;
                    for (styleIndex = 0; styleIndex < stylesLength; styleIndex++) {
                        style = this._styleArray[styleIndex];
                        xmlStyles.push(this._getXMLTag("xf", [{
                            name: "xfId",
                            value: 0
                        }, {
                            name: "applyAlignment",
                            value: 1
                        }, {
                            name: "fontId",
                            value: Number(!!style.bold)
                        }, {
                            name: "applyNumberFormat",
                            value: commonUtils.isDefined(style.formatID) ? 1 : 0
                        }, {
                            name: "numFmtId",
                            value: commonUtils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
                        }], this._getXMLTag("alignment", [{
                            name: "horizontal",
                            value: style.alignment
                        }, {
                            name: "vertical",
                            value: "top"
                        }, {
                            name: "wrapText",
                            value: style.wrapText
                        }])))
                    }
                    XML += this._getXMLTag("cellXfs", [{
                        name: "count",
                        value: xmlStyles.length
                    }], xmlStyles.join(""));
                    XML += this._getXMLTag("cellStyles", [{
                        name: "count",
                        value: 1
                    }], this._getXMLTag("cellStyle", [{
                        name: "name",
                        value: "Normal"
                    }, {
                        name: "xfId",
                        value: 0
                    }, {
                        name: "builtinId",
                        value: 0
                    }]));
                    XML = XML_TAG + this._getXMLTag("styleSheet", [{
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }], XML);
                    xlFolder.file(STYLE_FILE_NAME, XML);
                    this._styleArray = []
                },
                _generateStringsXML: function() {
                    var stringIndex, xlFolder = this._zip.folder(XL_FOLDER_NAME),
                        stringsLength = this._stringArray.length,
                        sharedStringXml = XML_TAG;
                    for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
                        this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]))
                    }
                    sharedStringXml += this._getXMLTag("sst", [{
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }, {
                        name: "count",
                        value: this._stringArray.length
                    }, {
                        name: "uniqueCount",
                        value: this._stringArray.length
                    }], this._stringArray.join(""));
                    xlFolder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
                    this._stringArray = []
                },
                _getPaneXML: function() {
                    var attributes = [{
                            name: "activePane",
                            value: "bottomLeft"
                        }, {
                            name: "state",
                            value: "frozen"
                        }],
                        frozenArea = this._dataProvider.getFrozenArea();
                    if (!(frozenArea.x || frozenArea.y)) {
                        return ""
                    }
                    if (frozenArea.x) {
                        attributes.push({
                            name: "xSplit",
                            value: frozenArea.x
                        })
                    }
                    if (frozenArea.y) {
                        attributes.push({
                            name: "ySplit",
                            value: frozenArea.y
                        })
                    }
                    attributes.push({
                        name: "topLeftCell",
                        value: this._getCellIndex(frozenArea.y + 1, frozenArea.x)
                    });
                    return this._getXMLTag("pane", attributes)
                },
                _generateWorksheetXML: function() {
                    var colIndex, rowIndex, cellData, xmlCells, maxCellIndex, cellsLength, counter = 0,
                        xmlRows = [],
                        rowsLength = this._cellsArray.length,
                        colsLength = this._colsArray.length,
                        rSpans = "1:" + colsLength,
                        headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1,
                        xmlResult = [
                            ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">', this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, '<dimension ref="A1:', this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + '"/><sheetViews><sheetView ' + (this._rtlEnabled ? 'rightToLeft="1" ' : "") + 'tabSelected="1" workbookViewId="0">' + this._getPaneXML() + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" outlineLevelRow="', this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, '" x14ac:dyDescent="0.25"/>'].join("")
                        ];
                    for (colIndex = 0; colIndex < colsLength; colIndex++) {
                        this._colsArray[colIndex] = this._getXMLTag("col", [{
                            name: "width",
                            value: this._colsArray[colIndex]
                        }, {
                            name: "min",
                            value: Number(colIndex) + 1
                        }, {
                            name: "max",
                            value: Number(colIndex) + 1
                        }])
                    }
                    xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        xmlCells = [];
                        cellsLength = this._cellsArray[rowIndex].length;
                        for (colIndex = 0; colIndex < cellsLength; colIndex++) {
                            rowIndex = Number(rowIndex);
                            cellData = this._cellsArray[rowIndex][colIndex];
                            xmlCells.push(this._getXMLTag("c", [{
                                name: "r",
                                value: this._getCellIndex(rowIndex + 1, colIndex)
                            }, {
                                name: "s",
                                value: cellData.style
                            }, {
                                name: "t",
                                value: cellData.type
                            }], commonUtils.isDefined(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null))
                        }
                        xmlRows.push(this._getXMLTag("row", [{
                            name: "r",
                            value: Number(rowIndex) + 1
                        }, {
                            name: "spans",
                            value: rSpans
                        }, {
                            name: "outlineLevel",
                            value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) : 0
                        }, {
                            name: "x14ac:dyDescent",
                            value: "0.25"
                        }], xmlCells.join("")));
                        this._cellsArray[rowIndex] = null;
                        if (counter++ > 1e4) {
                            xmlResult.push(xmlRows.join(""));
                            xmlRows = [];
                            counter = 0
                        }
                    }
                    xmlResult.push(xmlRows.join(""));
                    xmlRows = [];
                    maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
                    xmlResult.push("</sheetData>" + this._generateMergingXML() + (this._options.autoFilterEnabled ? '<autoFilter ref="A1:' + maxCellIndex + '" />' : "") + '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors></worksheet>');
                    this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
                    this._colsArray = [];
                    this._cellsArray = [];
                    xmlResult = []
                },
                _generateMergingXML: function() {
                    var k, l, cellIndex, rowIndex, mergeArrayLength, mergeIndex, rowsLength = commonUtils.isDefined(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount(),
                        columnsLength = this._dataProvider.getColumns().length,
                        usedArea = [],
                        mergeArray = [],
                        mergeXML = "";
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
                            if (!commonUtils.isDefined(usedArea[rowIndex]) || !commonUtils.isDefined(usedArea[rowIndex][cellIndex])) {
                                var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
                                if (cellMerge.colspan || cellMerge.rowspan) {
                                    mergeArray.push({
                                        start: this._getCellIndex(rowIndex + 1, cellIndex),
                                        end: this._getCellIndex(rowIndex + 1 + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
                                    });
                                    for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
                                        for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                                            if (!commonUtils.isDefined(usedArea[k])) {
                                                usedArea[k] = []
                                            }
                                            usedArea[k][l] = true
                                        }
                                    }
                                }
                            }
                        }
                    }
                    mergeArrayLength = mergeArray.length;
                    for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
                        mergeXML += this._getXMLTag("mergeCell", [{
                            name: "ref",
                            value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
                        }])
                    }
                    return mergeXML.length ? this._getXMLTag("mergeCells", [{
                        name: "count",
                        value: mergeArrayLength
                    }], mergeXML) : ""
                },
                _generateCommonXML: function() {
                    var xmlRelationships, relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
                        xlFolder = this._zip.folder(XL_FOLDER_NAME),
                        relsXML = XML_TAG;
                    this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
                    xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
                    relsXML += this._createXMLRelationships(xmlRelationships);
                    xlFolder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
                    xlFolder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
                    this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
                },
                _generateContent: function() {
                    this._prepareStyleData();
                    this._prepareCellData();
                    this._generateWorkXML();
                    this._generateCommonXML()
                },
                _generateWorkXML: function() {
                    this._generateStylesXML();
                    this._generateStringsXML();
                    this._generateWorksheetXML()
                },
                ctor: function(dataProvider, options) {
                    this._rtlEnabled = options && !!options.rtlEnabled;
                    this._options = options;
                    this._maxIndex = [1, 2];
                    this._stringArray = [];
                    this._stringHash = {};
                    this._styleArray = [];
                    this._colsArray = [];
                    this._cellsArray = [];
                    this._styleFormat = [];
                    this._needSheetPr = false;
                    this._dataProvider = dataProvider;
                    this._zip = new JSZip
                },
                ready: function() {
                    return this._dataProvider.ready()
                },
                getData: function(isBlob) {
                    var options = {
                        type: isBlob ? "blob" : "base64",
                        compression: "DEFLATE",
                        mimeType: fileSaver.MIME_TYPES.EXCEL
                    };
                    this._generateContent();
                    return this._zip.generateAsync ? this._zip.generateAsync(options) : this._zip.generate(options)
                }
            });
            exports.getBlob = function(data, options, callback) {
                var excelCreator = new exports.ExcelCreator(data, options);
                excelCreator.ready().done(function() {
                    if (excelCreator._zip.generateAsync) {
                        excelCreator.getData(commonUtils.isFunction(window.Blob)).then(callback)
                    } else {
                        callback(excelCreator.getData(commonUtils.isFunction(window.Blob)))
                    }
                })
            };
            exports.__internals = {
                CONTENTTYPES_FILE_NAME: CONTENTTYPES_FILE_NAME,
                RELATIONSHIP_PART_NAME: RELATIONSHIP_PART_NAME,
                XL_FOLDER_NAME: XL_FOLDER_NAME,
                WORKBOOK_FILE_NAME: WORKBOOK_FILE_NAME,
                STYLE_FILE_NAME: STYLE_FILE_NAME,
                WORKSHEET_FILE_NAME: WORKSHEET_FILE_NAME,
                WORKSHEETS_FOLDER: WORKSHEETS_FOLDER,
                SHAREDSTRING_FILE_NAME: SHAREDSTRING_FILE_NAME,
                GROUP_SHEET_PR_XML: GROUP_SHEET_PR_XML,
                SINGLE_SHEET_PR_XML: SINGLE_SHEET_PR_XML
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/data/odata/query_adapter.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                queryAdapters = __webpack_require__( /*! ../query_adapters */ 144),
                odataUtils = __webpack_require__( /*! ./utils */ 71),
                serializePropName = odataUtils.serializePropName,
                errors = __webpack_require__( /*! ../errors */ 25).errors,
                dataUtils = __webpack_require__( /*! ../utils */ 28);
            var DEFAULT_PROTOCOL_VERSION = 2;
            var compileCriteria = function() {
                var createBinaryOperationFormatter = function(op) {
                    return function(prop, val) {
                        return prop + " " + op + " " + val
                    }
                };
                var createStringFuncFormatter = function(op, reverse) {
                    return function(prop, val) {
                        var bag = [op, "("];
                        if (reverse) {
                            bag.push(val, ",", prop)
                        } else {
                            bag.push(prop, ",", val)
                        }
                        bag.push(")");
                        return bag.join("")
                    }
                };
                var formatters = {
                    "=": createBinaryOperationFormatter("eq"),
                    "<>": createBinaryOperationFormatter("ne"),
                    ">": createBinaryOperationFormatter("gt"),
                    ">=": createBinaryOperationFormatter("ge"),
                    "<": createBinaryOperationFormatter("lt"),
                    "<=": createBinaryOperationFormatter("le"),
                    startswith: createStringFuncFormatter("startswith"),
                    endswith: createStringFuncFormatter("endswith")
                };
                var formattersV2 = $.extend({}, formatters, {
                    contains: createStringFuncFormatter("substringof", true),
                    notcontains: createStringFuncFormatter("not substringof", true)
                });
                var formattersV4 = $.extend({}, formatters, {
                    contains: createStringFuncFormatter("contains"),
                    notcontains: createStringFuncFormatter("not contains")
                });
                var compileBinary = function(criteria, protocolVersion) {
                    criteria = dataUtils.normalizeBinaryCriterion(criteria);
                    var op = criteria[1],
                        formatters = 4 === protocolVersion ? formattersV4 : formattersV2,
                        formatter = formatters[op.toLowerCase()];
                    if (!formatter) {
                        throw errors.Error("E4003", op)
                    }
                    return formatter(serializePropName(criteria[0]), odataUtils.serializeValue(criteria[2], protocolVersion))
                };
                var compileGroup = function(criteria, protocolVersion) {
                    var groupOperator, nextGroupOperator, bag = [];
                    $.each(criteria, function(index, criterion) {
                        if ($.isArray(criterion)) {
                            if (bag.length > 1 && groupOperator !== nextGroupOperator) {
                                throw new errors.Error("E4019")
                            }
                            bag.push("(" + compileCore(criterion, protocolVersion) + ")");
                            groupOperator = nextGroupOperator;
                            nextGroupOperator = "and"
                        } else {
                            nextGroupOperator = dataUtils.isConjunctiveOperator(this) ? "and" : "or"
                        }
                    });
                    return bag.join(" " + groupOperator + " ")
                };
                var compileCore = function(criteria, protocolVersion) {
                    if ($.isArray(criteria[0])) {
                        return compileGroup(criteria, protocolVersion)
                    }
                    return compileBinary(criteria, protocolVersion)
                };
                return function(criteria, protocolVersion) {
                    return compileCore(criteria, protocolVersion)
                }
            }();
            var createODataQueryAdapter = function(queryOptions) {
                var _select, _skip, _take, _countQuery, _sorting = [],
                    _criteria = [],
                    _expand = queryOptions.expand,
                    _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
                var hasSlice = function() {
                    return _skip || void 0 !== _take
                };
                var hasFunction = function(criterion) {
                    for (var i = 0; i < criterion.length; i++) {
                        if ($.isFunction(criterion[i])) {
                            return true
                        }
                        if ($.isArray(criterion[i]) && hasFunction(criterion[i])) {
                            return true
                        }
                    }
                    return false
                };
                var generateSelectExpand = function() {
                    var hasDot = function(x) {
                        return /\./.test(x)
                    };
                    var generateSelect = function() {
                        if (!_select) {
                            return
                        }
                        if (_oDataVersion < 4) {
                            return serializePropName(_select.join())
                        }
                        return $.grep(_select, hasDot, true).join()
                    };
                    var generateExpand = function() {
                        var generatorV2 = function() {
                            var hash = {};
                            if (_expand) {
                                $.each($.makeArray(_expand), function() {
                                    hash[serializePropName(this)] = 1
                                })
                            }
                            if (_select) {
                                $.each($.makeArray(_select), function() {
                                    var path = this.split(".");
                                    if (path.length < 2) {
                                        return
                                    }
                                    path.pop();
                                    hash[serializePropName(path.join("."))] = 1
                                })
                            }
                            return $.map(hash, function(k, v) {
                                return v
                            }).join()
                        };
                        var generatorV4 = function() {
                            var format = function(hash) {
                                var formatCore = function(hash) {
                                    var ret = "",
                                        select = [],
                                        expand = [];
                                    $.each(hash, function(key, value) {
                                        if ($.isArray(value)) {
                                            [].push.apply(select, value)
                                        }
                                        if ($.isPlainObject(value)) {
                                            expand.push(key + formatCore(value))
                                        }
                                    });
                                    if (select.length || expand.length) {
                                        ret += "(";
                                        if (select.length) {
                                            ret += "$select=" + $.map(select, serializePropName).join()
                                        }
                                        if (expand.length) {
                                            if (select.length) {
                                                ret += ";"
                                            }
                                            ret += "$expand=" + $.map(expand, serializePropName).join()
                                        }
                                        ret += ")"
                                    }
                                    return ret
                                };
                                var ret = [];
                                $.each(hash, function(key, value) {
                                    ret.push(key + formatCore(value))
                                });
                                return ret.join()
                            };
                            var parseTree = function(exprs, root, stepper) {
                                var parseCore = function(exprParts, root, stepper) {
                                    var result = stepper(root, exprParts.shift(), exprParts);
                                    if (false === result) {
                                        return
                                    }
                                    parseCore(exprParts, result, stepper)
                                };
                                $.each(exprs, function(_, x) {
                                    parseCore(x.split("."), root, stepper)
                                })
                            };
                            var hash = {};
                            if (_expand || _select) {
                                if (_expand) {
                                    parseTree($.makeArray(_expand), hash, function(node, key, path) {
                                        node[key] = node[key] || {};
                                        if (!path.length) {
                                            return false
                                        }
                                        return node[key]
                                    })
                                }
                                if (_select) {
                                    parseTree($.grep($.makeArray(_select), hasDot), hash, function(node, key, path) {
                                        if (!path.length) {
                                            node[key] = node[key] || [];
                                            node[key].push(key);
                                            return false
                                        }
                                        return node[key] = node[key] || {}
                                    })
                                }
                                return format(hash)
                            }
                        };
                        if (_oDataVersion < 4) {
                            return generatorV2()
                        }
                        return generatorV4()
                    };
                    var tuple = {
                        $select: generateSelect() || void 0,
                        $expand: generateExpand() || void 0
                    };
                    return tuple
                };
                var requestData = function() {
                    var result = {};
                    if (!_countQuery) {
                        if (_sorting.length) {
                            result.$orderby = _sorting.join(",")
                        }
                        if (_skip) {
                            result.$skip = _skip
                        }
                        if (void 0 !== _take) {
                            result.$top = _take
                        }
                        var tuple = generateSelectExpand();
                        result.$select = tuple.$select;
                        result.$expand = tuple.$expand
                    }
                    if (_criteria.length) {
                        result.$filter = compileCriteria(_criteria.length < 2 ? _criteria[0] : _criteria, _oDataVersion)
                    }
                    if (_countQuery) {
                        result.$top = 0
                    }
                    if (queryOptions.requireTotalCount || _countQuery) {
                        if (4 !== _oDataVersion) {
                            result.$inlinecount = "allpages"
                        } else {
                            result.$count = "true"
                        }
                    }
                    return result
                };
                return {
                    exec: function(url) {
                        return odataUtils.sendRequest(_oDataVersion, {
                            url: url,
                            params: $.extend(requestData(), queryOptions && queryOptions.params)
                        }, {
                            beforeSend: queryOptions.beforeSend,
                            jsonp: queryOptions.jsonp,
                            withCredentials: queryOptions.withCredentials,
                            countOnly: _countQuery
                        }, queryOptions.deserializeDates)
                    },
                    multiSort: function(args) {
                        var rules;
                        if (hasSlice()) {
                            return false
                        }
                        for (var i = 0; i < args.length; i++) {
                            var rule, getter = args[i][0],
                                desc = !!args[i][1];
                            if ("string" !== typeof getter) {
                                return false
                            }
                            rule = serializePropName(getter);
                            if (desc) {
                                rule += " desc"
                            }
                            rules = rules || [];
                            rules.push(rule)
                        }
                        _sorting = rules
                    },
                    slice: function(skipCount, takeCount) {
                        if (hasSlice()) {
                            return false
                        }
                        _skip = skipCount;
                        _take = takeCount
                    },
                    filter: function(criterion) {
                        if (hasSlice()) {
                            return false
                        }
                        if (!$.isArray(criterion)) {
                            criterion = $.makeArray(arguments)
                        }
                        if (hasFunction(criterion)) {
                            return false
                        }
                        if (_criteria.length) {
                            _criteria.push("and")
                        }
                        _criteria.push(criterion)
                    },
                    select: function(expr) {
                        if (_select || $.isFunction(expr)) {
                            return false
                        }
                        if (!$.isArray(expr)) {
                            expr = $.makeArray(arguments)
                        }
                        _select = expr
                    },
                    count: function() {
                        _countQuery = true
                    }
                }
            };
            queryAdapters.odata = createODataQueryAdapter;
            exports.odata = createODataQueryAdapter
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/events/pointer/base.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                browser = __webpack_require__( /*! ../../core/utils/browser */ 22),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                eventUtils = __webpack_require__( /*! ../utils */ 4);
            var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
            var BaseStrategy = Class.inherit({
                ctor: function(eventName, originalEvents) {
                    this._eventName = eventName;
                    this._originalEvents = eventUtils.addNamespace(originalEvents, POINTER_EVENTS_NAMESPACE);
                    this._handlerCount = 0;
                    this.noBubble = this._isNoBubble()
                },
                _isNoBubble: function() {
                    var eventName = this._eventName;
                    return "dxpointerenter" === eventName || "dxpointerleave" === eventName
                },
                _handler: function(e) {
                    var delegateTarget = this._getDelegateTarget(e);
                    return this._fireEvent({
                        type: this._eventName,
                        pointerType: e.pointerType || eventUtils.eventSource(e),
                        originalEvent: e,
                        delegateTarget: delegateTarget,
                        timeStamp: browser.mozilla ? (new Date).getTime() : e.timeStamp
                    })
                },
                _getDelegateTarget: function(e) {
                    var delegateTarget;
                    if (this.noBubble) {
                        delegateTarget = e.delegateTarget
                    }
                    return delegateTarget
                },
                _fireEvent: function(args) {
                    return eventUtils.fireEvent(args)
                },
                setup: function() {
                    return true
                },
                add: function(element, handleObj) {
                    if (this._handlerCount <= 0 || this.noBubble) {
                        this._selector = handleObj.selector;
                        element = this.noBubble ? element : document;
                        var that = this;
                        $(element).on(this._originalEvents, this._selector, function(e) {
                            that._handler(e)
                        })
                    }
                    if (!this.noBubble) {
                        this._handlerCount++
                    }
                },
                remove: function(element) {
                    if (!this.noBubble) {
                        this._handlerCount--
                    }
                },
                teardown: function(element) {
                    if (this._handlerCount && !this.noBubble) {
                        return
                    }
                    element = this.noBubble ? element : document;
                    if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
                        $(element).off(this._originalEvents, this._selector)
                    }
                },
                dispose: function(element) {
                    element = this.noBubble ? element : document;
                    $(element).off(this._originalEvents)
                }
            });
            module.exports = BaseStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/framework/html/presets.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            exports.layoutSets = {};
            exports.animationSets = {
                "native": {
                    "view-content-change": [{
                        animation: "slide"
                    }, {
                        animation: "ios7-slide",
                        device: {
                            platform: "ios"
                        }
                    }, {
                        animation: "none",
                        device: {
                            deviceType: "desktop",
                            platform: "generic"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-header-toolbar": [{
                        animation: "ios7-toolbar"
                    }, {
                        animation: "slide",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }]
                },
                "default": {
                    "layout-change": [{
                        animation: "none"
                    }, {
                        animation: "ios7-slide",
                        device: {
                            platform: "ios"
                        }
                    }, {
                        animation: "pop",
                        device: {
                            platform: "android"
                        }
                    }, {
                        animation: "openDoor",
                        device: {
                            deviceType: "phone",
                            platform: "win",
                            version: [8]
                        }
                    }, {
                        animation: "win-pop",
                        device: {
                            deviceType: "phone",
                            platform: "win"
                        }
                    }],
                    "view-content-change": [{
                        animation: "slide"
                    }, {
                        animation: "ios7-slide",
                        device: {
                            platform: "ios"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop",
                            platform: "generic"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-content-rendered": [{
                        animation: "fade"
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-header-toolbar": [{
                        animation: "ios7-toolbar"
                    }, {
                        animation: "slide",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "command-rendered-top": [{
                        animation: "stagger-fade-drop"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }, {
                        animation: "none",
                        device: {
                            platform: "win",
                            version: [10]
                        }
                    }],
                    "command-rendered-bottom": [{
                        animation: "stagger-fade-rise"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }, {
                        animation: "none",
                        device: {
                            platform: "win",
                            version: [10]
                        }
                    }],
                    "list-item-rendered": [{
                        animation: "stagger-3d-drop",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "detail-item-rendered": [{
                        animation: "stagger-3d-drop",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "edit-item-rendered": [{
                        animation: "stagger-3d-drop",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }]
                },
                slide: {
                    "view-content-change": [{
                        animation: "slide"
                    }, {
                        animation: "ios7-slide",
                        device: {
                            platform: "ios"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop",
                            platform: "generic"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-content-rendered": [{
                        animation: "fade"
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-header-toolbar": [{
                        animation: "ios7-toolbar"
                    }, {
                        animation: "slide",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "command-rendered-top": [{
                        animation: "stagger-fade-drop"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "command-rendered-bottom": [{
                        animation: "stagger-fade-rise"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "list-item-rendered": [{
                        animation: "stagger-fade-slide",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "detail-item-rendered": [{
                        animation: "stagger-fade-slide",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "edit-item-rendered": [{
                        animation: "stagger-fade-slide",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }]
                },
                zoom: {
                    "view-content-change": [{
                        animation: "slide"
                    }, {
                        animation: "ios7-slide",
                        device: {
                            platform: "ios"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop",
                            platform: "generic"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-content-rendered": [{
                        animation: "fade"
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "view-header-toolbar": [{
                        animation: "ios7-toolbar"
                    }, {
                        animation: "slide",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "command-rendered-top": [{
                        animation: "stagger-fade-zoom"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "command-rendered-bottom": [{
                        animation: "stagger-fade-zoom"
                    }, {
                        animation: "fade",
                        device: {
                            grade: "B"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "list-item-rendered": [{
                        animation: "stagger-fade-zoom",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "detail-item-rendered": [{
                        animation: "stagger-fade-zoom",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }],
                    "edit-item-rendered": [{
                        animation: "stagger-fade-zoom",
                        device: {
                            grade: "A"
                        }
                    }, {
                        animation: "fade",
                        device: {
                            deviceType: "desktop"
                        }
                    }, {
                        animation: "none",
                        device: {
                            grade: "C"
                        }
                    }]
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/framework/navigation_devices.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                browserAdapters = __webpack_require__( /*! ./browser_adapters */ 211),
                SessionStorage = __webpack_require__( /*! ../core/utils/storage */ 122).sessionStorage,
                devices = __webpack_require__( /*! ../core/devices */ 7);
            var SESSION_KEY = "dxPhoneJSApplication";
            var HistoryBasedNavigationDevice = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._browserAdapter = options.browserAdapter || this._createBrowserAdapter(options);
                    this.uriChanged = $.Callbacks();
                    this._browserAdapter.popState.add($.proxy(this._onPopState, this))
                },
                init: $.noop,
                getUri: function() {
                    return this._browserAdapter.getHash()
                },
                setUri: function(uri, replaceCurrent) {
                    if (replaceCurrent) {
                        return this._browserAdapter.replaceState(uri)
                    } else {
                        if (uri !== this.getUri()) {
                            return this._browserAdapter.pushState(uri)
                        } else {
                            return $.Deferred().resolve().promise()
                        }
                    }
                },
                back: function() {
                    return this._browserAdapter.back()
                },
                _onPopState: function() {
                    this.uriChanged.fire(this.getUri())
                },
                _isBuggyAndroid2: function() {
                    var realDevice = devices.real();
                    var version = realDevice.version;
                    return "android" === realDevice.platform && version.length > 1 && (2 === version[0] && version[1] < 4 || version[0] < 2)
                },
                _isBuggyAndroid4: function() {
                    var realDevice = devices.real();
                    var version = realDevice.version;
                    return "android" === realDevice.platform && version.length > 1 && 4 === version[0] && 0 === version[1]
                },
                _isWindowsPhone8: function() {
                    var realDevice = devices.real();
                    return "win" === realDevice.platform && realDevice.phone
                },
                _createBrowserAdapter: function(options) {
                    var result, sourceWindow = options.window || window,
                        supportPushReplace = sourceWindow.history.replaceState && sourceWindow.history.pushState;
                    if (this._isWindowsPhone8()) {
                        result = new browserAdapters.BuggyCordovaWP81BrowserAdapter(options)
                    } else {
                        if (sourceWindow !== sourceWindow.top) {
                            result = new browserAdapters.HistorylessBrowserAdapter(options)
                        } else {
                            if (this._isBuggyAndroid4()) {
                                result = new browserAdapters.BuggyAndroidBrowserAdapter(options)
                            } else {
                                if (this._isBuggyAndroid2() || !supportPushReplace) {
                                    result = new browserAdapters.OldBrowserAdapter(options)
                                } else {
                                    result = new browserAdapters.DefaultBrowserAdapter(options)
                                }
                            }
                        }
                    }
                    return result
                }
            });
            var StackBasedNavigationDevice = HistoryBasedNavigationDevice.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this.backInitiated = $.Callbacks();
                    this._rootStateHandler = null;
                    $(window).on("unload", this._saveBrowserState)
                },
                init: function() {
                    var that = this;
                    if (that._browserAdapter.canWorkInPureBrowser) {
                        return that._initRootPage().done(function() {
                            if (that._browserAdapter.isRootPage()) {
                                that._browserAdapter.pushState("")
                            }
                        })
                    } else {
                        return $.Deferred().resolve().promise()
                    }
                },
                setUri: function(uri) {
                    return this.callBase(uri, !this._browserAdapter.isRootPage())
                },
                _saveBrowserState: function() {
                    var sessionStorage = SessionStorage();
                    if (sessionStorage) {
                        sessionStorage.setItem(SESSION_KEY, true)
                    }
                },
                _initRootPage: function() {
                    var hash = this.getUri(),
                        sessionStorage = SessionStorage();
                    if (!sessionStorage || sessionStorage.getItem(SESSION_KEY)) {
                        return $.Deferred().resolve().promise()
                    }
                    sessionStorage.removeItem(SESSION_KEY);
                    this._browserAdapter.createRootPage();
                    return this._browserAdapter.pushState(hash)
                },
                _onPopState: function() {
                    if (this._browserAdapter.isRootPage()) {
                        if (this._rootStateHandler) {
                            this._rootStateHandler()
                        } else {
                            this.backInitiated.fire()
                        }
                    } else {
                        if (!this._rootStateHandler) {
                            this._createRootStateHandler()
                        }
                        this.back()
                    }
                },
                _createRootStateHandler: function() {
                    var uri = this.getUri();
                    this._rootStateHandler = function() {
                        this.uriChanged.fire(uri);
                        this._rootStateHandler = null
                    }
                }
            });
            exports.HistoryBasedNavigationDevice = HistoryBasedNavigationDevice;
            exports.StackBasedNavigationDevice = StackBasedNavigationDevice
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/framework/router.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5);
            var JSON_URI_PREFIX = encodeURIComponent("json:");
            var Route = Class.inherit({
                _trimSeparators: function(str) {
                    return str.replace(/^[\/.]+|\/+$/g, "")
                },
                _escapeRe: function(str) {
                    return str.replace(/\W/g, "\\$1")
                },
                _checkConstraint: function(param, constraint) {
                    param = String(param);
                    if ("string" === typeof constraint) {
                        constraint = new RegExp(constraint)
                    }
                    var match = constraint.exec(param);
                    if (!match || match[0] !== param) {
                        return false
                    }
                    return true
                },
                _ensureReady: function() {
                    var that = this;
                    if (this._patternRe) {
                        return false
                    }
                    this._pattern = this._trimSeparators(this._pattern);
                    this._patternRe = "";
                    this._params = [];
                    this._segments = [];
                    this._separators = [];
                    this._pattern.replace(/[^\/]+/g, function(segment, index) {
                        that._segments.push(segment);
                        if (index) {
                            that._separators.push(that._pattern.substr(index - 1, 1))
                        }
                    });
                    $.each(this._segments, function(index) {
                        var isStatic = true,
                            segment = this,
                            separator = index ? that._separators[index - 1] : "";
                        if (":" === segment.charAt(0)) {
                            isStatic = false;
                            segment = segment.substr(1);
                            that._params.push(segment);
                            that._patternRe += "(?:" + separator + "([^/]*))";
                            if (segment in that._defaults) {
                                that._patternRe += "?"
                            }
                        } else {
                            that._patternRe += separator + that._escapeRe(segment)
                        }
                    });
                    this._patternRe = new RegExp("^" + this._patternRe + "$")
                },
                ctor: function(pattern, defaults, constraints) {
                    this._pattern = pattern || "";
                    this._defaults = defaults || {};
                    this._constraints = constraints || {}
                },
                parse: function(uri) {
                    var that = this;
                    this._ensureReady();
                    var matches = this._patternRe.exec(uri);
                    if (!matches) {
                        return false
                    }
                    var result = $.extend({}, this._defaults);
                    $.each(this._params, function(i) {
                        var index = i + 1;
                        if (matches.length >= index && matches[index]) {
                            result[this] = that.parseSegment(matches[index])
                        }
                    });
                    $.each(this._constraints, function(key) {
                        if (!that._checkConstraint(result[key], that._constraints[key])) {
                            result = false;
                            return false
                        }
                    });
                    return result
                },
                format: function(routeValues) {
                    var that = this,
                        query = "";
                    this._ensureReady();
                    var mergeValues = $.extend({}, this._defaults),
                        useStatic = 0,
                        ret = [],
                        dels = [],
                        unusedRouteValues = {};
                    $.each(routeValues, function(paramName, paramValue) {
                        routeValues[paramName] = that.formatSegment(paramValue);
                        if (!(paramName in mergeValues)) {
                            unusedRouteValues[paramName] = true
                        }
                    });
                    $.each(this._segments, function(index, segment) {
                        ret[index] = index ? that._separators[index - 1] : "";
                        if (":" === segment.charAt(0)) {
                            var paramName = segment.substr(1);
                            if (!(paramName in routeValues) && !(paramName in that._defaults)) {
                                ret = null;
                                return false
                            }
                            if (paramName in that._constraints && !that._checkConstraint(routeValues[paramName], that._constraints[paramName])) {
                                ret = null;
                                return false
                            }
                            if (paramName in routeValues) {
                                if (void 0 !== routeValues[paramName]) {
                                    mergeValues[paramName] = routeValues[paramName];
                                    ret[index] += routeValues[paramName];
                                    useStatic = index
                                }
                                delete unusedRouteValues[paramName]
                            } else {
                                if (paramName in mergeValues) {
                                    ret[index] += mergeValues[paramName];
                                    dels.push(index)
                                }
                            }
                        } else {
                            ret[index] += segment;
                            useStatic = index
                        }
                    });
                    $.each(mergeValues, function(key, value) {
                        if (!!value && -1 === $.inArray(":" + key, that._segments) && routeValues[key] !== value) {
                            ret = null;
                            return false
                        }
                    });
                    var unusedCount = 0;
                    if (!$.isEmptyObject(unusedRouteValues)) {
                        query = "?";
                        $.each(unusedRouteValues, function(key) {
                            query += key + "=" + routeValues[key] + "&";
                            unusedCount++
                        });
                        query = query.substr(0, query.length - 1)
                    }
                    if (null === ret) {
                        return false
                    }
                    if (dels.length) {
                        $.map(dels, function(i) {
                            if (i >= useStatic) {
                                ret[i] = ""
                            }
                        })
                    }
                    var path = ret.join("");
                    path = path.replace(/\/+$/, "");
                    return {
                        uri: path + query,
                        unusedCount: unusedCount
                    }
                },
                formatSegment: function(value) {
                    if ($.isArray(value) || $.isPlainObject(value)) {
                        return JSON_URI_PREFIX + encodeURIComponent(JSON.stringify(value))
                    }
                    return encodeURIComponent(value)
                },
                parseSegment: function(value) {
                    if (value.substr(0, JSON_URI_PREFIX.length) === JSON_URI_PREFIX) {
                        try {
                            return $.parseJSON(decodeURIComponent(value.substr(JSON_URI_PREFIX.length)))
                        } catch (x) {}
                    }
                    return decodeURIComponent(value)
                }
            });
            var Router = Class.inherit({
                ctor: function() {
                    this._registry = []
                },
                _trimSeparators: function(str) {
                    return str.replace(/^[\/.]+|\/+$/g, "")
                },
                _createRoute: function(pattern, defaults, constraints) {
                    return new Route(pattern, defaults, constraints)
                },
                register: function(pattern, defaults, constraints) {
                    this._registry.push(this._createRoute(pattern, defaults, constraints))
                },
                _parseQuery: function(query) {
                    var result = {},
                        values = query.split("&");
                    $.each(values, function(index, value) {
                        var keyValuePair = value.split("=");
                        result[keyValuePair[0]] = decodeURIComponent(keyValuePair[1])
                    });
                    return result
                },
                parse: function(uri) {
                    var ret, that = this;
                    uri = this._trimSeparators(uri);
                    var parts = uri.split("?", 2),
                        path = parts[0],
                        query = parts[1];
                    $.each(this._registry, function() {
                        var result = this.parse(path);
                        if (false !== result) {
                            ret = result;
                            if (query) {
                                ret = $.extend(ret, that._parseQuery(query))
                            }
                            return false
                        }
                    });
                    return ret ? ret : false
                },
                format: function(obj) {
                    var ret = false,
                        minUnusedCount = 99999;
                    obj = obj || {};
                    $.each(this._registry, function() {
                        var toFormat = $.extend(true, {}, obj);
                        var result = this.format(toFormat);
                        if (false !== result) {
                            if (minUnusedCount > result.unusedCount) {
                                minUnusedCount = result.unusedCount;
                                ret = result.uri
                            }
                        }
                    });
                    return ret
                }
            });
            Route.__internals = {
                JSON_URI_PREFIX: JSON_URI_PREFIX
            };
            module.exports = Router;
            module.exports.Route = Route
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/localization/currency.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                numberLocalization = __webpack_require__( /*! ./number */ 38);
            numberLocalization.inject({
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("currency" === format) {
                        formatConfig.precision = formatConfig.precision || 0;
                        return this.getCurrencySymbol().symbol + this.format(value, $.extend({}, formatConfig, {
                            type: "fixedpoint"
                        }))
                    }
                    return this.callBase.apply(this, arguments)
                },
                getCurrencySymbol: function(currency) {
                    return {
                        symbol: "$"
                    }
                },
                getOpenXmlCurrencyFormat: function(currency) {
                    return "$#,##0{0}_);\\($#,##0{0}\\)"
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/ui/collection/ui.data_helper.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                DataSource = __webpack_require__( /*! ../../data/data_source/data_source */ 37).DataSource,
                normalizeDataSourceOptions = __webpack_require__( /*! ../../data/data_source/data_source */ 37).normalizeDataSourceOptions;
            var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
                DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler",
                DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler",
                DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
            var DataHelperMixin = {
                postCtor: function() {
                    this.on("disposing", function() {
                        this._disposeDataSource()
                    })
                },
                _refreshDataSource: function() {
                    this._initDataSource();
                    this._loadDataSource()
                },
                _initDataSource: function() {
                    var widgetDataSourceOptions, dataSourceType, dataSourceOptions = this.option("dataSource");
                    this._disposeDataSource();
                    if (dataSourceOptions) {
                        if (dataSourceOptions instanceof DataSource) {
                            this._isSharedDataSource = true;
                            this._dataSource = dataSourceOptions
                        } else {
                            widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                            dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
                            this._dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, normalizeDataSourceOptions(dataSourceOptions)))
                        }
                        this._addDataSourceHandlers()
                    }
                },
                _addDataSourceHandlers: function() {
                    if (DATA_SOURCE_CHANGED_METHOD in this) {
                        this._addDataSourceChangeHandler()
                    }
                    if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
                        this._addDataSourceLoadErrorHandler()
                    }
                    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
                        this._addDataSourceLoadingChangedHandler()
                    }
                    this._addReadyWatcher()
                },
                _addReadyWatcher: function() {
                    this._dataSource.on("loadingChanged", $.proxy(function(isLoading) {
                        this._ready && this._ready(!isLoading)
                    }, this))
                },
                _addDataSourceChangeHandler: function() {
                    var dataSource = this._dataSource;
                    this._proxiedDataSourceChangedHandler = $.proxy(function() {
                        this[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
                    }, this);
                    dataSource.on("changed", this._proxiedDataSourceChangedHandler)
                },
                _addDataSourceLoadErrorHandler: function() {
                    this._proxiedDataSourceLoadErrorHandler = $.proxy(this[DATA_SOURCE_LOAD_ERROR_METHOD], this);
                    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
                },
                _addDataSourceLoadingChangedHandler: function() {
                    this._proxiedDataSourceLoadingChangedHandler = $.proxy(this[DATA_SOURCE_LOADING_CHANGED_METHOD], this);
                    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                },
                _loadDataSource: function() {
                    if (this._dataSource) {
                        var dataSource = this._dataSource;
                        if (dataSource.isLoaded()) {
                            this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler()
                        } else {
                            dataSource.load()
                        }
                    }
                },
                _loadSingle: function(key, value) {
                    key = "this" === key ? this._dataSource.key() || "this" : key;
                    return this._dataSource.loadSingle(key, value)
                },
                _isLastPage: function() {
                    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
                },
                _isDataSourceLoading: function() {
                    return this._dataSource && this._dataSource.isLoading()
                },
                _disposeDataSource: function() {
                    if (this._dataSource) {
                        if (this._isSharedDataSource) {
                            delete this._isSharedDataSource;
                            this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                            this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                            this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                        } else {
                            this._dataSource.dispose()
                        }
                        delete this._dataSource;
                        delete this._proxiedDataSourceChangedHandler;
                        delete this._proxiedDataSourceLoadErrorHandler;
                        delete this._proxiedDataSourceLoadingChangedHandler
                    }
                }
            };
            module.exports = DataHelperMixin
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!***************************************************!*\
      !*** ./Scripts/events/gesture/emitter.gesture.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                support = __webpack_require__( /*! ../../core/utils/support */ 18),
                browser = __webpack_require__( /*! ../../core/utils/browser */ 22),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                mathUtils = __webpack_require__( /*! ../../core/utils/math */ 66),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                eventUtils = __webpack_require__( /*! ../utils */ 4),
                Emitter = __webpack_require__( /*! ../core/emitter */ 81),
                sign = mathUtils.sign,
                abs = Math.abs;
            var SLEEP = 0,
                INITED = 1,
                STARTED = 2,
                TOUCH_BOUNDARY = 10,
                IMMEDIATE_TOUCH_BOUNDARY = 0,
                IMMEDIATE_TIMEOUT = 180;
            var isMousewheelEvent = function(e) {
                return e && "dxmousewheel" === e.type
            };
            var supportPointerEvents = function() {
                var cssSupport = support.styleProp("pointer-events");
                var msieLess11 = browser.msie && parseInt(browser.version, 10) < 11;
                return cssSupport && !msieLess11
            };
            var gestureCover = function() {
                var GESTURE_COVER_CLASS = "dx-gesture-cover";
                var isDesktop = "generic" === devices.real().platform;
                if (!supportPointerEvents() || !isDesktop) {
                    return $.noop
                }
                var $cover = $("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
                $cover.on("dxmousewheel", function(e) {
                    e.preventDefault()
                });
                $(function() {
                    $cover.appendTo("body")
                });
                return function(toggle, cursor) {
                    $cover.css("pointerEvents", toggle ? "all" : "none");
                    toggle && $cover.css("cursor", cursor)
                }
            }();
            var GestureEmitter = Emitter.inherit({
                gesture: true,
                configurate: function(data) {
                    this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
                    this.callBase(data)
                },
                allowInterruptionByMousewheel: function() {
                    return this._stage !== STARTED
                },
                getDirection: function() {
                    return this.direction
                },
                _cancel: function(e) {
                    this.callBase.apply(this, arguments);
                    this._toggleGestureCover(false);
                    this._stage = SLEEP
                },
                start: function(e) {
                    if (eventUtils.needSkipEvent(e)) {
                        this._cancel(e);
                        return
                    }
                    this._startEvent = eventUtils.createEvent(e);
                    this._startEventData = eventUtils.eventData(e);
                    this._prevEventData = this._startEventData;
                    this._stage = INITED;
                    this._init(e);
                    this._setupImmediateTimer()
                },
                _setupImmediateTimer: function() {
                    clearTimeout(this._immediateTimer);
                    this._immediateAccepted = false;
                    if (!this.immediate) {
                        return
                    }
                    this._immediateTimer = setTimeout($.proxy(function() {
                        this._immediateAccepted = true
                    }, this), IMMEDIATE_TIMEOUT)
                },
                move: function(e) {
                    if (this._stage === INITED && this._directionConfirmed(e)) {
                        this._stage = STARTED;
                        this._resetActiveElement();
                        this._toggleGestureCover(true, e);
                        this._clearSelection(e);
                        this._adjustStartEvent(e);
                        this._start(this._startEvent);
                        this._prevEventData = eventUtils.eventData(this._startEvent);
                        if (this._stage === SLEEP) {
                            return
                        }
                        this._requestAccept(e);
                        this._move(e);
                        this._forgetAccept()
                    } else {
                        if (this._stage === STARTED) {
                            this._clearSelection(e);
                            this._move(e)
                        }
                    }
                    this._prevEventData = eventUtils.eventData(e)
                },
                _directionConfirmed: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e)),
                        deltaX = abs(delta.x),
                        deltaY = abs(delta.y);
                    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),
                        verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
                    var direction = this.getDirection(e),
                        bothAccepted = "both" === direction && (horizontalMove || verticalMove),
                        horizontalAccepted = "horizontal" === direction && horizontalMove,
                        verticalAccepted = "vertical" === direction && verticalMove;
                    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted
                },
                _validateMove: function(touchBoundary, mainAxis, crossAxis) {
                    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
                },
                _getTouchBoundary: function(e) {
                    return this.immediate || isMousewheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
                },
                _adjustStartEvent: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                    this._startEvent.pageX += sign(delta.x) * touchBoundary;
                    this._startEvent.pageY += sign(delta.y) * touchBoundary
                },
                _resetActiveElement: function() {
                    if ("ios" === devices.real().platform && $(":focus", this.getElement()).length) {
                        domUtils.resetActiveElement()
                    }
                },
                _toggleGestureCover: function(toggle, e) {
                    var isStarted = this._stage === STARTED;
                    if (isStarted) {
                        gestureCover(toggle, this.getElement().css("cursor"))
                    }
                },
                _clearSelection: function(e) {
                    if (isMousewheelEvent(e) || eventUtils.isTouchEvent(e)) {
                        return
                    }
                    domUtils.clearSelection()
                },
                end: function(e) {
                    this._toggleGestureCover(false, e);
                    if (this._stage === STARTED) {
                        this._end(e)
                    } else {
                        if (this._stage === INITED) {
                            this._stop(e)
                        }
                    }
                    this._stage = SLEEP
                },
                dispose: function() {
                    clearTimeout(this._immediateTimer);
                    this.callBase.apply(this, arguments);
                    this._toggleGestureCover(false)
                },
                _init: $.noop,
                _start: $.noop,
                _move: $.noop,
                _stop: $.noop,
                _end: $.noop
            });
            GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
            GestureEmitter.touchBoundary = function(newBoundary) {
                if (commonUtils.isDefined(newBoundary)) {
                    TOUCH_BOUNDARY = newBoundary;
                    return
                }
                return TOUCH_BOUNDARY
            };
            module.exports = GestureEmitter
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************!*\
      !*** ./Scripts/viz/palette.js ***!
      \********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ./core/utils */ 6),
                _floor = Math.floor,
                _ceil = Math.ceil,
                _Color = __webpack_require__( /*! ../color */ 55),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                _isArray = commonUtils.isArray,
                _isString = commonUtils.isString,
                _extend = $.extend,
                _normalizeEnum = vizUtils.normalizeEnum,
                HIGHLIGHTING_STEP = 50,
                DEFAULT = "default",
                currentPaletteName = DEFAULT;
            var palettes = {
                "default": {
                    simpleSet: ["#5f8b95", "#ba4d51", "#af8a53", "#955f71", "#859666", "#7e688c"],
                    indicatingSet: ["#a3b97c", "#e1b676", "#ec7f83"],
                    gradientSet: ["#5f8b95", "#ba4d51"]
                },
                "harmony light": {
                    simpleSet: ["#fcb65e", "#679ec5", "#ad79ce", "#7abd5c", "#e18e92", "#b6d623", "#b7abea", "#85dbd5"],
                    indicatingSet: ["#b6d623", "#fcb65e", "#e18e92"],
                    gradientSet: ["#7abd5c", "#fcb65e"]
                },
                "soft pastel": {
                    simpleSet: ["#60a69f", "#78b6d9", "#6682bb", "#a37182", "#eeba69", "#90ba58", "#456c68", "#7565a4"],
                    indicatingSet: ["#90ba58", "#eeba69", "#a37182"],
                    gradientSet: ["#78b6d9", "#eeba69"]
                },
                pastel: {
                    simpleSet: ["#bb7862", "#70b3a1", "#bb626a", "#057d85", "#ab394b", "#dac599", "#153459", "#b1d2c6"],
                    indicatingSet: ["#70b3a1", "#dac599", "#bb626a"],
                    gradientSet: ["#bb7862", "#70b3a1"]
                },
                bright: {
                    simpleSet: ["#70c92f", "#f8ca00", "#bd1550", "#e97f02", "#9d419c", "#7e4452", "#9ab57e", "#36a3a6"],
                    indicatingSet: ["#70c92f", "#f8ca00", "#bd1550"],
                    gradientSet: ["#e97f02", "#f8ca00"]
                },
                soft: {
                    simpleSet: ["#cbc87b", "#9ab57e", "#e55253", "#7e4452", "#e8c267", "#565077", "#6babac", "#ad6082"],
                    indicatingSet: ["#9ab57e", "#e8c267", "#e55253"],
                    gradientSet: ["#9ab57e", "#e8c267"]
                },
                ocean: {
                    simpleSet: ["#75c099", "#acc371", "#378a8a", "#5fa26a", "#064970", "#38c5d2", "#00a7c6", "#6f84bb"],
                    indicatingSet: ["#c8e394", "#7bc59d", "#397c8b"],
                    gradientSet: ["#acc371", "#38c5d2"]
                },
                vintage: {
                    simpleSet: ["#dea484", "#efc59c", "#cb715e", "#eb9692", "#a85c4c", "#f2c0b5", "#c96374", "#dd956c"],
                    indicatingSet: ["#ffe5c6", "#f4bb9d", "#e57660"],
                    gradientSet: ["#efc59c", "#cb715e"]
                },
                violet: {
                    simpleSet: ["#d1a1d1", "#eeacc5", "#7b5685", "#7e7cad", "#a13d73", "#5b41ab", "#e287e2", "#689cc1"],
                    indicatingSet: ["#d8e2f6", "#d0b2da", "#d56a8a"],
                    gradientSet: ["#eeacc5", "#7b5685"]
                }
            };

            function currentPalette(name) {
                if (void 0 === name) {
                    return currentPaletteName
                } else {
                    name = _normalizeEnum(name);
                    currentPaletteName = name in palettes ? name : DEFAULT
                }
            }

            function getPalette(palette, parameters) {
                var result, type = parameters && parameters.type;
                if (_isArray(palette)) {
                    return palette.slice(0)
                } else {
                    if (_isString(palette)) {
                        result = palettes[_normalizeEnum(palette)]
                    }
                    if (!result) {
                        result = palettes[currentPaletteName]
                    }
                }
                result = result || null;
                return type ? result ? result[type].slice(0) : result : result
            }

            function registerPalette(name, palette) {
                var paletteName, item = {};
                if (_isArray(palette)) {
                    item.simpleSet = palette.slice(0)
                } else {
                    if (palette) {
                        item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : void 0;
                        item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : void 0;
                        item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : void 0
                    }
                }
                if (item.simpleSet || item.indicatingSet || item.gradientSet) {
                    paletteName = _normalizeEnum(name);
                    _extend(palettes[paletteName] = palettes[paletteName] || {}, item)
                }
            }

            function RingBuf(buf) {
                var ind = 0;
                this.next = function() {
                    var res = buf[ind++];
                    if (ind === buf.length) {
                        this.reset()
                    }
                    return res
                };
                this.reset = function() {
                    ind = 0
                }
            }

            function Palette(palette, parameters) {
                parameters = parameters || {};
                var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
                this._originalPalette = getPalette(palette, {
                    type: parameters.type || "simpleSet"
                });
                this._paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
                this._resetPalette()
            }
            Palette.prototype = {
                constructor: Palette,
                dispose: function() {
                    this._originalPalette = this._palette = this._paletteSteps = null
                },
                getNextColor: function() {
                    var that = this;
                    if (that._currentColor >= that._palette.length) {
                        that._resetPalette()
                    }
                    return that._palette[that._currentColor++]
                },
                _resetPalette: function() {
                    var that = this,
                        step = that._paletteSteps.next();
                    that._palette = step ? getAlteredPalette(that._originalPalette, step) : that._originalPalette.slice(0);
                    that._currentColor = 0
                },
                reset: function() {
                    this._paletteSteps.reset();
                    this._resetPalette();
                    return this
                }
            };

            function getAlteredPalette(originalPalette, step) {
                var i, palette = [],
                    ii = originalPalette.length;
                for (i = 0; i < ii; ++i) {
                    palette.push(getNewColor(originalPalette[i], step))
                }
                return palette
            }

            function getNewColor(currentColor, step) {
                var newColor = new _Color(currentColor).alter(step),
                    lightness = getLightness(newColor);
                if (lightness > 200 || lightness < 55) {
                    newColor = new _Color(currentColor).alter(-step / 2)
                }
                return newColor.toHex()
            }

            function getLightness(color) {
                return .3 * color.r + .59 * color.g + .11 * color.b
            }

            function DiscretePalette(source, size) {
                var palette = size > 0 ? createDiscreteColors(getPalette(source, {
                    type: "gradientSet"
                }), size) : [];
                this.getColor = function(index) {
                    return palette[index] || null
                }
            }

            function createDiscreteColors(source, count) {
                var i, ncolors = count - 1,
                    nsource = source.length - 1,
                    colors = [],
                    gradient = [];

                function addColor(pos) {
                    var k = nsource * pos,
                        kl = _floor(k),
                        kr = _ceil(k);
                    gradient.push(colors[kl].blend(colors[kr], k - kl).toHex())
                }
                for (i = 0; i <= nsource; ++i) {
                    colors.push(new _Color(source[i]))
                }
                if (ncolors > 0) {
                    for (i = 0; i <= ncolors; ++i) {
                        addColor(i / ncolors)
                    }
                } else {
                    addColor(.5)
                }
                return gradient
            }

            function GradientPalette(source) {
                var palette = getPalette(source, {
                        type: "gradientSet"
                    }),
                    color1 = new _Color(palette[0]),
                    color2 = new _Color(palette[1]);
                this.getColor = function(ratio) {
                    return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null
                }
            }
            _extend(exports, {
                Palette: Palette,
                DiscretePalette: DiscretePalette,
                GradientPalette: GradientPalette,
                registerPalette: registerPalette,
                getPalette: getPalette,
                currentPalette: currentPalette
            });
            exports._DEBUG_palettes = palettes
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/core/utils/storage.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var getSessionStorage = function() {
                var sessionStorage;
                try {
                    sessionStorage = window.sessionStorage
                } catch (e) {}
                return sessionStorage
            };
            exports.sessionStorage = getSessionStorage
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/core/version.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = "16.1.5"
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , ,
    /*!******************************************!*\
      !*** ./Scripts/viz/components/consts.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = {
                events: {
                    mouseover: "mouseover",
                    mouseout: "mouseout",
                    mousemove: "mousemove",
                    touchstart: "touchstart",
                    touchmove: "touchmove",
                    touchend: "touchend",
                    mousedown: "mousedown",
                    mouseup: "mouseup",
                    click: "click",
                    selectSeries: "selectseries",
                    deselectSeries: "deselectseries",
                    selectPoint: "selectpoint",
                    deselectPoint: "deselectpoint",
                    showPointTooltip: "showpointtooltip",
                    hidePointTooltip: "hidepointtooltip"
                },
                states: {
                    hover: "hover",
                    normal: "normal",
                    selection: "selection",
                    normalMark: 0,
                    hoverMark: 1,
                    selectedMark: 2,
                    applyHover: "applyHover",
                    applySelected: "applySelected",
                    resetItem: "resetItem"
                },
                pieLabelIndent: 30,
                pieLabelSpacing: 10,
                pieSeriesSpacing: 4
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/viz/core/export.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _extend = $.extend,
                _each = $.each,
                clientExporter = __webpack_require__( /*! ../../client_exporter */ 138),
                messageLocalization = __webpack_require__( /*! ../../localization/message */ 8),
                config = __webpack_require__( /*! ../../core/config */ 35),
                imageExporter = clientExporter.image,
                svgExporter = clientExporter.svg,
                pdfExporter = clientExporter.pdf,
                hoverEvent = __webpack_require__( /*! ../../events/hover */ 133),
                pointerEvents = __webpack_require__( /*! ../../events/pointer */ 13),
                pointerActions = [pointerEvents.down, pointerEvents.move].join(" "),
                BUTTON_SIZE = 35,
                ICON_COORDS = [
                    [9, 12, 26, 12, 26, 14, 9, 14],
                    [9, 17, 26, 17, 26, 19, 9, 19],
                    [9, 22, 26, 22, 26, 24, 9, 24]
                ],
                LIST_PADDING_TOP = 4,
                LIST_WIDTH = 120,
                VERTICAL_TEXT_MARGIN = 8,
                HORIZONTAL_TEXT_MARGIN = 15,
                MENU_ITEM_HEIGHT = 30,
                LIST_STROKE_WIDTH = 1,
                MARGIN = 10,
                SHADOW_OFFSET = 2,
                SHADOW_BLUR = 3,
                ALLOWED_EXPORT_FORMATS = ["PNG", "PDF", "JPEG", "SVG", "GIF"],
                EXPORT_CSS_CLASS = "dx-export-menu",
                EXPORT_DATA_KEY = "export-element-type",
                FORMAT_DATA_KEY = "export-element-format";

            function validateFormat(format) {
                var validatedFormat = String(format).toUpperCase();
                if (-1 !== $.inArray(validatedFormat, ALLOWED_EXPORT_FORMATS)) {
                    return validatedFormat
                }
            }

            function getCreatorFunc(format) {
                if ("SVG" === format) {
                    return svgExporter.getBlob
                } else {
                    if ("PDF" === format) {
                        return pdfExporter.getBlob
                    } else {
                        return imageExporter.getBlob
                    }
                }
            }

            function print(data) {
                var vizWindow = window.open();
                if (!vizWindow) {
                    return
                }
                vizWindow.document.open();
                vizWindow.document.write(data);
                vizWindow.document.close();
                vizWindow.print();
                vizWindow.close()
            }
            exports.exportFromMarkup = function(markup, options) {
                options.format = validateFormat(options.format) || "PNG";
                options.fileName = options.fileName || "file";
                clientExporter.export(markup, options, getCreatorFunc(options.format))
            };
            exports.ExportMenu = function(renderer, svgMethod) {
                var that = this;
                that._renderer = renderer;
                that._svgMethod = svgMethod;
                that._shadow = renderer.shadowFilter("-50%", "-50%", "200%", "200%", SHADOW_OFFSET, 6, SHADOW_BLUR);
                that._shadow.attr({
                    opacity: .8
                });
                that._group = renderer.g().attr({
                    "class": EXPORT_CSS_CLASS
                }).linkOn(renderer.root, {
                    name: "export-menu",
                    after: "peripheral"
                });
                that._buttonGroup = renderer.g().attr({
                    "class": EXPORT_CSS_CLASS + "-button"
                }).append(that._group);
                that._listGroup = renderer.g().attr({
                    "class": EXPORT_CSS_CLASS + "-list"
                }).append(that._group);
                that._subscribeEvents()
            };
            _extend(exports.ExportMenu.prototype, {
                getLayoutOptions: function() {
                    var bbox = this._buttonGroup.getBBox();
                    bbox.cutSide = "vertical";
                    bbox.cutLayoutSide = "top";
                    bbox.height += 2 * MARGIN;
                    bbox.position = {
                        vertical: "top",
                        horizontal: "right"
                    };
                    bbox.verticalAlignment = "top";
                    bbox.horizontalAlignment = "right";
                    return bbox
                },
                probeDraw: $.noop,
                shift: function(_, y) {
                    this._group.attr({
                        translateY: this._group.attr("translateY") + y
                    })
                },
                draw: function(_, height, canvas) {
                    this._options.exportOptions.width = canvas.width;
                    this._options.exportOptions.height = canvas.height;
                    this._group.move(canvas.width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR, height - BUTTON_SIZE - MARGIN)
                },
                show: function() {
                    this._group.linkAppend()
                },
                hide: function() {
                    this._group.linkRemove()
                },
                setOptions: function(options) {
                    this._options = options;
                    options.formats = options.formats || ALLOWED_EXPORT_FORMATS;
                    options.printingEnabled = void 0 === options.printingEnabled ? true : options.printingEnabled;
                    if (options.enabled && (options.formats.length || options.printingEnabled)) {
                        this.show();
                        this._updateButton();
                        this._updateList();
                        this._hideList()
                    } else {
                        this.hide()
                    }
                },
                dispose: function() {
                    var that = this;
                    that._unsubscribeEvents();
                    that._group.linkRemove().linkOff();
                    that._group.dispose();
                    that._shadow.dispose();
                    that._shadow = that._group = that._listGroup = that._buttonGroup = that._button = null;
                    that._options = null
                },
                layoutOptions: function() {
                    var options = this._options;
                    return options.enabled && {
                        horizontalAlignment: "right",
                        verticalAlignment: "top",
                        weak: true
                    }
                },
                measure: function() {
                    return [BUTTON_SIZE + SHADOW_OFFSET, BUTTON_SIZE]
                },
                move: function(rect) {
                    this._group.attr({
                        translateX: Math.round(rect[0]),
                        translateY: Math.round(rect[1])
                    })
                },
                _hideList: function() {
                    this._listGroup.attr({
                        visibility: "hidden"
                    });
                    this._listShown = false;
                    this._setButtonState("default")
                },
                _showList: function() {
                    this._listGroup.attr({
                        visibility: "visible"
                    });
                    this._listShown = true
                },
                _setButtonState: function(state) {
                    var that = this,
                        style = that._options.button[state];
                    this._button.attr({
                        stroke: style.borderColor,
                        fill: style.backgroundColor
                    });
                    this._icon.attr({
                        fill: style.color
                    })
                },
                _subscribeEvents: function() {
                    var that = this;
                    that._renderer.root.on(pointerEvents.up + ".export", function(e) {
                        var exportOptions, elementType = e.target[EXPORT_DATA_KEY],
                            options = that._options;
                        if (!elementType) {
                            if (that._button) {
                                that._hideList()
                            }
                            return
                        }
                        if ("button" === elementType) {
                            if (that._listShown) {
                                that._setButtonState("default");
                                that._hideList()
                            } else {
                                that._setButtonState("focus");
                                that._showList()
                            }
                        } else {
                            if ("printing" === elementType) {
                                that.hide();
                                print(that._svgMethod());
                                that.show();
                                that._hideList()
                            } else {
                                if ("exporting" === elementType) {
                                    that.hide();
                                    exportOptions = _extend({}, options.exportOptions, {
                                        format: e.target[FORMAT_DATA_KEY],
                                        backgroundColor: options.backgroundColor
                                    });
                                    clientExporter.export(that._svgMethod(), exportOptions, getCreatorFunc(exportOptions.format));
                                    that.show();
                                    that._hideList()
                                }
                            }
                        }
                    });
                    that._listGroup.on(pointerActions, function(e) {
                        e.stopPropagation()
                    });
                    that._buttonGroup.on(pointerEvents.enter, function() {
                        that._setButtonState("hover")
                    });
                    that._buttonGroup.on(pointerEvents.leave, function() {
                        that._setButtonState(that._listShown ? "focus" : "default")
                    });
                    that._buttonGroup.on(pointerEvents.down + ".export", function(e) {
                        that._setButtonState("active")
                    })
                },
                _unsubscribeEvents: function() {
                    this._renderer.root.off(".export");
                    this._listGroup.off();
                    this._buttonGroup.off()
                },
                _updateButton: function() {
                    var that = this,
                        renderer = that._renderer,
                        options = that._options,
                        iconAttr = {
                            fill: options.button.default.color,
                            cursor: "pointer"
                        },
                        exportData = {
                            "export-element-type": "button"
                        };
                    if (!that._button) {
                        that._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(that._buttonGroup);
                        that._button.attr({
                            rx: 4,
                            ry: 4,
                            fill: options.button.default.backgroundColor,
                            stroke: options.button.default.borderColor,
                            "stroke-width": 1,
                            cursor: "pointer"
                        });
                        that._button.data(exportData);
                        that._icon = renderer.path(ICON_COORDS).append(that._buttonGroup);
                        that._icon.attr(iconAttr);
                        that._icon.data(exportData);
                        that._buttonGroup.setTitle(messageLocalization.format("vizExport-titleMenuText"))
                    }
                },
                _getItemStyle: function(options) {
                    var font = options.font,
                        style = {
                            rect: {
                                cursor: "pointer",
                                "pointer-events": "all"
                            },
                            text: {
                                "pointer-events": "none"
                            }
                        };
                    style.text["font-size"] = font.size;
                    style.text["font-family"] = font.family;
                    style.text.fill = font.color;
                    style.text["font-weight"] = font.weight;
                    return style
                },
                _getItemAttributes: function(options, items) {
                    var path, attr = {},
                        x = BUTTON_SIZE - LIST_WIDTH,
                        y = BUTTON_SIZE + LIST_PADDING_TOP + (items.length + 1) * MENU_ITEM_HEIGHT;
                    attr.rect = {
                        width: LIST_WIDTH - 2 * LIST_STROKE_WIDTH,
                        height: MENU_ITEM_HEIGHT,
                        x: x + LIST_STROKE_WIDTH,
                        y: y - MENU_ITEM_HEIGHT
                    };
                    attr.text = config().rtlEnabled ? {
                        x: x + LIST_WIDTH - 2 * LIST_STROKE_WIDTH - HORIZONTAL_TEXT_MARGIN
                    } : {
                        x: x + HORIZONTAL_TEXT_MARGIN
                    };
                    attr.text.y = y - VERTICAL_TEXT_MARGIN;
                    if ("printing" === options.type) {
                        path = "M " + x + " " + (y - LIST_STROKE_WIDTH) + " L " + (x + LIST_WIDTH) + " " + (y - LIST_STROKE_WIDTH);
                        attr.separator = {
                            stroke: options.stroke,
                            "stroke-width": LIST_STROKE_WIDTH,
                            cursor: "pointer",
                            sharp: "v",
                            d: path
                        }
                    }
                    return attr
                },
                _addMenuItem: function(renderer, options, items) {
                    var menuItem, that = this,
                        itemData = {},
                        hoverFill = options.hoverFill,
                        fill = options.fill,
                        type = options.type,
                        format = options.format,
                        style = that._getItemStyle(options),
                        attr = that._getItemAttributes(options, items);
                    menuItem = renderer.g().attr({
                        "class": EXPORT_CSS_CLASS + "-list-item"
                    });
                    itemData[EXPORT_DATA_KEY] = type;
                    if (format) {
                        itemData[FORMAT_DATA_KEY] = format
                    }
                    var rect = renderer.rect(),
                        text = renderer.text(options.text);
                    rect.attr(attr.rect).css(style.rect).data(itemData);
                    rect.on(hoverEvent.start + ".export", function(e) {
                        rect.attr({
                            fill: hoverFill
                        })
                    }).on(hoverEvent.end + ".export", function(e) {
                        rect.attr({
                            fill: fill
                        })
                    });
                    rect.append(menuItem);
                    text.css(style.text).attr(attr.text).append(menuItem);
                    if ("printing" === type) {
                        renderer.path(null, "line").attr(attr.separator).append(menuItem)
                    }
                    items.push({
                        g: menuItem,
                        rect: rect
                    })
                },
                _getMenuItems: function(options) {
                    var that = this,
                        buttonDefault = options.button.default,
                        buttonHover = options.button.hover,
                        formats = options.formats,
                        renderer = that._renderer,
                        items = [];
                    if (options.printingEnabled) {
                        that._addMenuItem(renderer, {
                            font: options.font,
                            type: "printing",
                            fill: buttonDefault.backgroundColor,
                            stroke: buttonDefault.borderColor,
                            hoverFill: buttonHover.backgroundColor,
                            text: messageLocalization.format("vizExport-printingButtonText")
                        }, items)
                    }
                    _each(formats, function(_, format) {
                        format = validateFormat(format);
                        if (format) {
                            that._addMenuItem(renderer, {
                                font: options.font,
                                fill: buttonDefault.backgroundColor,
                                stroke: buttonDefault.borderColor,
                                hoverFill: buttonHover.backgroundColor,
                                type: "exporting",
                                text: messageLocalization.getFormatter("vizExport-exportButtonText")(format),
                                format: format
                            }, items)
                        }
                    });
                    items && that._setConnerRadius(items);
                    return items
                },
                _getMenuOverlay: function(options, items) {
                    var rect, listHeight, that = this,
                        listPadding = BUTTON_SIZE + LIST_PADDING_TOP,
                        renderer = that._renderer,
                        xCoord = -LIST_WIDTH + BUTTON_SIZE;
                    listHeight = items.length * MENU_ITEM_HEIGHT;
                    rect = renderer.rect(xCoord, listPadding, LIST_WIDTH, listHeight);
                    that._shadow.attr({
                        color: options.shadowColor
                    });
                    rect.attr({
                        fill: options.button.default.backgroundColor,
                        stroke: options.button.default.borderColor,
                        "stroke-width": LIST_STROKE_WIDTH,
                        cursor: "pointer",
                        rx: 4,
                        ry: 4,
                        filter: that._shadow.ref
                    });
                    rect.data({
                        "export-element-type": "list"
                    });
                    return rect
                },
                _setConnerRadius: function(items) {
                    var firstRect = items[0].rect,
                        lastRect = items[items.length - 1].rect;
                    firstRect.attr({
                        y: parseInt(firstRect.attr("y")) + 2 * LIST_STROKE_WIDTH,
                        height: parseInt(firstRect.attr("height")) - 2 * LIST_STROKE_WIDTH
                    });
                    lastRect.attr({
                        height: parseInt(lastRect.attr("height")) - 2 * LIST_STROKE_WIDTH
                    })
                },
                _updateList: function() {
                    var that = this,
                        options = that._options,
                        listGroup = that._listGroup,
                        items = that._getMenuItems(options),
                        menuOverlay = that._getMenuOverlay(options, items);
                    listGroup.clear();
                    menuOverlay.append(listGroup);
                    _each(items, function(_, item) {
                        item.g.append(listGroup)
                    })
                }
            });

            function getExportOptions(widget, fileName, format, backgroundColor) {
                var validatedFormat = String(format).toUpperCase();
                if (-1 === $.inArray(validatedFormat, ["PNG", "PDF", "JPEG", "SVG", "GIF"])) {
                    validatedFormat = "PNG"
                }
                return {
                    format: validatedFormat,
                    fileName: fileName || "file",
                    proxyUrl: widget.option("export.proxyUrl"),
                    width: widget._canvas.width,
                    height: widget._canvas.height,
                    exportingAction: widget._createActionByOption("onExporting"),
                    exportedAction: widget._createActionByOption("onExported"),
                    fileSavingAction: widget._createActionByOption("onFileSaving")
                }
            }
            exports.plugin = {
                name: "export",
                init: function() {
                    var that = this;
                    that._exportMenu = new exports.ExportMenu(that._renderer, function() {
                        return that.svg()
                    });
                    that._layout.add(that._exportMenu)
                },
                dispose: function() {
                    this._exportMenu.dispose();
                    this._exportMenu = null
                },
                members: {
                    _getExportMenuOptions: function() {
                        var that = this,
                            userOptions = that._getOption("export") || {},
                            options = getExportOptions(that, userOptions.fileName, userOptions.format, userOptions.color);
                        return $.extend({}, userOptions, {
                            exportOptions: options
                        })
                    },
                    exportTo: function(fileName, format) {
                        var creatorFunc, exportOptions = getExportOptions(this, fileName, format),
                            exportMenu = this._exportMenu;
                        if ("SVG" === exportOptions.format) {
                            creatorFunc = clientExporter.svg.getBlob
                        } else {
                            if ("PDF" === exportOptions.format) {
                                creatorFunc = clientExporter.pdf.getBlob
                            } else {
                                creatorFunc = clientExporter.image.getBlob
                            }
                        }
                        exportMenu && exportMenu.hide();
                        clientExporter.export(this.svg(), exportOptions, creatorFunc);
                        exportMenu && exportMenu.show()
                    },
                    print: function() {
                        var vizWindow = window.open();
                        if (!vizWindow) {
                            return
                        }
                        vizWindow.document.open();
                        vizWindow.document.write(this.svg());
                        vizWindow.document.close();
                        vizWindow.print();
                        vizWindow.close()
                    }
                },
                customize: function(constructor) {
                    var proto = constructor.prototype;
                    constructor.addChange({
                        code: "EXPORT",
                        handler: function() {
                            this._exportMenu.setOptions(this._getExportMenuOptions());
                            this._change(["LAYOUT"])
                        },
                        isThemeDependent: true,
                        isOptionChange: true,
                        option: "export"
                    });
                    proto._optionChangesMap.onExporting = "EXPORT";
                    proto._optionChangesMap.onExported = "EXPORT";
                    proto._optionChangesMap.onFileSaving = "EXPORT"
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/gauges/base_gauge.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _Number = Number,
                _getAppropriateFormat = __webpack_require__( /*! ../core/utils */ 6).getAppropriateFormat,
                translator1DModule = __webpack_require__( /*! ../translators/translator1d */ 341),
                _extend = $.extend,
                BaseWidget = __webpack_require__( /*! ../core/base_widget */ 109),
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                Tracker = __webpack_require__( /*! ./tracker */ 528),
                _isString = commonUtils.isString;
            var dxBaseGauge = BaseWidget.inherit({
                _rootClassPrefix: "dxg",
                _createThemeManager: function() {
                    return new this._factory.ThemeManager
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    _extend(this._deprecatedOptions, {
                        subtitle: {
                            since: "15.2",
                            message: "Use the 'title.subtitle' option instead"
                        },
                        "title.position": {
                            since: "15.2",
                            message: "Use the 'verticalAlignment' and 'horizontalAlignment' options instead"
                        },
                        "scale.hideFirstTick": {
                            since: "15.2",
                            message: "The functionality is not more available"
                        },
                        "scale.hideLastTick": {
                            since: "15.2",
                            message: "The functionality is not more available"
                        },
                        "scale.hideFirstLabel": {
                            since: "15.2",
                            message: "The functionality is not more available"
                        },
                        "scale.hideLastLabel": {
                            since: "15.2",
                            message: "The functionality is not more available"
                        },
                        "scale.majorTick": {
                            since: "15.2",
                            message: "Use the 'tick' option instead"
                        },
                        "scale.minorTick.showCalculatedTicks": {
                            since: "15.2",
                            message: "The functionality is not more available"
                        },
                        "scale.minorTick.customTickValues": {
                            since: "15.2",
                            message: "Use the 'customMinorTicks' option instead"
                        },
                        "scale.minorTick.tickInterval": {
                            since: "15.2",
                            message: "Use the 'minorTickInterval' option instead"
                        }
                    })
                },
                _initCore: function() {
                    var that = this,
                        root = that._renderer.root;
                    that._valueChangingLocker = 0;
                    that._translator = that._factory.createTranslator();
                    that._initDeltaIndicator();
                    that._tracker = that._factory.createTracker({
                        renderer: that._renderer,
                        container: root
                    });
                    that._setTrackerCallbacks()
                },
                _beginValueChanging: function() {
                    this._resetIsReady();
                    ++this._valueChangingLocker
                },
                _endValueChanging: function() {
                    if (0 === --this._valueChangingLocker) {
                        this._drawn()
                    }
                },
                _initDeltaIndicator: function() {
                    var that = this,
                        DeltaIndicator = that._DeltaIndicator;
                    if (DeltaIndicator) {
                        that._deltaIndicator = new DeltaIndicator({
                            renderer: that._renderer,
                            container: that._renderer.root
                        });
                        that._deltaIndicator.layoutOptions = function() {
                            this.clean();
                            this.draw(that._getOption("indicator"));
                            var options = this.getLayoutOptions();
                            this._size = options ? [options.width, options.height] : null;
                            return options && {
                                horizontalAlignment: options.horizontalAlignment || "center",
                                verticalAlignment: options.verticalAlignment || "bottom"
                            }
                        };
                        that._deltaIndicator.measure = function() {
                            return this._size
                        };
                        that._deltaIndicator.move = function(rect) {
                            return this.shift(Math.round(rect[0]), Math.round(rect[1]))
                        };
                        that._layout.add(that._deltaIndicator)
                    }
                },
                _disposeDeltaIndicator: function() {
                    if (this._deltaIndicator) {
                        this._deltaIndicator.clean();
                        this._deltaIndicator.dispose()
                    }
                },
                _setTrackerCallbacks: function() {
                    var that = this,
                        renderer = that._renderer,
                        tooltip = that._tooltip;
                    that._tracker.setCallbacks({
                        "tooltip-show": function(target, info) {
                            var tooltipParameters = target.getTooltipParameters(),
                                offset = renderer.getRootOffset(),
                                formatObject = _extend({
                                    value: tooltipParameters.value,
                                    valueText: tooltip.formatValue(tooltipParameters.value),
                                    color: tooltipParameters.color
                                }, info);
                            return tooltip.show(formatObject, {
                                x: tooltipParameters.x + offset.left,
                                y: tooltipParameters.y + offset.top,
                                offset: tooltipParameters.offset
                            }, {
                                target: info
                            })
                        },
                        "tooltip-hide": function() {
                            return tooltip.hide()
                        }
                    });
                    that._resetTrackerCallbacks = function() {
                        that._resetTrackerCallbacks = that = renderer = tooltip = null
                    }
                },
                _dispose: function() {
                    this._cleanCore();
                    this.callBase.apply(this, arguments)
                },
                _disposeCore: function() {
                    var that = this;
                    that._themeManager.dispose();
                    that._tracker.dispose();
                    that._disposeDeltaIndicator();
                    that._translator = that._tracker = null
                },
                _cleanCore: function() {
                    var that = this;
                    that._tracker.deactivate();
                    that._cleanContent()
                },
                _renderCore: function() {
                    var that = this;
                    if (!that._isValidDomain) {
                        return
                    }
                    that._renderContent();
                    that._tracker.setTooltipState(that._tooltip.isEnabled());
                    that._tracker.activate();
                    that._noAnimation = false;
                    that._debug_rendered && that._debug_rendered()
                },
                _applyChanges: function() {
                    this.callBase.apply(this, arguments);
                    this._resizing = this._noAnimation = false
                },
                _setContentSize: function() {
                    var that = this;
                    that._resizing = that._noAnimation = 2 === that._changes.count();
                    that.callBase.apply(that, arguments)
                },
                _applySize: function(rect) {
                    var that = this;
                    that._DEBUG_rootRect = rect;
                    that._innerRect = {
                        left: rect[0],
                        top: rect[1],
                        right: rect[2],
                        bottom: rect[3]
                    };
                    var layoutCache = that._layout._cache;
                    that._cleanCore();
                    that._renderCore();
                    that._layout._cache = that._layout._cache || layoutCache;
                    return [rect[0], that._innerRect.top, rect[2], that._innerRect.bottom]
                },
                _initialChanges: ["DOMAIN"],
                _themeDependentChanges: ["DOMAIN"],
                _optionChangesMap: {
                    subtitle: "MOSTLY_TOTAL",
                    indicator: "MOSTLY_TOTAL",
                    geometry: "MOSTLY_TOTAL",
                    animation: "MOSTLY_TOTAL",
                    startValue: "DOMAIN",
                    endValue: "DOMAIN"
                },
                _optionChangesOrder: ["DOMAIN", "MOSTLY_TOTAL"],
                _change_DOMAIN: function() {
                    this._setupDomain()
                },
                _change_MOSTLY_TOTAL: function() {
                    this._applyMostlyTotalChange()
                },
                _setupDomain: function() {
                    var that = this;
                    that._setupDomainCore();
                    that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));
                    if (!that._isValidDomain) {
                        that._incidentOccurred("W2301")
                    }
                    that._change(["MOSTLY_TOTAL"])
                },
                _applyMostlyTotalChange: function() {
                    var that = this;
                    that._setupCodomain();
                    that._setupAnimationSettings();
                    that._setupDefaultFormat();
                    that._change(["LAYOUT"])
                },
                _setupAnimationSettings: function() {
                    var that = this,
                        option = that.option("animation");
                    that._animationSettings = null;
                    if (void 0 === option || option) {
                        option = _extend({
                            enabled: true,
                            duration: 1e3,
                            easing: "easeOutCubic"
                        }, option);
                        if (option.enabled && option.duration > 0) {
                            that._animationSettings = {
                                duration: _Number(option.duration),
                                easing: option.easing
                            }
                        }
                    }
                    that._containerBackgroundColor = that.option("containerBackgroundColor") || that._themeManager.theme().containerBackgroundColor
                },
                _setupDefaultFormat: function() {
                    var domain = this._translator.getDomain();
                    this._defaultFormatOptions = _getAppropriateFormat(domain[0], domain[1], this._getApproximateScreenRange())
                },
                _setupDomainCore: null,
                _calculateSize: null,
                _cleanContent: null,
                _renderContent: null,
                _setupCodomain: null,
                _getApproximateScreenRange: null,
                _factory: {
                    createTranslator: function() {
                        return new translator1DModule.Translator1D
                    },
                    createTracker: function(parameters) {
                        return new Tracker(parameters)
                    }
                }
            });
            exports.dxBaseGauge = dxBaseGauge;
            var _format = __webpack_require__( /*! ../core/format */ 162);
            var formatValue = function(value, options, extra) {
                options = options || {};
                var formatObject, text = _format(value, options);
                if ("function" === typeof options.customizeText) {
                    formatObject = _extend({
                        value: value,
                        valueText: text
                    }, extra);
                    return String(options.customizeText.call(formatObject, formatObject))
                }
                return text
            };
            var getSampleText = function(translator, options) {
                var text1 = formatValue(translator.getDomainStart(), options),
                    text2 = formatValue(translator.getDomainEnd(), options);
                return text1.length >= text2.length ? text1 : text2
            };
            exports.formatValue = formatValue;
            exports.getSampleText = getSampleText;
            exports.compareArrays = function(array1, array2) {
                return array1 && array2 && array1.length === array2.length && compareArraysElements(array1, array2)
            };

            function compareArraysElements(array1, array2) {
                var i, ii = array1.length;
                for (i = 0; i < ii; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false
                    }
                }
                return true
            }
            dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/export */ 127).plugin);
            dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/title */ 164).plugin);
            dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/tooltip */ 165).plugin);
            dxBaseGauge.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 163).plugin);
            var _setTooltipOptions = dxBaseGauge.prototype._setTooltipOptions;
            dxBaseGauge.prototype._setTooltipOptions = function() {
                _setTooltipOptions.apply(this, arguments);
                this._tracker && this._tracker.setTooltipState(this._tooltip.isEnabled())
            };

            function processTitleOptions(options) {
                return _isString(options) ? {
                    text: options
                } : options || {}
            }
            dxBaseGauge.prototype._getTitleOptions = function() {
                var options, position, that = this,
                    titleOptions = processTitleOptions(that.option("title"));
                that._suppressDeprecatedWarnings();
                titleOptions.subtitle = $.extend(processTitleOptions(titleOptions.subtitle), processTitleOptions(that.option("subtitle")));
                that._resumeDeprecatedWarnings();
                options = _extend(true, {}, that._themeManager.theme("title"), titleOptions);
                if (options.position) {
                    position = _normalizeEnum(options.position).split("-");
                    options.verticalAlignment = position[0];
                    options.horizontalAlignment = position[1]
                }
                return options
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/series/bar_series.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88),
                areaSeries = __webpack_require__( /*! ./area_series */ 166).chart.area,
                chartSeries = scatterSeries.chart,
                polarSeries = scatterSeries.polar,
                _extend = $.extend,
                _each = $.each,
                DEFAULT_BAR_POINT_SIZE = 3;
            exports.chart = {};
            exports.polar = {};
            var baseBarSeriesMethods = {
                _getSpecialColor: areaSeries._getSpecialColor,
                _createPattern: areaSeries._createPattern,
                _updateOptions: function(options) {
                    this._stackName = "axis_" + (options.axis || "default") + "_stack_" + (options.stack || "default")
                },
                _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                    var color = this._createPattern(style.color || defaultColor, style.hatching),
                        base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
                    base.fill = color;
                    base.dashStyle = style.border && style.border.dashStyle || "solid";
                    delete base.r;
                    return base
                },
                _applyMarkerClipRect: function(settings) {
                    settings.clipId = null
                },
                _clearingAnimation: function(translators, drawComplete) {
                    var that = this,
                        settings = that._oldgetAffineCoordOptions(translators) || that._getAffineCoordOptions(translators);
                    that._labelsGroup && that._labelsGroup.animate({
                        opacity: .001
                    }, {
                        duration: that._defaultDuration,
                        partitionDuration: .5
                    }, function() {
                        that._markersGroup.animate(settings, {
                            partitionDuration: .5
                        }, function() {
                            that._markersGroup.attr({
                                scaleX: null,
                                scaleY: null,
                                translateX: 0,
                                translateY: 0
                            });
                            drawComplete()
                        })
                    })
                },
                _setGroupsSettings: function(animationEnabled, firstDrawing) {
                    var that = this,
                        settings = {};
                    chartSeries._setGroupsSettings.apply(that, arguments);
                    if (animationEnabled && firstDrawing) {
                        settings = this._getAffineCoordOptions(that.translators, true)
                    } else {
                        if (!animationEnabled) {
                            settings = {
                                scaleX: 1,
                                scaleY: 1,
                                translateX: 0,
                                translateY: 0
                            }
                        }
                    }
                    that._markersGroup.attr(settings)
                },
                _drawPoint: function(options) {
                    options.hasAnimation = options.hasAnimation && !options.firstDrawing;
                    options.firstDrawing = false;
                    chartSeries._drawPoint.call(this, options)
                },
                _getMainColor: function() {
                    return this._options.mainSeriesColor
                },
                _createPointStyles: function(pointOptions) {
                    var that = this,
                        mainColor = pointOptions.color || that._getMainColor(),
                        specialMainColor = that._getSpecialColor(mainColor);
                    return {
                        normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                        hover: that._parsePointStyle(pointOptions.hoverStyle || {}, specialMainColor, mainColor),
                        selection: that._parsePointStyle(pointOptions.selectionStyle || {}, specialMainColor, mainColor)
                    }
                },
                _updatePointsVisibility: function() {
                    var visibility = this._options.visible;
                    $.each(this._points, function(_, point) {
                        point._options.visible = visibility
                    })
                },
                _getOptionsForPoint: function() {
                    return this._options
                },
                _animate: function(firstDrawing) {
                    var that = this,
                        complete = function() {
                            that._animateComplete()
                        },
                        animateFunc = function(drawnPoints, complete) {
                            var lastPointIndex = drawnPoints.length - 1;
                            _each(drawnPoints || [], function(i, point) {
                                point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords())
                            })
                        };
                    that._animatePoints(firstDrawing, complete, animateFunc)
                },
                _getPointSize: function() {
                    return DEFAULT_BAR_POINT_SIZE
                },
                _beginUpdateData: function(data) {
                    chartSeries._beginUpdateData.call(this, data);
                    this._deletePatterns()
                }
            };
            exports.chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
                _getAffineCoordOptions: function(translators) {
                    var rotated = this._options.rotated,
                        direction = rotated ? "x" : "y",
                        settings = {
                            scaleX: rotated ? .001 : 1,
                            scaleY: rotated ? 1 : .001
                        };
                    settings["translate" + direction.toUpperCase()] = translators[direction].translate("canvas_position_default");
                    return settings
                },
                _getRangeData: function() {
                    var rangeData = areaSeries._getRangeData.apply(this, arguments);
                    rangeData.arg.stick = false;
                    return rangeData
                },
                _animatePoints: function(firstDrawing, complete, animateFunc) {
                    var that = this;
                    that._markersGroup.animate({
                        scaleX: 1,
                        scaleY: 1,
                        translateY: 0,
                        translateX: 0
                    }, void 0, complete);
                    if (!firstDrawing) {
                        animateFunc(that._drawnPoints, complete)
                    }
                }
            });
            exports.polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
                _animatePoints: function(firstDrawing, complete, animateFunc) {
                    animateFunc(this._drawnPoints, complete)
                },
                _setGroupsSettings: chartSeries._setGroupsSettings,
                _drawPoint: function(point, groups, animationEnabled) {
                    chartSeries._drawPoint.call(this, point, groups, animationEnabled)
                },
                _parsePointStyle: function(style) {
                    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);
                    base.opacity = style.opacity;
                    return base
                },
                _createGroups: chartSeries._createGroups,
                _setMarkerGroupSettings: function() {
                    var groupSettings, that = this,
                        markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
                    markersSettings.class = "dxc-markers";
                    that._applyMarkerClipRect(markersSettings);
                    groupSettings = _extend({}, markersSettings);
                    delete groupSettings.opacity;
                    that._markersGroup.attr(groupSettings)
                },
                _createLegendState: areaSeries._createLegendState,
                _getRangeData: areaSeries._getRangeData
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/tree_map/api.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                nodeProto = __webpack_require__( /*! ./node */ 168).prototype,
                _extend = __webpack_require__( /*! jquery */ 1).extend;
            proto._eventsMap.onNodesInitialized = {
                name: "nodesInitialized"
            };
            proto._eventsMap.onNodesRendering = {
                name: "nodesRendering"
            };
            proto._createProxyType = function() {
                var nodes, that = this;
                Proxy.prototype = {
                    constructor: Proxy,
                    getParent: function() {
                        return nodes[this._id].parent.proxy || null
                    },
                    getChild: function(index) {
                        var _nodes = nodes[this._id].nodes;
                        return _nodes ? _nodes[index].proxy : null
                    },
                    getChildrenCount: function() {
                        var _nodes = nodes[this._id].nodes;
                        return _nodes ? _nodes.length : 0
                    },
                    getAllChildren: function() {
                        var i, _nodes = nodes[this._id].nodes,
                            ii = _nodes && _nodes.length,
                            list = [];
                        for (i = 0; i < ii; ++i) {
                            list.push(_nodes[i].proxy)
                        }
                        return list
                    },
                    getAllNodes: function() {
                        var list = [];
                        collectNodes(nodes[this._id], list);
                        return list
                    },
                    isLeaf: function() {
                        return !nodes[this._id].isNode()
                    },
                    isActive: function() {
                        return nodes[this._id].isActive()
                    },
                    value: function(arg) {
                        var ret, node = nodes[this._id];
                        if (void 0 !== arg) {
                            updateValue(node, arg > 0 ? Number(arg) : 0);
                            change(node, ["TILING"]);
                            ret = this
                        } else {
                            ret = node.value
                        }
                        return ret
                    },
                    label: function(arg) {
                        var ret, node = nodes[this._id];
                        if (void 0 !== arg) {
                            node.customLabel = arg ? String(arg) : null;
                            change(node, ["LABELS"]);
                            ret = this
                        } else {
                            ret = node.customLabel || node.label
                        }
                        return ret
                    },
                    customize: function(settings) {
                        var node = nodes[this._id];
                        if (settings) {
                            node._custom = node._custom || {};
                            _extend(true, node._custom, settings);
                            node._partialState = node._partialLabelState = null
                        }
                        change(node, ["TILES", "LABELS"]);
                        return this
                    },
                    resetCustomization: function() {
                        var node = nodes[this._id];
                        node._custom = node._partialState = node._partialLabelState = null;
                        change(node, ["TILES", "LABELS"]);
                        return this
                    }
                };
                that._extendProxyType(Proxy.prototype);

                function Proxy(node) {
                    var that = this;
                    node.proxy = that;
                    that._id = node._id;
                    that.level = node.level;
                    that.index = node.index;
                    that.data = node.data
                }
                that._handlers.beginBuildNodes = function() {
                    nodes = that._nodes;
                    new Proxy(that._root)
                };
                that._handlers.buildNode = function(node) {
                    new Proxy(node)
                };
                that._handlers.endBuildNodes = function() {
                    that._eventTrigger("nodesInitialized", {
                        root: that._root.proxy
                    })
                }
            };

            function change(node, codes) {
                var ctx = node.ctx;
                ctx.suspend();
                ctx.change(codes);
                ctx.resume()
            }

            function collectNodes(node, list) {
                var i, nodes = node.nodes,
                    ii = nodes && nodes.length;
                for (i = 0; i < ii; ++i) {
                    list.push(nodes[i].proxy);
                    collectNodes(nodes[i], list)
                }
            }

            function updateValue(node, value) {
                var delta = value - node.value;
                while (node) {
                    node.value += delta;
                    node = node.parent
                }
            }
            proto._extendProxyType = __webpack_require__( /*! ./common */ 90).empty;
            var _resetNodes = proto._resetNodes;
            proto._resetNodes = function() {
                _resetNodes.call(this);
                this._eventTrigger("nodesRendering", {
                    node: this._topNode.proxy
                })
            };
            var _updateStyles = nodeProto.updateStyles;
            nodeProto.updateStyles = function() {
                var that = this;
                _updateStyles.call(that);
                if (that._custom) {
                    that._partialState = !that.ctx.forceReset && that._partialState || that.ctx.calculateState(that._custom);
                    _extend(true, that.state, that._partialState)
                }
            };
            var _updateLabelStyle = nodeProto.updateLabelStyle;
            nodeProto.updateLabelStyle = function() {
                var that = this,
                    custom = that._custom;
                _updateLabelStyle.call(that);
                if (custom && custom.label) {
                    that._partialLabelState = !that.ctx.forceReset && that._partialLabelState || calculatePartialLabelState(that, custom.label);
                    that.labelState = _extend(true, {}, that.labelState, that._partialLabelState)
                }
            };

            function calculatePartialLabelState(node, settings) {
                var state = node.ctx.calculateLabelState(settings);
                if ("visible" in settings) {
                    state.visible = !!settings.visible
                }
                return state
            }
            proto.getRootNode = function() {
                return this._root.proxy
            };
            proto.resetNodes = function() {
                var context = this._context;
                context.suspend();
                context.change(["NODES_CREATE"]);
                context.resume();
                return this
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!***************************************************!*\
      !*** ./Scripts/ui/validation/validation_mixin.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var ValidationMixin = {
                _findGroup: function() {
                    var $dxGroup, group = this.option("validationGroup");
                    if (!group) {
                        $dxGroup = this.element().parents(".dx-validationgroup:first");
                        if ($dxGroup.length) {
                            group = $dxGroup.dxValidationGroup("instance")
                        } else {
                            group = this._modelByElement(this.element())
                        }
                    }
                    return group
                }
            };
            module.exports = ValidationMixin
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/events/hover.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                registerEvent = __webpack_require__( /*! ./core/event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                pointerEvents = __webpack_require__( /*! ./pointer */ 13);
            var HOVERSTART_NAMESPACE = "dxHoverStart",
                HOVERSTART = "dxhoverstart",
                POINTERENTER_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, HOVERSTART_NAMESPACE),
                HOVEREND_NAMESPACE = "dxHoverEnd",
                HOVEREND = "dxhoverend",
                POINTERLEAVE_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, HOVEREND_NAMESPACE);
            var Hover = Class.inherit({
                noBubble: true,
                add: function(element, handleObj) {
                    var that = this,
                        $element = $(element);
                    $element.off(this._originalEventName).on(this._originalEventName, handleObj.selector, function(e) {
                        that._handler(e)
                    })
                },
                _handler: function(e) {
                    if (eventUtils.isTouchEvent(e) || devices.isSimulator()) {
                        return
                    }
                    eventUtils.fireEvent({
                        type: this._eventName,
                        originalEvent: e,
                        delegateTarget: e.delegateTarget
                    })
                },
                teardown: function(element) {
                    $(element).off(this._originalEventName)
                }
            });
            var HoverStart = Hover.inherit({
                ctor: function() {
                    this._eventName = HOVERSTART;
                    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
                    this._isMouseDown = false
                },
                _handler: function(e) {
                    var pointers = e.pointers || [];
                    if (!pointers.length) {
                        this.callBase(e)
                    }
                }
            });
            var HoverEnd = Hover.inherit({
                ctor: function() {
                    this._eventName = HOVEREND;
                    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME
                }
            });
            registerEvent(HOVERSTART, new HoverStart);
            registerEvent(HOVEREND, new HoverEnd);
            exports.start = HOVERSTART;
            exports.end = HOVEREND
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , ,
    /*!************************************!*\
      !*** ./Scripts/client_exporter.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var fileSaver = __webpack_require__( /*! ./client_exporter/file_saver */ 197).fileSaver,
                _isFunction = __webpack_require__( /*! ./core/utils/common */ 2).isFunction;
            exports.export = function(data, options, getBlob) {
                if (!data) {
                    return
                }
                var exportingAction = options.exportingAction,
                    exportedAction = options.exportedAction,
                    fileSavingAction = options.fileSavingAction,
                    eventArgs = {
                        fileName: options.fileName,
                        format: options.format,
                        cancel: false
                    };
                _isFunction(exportingAction) && exportingAction(eventArgs);
                if (!eventArgs.cancel) {
                    getBlob(data, options, function(blob) {
                        _isFunction(exportedAction) && exportedAction();
                        if (_isFunction(fileSavingAction)) {
                            eventArgs.data = blob;
                            fileSavingAction(eventArgs)
                        }
                        if (!eventArgs.cancel) {
                            fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl)
                        }
                    })
                }
            };
            exports.fileSaver = fileSaver;
            exports.excel = {
                creator: __webpack_require__( /*! ./client_exporter/excel_creator */ 111).ExcelCreator,
                getBlob: __webpack_require__( /*! ./client_exporter/excel_creator */ 111).getBlob,
                formatConverter: __webpack_require__( /*! ./client_exporter/excel_creator */ 111).excelFormatConverter
            };
            exports.excel.__internals = __webpack_require__( /*! ./client_exporter/excel_creator */ 111).__internals;
            exports.image = {
                creator: __webpack_require__( /*! ./client_exporter/image_creator */ 139).imageCreator,
                getBlob: __webpack_require__( /*! ./client_exporter/image_creator */ 139).getBlob
            };
            exports.pdf = {
                creator: __webpack_require__( /*! ./client_exporter/pdf_creator */ 198).pdfCreator,
                getBlob: __webpack_require__( /*! ./client_exporter/pdf_creator */ 198).getBlob
            };
            exports.svg = {
                creator: __webpack_require__( /*! ./client_exporter/svg_creator */ 199).svgCreator,
                getBlob: __webpack_require__( /*! ./client_exporter/svg_creator */ 199).getBlob
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/client_exporter/image_creator.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var currentTspanY, clipPaths, textOffset, imageDeferreds, patterns, filters, $ = __webpack_require__( /*! jquery */ 1),
                Color = __webpack_require__( /*! ../color */ 55),
                _math = Math,
                PI = _math.PI,
                _min = _math.min,
                _abs = _math.abs,
                _sqrt = _math.sqrt,
                _pow = _math.pow,
                _atan2 = _math.atan2,
                _cos = _math.cos,
                _sin = _math.sin,
                _each = $.each,
                _extend = $.extend,
                _number = Number,
                IMAGE_QUALITY = 1,
                TEXT_DECORATION_LINE_WIDTH_COEFF = .05,
                DEFAULT_MARGIN_SIZE = {
                    x: 30,
                    y: 20
                },
                DEFAULT_FONT_SIZE = "10px",
                DEFAULT_FONT_FAMILY = "sans-serif",
                DEFAULT_TEXT_COLOR = "#000";

            function createCanvas(width, height) {
                var canvas = $("<canvas>")[0];
                canvas.width = width + 2 * DEFAULT_MARGIN_SIZE.x;
                canvas.height = height + 2 * DEFAULT_MARGIN_SIZE.y;
                return canvas
            }

            function getStringFromCanvas(canvas, mimeType) {
                var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY),
                    imageData = atob(dataURL.substring(("data:" + mimeType + ";base64,").length));
                return imageData
            }

            function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
                var opSide, adjSide, centerX, centerY, startAngle, endAngle, cBx = (x1 + x2) / 2,
                    cBy = (y1 + y2) / 2,
                    aB = _atan2(y1 - y2, x1 - x2),
                    k = largeArcFlag ? 1 : -1;
                aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
                opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
                adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
                centerX = cBx + k * (adjSide * _cos(aB));
                centerY = cBy + k * (adjSide * _sin(aB));
                startAngle = _atan2(y1 - centerY, x1 - centerX);
                endAngle = _atan2(y2 - centerY, x2 - centerX);
                context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise)
            }

            function getElementOptions(element, isText) {
                var coords, attr = parseAttributes(element.attributes),
                    style = element.style || {},
                    options = _extend({}, attr, {
                        text: element.textContent,
                        textAlign: "middle" === attr["text-anchor"] ? "center" : attr["text-anchor"]
                    }),
                    transform = attr.transform;
                if (transform) {
                    coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
                    if (coords) {
                        coords = coords[0].match(/-*\d+([.]\d+)*/g);
                        options.translateX = _number(coords[0]);
                        options.translateY = coords[1] ? _number(coords[1]) : 0
                    }
                    coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
                    if (coords) {
                        coords = coords[0].match(/-*\d+([.]\d+)*/g);
                        options.rotationAngle = _number(coords[0]);
                        options.rotationX = coords[1] && _number(coords[1]);
                        options.rotationY = coords[2] && _number(coords[2])
                    }
                }
                parseStyles(style, options, isText);
                isText && aggregateTextPosition(options);
                return options
            }

            function drawRect(context, options) {
                var x = options.x,
                    y = options.y,
                    width = options.width,
                    height = options.height,
                    cornerRadius = options.rx;
                if (!cornerRadius) {
                    context.rect(options.x, options.y, options.width, options.height)
                } else {
                    cornerRadius = _min(cornerRadius, width / 2, height / 2);
                    context.save();
                    context.translate(x, y);
                    context.moveTo(width / 2, 0);
                    context.arcTo(width, 0, width, height, cornerRadius);
                    context.arcTo(width, height, 0, height, cornerRadius);
                    context.arcTo(0, height, 0, 0, cornerRadius);
                    context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
                    context.lineTo(width / 2, 0);
                    context.restore()
                }
            }

            function drawImage(context, options) {
                var d = $.Deferred(),
                    image = new Image;
                image.onload = function() {
                    context.save();
                    context.globalAlpha = options.globalAlpha;
                    transformElement(context, options);
                    clipElement(context, options);
                    context.drawImage(image, options.x, options.y, options.width, options.height);
                    context.restore();
                    d.resolve()
                };
                image.onerror = function(e) {
                    d.resolve()
                };
                imageDeferreds.push(d);
                image.setAttribute("crossOrigin", "anonymous");
                image.src = options["xlink:href"]
            }

            function drawPath(context, dAttr) {
                var param1, param2, dArray = dAttr.split(" "),
                    i = 0;
                do {
                    param1 = _number(dArray[i + 1]);
                    param2 = _number(dArray[i + 2]);
                    switch (dArray[i]) {
                        case "M":
                            context.moveTo(param1, param2);
                            i += 3;
                            break;
                        case "L":
                            context.lineTo(param1, param2);
                            i += 3;
                            break;
                        case "C":
                            context.bezierCurveTo(param1, param2, _number(dArray[i + 3]), _number(dArray[i + 4]), _number(dArray[i + 5]), _number(dArray[i + 6]));
                            i += 7;
                            break;
                        case "A":
                            arcTo(_number(dArray[i - 2]), _number(dArray[i - 1]), _number(dArray[i + 6]), _number(dArray[i + 7]), param1, _number(dArray[i + 4]), _number(dArray[i + 5]), context);
                            i += 8;
                            break;
                        case "Z":
                            context.closePath();
                            i += 1
                    }
                } while (i < dArray.length)
            }

            function parseStyles(style, options, isText) {
                _each(style, function(_, field) {
                    if ("" !== style[field]) {
                        options[$.camelCase(field)] = style[field]
                    }
                });
                options.textDecoration = options.textDecoration || options.textDecorationLine;
                options.globalAlpha = options.opacity || options.globalAlpha
            }

            function parseUrl(urlString) {
                return urlString.match(/\w+/g)[1]
            }

            function setFontStyle(context, options) {
                var fontParams = [];
                options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
                options.fontFamily || DEFAULT_FONT_FAMILY;
                options.fill = options.fill || DEFAULT_TEXT_COLOR;
                options.fontStyle && fontParams.push(options.fontStyle);
                options.fontWeight && fontParams.push(options.fontWeight);
                fontParams.push(options.fontSize);
                fontParams.push(options.fontFamily);
                context.font = fontParams.join(" ");
                context.textAlign = options.textAlign;
                context.fillStyle = options.fill;
                context.globalAlpha = options.globalAlpha
            }

            function drawText(context, options) {
                setFontStyle(context, options);
                options.text && context.fillText(options.text, options.x, options.y);
                strokeElement(context, options, true);
                drawTextDecoration(context, options);
                textOffset = options.x + context.measureText(options.text).width
            }

            function drawTextDecoration(context, options) {
                if (!options.textDecoration || "none" === options.textDecoration) {
                    return
                }
                var x = options.x,
                    align = options.textAlign,
                    textWidth = context.measureText(options.text).width,
                    textHeight = parseInt(options.fontSize, 10),
                    lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF,
                    y = options.y;
                if ("center" === align) {
                    x -= textWidth / 2
                } else {
                    if ("end" === align) {
                        x -= textWidth
                    }
                }
                switch (options.textDecoration) {
                    case "line-through":
                        y -= textHeight / 3 + lineHeight / 2;
                        break;
                    case "overline":
                        y -= textHeight - lineHeight;
                        break;
                    case "underline":
                        y += lineHeight
                }
                context.rect(x, y, textWidth, lineHeight);
                fillElement(context, options);
                strokeElement(context, options)
            }

            function createClipPath(element) {
                clipPaths[element.attributes.id.textContent] = element.childNodes[0]
            }

            function createPattern(element) {
                patterns[element.attributes.id.textContent] = element
            }

            function aggregateOpacity(options) {
                options.strokeOpacity = void 0 !== options["stroke-opacity"] ? options["stroke-opacity"] : 1;
                options.fillOpacity = void 0 !== options["fill-opacity"] ? options["fill-opacity"] : 1;
                if (void 0 !== options.opacity) {
                    options.strokeOpacity *= options.opacity;
                    options.fillOpacity *= options.opacity
                }
            }

            function aggregateTextPosition(options) {
                if (options.dy) {
                    options.y = currentTspanY + _number(options.dy)
                }
                if (textOffset && void 0 === options.x) {
                    options.x = textOffset
                }
                if (void 0 !== options.y) {
                    currentTspanY = options.y
                } else {
                    options.y = currentTspanY
                }
            }

            function drawElement(element, context, parentOptions) {
                var tagName = element.tagName,
                    isText = "text" === tagName || "tspan" === tagName || void 0 === tagName,
                    isImage = "image" === tagName,
                    options = _extend({}, parentOptions, getElementOptions(element, isText));
                if ("hidden" === options.visibility) {
                    return
                }
                context.save();
                !isImage && transformElement(context, options);
                clipElement(context, options);
                aggregateOpacity(options);
                context.beginPath();
                switch (element.tagName) {
                    case void 0:
                        drawText(context, options);
                        break;
                    case "text":
                    case "tspan":
                        textOffset = 0;
                        drawCanvasElements(element.childNodes, context, options);
                        break;
                    case "title":
                        return;
                    case "image":
                        drawImage(context, options);
                        break;
                    case "path":
                        drawPath(context, options.d);
                        break;
                    case "rect":
                        drawRect(context, options);
                        context.closePath();
                        break;
                    case "circle":
                        context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1)
                }
                applyFilter(context, options);
                if (!isText) {
                    fillElement(context, options);
                    strokeElement(context, options)
                }
                context.restore()
            }

            function applyFilter(context, options) {
                var filterOptions, matches = options.filter && options.filter.match(/url\(\#(.*)\)/);
                if (matches && matches[1]) {
                    filterOptions = filters && filters[matches[1]];
                    if (!filterOptions) {
                        filterOptions = {
                            offsetX: 0,
                            offsetY: 0,
                            blur: 0,
                            color: "#000"
                        }
                    }
                    context.shadowOffsetX = filterOptions.offsetX;
                    context.shadowOffsetY = filterOptions.offsetY;
                    context.shadowColor = filterOptions.color;
                    context.shadowBlur = filterOptions.blur
                }
            }

            function transformElement(context, options) {
                context.translate(options.translateX || 0, options.translateY || 0);
                delete options.translateX;
                delete options.translateY;
                if (options.rotationAngle) {
                    context.translate(options.rotationX || 0, options.rotationY || 0);
                    context.rotate(options.rotationAngle * PI / 180);
                    context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
                    delete options.rotationAngle;
                    delete options.rotationX;
                    delete options.rotationY
                }
            }

            function clipElement(context, options) {
                if (options["clip-path"]) {
                    drawElement(clipPaths[parseUrl(options["clip-path"])], context, {});
                    context.clip();
                    delete options["clip-path"]
                }
            }

            function hex2rgba(hexColor, alpha) {
                var color = new Color(hexColor);
                return "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")"
            }

            function createFilter(element) {
                var color, opacity, filterOptions = {};
                _each(element.childNodes, function(_, node) {
                    var attr = node.attributes;
                    if (!attr.result) {
                        return
                    }
                    switch (attr.result.value) {
                        case "gaussianBlurResult":
                            filterOptions.blur = _number(attr.stdDeviation.value);
                            break;
                        case "offsetResult":
                            filterOptions.offsetX = _number(attr.dx.value);
                            filterOptions.offsetY = _number(attr.dy.value);
                            break;
                        case "floodResult":
                            color = attr["flood-color"] ? attr["flood-color"].value : "#000";
                            opacity = attr["flood-opacity"] ? attr["flood-opacity"].value : 1;
                            filterOptions.color = hex2rgba(color, opacity)
                    }
                });
                filters[element.id] = filterOptions
            }

            function drawCanvasElements(elements, context, parentOptions) {
                var options;
                _each(elements, function(_, element) {
                    switch (element.tagName && element.tagName.toLowerCase()) {
                        case "g":
                            options = _extend({}, parentOptions, getElementOptions(element));
                            context.save();
                            transformElement(context, options);
                            clipElement(context, options);
                            drawCanvasElements(element.childNodes, context, options);
                            context.restore();
                            break;
                        case "defs":
                            clipPaths = {};
                            patterns = {};
                            filters = {};
                            drawCanvasElements(element.childNodes, context);
                            break;
                        case "clippath":
                            createClipPath(element);
                            break;
                        case "pattern":
                            createPattern(element);
                            break;
                        case "filter":
                            createFilter(element);
                            break;
                        default:
                            drawElement(element, context, parentOptions)
                    }
                })
            }

            function setLineDash(context, options) {
                var matches = options["stroke-dasharray"] && options["stroke-dasharray"].match(/(\d+)/g);
                if (matches && matches.length) {
                    matches = $.map(matches, function(item) {
                        return _number(item)
                    });
                    context.setLineDash(matches)
                }
            }

            function strokeElement(context, options, isText) {
                var stroke = options.stroke;
                if (stroke && "none" !== stroke && 0 !== options["stroke-width"]) {
                    setLineDash(context, options);
                    context.lineJoin = options["stroke-linejoin"];
                    context.lineWidth = options["stroke-width"];
                    context.globalAlpha = options.strokeOpacity;
                    context.strokeStyle = stroke;
                    isText ? context.strokeText(options.text, options.x, options.y) : context.stroke()
                }
            }

            function getPattern(context, fill) {
                var pattern = patterns[parseUrl(fill)],
                    options = getElementOptions(pattern),
                    patternCanvas = createCanvas(options.width, options.height),
                    patternContext = patternCanvas.getContext("2d");
                drawCanvasElements(pattern.childNodes, patternContext, options);
                return context.createPattern(patternCanvas, "repeat")
            }

            function fillElement(context, options) {
                var fill = options.fill;
                if (fill && "none" !== fill) {
                    context.fillStyle = -1 === fill.search(/url/) ? fill : getPattern(context, fill);
                    context.globalAlpha = options.fillOpacity;
                    context.fill()
                }
            }

            function parseAttributes(attributes) {
                var attr, newAttributes = {};
                $.each(attributes, function(index, item) {
                    attr = item.textContent;
                    if (isFinite(attr)) {
                        attr = _number(attr)
                    }
                    newAttributes[item.name.toLowerCase()] = attr
                });
                return newAttributes
            }

            function drawBackground(context, width, height, backgroundColor) {
                context.fillStyle = backgroundColor || "#ffffff";
                context.fillRect(-DEFAULT_MARGIN_SIZE.x, -DEFAULT_MARGIN_SIZE.y, width + 2 * DEFAULT_MARGIN_SIZE.x, height + 2 * DEFAULT_MARGIN_SIZE.y)
            }

            function getCanvasFromSvg(markup, width, height, backgroundColor) {
                var canvas = createCanvas(width, height),
                    context = canvas.getContext("2d"),
                    parser = new DOMParser,
                    elem = parser.parseFromString(markup, "image/svg+xml"),
                    svgElem = elem.childNodes[0];
                context.translate(DEFAULT_MARGIN_SIZE.x, DEFAULT_MARGIN_SIZE.y);
                imageDeferreds = [];
                document.body.appendChild(canvas);
                if (svgElem.attributes.direction) {
                    canvas.dir = svgElem.attributes.direction.textContent
                }
                drawBackground(context, width, height, backgroundColor);
                drawCanvasElements(svgElem.childNodes, context, {});
                document.body.removeChild(canvas);
                return canvas
            }

            function resolveString(string, canvas, mimeType) {
                $.when.apply($, imageDeferreds).done(function() {
                    var resultString = getStringFromCanvas(canvas, mimeType);
                    string.resolve(resultString)
                })
            }
            exports.imageCreator = {
                getImageData: function(markup, options) {
                    var mimeType = "image/" + options.format,
                        string = $.Deferred(),
                        width = options.width,
                        height = options.height,
                        backgroundColor = options.backgroundColor;
                    resolveString(string, getCanvasFromSvg(markup, width, height, backgroundColor), mimeType);
                    return string
                },
                getBlob: function(markup, options) {
                    var blobSource, i, imageData = exports.imageCreator.getImageData(markup, options),
                        mimeType = "image/" + options.format,
                        blob = $.Deferred();
                    $.when(imageData).done(function(data) {
                        blobSource = new Uint8Array(data.length);
                        for (i = 0; i < data.length; i++) {
                            blobSource[i] = data.charCodeAt(i)
                        }
                        blob.resolve(new Blob([blobSource.buffer], {
                            type: mimeType
                        }))
                    });
                    return blob
                }
            };
            exports.getBlob = function(data, options, callback) {
                exports.imageCreator.getBlob(data, options).done(callback)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/core/memorized_callbacks.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var MemorizedCallbacks = function() {
                var memory = [];
                var callbacks = $.Callbacks();
                this.add = function(fn) {
                    $.each(memory, function(_, item) {
                        fn.apply(fn, item)
                    });
                    callbacks.add(fn)
                };
                this.remove = function(fn) {
                    callbacks.remove(fn)
                };
                this.fire = function() {
                    memory.push(arguments);
                    callbacks.fire.apply(callbacks, arguments)
                }
            };
            module.exports = MemorizedCallbacks
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/remove_event.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                cleanData = $.cleanData,
                specialEvents = $.event.special;
            var eventName = "dxremove",
                eventPropName = "dxRemoveEvent";
            $.cleanData = function(elements) {
                for (var i = 0; i < elements.length; i++) {
                    var $element = $(elements[i]);
                    if ($element.prop(eventPropName)) {
                        $element.removeProp(eventPropName);
                        $element.triggerHandler(eventName)
                    }
                }
                return cleanData(elements)
            };
            specialEvents[eventName] = {
                noBubble: true,
                setup: function() {
                    $(this).prop(eventPropName, true)
                }
            };
            module.exports = eventName
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/core/utils/public_component.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                WeakMap = __webpack_require__( /*! ./weak_map */ 268),
                commonUtils = __webpack_require__( /*! ./common */ 2),
                removeEvent = __webpack_require__( /*! ../remove_event */ 141);
            var COMPONENT_NAMES_DATA_KEY = "dxComponents",
                ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
            var componentNames = new WeakMap,
                nextAnonymousComponent = 0;
            exports.attachInstanceToElement = function($element, name, component, disposeFn) {
                var element = $element.get(0),
                    data = $.data(element);
                disposeFn = disposeFn || $.noop;
                data[name] = component;
                $element.one(removeEvent, function() {
                    disposeFn.call(component)
                });
                if (!data[COMPONENT_NAMES_DATA_KEY]) {
                    data[COMPONENT_NAMES_DATA_KEY] = []
                }
                data[COMPONENT_NAMES_DATA_KEY].push(name)
            };
            exports.getInstanceByElement = function(element, name) {
                element = $(element).get(0);
                return $.data(element, name)
            };
            exports.getName = function(newName) {
                if (commonUtils.isDefined(newName)) {
                    componentNames.set(this, newName);
                    return
                }
                if (!componentNames.has(this)) {
                    var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
                    componentNames.set(this, generatedName);
                    return generatedName
                }
                return componentNames.get(this)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/core/utils/queue.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../errors */ 10);

            function createQueue(discardPendingTasks) {
                var _tasks = [],
                    _busy = false;

                function exec() {
                    while (_tasks.length) {
                        _busy = true;
                        var task = _tasks.shift(),
                            result = task();
                        if (void 0 === result) {
                            continue
                        }
                        if (result.then) {
                            $.when(result).always(exec);
                            return
                        }
                        throw errors.Error("E0015")
                    }
                    _busy = false
                }

                function add(task, removeTaskCallback) {
                    if (!discardPendingTasks) {
                        _tasks.push(task)
                    } else {
                        if (_tasks[0] && removeTaskCallback) {
                            removeTaskCallback(_tasks[0])
                        }
                        _tasks = [task]
                    }
                    if (!_busy) {
                        exec()
                    }
                }

                function busy() {
                    return _busy
                }
                return {
                    add: add,
                    busy: busy
                }
            }
            exports.create = createQueue;
            exports.enqueue = createQueue().add
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/data/query_adapters.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var queryAdapters = {};
            module.exports = queryAdapters
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/framework/command.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ./errors */ 44),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                DOMComponent = __webpack_require__( /*! ../core/dom_component */ 39);
            __webpack_require__( /*! ../integration/knockout */ 85);
            var Command = DOMComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.callBase(element, options)
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {
                        iconSrc: {
                            since: "15.1",
                            alias: "icon"
                        }
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        onExecute: null,
                        id: null,
                        title: "",
                        icon: "",
                        visible: true,
                        disabled: false,
                        renderStage: "onViewShown"
                    })
                },
                execute: function() {
                    var isDisabled = this._options.disabled;
                    if ($.isFunction(isDisabled)) {
                        isDisabled = !!isDisabled.apply(this, arguments)
                    }
                    if (isDisabled) {
                        throw errors.Error("E3004", this._options.id)
                    }
                    this.fireEvent("beforeExecute", arguments);
                    this._createActionByOption("onExecute").apply(this, arguments);
                    this.fireEvent("afterExecute", arguments)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command")
                },
                _renderDisabledState: $.noop,
                _dispose: function() {
                    this.callBase();
                    this.element().removeData(this.NAME)
                }
            });
            registerComponent("dxCommand", Command);
            module.exports = Command
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/framework/command_mapping.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                errors = __webpack_require__( /*! ./errors */ 44);
            var CommandMapping = Class.inherit({
                ctor: function() {
                    this._commandMappings = {};
                    this._containerDefaults = {}
                },
                setDefaults: function(containerId, defaults) {
                    this._containerDefaults[containerId] = defaults;
                    return this
                },
                mapCommands: function(containerId, commandMappings) {
                    var that = this;
                    $.each(commandMappings, function(index, commandMapping) {
                        if ("string" === typeof commandMapping) {
                            commandMapping = {
                                id: commandMapping
                            }
                        }
                        var commandId = commandMapping.id;
                        var mappings = that._commandMappings[containerId] || {};
                        mappings[commandId] = $.extend({
                            showIcon: true,
                            showText: true
                        }, that._containerDefaults[containerId] || {}, commandMapping);
                        that._commandMappings[containerId] = mappings
                    });
                    this._initExistingCommands();
                    return this
                },
                unmapCommands: function(containerId, commandIds) {
                    var that = this;
                    $.each(commandIds, function(index, commandId) {
                        var mappings = that._commandMappings[containerId] || {};
                        if (mappings) {
                            delete mappings[commandId]
                        }
                    });
                    this._initExistingCommands()
                },
                getCommandMappingForContainer: function(commandId, containerId) {
                    return (this._commandMappings[containerId] || {})[commandId]
                },
                checkCommandsExist: function(commands) {
                    var that = this,
                        result = $.grep(commands, function(commandName, index) {
                            return $.inArray(commandName, that._existingCommands) < 0 && $.inArray(commandName, commands) === index
                        });
                    if (0 !== result.length) {
                        throw errors.Error("E3005", result.join("', '"), 1 === result.length ? " is" : "s are")
                    }
                },
                load: function(config) {
                    if (!config) {
                        return
                    }
                    var that = this;
                    $.each(config, function(name, container) {
                        that.setDefaults(name, container.defaults);
                        that.mapCommands(name, container.commands)
                    });
                    return this
                },
                _initExistingCommands: function() {
                    var that = this;
                    this._existingCommands = [];
                    $.each(that._commandMappings, function(name, _commands) {
                        $.each(_commands, function(index, command) {
                            if ($.inArray(command.id, that._existingCommands) < 0) {
                                that._existingCommands.push(command.id)
                            }
                        })
                    })
                }
            });
            CommandMapping.defaultMapping = {
                "global-navigation": {
                    defaults: {
                        showIcon: true,
                        showText: true
                    },
                    commands: []
                },
                "ios-header-toolbar": {
                    defaults: {
                        showIcon: false,
                        showText: true,
                        location: "after"
                    },
                    commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
                },
                "ios-action-sheet": {
                    defaults: {
                        showIcon: false,
                        showText: true
                    },
                    commands: []
                },
                "ios-view-footer": {
                    defaults: {
                        showIcon: false,
                        showText: true
                    },
                    commands: [{
                        id: "delete",
                        type: "danger"
                    }]
                },
                "android-header-toolbar": {
                    defaults: {
                        showIcon: true,
                        showText: false,
                        location: "after"
                    },
                    commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, "create", {
                        id: "save",
                        showText: true,
                        showIcon: false,
                        location: "after"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "after"
                    }, {
                        id: "cancel",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        showText: false,
                        location: "after"
                    }]
                },
                "android-simple-toolbar": {
                    defaults: {
                        showIcon: true,
                        showText: false,
                        location: "after"
                    },
                    commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {
                        id: "create"
                    }, {
                        id: "save",
                        showText: true,
                        showIcon: false,
                        location: "after"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "after"
                    }, {
                        id: "cancel",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        showText: false,
                        location: "after"
                    }]
                },
                "android-footer-toolbar": {
                    defaults: {
                        location: "after"
                    },
                    commands: [{
                        id: "create",
                        showText: false,
                        location: "center"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        locateInMenu: "always"
                    }, {
                        id: "save",
                        showIcon: false,
                        location: "before"
                    }]
                },
                "generic-header-toolbar": {
                    defaults: {
                        showIcon: false,
                        showText: true,
                        location: "after"
                    },
                    commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
                },
                "generic-view-footer": {
                    defaults: {
                        showIcon: false,
                        showText: true
                    },
                    commands: [{
                        id: "delete",
                        type: "danger"
                    }]
                },
                "win8-appbar": {
                    defaults: {
                        location: "after"
                    },
                    commands: ["edit", "cancel", "save", "delete", {
                        id: "create",
                        location: "before"
                    }, {
                        id: "refresh",
                        location: "before"
                    }]
                },
                "win8-toolbar": {
                    defaults: {
                        showText: false,
                        location: "before"
                    },
                    commands: [{
                        id: "previousPage"
                    }]
                },
                "win8-phone-appbar": {
                    defaults: {
                        location: "center"
                    },
                    commands: ["create", "edit", "cancel", "save", "refresh", {
                        id: "delete",
                        locateInMenu: "always"
                    }]
                },
                "win8-split-toolbar": {
                    defaults: {
                        showIcon: true,
                        showText: false,
                        location: "after"
                    },
                    commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {
                        id: "create"
                    }, {
                        id: "save",
                        showText: true,
                        location: "before"
                    }, {
                        id: "edit",
                        showText: true,
                        locateInMenu: "always"
                    }, {
                        id: "cancel",
                        showText: true,
                        locateInMenu: "always"
                    }, {
                        id: "delete",
                        showText: true,
                        locateInMenu: "always"
                    }]
                },
                "win8-master-detail-toolbar": {
                    defaults: {
                        showText: false,
                        location: "before"
                    },
                    commands: ["back"]
                },
                "win10-appbar": {
                    defaults: {
                        showText: false,
                        location: "after"
                    },
                    commands: [{
                        id: "back",
                        location: "before"
                    }, "edit", "cancel", "save", "delete", "create", "refresh"]
                },
                "win10-phone-appbar": {
                    defaults: {
                        location: "after"
                    },
                    commands: ["create", "edit", "cancel", "save", "refresh", {
                        id: "delete",
                        locateInMenu: "always"
                    }]
                },
                "desktop-toolbar": {
                    defaults: {
                        showIcon: false,
                        showText: true,
                        location: "after"
                    },
                    commands: ["cancel", "create", "edit", "save", {
                        id: "delete",
                        type: "danger"
                    }]
                }
            };
            module.exports = CommandMapping
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/framework/html/command_container.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                MarkupComponent = __webpack_require__( /*! ./markup_component */ 149).MarkupComponent,
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3);
            __webpack_require__( /*! ../../integration/knockout */ 85);
            var CommandContainer = MarkupComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.callBase(element, options)
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        id: null
                    })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command-container")
                }
            });
            registerComponent("dxCommandContainer", CommandContainer);
            module.exports = CommandContainer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/framework/html/layout_controller.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                frameworkUtils = __webpack_require__( /*! ../utils */ 84),
                layoutSets = __webpack_require__( /*! ./presets */ 114).layoutSets,
                EventsMixin = __webpack_require__( /*! ../../core/events_mixin */ 32),
                errors = __webpack_require__( /*! ../errors */ 44),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                HIDDEN_BAG_ID = "__hidden-bag",
                TRANSITION_SELECTOR = ".dx-transition:not(.dx-transition .dx-transition)",
                CONTENT_SELECTOR = ".dx-content",
                DEFAULT_COMMAND_RENDER_STAGE = "onViewShown",
                CONTENT_RENDERED_EVENT_NAME = "dxcontentrendered.layoutController",
                PENDING_RENDERING_SELECTOR = ".dx-pending-rendering",
                PENDING_RENDERING_MANUAL_SELECTOR = ".dx-pending-rendering-manual",
                TransitionExecutorModule = __webpack_require__( /*! ../../animation/transition_executor/transition_executor */ 91);
            __webpack_require__( /*! ./command_container */ 147);
            __webpack_require__( /*! ./view_engine_components */ 45);
            var transitionSelector = function(transitionName) {
                return ".dx-transition-" + transitionName
            };
            var DefaultLayoutController = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.name = options.name || "";
                    this._layoutModel = options.layoutModel || {};
                    this._defaultPaneName = options.defaultPaneName || "content";
                    this._transitionDuration = void 0 === options.transitionDuration ? 400 : options.transitionDuration;
                    this._showViewFired = false
                },
                init: function(options) {
                    options = options || {};
                    this._visibleViews = {};
                    this._$viewPort = options.$viewPort || $("body");
                    this._commandManager = options.commandManager;
                    this._viewEngine = options.viewEngine;
                    this.transitionExecutor = new TransitionExecutorModule.TransitionExecutor;
                    this._prepareTemplates();
                    this._$viewPort.append(this.element());
                    this._hideElements(this.element());
                    if (options.templateContext) {
                        this._templateContext = options.templateContext;
                        this._proxiedTemplateContextChangedHandler = $.proxy(this._templateContextChangedHandler, this)
                    }
                },
                ensureActive: function(targetNode) {
                    if (this._disabledState) {
                        return this.enable()
                    } else {
                        return this.activate(targetNode)
                    }
                },
                activate: function() {
                    this._showViewFired = false;
                    var $rootElement = this.element();
                    this._showElements($rootElement);
                    this._attachRefreshViewRequiredHandler();
                    return $.Deferred().resolve().promise()
                },
                deactivate: function() {
                    this._disabledState = false;
                    this._showViewFired = false;
                    this._releaseVisibleViews();
                    this._hideElements(this.element());
                    this._detachRefreshViewRequiredHandler();
                    return $.Deferred().resolve().promise()
                },
                enable: function() {
                    this._disabledState = false;
                    if (!this._showViewFired) {
                        this._notifyShowing()
                    }
                    this._showViewFired = false;
                    return $.Deferred().resolve().promise()
                },
                disable: function() {
                    this._disabledState = true;
                    this._showViewFired = false;
                    this._notifyHidden()
                },
                activeViewInfo: function() {
                    return this._visibleViews[this._defaultPaneName]
                },
                _fireViewEvents: function(eventName) {
                    var that = this;
                    $.each(this._visibleViews, function(index, viewInfo) {
                        that.fireEvent(eventName, [viewInfo])
                    })
                },
                _notifyShowing: function() {
                    this._fireViewEvents("viewShowing")
                },
                _notifyShown: function() {
                    this._fireViewEvents("viewShown")
                },
                _notifyHidden: function() {
                    this._fireViewEvents("viewHidden")
                },
                _applyTemplate: function($elements, model) {
                    $elements.each(function(i, element) {
                        frameworkUtils.templateProvider.applyTemplate(element, model)
                    })
                },
                _releaseVisibleViews: function() {
                    var that = this;
                    $.each(this._visibleViews, function(index, viewInfo) {
                        that._hideView(viewInfo);
                        that._releaseView(viewInfo)
                    });
                    this._visibleViews = {}
                },
                _templateContextChangedHandler: function() {
                    var that = this;
                    $.when.apply($, $.map(that._visibleViews, function(viewInfo) {
                        return that.showView(viewInfo)
                    })).then(function() {
                        that._notifyShown()
                    })
                },
                _attachRefreshViewRequiredHandler: function() {
                    if (this._templateContext) {
                        this._templateContext.on("optionChanged", this._proxiedTemplateContextChangedHandler)
                    }
                },
                _detachRefreshViewRequiredHandler: function() {
                    if (this._templateContextChanged) {
                        this._templateContext.off("optionChanged", this._proxiedTemplateContextChangedHandler)
                    }
                },
                _getPreviousViewInfo: function(viewInfo) {
                    return this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)]
                },
                _prepareTemplates: function() {
                    var that = this;
                    var $layoutTemplate = that._viewEngine.getLayoutTemplate(this._getLayoutTemplateName());
                    that._$layoutTemplate = $layoutTemplate;
                    that._$mainLayout = that._createEmptyLayout();
                    that._showElements(that._$mainLayout);
                    that._applyTemplate(that._$mainLayout, that._layoutModel);
                    that._$navigationWidget = that._createNavigationWidget()
                },
                renderNavigation: function(navigationCommands) {
                    this._clearNavigationWidget();
                    this._renderNavigationImpl(navigationCommands)
                },
                _renderNavigationImpl: function(navigationCommands) {
                    this._renderCommands(this._$mainLayout, navigationCommands)
                },
                _createNavigationWidget: function() {
                    var result, containers = this._findCommandContainers(this._$mainLayout);
                    $.each(containers, function(k, container) {
                        if ("global-navigation" === container.option("id")) {
                            result = container.element();
                            return false
                        }
                    });
                    return result
                },
                _clearNavigationWidget: function() {
                    if (this._$navigationWidget) {
                        this._commandManager.clearContainer(this._$navigationWidget.dxCommandContainer("instance"))
                    }
                },
                element: function() {
                    return this._$mainLayout
                },
                _getViewFrame: function(viewInfo) {
                    return this._$mainLayout
                },
                _getLayoutTemplateName: function() {
                    return this.name
                },
                _applyModelToTransitionElements: function($markup, model) {
                    var that = this;
                    this._getTransitionElements($markup).each(function(i, item) {
                        that._applyTemplate($(item).children(), model)
                    })
                },
                _createViewLayoutTemplate: function() {
                    var that = this;
                    var $viewLayoutTemplate = that._$layoutTemplate.clone();
                    this._hideElements($viewLayoutTemplate);
                    return $viewLayoutTemplate
                },
                _createEmptyLayout: function() {
                    var that = this;
                    var $result = that._$layoutTemplate.clone();
                    this._hideElements($result);
                    this._getTransitionElements($result).empty();
                    $result.children(CONTENT_SELECTOR).remove();
                    return $result
                },
                _getTransitionElements: function($markup) {
                    return $markup.find(TRANSITION_SELECTOR).addBack(TRANSITION_SELECTOR)
                },
                showView: function(viewInfo, direction) {
                    direction = direction || "forward";
                    var result, that = this,
                        previousViewInfo = that._getPreviousViewInfo(viewInfo),
                        previousViewTemplateId = previousViewInfo === viewInfo ? previousViewInfo.currentViewTemplateId : void 0;
                    this._showViewFired = true;
                    this._defineCurrentViewTemplateId(viewInfo);
                    if (previousViewTemplateId && previousViewTemplateId === viewInfo.currentViewTemplateId && viewInfo === previousViewInfo) {
                        that.fireEvent("viewShowing", [viewInfo, direction]);
                        result = $.Deferred().resolve().promise()
                    } else {
                        that._ensureViewRendered(viewInfo);
                        that.fireEvent("viewShowing", [viewInfo, direction]);
                        result = this._showViewImpl(viewInfo, direction, previousViewTemplateId).done(function() {
                            that._onViewShown(viewInfo)
                        })
                    }
                    return result
                },
                disposeView: function(viewInfo) {
                    this._clearRenderResult(viewInfo)
                },
                _clearRenderResult: function(viewInfo) {
                    if (viewInfo.renderResult) {
                        viewInfo.renderResult.$markup.remove();
                        viewInfo.renderResult.$viewItems.remove();
                        delete viewInfo.renderResult
                    }
                },
                _renderViewImpl: function($viewTemplate, viewInfo) {
                    var $viewItems, that = this,
                        allowedChildrenSelector = ".dx-command,.dx-content,script",
                        $layout = this._createViewLayoutTemplate(),
                        isSimplifiedMarkup = true,
                        outOfContentItems = $();
                    if (0 === $viewTemplate.children(allowedChildrenSelector).length) {
                        this._viewEngine._wrapViewDefaultContent($viewTemplate)
                    }
                    $viewItems = $viewTemplate.children();
                    this._applyModelToTransitionElements($layout, viewInfo.model);
                    this._viewEngine.applyLayout($viewTemplate, $layout);
                    $viewItems.each(function(i, item) {
                        var $item = $(item);
                        that._applyTemplate($item, viewInfo.model);
                        if ($item.is(allowedChildrenSelector)) {
                            isSimplifiedMarkup = false
                        } else {
                            outOfContentItems = outOfContentItems.add($item)
                        }
                    });
                    if (outOfContentItems.length && !isSimplifiedMarkup) {
                        throw errors.Error("E3014", outOfContentItems[0].outerHTML)
                    }
                    viewInfo.renderResult = viewInfo.renderResult || {};
                    viewInfo.renderResult.$viewItems = $viewItems;
                    viewInfo.renderResult.$markup = $layout
                },
                _renderCommands: function($markup, commands) {
                    var commandContainers = this._findCommandContainers($markup);
                    return this._commandManager.renderCommandsToContainers(commands, commandContainers)
                },
                _prepareViewCommands: function(viewInfo) {
                    var $viewItems = viewInfo.renderResult.$viewItems,
                        viewCommands = this._commandManager.findCommands($viewItems),
                        commandsToRenderMap = {};
                    viewInfo.commands = frameworkUtils.utils.mergeCommands(viewInfo.commands || [], viewCommands);
                    viewInfo.commandsToRenderMap = commandsToRenderMap;
                    $.each(viewInfo.commands, function(index, command) {
                        var renderStage = command.option("renderStage") || DEFAULT_COMMAND_RENDER_STAGE,
                            targetArray = commandsToRenderMap[renderStage] = commandsToRenderMap[renderStage] || [];
                        targetArray.push(command)
                    })
                },
                _applyViewCommands: function(viewInfo, renderStage) {
                    renderStage = renderStage || DEFAULT_COMMAND_RENDER_STAGE;
                    var result, commandsToRender = viewInfo.commandsToRenderMap[renderStage],
                        $markup = viewInfo.renderResult.$markup;
                    if (commandsToRender) {
                        result = this._renderCommands($markup, commandsToRender);
                        delete viewInfo.commandsToRenderMap[renderStage]
                    } else {
                        result = $.Deferred().resolve().promise()
                    }
                    return result
                },
                _findCommandContainers: function($markup) {
                    return domUtils.createComponents($markup, ["dxCommandContainer"])
                },
                _defineCurrentViewTemplateId: function(viewInfo) {
                    var viewTemplateInstance = viewInfo.$viewTemplate ? viewInfo.$viewTemplate.dxView("instance") : this._viewEngine.getViewTemplateInfo(viewInfo.viewName),
                        currentViewTemplateId = viewTemplateInstance.getId();
                    viewInfo.currentViewTemplateId = currentViewTemplateId
                },
                _ensureViewRendered: function(viewInfo) {
                    var $cachedMarkup = viewInfo.renderResult && viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId];
                    if ($cachedMarkup) {
                        viewInfo.renderResult.$markup = $cachedMarkup
                    } else {
                        this._renderView(viewInfo);
                        viewInfo.renderResult.markupCache = viewInfo.renderResult.markupCache || {};
                        viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId] = viewInfo.renderResult.$markup
                    }
                },
                _renderView: function(viewInfo) {
                    var $viewTemplate = viewInfo.$viewTemplate || this._viewEngine.getViewTemplate(viewInfo.viewName);
                    this._renderViewImpl($viewTemplate, viewInfo);
                    this._prepareViewCommands(viewInfo);
                    this._applyViewCommands(viewInfo, "onViewRendering");
                    this._appendViewToLayout(viewInfo);
                    $viewTemplate.remove();
                    this._onRenderComplete(viewInfo);
                    this.fireEvent("viewRendered", [viewInfo])
                },
                _prepareTransition: function($element, targetPlaceholderName) {
                    if (0 === $element.children(".dx-content").length) {
                        $element.wrapInner("<div>");
                        $element.children().dxContent({
                            targetPlaceholder: targetPlaceholderName
                        })
                    }
                },
                _appendViewToLayout: function(viewInfo) {
                    var that = this,
                        $viewFrame = that._getViewFrame(viewInfo),
                        $markup = viewInfo.renderResult.$markup,
                        $transitionContentElements = $(),
                        animationItems = [];
                    $.each($markup.find(".dx-content-placeholder"), function(index, el) {
                        that._prepareTransition($(el), $(el).attr("data-dx-content-placeholder-name"))
                    });
                    $.each(that._getTransitionElements($viewFrame), function(index, transitionElement) {
                        var $transition = $(transitionElement),
                            $viewElement = $markup.find(transitionSelector($transition.attr("data-dx-transition-name"))).children(),
                            animationItem = {
                                $element: $viewElement,
                                animation: $transition.attr("data-dx-transition-type")
                            };
                        animationItems.push(animationItem);
                        $transition.append($viewElement);
                        that._showViewElements($viewElement);
                        domUtils.triggerShownEvent($viewElement);
                        $transitionContentElements = $transitionContentElements.add($viewElement)
                    });
                    that._$mainLayout.append(viewInfo.renderResult.$viewItems.filter(".dx-command"));
                    $markup.remove();
                    viewInfo.renderResult.$markup = $transitionContentElements;
                    viewInfo.renderResult.animationItems = animationItems
                },
                _onRenderComplete: function(viewInfo) {},
                _onViewShown: function(viewInfo) {
                    $(document).trigger("dx.viewchanged")
                },
                _enter: function(animationItems, animationModifier) {
                    var transitionExecutor = this.transitionExecutor;
                    $.each(animationItems, function(index, item) {
                        transitionExecutor.enter(item.$element, item.animation, animationModifier)
                    })
                },
                _leave: function(animationItems, animationModifier) {
                    var transitionExecutor = this.transitionExecutor;
                    $.each(animationItems, function(index, item) {
                        transitionExecutor.leave(item.$element, item.animation, animationModifier)
                    })
                },
                _doTransition: function(oldViewInfo, newViewInfo, animationModifier) {
                    if (oldViewInfo) {
                        this._leave(oldViewInfo.renderResult.animationItems, animationModifier)
                    }
                    this._enter(newViewInfo.renderResult.animationItems, animationModifier);
                    this._showView(newViewInfo);
                    return this.transitionExecutor.start()
                },
                _showViewImpl: function(viewInfo, direction, previousViewTemplateId) {
                    var result, that = this,
                        previousViewInfo = this._getPreviousViewInfo(viewInfo),
                        animationModifier = {
                            direction: direction
                        };
                    if (previousViewInfo === viewInfo) {
                        previousViewInfo = void 0
                    }
                    if (!previousViewInfo) {
                        animationModifier.duration = 0;
                        animationModifier.delay = 0
                    }
                    result = that._doTransition(previousViewInfo, viewInfo, animationModifier).then(function() {
                        return that._changeView(viewInfo, previousViewTemplateId)
                    });
                    return result
                },
                _releaseView: function(viewInfo) {
                    this.fireEvent("viewReleased", [viewInfo])
                },
                _getReadyForRenderDeferredItems: function(viewInfo) {
                    return $.Deferred().resolve().promise()
                },
                _changeView: function(viewInfo, previousViewTemplateId) {
                    var that = this;
                    if (previousViewTemplateId) {
                        that._hideView(viewInfo, previousViewTemplateId)
                    } else {
                        var previousViewInfo = that._getPreviousViewInfo(viewInfo);
                        if (previousViewInfo && previousViewInfo !== viewInfo) {
                            that._hideView(previousViewInfo);
                            that._releaseView(previousViewInfo)
                        }
                        this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)] = viewInfo
                    }
                    this._subscribeToDeferredItems(viewInfo);
                    return this._getReadyForRenderDeferredItems(viewInfo).then(function() {
                        return that._applyViewCommands(viewInfo)
                    }).then(function() {
                        return that._renderDeferredItems(viewInfo.renderResult.$markup)
                    })
                },
                _subscribeToDeferredItems: function(viewInfo) {
                    var that = this,
                        $markup = viewInfo.renderResult.$markup;
                    $markup.find(PENDING_RENDERING_SELECTOR).add($markup.filter(PENDING_RENDERING_SELECTOR)).each(function() {
                        var eventData = {
                            viewInfo: viewInfo,
                            context: that
                        };
                        $(this).on(CONTENT_RENDERED_EVENT_NAME, eventData, that._onDeferredContentRendered)
                    })
                },
                _onDeferredContentRendered: function(event) {
                    var $element = $(event.target),
                        viewInfo = event.data.viewInfo,
                        that = event.data.context;
                    $element.off(CONTENT_RENDERED_EVENT_NAME, that._onDeferredContentRendered);
                    that._renderCommands($element, viewInfo.commands)
                },
                _renderDeferredItems: function($items) {
                    var that = this,
                        result = $.Deferred();
                    var $pendingItem = $items.find(PENDING_RENDERING_MANUAL_SELECTOR).add($items.filter(PENDING_RENDERING_MANUAL_SELECTOR)).first();
                    if ($pendingItem.length) {
                        var render = $pendingItem.data("dx-render-delegate");
                        commonUtils.executeAsync(function() {
                            render().then(function() {
                                return that._renderDeferredItems($items)
                            }).then(function() {
                                result.resolve()
                            })
                        })
                    } else {
                        result.resolve()
                    }
                    return result.promise()
                },
                _getViewPaneName: function(viewTemplateInfo) {
                    return this._defaultPaneName
                },
                _hideElements: function($elements) {
                    $elements.addClass("dx-fast-hidden")
                },
                _showElements: function($elements) {
                    $elements.removeClass("dx-fast-hidden")
                },
                _hideViewElements: function($elements) {
                    this._patchIDs($elements);
                    this._disableInputs($elements);
                    $elements.removeClass("dx-active-view").addClass("dx-inactive-view")
                },
                _hideView: function(viewInfo, templateId) {
                    if (viewInfo.renderResult) {
                        var $markupToHide = void 0 === templateId ? viewInfo.renderResult.$markup : viewInfo.renderResult.markupCache[templateId];
                        this._hideViewElements($markupToHide);
                        this.fireEvent("viewHidden", [viewInfo])
                    }
                },
                _showViewElements: function($elements) {
                    this._unpatchIDs($elements);
                    this._enableInputs($elements);
                    $elements.removeClass("dx-inactive-view").addClass("dx-active-view");
                    this._skipAnimation($elements)
                },
                _showView: function(viewInfo) {
                    if (viewInfo.renderResult) {
                        this._showViewElements(viewInfo.renderResult.$markup)
                    }
                },
                _skipAnimation: function($elements) {
                    $elements.addClass("dx-skip-animation");
                    for (var i = 0; i < $elements.length; i++) {
                        $elements.eq(i).css("transform")
                    }
                    $elements.removeClass("dx-skip-animation")
                },
                _patchIDs: function($markup) {
                    this._processIDs($markup, function(id) {
                        var result = id;
                        if (-1 === id.indexOf(HIDDEN_BAG_ID)) {
                            result = HIDDEN_BAG_ID + "-" + id
                        }
                        return result
                    })
                },
                _unpatchIDs: function($markup) {
                    this._processIDs($markup, function(id) {
                        var result = id;
                        if (0 === id.indexOf(HIDDEN_BAG_ID)) {
                            result = id.substr(HIDDEN_BAG_ID.length + 1)
                        }
                        return result
                    })
                },
                _processIDs: function($markup, process) {
                    var elementsWithIds = $markup.find("[id]");
                    $.each(elementsWithIds, function(index, element) {
                        var $el = $(element),
                            id = $el.attr("id");
                        $el.attr("id", process(id))
                    })
                },
                _enableInputs: function($markup) {
                    var $inputs = $markup.find(":input[data-disabled=true]");
                    $.each($inputs, function(index, input) {
                        $(input).removeAttr("disabled").removeAttr("data-disabled")
                    })
                },
                _disableInputs: function($markup) {
                    var $inputs = $markup.find(":input:not([disabled], [disabled=true])");
                    $.each($inputs, function(index, input) {
                        $(input).attr({
                            disabled: true,
                            "data-disabled": true
                        })
                    })
                }
            }).include(EventsMixin);
            layoutSets.default = layoutSets.default || [];
            layoutSets.default.push({
                controller: new DefaultLayoutController
            });
            exports.DefaultLayoutController = DefaultLayoutController;
            exports.layoutSets = layoutSets
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/framework/html/markup_component.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                publicComponentUtils = __webpack_require__( /*! ../../core/utils/public_component */ 142);
            var MarkupComponent = Class.inherit({
                ctor: function(element, options) {
                    this.NAME = this.constructor.publicName();
                    options = options || {};
                    this._$element = $(element);
                    publicComponentUtils.attachInstanceToElement(this._$element, this.NAME, this, this._dispose);
                    if (options.fromCache) {
                        this._options = options
                    } else {
                        this._options = {};
                        this._setDefaultOptions();
                        if (options) {
                            this.option(options)
                        }
                        this._render()
                    }
                },
                _setDefaultOptions: $.noop,
                _render: $.noop,
                _dispose: $.noop,
                element: function() {
                    return this._$element
                },
                option: function(name, value) {
                    if (0 === arguments.length) {
                        return this._options
                    } else {
                        if (1 === arguments.length) {
                            if ("string" === typeof name) {
                                return this._options[name]
                            } else {
                                value = name;
                                $.extend(this._options, value)
                            }
                        } else {
                            this._options[name] = value
                        }
                    }
                },
                instance: function() {
                    return this
                }
            });
            MarkupComponent.publicName = publicComponentUtils.getName;
            MarkupComponent.getInstance = function($element) {
                return publicComponentUtils.getInstanceByElement($element, this.publicName())
            };
            exports.MarkupComponent = MarkupComponent
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/framework/state_manager.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var Class = __webpack_require__( /*! ../core/class */ 5),
                $ = __webpack_require__( /*! jquery */ 1);
            var MemoryKeyValueStorage = Class.inherit({
                ctor: function() {
                    this.storage = {}
                },
                getItem: function(key) {
                    return this.storage[key]
                },
                setItem: function(key, value) {
                    this.storage[key] = value
                },
                removeItem: function(key) {
                    delete this.storage[key]
                }
            });
            var StateManager = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.storage = options.storage || new MemoryKeyValueStorage;
                    this.stateSources = options.stateSources || []
                },
                addStateSource: function(stateSource) {
                    this.stateSources.push(stateSource)
                },
                removeStateSource: function(stateSource) {
                    var index = $.inArray(stateSource, this.stateSources);
                    if (index > -1) {
                        this.stateSources.splice(index, 1);
                        stateSource.removeState(this.storage)
                    }
                },
                saveState: function() {
                    var that = this;
                    $.each(this.stateSources, function(index, stateSource) {
                        stateSource.saveState(that.storage)
                    })
                },
                restoreState: function() {
                    var that = this;
                    $.each(this.stateSources, function(index, stateSource) {
                        stateSource.restoreState(that.storage)
                    })
                },
                clearState: function() {
                    var that = this;
                    $.each(this.stateSources, function(index, stateSource) {
                        stateSource.removeState(that.storage)
                    })
                }
            });
            module.exports = StateManager;
            module.exports.MemoryKeyValueStorage = MemoryKeyValueStorage
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/integration/angular/module.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = window.angular.module("dx", ["ngSanitize"])
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/localization/globalize/number.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 86);
            var Globalize = __webpack_require__( /*! globalize */ 46),
                numberLocalization = __webpack_require__( /*! ../number */ 38),
                errors = __webpack_require__( /*! ../../core/errors */ 10);
            __webpack_require__( /*! globalize/number */ 46);
            if (!Globalize || !Globalize.formatNumber) {
                return
            }
            var enNumbers = {
                main: {
                    en: {
                        identity: {
                            version: {
                                _cldrVersion: "28",
                                _number: "$Revision: 11972 $"
                            },
                            language: "en"
                        },
                        numbers: {
                            defaultNumberingSystem: "latn",
                            otherNumberingSystems: {
                                "native": "latn"
                            },
                            minimumGroupingDigits: "1",
                            "symbols-numberSystem-latn": {
                                decimal: ".",
                                group: ",",
                                list: ";",
                                percentSign: "%",
                                plusSign: "+",
                                minusSign: "-",
                                exponential: "E",
                                superscriptingExponent: "×",
                                perMille: "‰",
                                infinity: "∞",
                                nan: "NaN",
                                timeSeparator: ":"
                            },
                            "decimalFormats-numberSystem-latn": {
                                standard: "#,##0.###",
                                "long": {
                                    decimalFormat: {
                                        "1000-count-one": "0 thousand",
                                        "1000-count-other": "0 thousand",
                                        "10000-count-one": "00 thousand",
                                        "10000-count-other": "00 thousand",
                                        "100000-count-one": "000 thousand",
                                        "100000-count-other": "000 thousand",
                                        "1000000-count-one": "0 million",
                                        "1000000-count-other": "0 million",
                                        "10000000-count-one": "00 million",
                                        "10000000-count-other": "00 million",
                                        "100000000-count-one": "000 million",
                                        "100000000-count-other": "000 million",
                                        "1000000000-count-one": "0 billion",
                                        "1000000000-count-other": "0 billion",
                                        "10000000000-count-one": "00 billion",
                                        "10000000000-count-other": "00 billion",
                                        "100000000000-count-one": "000 billion",
                                        "100000000000-count-other": "000 billion",
                                        "1000000000000-count-one": "0 trillion",
                                        "1000000000000-count-other": "0 trillion",
                                        "10000000000000-count-one": "00 trillion",
                                        "10000000000000-count-other": "00 trillion",
                                        "100000000000000-count-one": "000 trillion",
                                        "100000000000000-count-other": "000 trillion"
                                    }
                                },
                                "short": {
                                    decimalFormat: {
                                        "1000-count-one": "0K",
                                        "1000-count-other": "0K",
                                        "10000-count-one": "00K",
                                        "10000-count-other": "00K",
                                        "100000-count-one": "000K",
                                        "100000-count-other": "000K",
                                        "1000000-count-one": "0M",
                                        "1000000-count-other": "0M",
                                        "10000000-count-one": "00M",
                                        "10000000-count-other": "00M",
                                        "100000000-count-one": "000M",
                                        "100000000-count-other": "000M",
                                        "1000000000-count-one": "0B",
                                        "1000000000-count-other": "0B",
                                        "10000000000-count-one": "00B",
                                        "10000000000-count-other": "00B",
                                        "100000000000-count-one": "000B",
                                        "100000000000-count-other": "000B",
                                        "1000000000000-count-one": "0T",
                                        "1000000000000-count-other": "0T",
                                        "10000000000000-count-one": "00T",
                                        "10000000000000-count-other": "00T",
                                        "100000000000000-count-one": "000T",
                                        "100000000000000-count-other": "000T"
                                    }
                                }
                            },
                            "scientificFormats-numberSystem-latn": {
                                standard: "#E0"
                            },
                            "percentFormats-numberSystem-latn": {
                                standard: "#,##0%"
                            },
                            "currencyFormats-numberSystem-latn": {
                                currencySpacing: {
                                    beforeCurrency: {
                                        currencyMatch: "[:^S:]",
                                        surroundingMatch: "[:digit:]",
                                        insertBetween: " "
                                    },
                                    afterCurrency: {
                                        currencyMatch: "[:^S:]",
                                        surroundingMatch: "[:digit:]",
                                        insertBetween: " "
                                    }
                                },
                                standard: "¤#,##0.00",
                                accounting: "¤#,##0.00;(¤#,##0.00)",
                                "short": {
                                    standard: {
                                        "1000-count-one": "¤0K",
                                        "1000-count-other": "¤0K",
                                        "10000-count-one": "¤00K",
                                        "10000-count-other": "¤00K",
                                        "100000-count-one": "¤000K",
                                        "100000-count-other": "¤000K",
                                        "1000000-count-one": "¤0M",
                                        "1000000-count-other": "¤0M",
                                        "10000000-count-one": "¤00M",
                                        "10000000-count-other": "¤00M",
                                        "100000000-count-one": "¤000M",
                                        "100000000-count-other": "¤000M",
                                        "1000000000-count-one": "¤0B",
                                        "1000000000-count-other": "¤0B",
                                        "10000000000-count-one": "¤00B",
                                        "10000000000-count-other": "¤00B",
                                        "100000000000-count-one": "¤000B",
                                        "100000000000-count-other": "¤000B",
                                        "1000000000000-count-one": "¤0T",
                                        "1000000000000-count-other": "¤0T",
                                        "10000000000000-count-one": "¤00T",
                                        "10000000000000-count-other": "¤00T",
                                        "100000000000000-count-one": "¤000T",
                                        "100000000000000-count-other": "¤000T"
                                    }
                                },
                                "unitPattern-count-one": "{0} {1}",
                                "unitPattern-count-other": "{0} {1}"
                            },
                            "miscPatterns-numberSystem-latn": {
                                atLeast: "{0}+",
                                range: "{0}–{1}"
                            }
                        }
                    }
                }
            };
            Globalize.load(enNumbers);
            Globalize.locale("en");
            var formattersCache = {};
            var getFormatter = function(format) {
                var formatter, formatCacheKey;
                if ("object" === typeof format) {
                    formatCacheKey = Globalize.locale().locale + ":" + JSON.stringify(format)
                } else {
                    formatCacheKey = Globalize.locale().locale + ":" + format
                }
                formatter = formattersCache[formatCacheKey];
                if (!formatter) {
                    formatter = formattersCache[formatCacheKey] = Globalize.numberFormatter(format)
                }
                return formatter
            };
            var globalizeNumberLocalization = {
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("exponential" === format) {
                        return this.callBase.apply(this, arguments)
                    }
                    return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value)
                },
                _normalizeFormatConfig: function(format, formatConfig, value) {
                    var config;
                    if ("decimal" === format) {
                        config = {
                            minimumIntegerDigits: formatConfig.precision || 1,
                            useGrouping: false,
                            maximumFractionDigits: 0,
                            round: value < 0 ? "ceil" : "floor"
                        }
                    } else {
                        config = {
                            minimumFractionDigits: formatConfig.precision,
                            maximumFractionDigits: formatConfig.precision
                        }
                    }
                    if ("percent" === format) {
                        config.style = "percent"
                    }
                    return config
                },
                format: function(value, format) {
                    if ("number" !== typeof value) {
                        return value
                    }
                    format = this._normalizeFormat(format);
                    if (!format || "function" !== typeof format && !format.type && !format.formatter) {
                        return getFormatter(format)(value)
                    }
                    return this.callBase.apply(this, arguments)
                },
                parse: function(text, format) {
                    if (!text) {
                        return
                    }
                    if (format && format.parser) {
                        return format.parser(text)
                    }
                    if (format) {
                        errors.log("W0011")
                    }
                    return Globalize.parseNumber(text)
                }
            };
            numberLocalization.inject(globalizeNumberLocalization)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************************************!*\
      !*** ./Scripts/ui/collection/ui.collection_widget.edit.strategy.plain.js ***!
      \***************************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../widget/ui.errors */ 20),
                arrayUtils = __webpack_require__( /*! ../../core/utils/array */ 41),
                EditStrategy = __webpack_require__( /*! ./ui.collection_widget.edit.strategy */ 304);
            var PlainEditStrategy = EditStrategy.inherit({
                _getPlainItems: function() {
                    return this._collectionWidget.option("items") || []
                },
                getIndexByItemData: function(itemData) {
                    return $.inArray(itemData, this._getPlainItems())
                },
                getItemDataByIndex: function(index) {
                    return this._getPlainItems()[index]
                },
                deleteItemAtIndex: function(index) {
                    this._getPlainItems().splice(index, 1)
                },
                updateSelectionAfterDelete: function(fromIndex) {
                    var selectedItemIndices = this._collectionWidget._selectedItemIndices;
                    $.each(selectedItemIndices, function(i, index) {
                        if (index > fromIndex) {
                            selectedItemIndices[i] -= 1
                        }
                    })
                },
                fetchSelectedItems: function(indices) {
                    indices = indices || this._collectionWidget._selectedItemIndices;
                    indices.sort(function(a, b) {
                        return a - b
                    });
                    var items = this._getPlainItems(),
                        selectedItems = [];
                    $.each(indices, function(_, index) {
                        selectedItems.push(items[index])
                    });
                    if (this._collectionWidget._dataSource && "single" !== this._collectionWidget.option("selectionMode")) {
                        var allSelectedItems = this._collectionWidget.option("selectedItems"),
                            unavailableItems = $.grep(allSelectedItems, function(item) {
                                return -1 === $.inArray(item, items)
                            });
                        selectedItems = selectedItems.concat(unavailableItems)
                    }
                    return selectedItems
                },
                fetchSelectionDifference: function(addedSelection, removedSelection) {
                    var difference = this.callBase(addedSelection, removedSelection);
                    if (this._collectionWidget._dataSource) {
                        var addedItems = difference.addedItems,
                            removedItems = difference.removedItems,
                            duplicatedItems = arrayUtils.intersection(addedItems, removedItems);
                        $.each(duplicatedItems, function(_, item) {
                            var addedItemIndex = $.inArray(item, addedItems),
                                removedItemIndex = $.inArray(item, removedItems);
                            addedItems.splice(addedItemIndex, 1);
                            removedItems.splice(removedItemIndex, 1)
                        })
                    }
                    return difference
                },
                selectedItemIndices: function() {
                    var selectedIndices = [],
                        items = this._getPlainItems(),
                        selected = this._collectionWidget.option("selectedItems"),
                        dataSource = this._collectionWidget._dataSource;
                    $.each(selected, function(_, selectedItem) {
                        var index = $.inArray(selectedItem, items);
                        if (-1 !== index) {
                            selectedIndices.push(index)
                        } else {
                            if (!dataSource) {
                                errors.log("W1002", selectedItem)
                            }
                        }
                    });
                    return selectedIndices
                },
                moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                    var items = this._getPlainItems(),
                        movedItemData = items[movingIndex];
                    items.splice(movingIndex, 1);
                    items.splice(destinationIndex, 0, movedItemData)
                },
                _isItemIndex: function(index) {
                    return "number" === typeof index && Math.round(index) === index
                },
                _getNormalizedItemIndex: function(itemElement) {
                    return this._collectionWidget._itemElements().index(itemElement)
                },
                _normalizeItemIndex: function(index) {
                    return index
                },
                _denormalizeItemIndex: function(index) {
                    return index
                },
                _getItemByNormalizedIndex: function(index) {
                    return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
                },
                _itemsFromSameParent: function() {
                    return true
                }
            });
            module.exports = PlainEditStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , ,
    /*!*******************************************************!*\
      !*** ./Scripts/ui/widget/jquery.template_provider.js ***!
      \*******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                TemplateProviderBase = __webpack_require__( /*! ./ui.template_provider_base */ 324),
                Template = __webpack_require__( /*! ./jquery.template */ 222),
                FunctionTemplate = __webpack_require__( /*! ./ui.template.function */ 99),
                defaultTemplates = __webpack_require__( /*! ./jquery.default_templates */ 322);
            var TemplateProvider = TemplateProviderBase.inherit({
                createTemplate: function(element, owner) {
                    return new Template(element, owner)
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName] || {},
                        templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        templates[name] = new FunctionTemplate(function() {
                            var $markup = generator.apply(this, arguments);
                            if ("itemFrame" !== name) {
                                $markup = $markup.contents()
                            }
                            return $markup
                        }, templateProvider)
                    });
                    return templates
                }
            });
            var templateProvider = new TemplateProvider;
            module.exports = templateProvider
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/viz/core/data_source.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var dataSourceBaseModule = __webpack_require__( /*! ../../data/data_source/data_source */ 37),
                _isArray = __webpack_require__( /*! ../../core/utils/common */ 2).isArray;

            function createDataSource(options) {
                var ops = dataSourceBaseModule.normalizeDataSourceOptions(options);
                "paginate" in ops || (ops.paginate = false);
                return new dataSourceBaseModule.DataSource(ops)
            }

            function DataSource(callback) {
                this._callback = callback;
                this._items = this._ds = null;
                this._isShared = false
            }
            DataSource.prototype = {
                constructor: DataSource,
                dispose: function() {
                    this._reset()
                },
                isLoaded: function() {
                    return !this._ds || this._ds.isLoaded()
                },
                items: function() {
                    return this._ds ? this._ds.items() : this._items
                },
                _reset: function() {
                    var that = this;
                    that._items = null;
                    if (that._ds) {
                        if (that._isShared) {
                            that._ds.off({
                                changed: that._callback,
                                loadError: that._callback
                            })
                        } else {
                            that._ds.dispose()
                        }
                        that._ds = null;
                        that._isShared = false
                    }
                },
                update: function(value) {
                    var that = this;
                    that._reset();
                    if (!value || _isArray(value)) {
                        that._items = value || null;
                        that._callback()
                    } else {
                        that._isShared = value instanceof dataSourceBaseModule.DataSource;
                        that._ds = that._isShared ? value : createDataSource(value);
                        that._ds.on({
                            changed: that._callback,
                            loadError: that._callback
                        });
                        if (that._ds.isLoaded()) {
                            that._callback()
                        } else {
                            that._ds.load()
                        }
                    }
                }
            };
            exports.DataSource = DataSource;
            exports.plugin = {
                name: "data_source",
                init: function() {
                    var that = this;
                    that._dataSource = new exports.DataSource(function() {
                        that._dataSourceChangedHandler()
                    })
                },
                dispose: function() {
                    this._dataSource.dispose()
                },
                members: {
                    _updateDataSource: function() {
                        this._dataSource.update(this.option("dataSource"))
                    }
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/viz/core/format.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _format = __webpack_require__( /*! ../../format_helper */ 68).format;
            module.exports = function(value, options) {
                return _format(value, options.format, options.precision)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/core/loading_indicator.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _patchFontOptions = __webpack_require__( /*! ./utils */ 6).patchFontOptions,
                STATE_HIDDEN = 0,
                STATE_SHOWN = 1,
                ANIMATION_EASING = "linear",
                ANIMATION_DURATION = 400,
                LOADING_INDICATOR_READY = "loadingIndicatorReady";

            function LoadingIndicator(parameters) {
                var that = this,
                    renderer = parameters.renderer;
                that._group = renderer.g().attr({
                    "class": "dx-loading-indicator"
                }).linkOn(renderer.root, {
                    name: "loading-indicator",
                    after: "peripheral"
                });
                that._rect = renderer.rect().attr({
                    opacity: 0
                }).append(that._group);
                that._text = renderer.text().attr({
                    align: "center"
                }).append(that._group);
                that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify)
            }
            LoadingIndicator.prototype = {
                constructor: LoadingIndicator,
                _createStates: function(eventTrigger, group, root, notify) {
                    var that = this;
                    that._states = [{
                        opacity: 0,
                        start: function() {
                            notify(false)
                        },
                        complete: function() {
                            group.linkRemove();
                            root.attr({
                                "pointer-events": null
                            });
                            eventTrigger(LOADING_INDICATOR_READY)
                        }
                    }, {
                        opacity: .85,
                        start: function() {
                            group.linkAppend();
                            root.attr({
                                "pointer-events": "none"
                            });
                            notify(true)
                        },
                        complete: function() {
                            eventTrigger(LOADING_INDICATOR_READY)
                        }
                    }];
                    that._state = STATE_HIDDEN
                },
                setSize: function(size) {
                    var width = size.width,
                        height = size.height;
                    this._rect.attr({
                        width: width,
                        height: height
                    });
                    this._text.attr({
                        x: width / 2,
                        y: height / 2
                    })
                },
                setOptions: function(options) {
                    this._rect.attr({
                        fill: options.backgroundColor
                    });
                    this._text.css(_patchFontOptions(options.font)).attr({
                        text: options.text
                    });
                    this[options.show ? "show" : "hide"]()
                },
                dispose: function() {
                    var that = this;
                    that._group.linkRemove().linkOff();
                    that._group = that._rect = that._text = that._states = null
                },
                _transit: function(stateId) {
                    var state, that = this;
                    if (that._state !== stateId) {
                        that._state = stateId;
                        that._isHiding = false;
                        state = that._states[stateId];
                        that._rect.stopAnimation().animate({
                            opacity: state.opacity
                        }, {
                            complete: state.complete,
                            easing: ANIMATION_EASING,
                            duration: ANIMATION_DURATION,
                            unstoppable: true
                        });
                        that._noHiding = true;
                        state.start();
                        that._noHiding = false
                    }
                },
                show: function() {
                    this._transit(STATE_SHOWN)
                },
                hide: function() {
                    this._transit(STATE_HIDDEN)
                },
                scheduleHiding: function() {
                    if (!this._noHiding) {
                        this._isHiding = true
                    }
                },
                fulfillHiding: function() {
                    if (this._isHiding) {
                        this.hide()
                    }
                }
            };
            exports.LoadingIndicator = LoadingIndicator;
            exports.plugin = {
                name: "loading_indicator",
                init: function() {
                    var that = this;
                    that._loadingIndicator = new exports.LoadingIndicator({
                        eventTrigger: that._eventTrigger,
                        renderer: that._renderer,
                        notify: notify
                    });
                    that._scheduleLoadingIndicatorHiding();

                    function notify(state) {
                        that._skipLoadingIndicatorOptions = true;
                        that.option("loadingIndicator", {
                            show: state
                        });
                        that._skipLoadingIndicatorOptions = false;
                        if (state) {
                            that._hideTooltip && that._hideTooltip()
                        }
                    }
                },
                dispose: function() {
                    this._loadingIndicator.dispose();
                    this._loadingIndicator = null
                },
                members: {
                    _scheduleLoadingIndicatorHiding: function() {
                        this._loadingIndicator.scheduleHiding()
                    },
                    _fulfillLoadingIndicatorHiding: function() {
                        this._loadingIndicator.fulfillHiding()
                    },
                    showLoadingIndicator: function() {
                        this._loadingIndicator.show()
                    },
                    hideLoadingIndicator: function() {
                        this._loadingIndicator.hide()
                    },
                    _onBeginUpdate: function() {
                        this._scheduleLoadingIndicatorHiding()
                    }
                },
                customize: function(constructor) {
                    var proto = constructor.prototype;
                    if (proto._dataSourceChangedHandler) {
                        var _dataSourceChangedHandler = proto._dataSourceChangedHandler;
                        proto._dataSourceChangedHandler = function() {
                            this._scheduleLoadingIndicatorHiding();
                            _dataSourceChangedHandler.apply(this, arguments)
                        }
                    }
                    var _setContentSize = proto._setContentSize;
                    proto._setContentSize = function() {
                        _setContentSize.apply(this, arguments);
                        this._loadingIndicator.setSize(this._canvas)
                    };
                    constructor.addChange({
                        code: "LOADING_INDICATOR",
                        handler: function() {
                            if (!this._skipLoadingIndicatorOptions) {
                                this._loadingIndicator.setOptions(this._getOption("loadingIndicator"))
                            }
                            this._scheduleLoadingIndicatorHiding()
                        },
                        isThemeDependent: true,
                        option: "loadingIndicator",
                        isOptionChange: true
                    });
                    proto._eventsMap.onLoadingIndicatorReady = {
                        name: "loadingIndicatorReady"
                    };
                    var _drawn = proto._drawn;
                    proto._drawn = function() {
                        _drawn.apply(this, arguments);
                        if (this._dataIsReady()) {
                            this._fulfillLoadingIndicatorHiding()
                        }
                    }
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/viz/core/title.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _Number = Number,
                _isString = __webpack_require__( /*! ../../core/utils/common */ 2).isString,
                _patchFontOptions = __webpack_require__( /*! ./utils */ 6).patchFontOptions,
                parseHorizontalAlignment = __webpack_require__( /*! ./utils */ 6).enumParser(["left", "center", "right"]),
                parseVerticalAlignment = __webpack_require__( /*! ./utils */ 6).enumParser(["top", "bottom"]),
                DEFAULT_MARGIN = 10,
                DEFAULT_GAP = 3;

            function hasText(text) {
                return !!(text && String(text).length > 0)
            }

            function processTitleLength(elem, text, width) {
                if (elem.attr({
                        text: text
                    }).applyEllipsis(width)) {
                    elem.setTitle(text)
                }
            }

            function pickMarginValue(value) {
                return value >= 0 ? _Number(value) : DEFAULT_MARGIN
            }

            function validateMargin(margin) {
                var result;
                if (margin >= 0) {
                    result = {
                        left: _Number(margin),
                        top: _Number(margin),
                        right: _Number(margin),
                        bottom: _Number(margin)
                    }
                } else {
                    margin = margin || {};
                    result = {
                        left: pickMarginValue(margin.left),
                        top: pickMarginValue(margin.top),
                        right: pickMarginValue(margin.right),
                        bottom: pickMarginValue(margin.bottom)
                    }
                }
                return result
            }

            function Title(params) {
                this._params = params;
                this._group = params.renderer.g().attr({
                    "class": params.cssClass
                }).linkOn(params.renderer.root, {
                    name: "title",
                    after: "peripheral"
                });
                this._hasText = false
            }
            __webpack_require__( /*! jquery */ 1).extend(Title.prototype, __webpack_require__( /*! ./layout_element */ 190).LayoutElement.prototype, {
                dispose: function() {
                    var that = this;
                    that._group.linkRemove();
                    that._group.linkOff();
                    if (that._titleElement) {
                        that._clipRect.dispose();
                        that._titleElement = that._subtitleElement = that._clipRect = null
                    }
                    that._params = that._group = that._options = null
                },
                _updateOptions: function(options) {
                    this._options = options;
                    this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, "center");
                    this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, "top");
                    this._options.margin = validateMargin(options.margin)
                },
                _updateStructure: function() {
                    var that = this,
                        renderer = that._params.renderer,
                        group = that._group,
                        alignObj = {
                            align: that._options.horizontalAlignment
                        };
                    if (!that._titleElement) {
                        that._titleElement = renderer.text().attr(alignObj).append(group);
                        that._subtitleElement = renderer.text().attr(alignObj);
                        that._clipRect = renderer.clipRect();
                        group.attr({
                            clipId: that._clipRect.id
                        })
                    }
                    group.linkAppend();
                    hasText(that._options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove()
                },
                _updateTexts: function() {
                    var titleBox, y, that = this,
                        options = that._options,
                        subtitleOptions = options.subtitle,
                        titleElement = that._titleElement,
                        subtitleElement = that._subtitleElement,
                        testText = "A";
                    titleElement.attr({
                        text: testText,
                        y: 0
                    }).css(_patchFontOptions(options.font));
                    titleBox = titleElement.getBBox();
                    that._titleTextY = titleBox.height + titleBox.y;
                    titleElement.attr({
                        text: options.text
                    });
                    titleBox = titleElement.getBBox();
                    y = -titleBox.y;
                    titleElement.attr({
                        y: y
                    });
                    if (hasText(subtitleOptions.text)) {
                        y += titleBox.height + titleBox.y;
                        subtitleElement.attr({
                            text: subtitleOptions.text,
                            y: 0
                        }).css(_patchFontOptions(subtitleOptions.font));
                        y += -subtitleElement.getBBox().y - that._titleTextY + DEFAULT_GAP;
                        subtitleElement.attr({
                            y: y
                        })
                    }
                },
                _updateBoundingRectAlignment: function() {
                    var boundingRect = this._boundingRect,
                        options = this._options;
                    boundingRect.verticalAlignment = options.verticalAlignment;
                    boundingRect.horizontalAlignment = options.horizontalAlignment;
                    boundingRect.cutLayoutSide = options.verticalAlignment;
                    boundingRect.cutSide = "vertical";
                    boundingRect.position = {
                        horizontal: options.horizontalAlignment,
                        vertical: options.verticalAlignment
                    }
                },
                update: function(options) {
                    var that = this,
                        _hasText = hasText(options.text),
                        isLayoutChanged = _hasText || _hasText !== that._hasText;
                    if (_hasText) {
                        that._updateOptions(options);
                        that._updateStructure();
                        that._updateTexts();
                        that._boundingRect = {};
                        that._updateBoundingRect();
                        that._updateBoundingRectAlignment()
                    } else {
                        that._group.linkRemove();
                        that._boundingRect = null
                    }
                    that._hasText = _hasText;
                    return isLayoutChanged
                },
                draw: function(width, height) {
                    var layoutOptions, that = this;
                    that._group.linkAppend();
                    that._correctTitleLength(width);
                    layoutOptions = that.getLayoutOptions();
                    if (layoutOptions.width > width || layoutOptions.height > height) {
                        that._params.incidentOccurred("W2103");
                        that._group.linkRemove();
                        that._boundingRect.width = that._boundingRect.height = 0
                    }
                    return that
                },
                probeDraw: function(width, height) {
                    this.draw(width, height);
                    return this
                },
                _correctTitleLength: function(width) {
                    var that = this,
                        options = that._options,
                        margin = options.margin,
                        maxWidth = width - margin.left - margin.right;
                    processTitleLength(that._titleElement, options.text, maxWidth);
                    that._subtitleElement && processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth);
                    that._updateBoundingRect()
                },
                getLayoutOptions: function() {
                    return this._boundingRect || null
                },
                shift: function(x, y) {
                    var that = this,
                        box = that.getLayoutOptions();
                    that._group.move(x - box.x, y - box.y);
                    that._setClipRectSettings();
                    return that
                },
                _setClipRectSettings: function() {
                    var bbox = this.getLayoutOptions();
                    this._clipRect.attr({
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    })
                },
                _updateBoundingRect: function() {
                    var box, that = this,
                        options = that._options,
                        margin = options.margin,
                        boundingRect = that._boundingRect;
                    box = that._group.getBBox();
                    box.height += margin.top + margin.bottom - that._titleTextY;
                    box.width += margin.left + margin.right;
                    box.x -= margin.left;
                    box.y += that._titleTextY - margin.top;
                    if (options.placeholderSize > 0) {
                        box.height = options.placeholderSize
                    }
                    boundingRect.height = box.height;
                    boundingRect.width = box.width;
                    boundingRect.x = box.x;
                    boundingRect.y = box.y
                },
                layoutOptions: function() {
                    return this._boundingRect && {
                        horizontalAlignment: this._boundingRect.horizontalAlignment,
                        verticalAlignment: this._boundingRect.verticalAlignment
                    }
                },
                measure: function(size) {
                    this.draw(size[0], size[1]);
                    return [this._boundingRect.width, this._boundingRect.height]
                },
                move: function(rect) {
                    var boundingRect = this._boundingRect;
                    if (rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height) {
                        this.draw(rect[2] - rect[0], rect[3] - rect[1])
                    }
                    this.shift(Math.round(rect[0]), Math.round(rect[1]))
                }
            });
            exports.Title = Title;
            Title.prototype.DEBUG_getOptions = function() {
                return this._options
            };

            function processTitleOptions(options) {
                var newOptions = _isString(options) ? {
                    text: options
                } : options || {};
                newOptions.subtitle = _isString(newOptions.subtitle) ? {
                    text: newOptions.subtitle
                } : newOptions.subtitle || {};
                return newOptions
            }
            exports.plugin = {
                name: "title",
                init: function() {
                    var that = this;
                    that._title = new exports.Title({
                        renderer: that._renderer,
                        cssClass: that._rootClassPrefix + "-title",
                        incidentOccurred: that._incidentOccurred
                    });
                    that._layout.add(that._title)
                },
                dispose: function() {
                    this._title.dispose();
                    this._title = null
                },
                members: {
                    _getTitleOptions: function() {
                        return $.extend(true, {}, this._themeManager.theme("title"), processTitleOptions(this.option("title")))
                    }
                },
                customize: function(constructor) {
                    constructor.addChange({
                        code: "TITLE",
                        handler: function() {
                            if (this._title.update(this._getTitleOptions())) {
                                this._change(["LAYOUT"])
                            }
                        },
                        isThemeDependent: true,
                        option: "title",
                        isOptionChange: true
                    })
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/core/tooltip.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var doc = document,
                win = window,
                $ = __webpack_require__( /*! jquery */ 1),
                rendererModule = __webpack_require__( /*! ./renderers/renderer */ 176),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                HALF_ARROW_WIDTH = 10,
                vizUtils = __webpack_require__( /*! ./utils */ 6),
                _format = __webpack_require__( /*! ./format */ 162),
                mathCeil = Math.ceil;

            function hideElement($element) {
                $element.css({
                    left: "-9999px"
                }).detach()
            }

            function getSpecialFormatOptions(options, specialFormat) {
                var ret = options;
                switch (specialFormat) {
                    case "argument":
                        ret = {
                            format: options.argumentFormat,
                            precision: options.argumentPrecision
                        };
                        break;
                    case "percent":
                        ret = {
                            format: {
                                type: "percent",
                                precision: options.format && options.format.percentPrecision || options.percentPrecision
                            }
                        }
                }
                return ret
            }

            function Tooltip(params) {
                var renderer, root, that = this;
                that._eventTrigger = params.eventTrigger;
                that._wrapper = $("<div></div>").css({
                    position: "absolute",
                    overflow: "visible",
                    width: 0,
                    height: 0,
                    "pointer-events": "none"
                }).addClass(params.cssClass);
                that._renderer = renderer = new rendererModule.Renderer({
                    pathModified: params.pathModified,
                    container: that._wrapper[0]
                });
                root = renderer.root;
                root.attr({
                    "pointer-events": "none"
                });
                that._cloud = renderer.path([], "area").sharp().append(root);
                that._shadow = renderer.shadowFilter();
                that._textGroup = renderer.g().attr({
                    align: "center"
                }).append(root);
                that._text = renderer.text(void 0, 0, 0).append(that._textGroup);
                that._textGroupHtml = $("<div></div>").css({
                    position: "absolute",
                    width: 0,
                    padding: 0,
                    margin: 0,
                    border: "0px solid transparent"
                }).appendTo(that._wrapper);
                that._textHtml = $("<div></div>").css({
                    position: "relative",
                    display: "inline-block",
                    padding: 0,
                    margin: 0,
                    border: "0px solid transparent"
                }).appendTo(that._textGroupHtml)
            }
            Tooltip.prototype = {
                constructor: Tooltip,
                dispose: function() {
                    this._wrapper.remove();
                    this._renderer.dispose();
                    this._options = null
                },
                setOptions: function(options) {
                    options = options || {};
                    var that = this,
                        cloudSettings = that._cloudSettigns = {
                            opacity: options.opacity,
                            filter: that._shadow.ref,
                            "stroke-width": null,
                            stroke: null
                        },
                        borderOptions = options.border || {},
                        container = $(options.container);
                    that._container = (container.length ? container : $("body")).get(0);
                    that._shadowSettings = $.extend({
                        x: "-50%",
                        y: "-50%",
                        width: "200%",
                        height: "200%"
                    }, options.shadow);
                    that._options = options;
                    if (borderOptions.visible) {
                        $.extend(cloudSettings, {
                            "stroke-width": borderOptions.width,
                            stroke: borderOptions.color,
                            "stroke-opacity": borderOptions.opacity,
                            dashStyle: borderOptions.dashStyle
                        })
                    }
                    that._textFontStyles = vizUtils.patchFontOptions(options.font);
                    that._textFontStyles.color = options.font.color;
                    that._wrapper.css({
                        "z-index": options.zIndex
                    });
                    that._customizeTooltip = $.isFunction(options.customizeTooltip) ? options.customizeTooltip : null;
                    return that
                },
                setRendererOptions: function(options) {
                    this._renderer.setOptions(options);
                    this._textGroupHtml.css({
                        direction: options.rtl ? "rtl" : "ltr"
                    });
                    return this
                },
                render: function() {
                    var that = this;
                    hideElement(that._wrapper);
                    that._cloud.attr(that._cloudSettigns);
                    that._shadow.attr(that._shadowSettings);
                    that._textGroupHtml.css(that._textFontStyles);
                    that._textGroup.css(that._textFontStyles);
                    that._text.css(that._textFontStyles);
                    that._eventData = null;
                    return that
                },
                update: function(options) {
                    return this.setOptions(options).render()
                },
                _prepare: function(formatObject, state) {
                    var options = this._options,
                        customize = {};
                    if (this._customizeTooltip) {
                        customize = this._customizeTooltip.call(formatObject, formatObject);
                        customize = $.isPlainObject(customize) ? customize : {};
                        if ("text" in customize) {
                            state.text = commonUtils.isDefined(customize.text) ? String(customize.text) : ""
                        }
                        if ("html" in customize) {
                            state.html = commonUtils.isDefined(customize.html) ? String(customize.html) : ""
                        }
                    }
                    if (!("text" in state) && !("html" in state)) {
                        state.text = formatObject.valueText || ""
                    }
                    state.color = customize.color || options.color;
                    state.borderColor = customize.borderColor || (options.border || {}).color;
                    state.textColor = customize.fontColor || (options.font || {}).color;
                    return !!state.text || !!state.html
                },
                show: function(formatObject, params, eventData) {
                    var bBox, contentSize, that = this,
                        state = {},
                        options = that._options,
                        plr = options.paddingLeftRight,
                        ptb = options.paddingTopBottom,
                        textGroupHtml = that._textGroupHtml,
                        textHtml = that._textHtml,
                        ss = that._shadowSettings,
                        xOff = ss.offsetX,
                        yOff = ss.offsetY,
                        blur = 2 * ss.blur + 1,
                        getComputedStyle = win.getComputedStyle;
                    if (!that._prepare(formatObject, state)) {
                        return false
                    }
                    that._state = state;
                    state.tc = {};
                    that._wrapper.appendTo(that._container);
                    that._cloud.attr({
                        fill: state.color,
                        stroke: state.borderColor
                    });
                    if (state.html) {
                        that._text.attr({
                            text: ""
                        });
                        textGroupHtml.css({
                            color: state.textColor,
                            width: that._getCanvas().width
                        });
                        textHtml.html(state.html);
                        if (getComputedStyle) {
                            bBox = getComputedStyle(textHtml.get(0));
                            bBox = {
                                x: 0,
                                y: 0,
                                width: mathCeil(parseFloat(bBox.width)),
                                height: mathCeil(parseFloat(bBox.height))
                            }
                        } else {
                            bBox = textHtml.get(0).getBoundingClientRect();
                            bBox = {
                                x: 0,
                                y: 0,
                                width: mathCeil(bBox.width ? bBox.width : bBox.right - bBox.left),
                                height: mathCeil(bBox.height ? bBox.height : bBox.bottom - bBox.top)
                            }
                        }
                        textGroupHtml.width(bBox.width);
                        textGroupHtml.height(bBox.height)
                    } else {
                        textHtml.html("");
                        that._text.css({
                            fill: state.textColor
                        }).attr({
                            text: state.text
                        });
                        bBox = that._textGroup.css({
                            fill: state.textColor
                        }).getBBox()
                    }
                    contentSize = state.contentSize = {
                        x: bBox.x - plr,
                        y: bBox.y - ptb,
                        width: bBox.width + 2 * plr,
                        height: bBox.height + 2 * ptb,
                        lm: blur - xOff > 0 ? blur - xOff : 0,
                        rm: blur + xOff > 0 ? blur + xOff : 0,
                        tm: blur - yOff > 0 ? blur - yOff : 0,
                        bm: blur + yOff > 0 ? blur + yOff : 0
                    };
                    contentSize.fullWidth = contentSize.width + contentSize.lm + contentSize.rm;
                    contentSize.fullHeight = contentSize.height + contentSize.tm + contentSize.bm + options.arrowLength;
                    that.move(params.x, params.y, params.offset);
                    that._eventData && that._eventTrigger("tooltipHidden", that._eventData);
                    that._eventData = eventData;
                    that._eventTrigger("tooltipShown", that._eventData);
                    return true
                },
                hide: function() {
                    var that = this;
                    hideElement(that._wrapper);
                    that._eventData && that._eventTrigger("tooltipHidden", that._eventData);
                    that._eventData = null
                },
                move: function(x, y, offset) {
                    offset = offset || 0;
                    var that = this,
                        canvas = that._getCanvas(),
                        state = that._state,
                        coords = state.tc,
                        contentSize = state.contentSize;
                    if (that._calculatePosition(x, y, offset, canvas)) {
                        that._cloud.attr({
                            points: coords.cloudPoints
                        }).move(contentSize.lm, contentSize.tm);
                        if (state.html) {
                            that._textGroupHtml.css({
                                left: -contentSize.x + contentSize.lm,
                                top: -contentSize.y + contentSize.tm + coords.correction
                            })
                        } else {
                            that._textGroup.move(-contentSize.x + contentSize.lm, -contentSize.y + contentSize.tm + coords.correction)
                        }
                        that._renderer.resize("out" === coords.hp ? canvas.fullWidth - canvas.left : contentSize.fullWidth, "out" === coords.vp ? canvas.fullHeight - canvas.top : contentSize.fullHeight)
                    }
                    offset = that._wrapper.css({
                        left: 0,
                        top: 0
                    }).offset();
                    that._wrapper.css({
                        left: coords.x - offset.left,
                        top: coords.y - offset.top
                    })
                },
                formatValue: function(value, _specialFormat) {
                    var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
                    return _format(value, options)
                },
                getLocation: function() {
                    return vizUtils.normalizeEnum(this._options.location)
                },
                isEnabled: function() {
                    return !!this._options.enabled
                },
                isShared: function() {
                    return !!this._options.shared
                },
                _calculatePosition: function(x, y, offset, canvas) {
                    var cloudPoints, y1, y3, hasDeprecatedPosition, that = this,
                        options = that._options,
                        arrowLength = options.arrowLength,
                        state = that._state,
                        coords = state.tc,
                        contentSize = state.contentSize,
                        contentWidth = contentSize.width,
                        halfContentWidth = contentWidth / 2,
                        contentHeight = contentSize.height,
                        cTop = y - canvas.top,
                        cBottom = canvas.top + canvas.height - y,
                        cLeft = x - canvas.left,
                        cRight = canvas.width + canvas.left - x,
                        tTop = contentHeight + arrowLength + offset + contentSize.tm,
                        tBottom = contentHeight + arrowLength + offset + contentSize.bm,
                        tLeft = contentWidth + contentSize.lm,
                        tRight = contentWidth + contentSize.rm,
                        tHalfLeft = halfContentWidth + contentSize.lm,
                        tHalfRight = halfContentWidth + contentSize.rm,
                        correction = 0,
                        arrowPoints = [6, 0],
                        x1 = halfContentWidth + HALF_ARROW_WIDTH,
                        x2 = halfContentWidth,
                        x3 = halfContentWidth - HALF_ARROW_WIDTH,
                        y2 = contentHeight + arrowLength,
                        hp = "center",
                        vp = "bottom";
                    y1 = y3 = contentHeight;
                    switch (options.verticalAlignment) {
                        case "top":
                            vp = "bottom";
                            hasDeprecatedPosition = true;
                            break;
                        case "bottom":
                            vp = "top";
                            hasDeprecatedPosition = true
                    }
                    if (!hasDeprecatedPosition) {
                        if (tTop > cTop && tBottom > cBottom) {
                            vp = "out"
                        } else {
                            if (tTop > cTop) {
                                vp = "top"
                            }
                        }
                    }
                    hasDeprecatedPosition = false;
                    switch (options.horizontalAlignment) {
                        case "left":
                            hp = "right";
                            hasDeprecatedPosition = true;
                            break;
                        case "center":
                            hp = "center";
                            hasDeprecatedPosition = true;
                            break;
                        case "right":
                            hp = "left";
                            hasDeprecatedPosition = true
                    }
                    if (!hasDeprecatedPosition) {
                        if (tLeft > cLeft && tRight > cRight) {
                            hp = "out"
                        } else {
                            if (tHalfLeft > cLeft && tRight < cRight) {
                                hp = "left"
                            } else {
                                if (tHalfRight > cRight && tLeft < cLeft) {
                                    hp = "right"
                                }
                            }
                        }
                    }
                    if ("out" === hp) {
                        x = canvas.left
                    } else {
                        if ("left" === hp) {
                            x1 = HALF_ARROW_WIDTH;
                            x2 = x3 = 0
                        } else {
                            if ("right" === hp) {
                                x1 = x2 = contentWidth;
                                x3 = contentWidth - HALF_ARROW_WIDTH;
                                x -= contentWidth
                            } else {
                                if ("center" === hp) {
                                    x -= halfContentWidth
                                }
                            }
                        }
                    }
                    if ("out" === vp) {
                        y = canvas.top
                    } else {
                        if ("top" === vp) {
                            "out" !== hp && (correction = arrowLength);
                            arrowPoints[0] = 2;
                            y1 = y3 = arrowLength;
                            y2 = x1;
                            x1 = x3;
                            x3 = y2;
                            y2 = 0;
                            y += offset
                        } else {
                            y -= contentHeight + arrowLength + offset
                        }
                    }
                    coords.x = x - contentSize.lm;
                    coords.y = y - contentSize.tm;
                    coords.correction = correction;
                    if (hp === coords.hp && vp === coords.vp) {
                        return false
                    }
                    coords.hp = hp;
                    coords.vp = vp;
                    cloudPoints = [0, 0 + correction, contentWidth, 0 + correction, contentWidth, contentHeight + correction, 0, contentHeight + correction];
                    if ("out" !== hp && "out" !== vp) {
                        arrowPoints.splice(2, 0, x1, y1, x2, y2, x3, y3);
                        cloudPoints.splice.apply(cloudPoints, arrowPoints)
                    }
                    coords.cloudPoints = cloudPoints;
                    return true
                },
                _getCanvas: function() {
                    var html = doc.documentElement,
                        body = doc.body;
                    return {
                        left: win.pageXOffset || html.scrollLeft || 0,
                        top: win.pageYOffset || html.scrollTop || 0,
                        width: html.clientWidth || 0,
                        height: html.clientHeight || 0,
                        fullWidth: Math.max(body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth, body.clientWidth, html.clientWidth),
                        fullHeight: Math.max(body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight, body.clientHeight, html.clientHeight)
                    }
                }
            };
            exports.Tooltip = Tooltip;
            exports.plugin = {
                name: "tooltip",
                init: function() {
                    this._initTooltip()
                },
                dispose: function() {
                    this._disposeTooltip()
                },
                members: {
                    _initTooltip: function() {
                        this._tooltip = new exports.Tooltip({
                            cssClass: this._rootClassPrefix + "-tooltip",
                            eventTrigger: this._eventTrigger,
                            pathModified: this.option("pathModified")
                        })
                    },
                    _disposeTooltip: function() {
                        this._tooltip.dispose();
                        this._tooltip = null
                    },
                    _hideTooltip: function() {
                        this._tooltip.hide()
                    },
                    _onRender: function() {
                        if (!this._$element.is(":visible")) {
                            this._hideTooltip()
                        }
                    },
                    _setTooltipRendererOptions: function() {
                        this._tooltip.setRendererOptions(this._getRendererOptions())
                    },
                    _setTooltipOptions: function() {
                        this._tooltip.update(this._getOption("tooltip"))
                    }
                },
                customize: function(constructor) {
                    var proto = constructor.prototype;
                    proto._eventsMap.onTooltipShown = {
                        name: "tooltipShown"
                    };
                    proto._eventsMap.onTooltipHidden = {
                        name: "tooltipHidden"
                    };
                    constructor.addChange({
                        code: "TOOLTIP_RENDERER",
                        handler: function() {
                            this._setTooltipRendererOptions()
                        },
                        isThemeDependent: true,
                        isOptionChange: true
                    });
                    constructor.addChange({
                        code: "TOOLTIP",
                        handler: function() {
                            this._setTooltipOptions()
                        },
                        isThemeDependent: true,
                        isOptionChange: true,
                        option: "tooltip"
                    })
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/series/area_series.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 167),
                Color = __webpack_require__( /*! ../../color */ 55),
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88).chart,
                lineSeries = __webpack_require__( /*! ./line_series */ 193),
                chartLineSeries = lineSeries.chart.line,
                polarLineSeries = lineSeries.polar.line,
                _map = __webpack_require__( /*! ../core/utils */ 6).map,
                _extend = $.extend,
                HOVER_COLOR_HIGHLIGHTING = 20;
            exports.chart = {};
            exports.polar = {};
            var baseAreaMethods = {
                _createBorderElement: chartLineSeries._createMainElement,
                _createLegendState: function(styleOptions, defaultColor) {
                    var legendState = scatterSeries._createLegendState.call(this, styleOptions, defaultColor);
                    legendState.opacity = styleOptions.opacity;
                    return legendState
                },
                _getSpecialColor: function(color) {
                    return this._options._IE8 ? new Color(color).highlight(HOVER_COLOR_HIGHLIGHTING) : color
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(this);
                    rangeCalculator.calculateRangeMinValue(this, zoomArgs);
                    return this._rangeData
                },
                _getDefaultSegment: function(segment) {
                    var defaultSegment = chartLineSeries._getDefaultSegment(segment);
                    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
                    return defaultSegment
                },
                _updateElement: function(element, segment, animate, animateParams, complete) {
                    var lineParams = {
                            points: segment.line
                        },
                        areaParams = {
                            points: segment.area
                        },
                        borderElement = element.line;
                    if (animate) {
                        borderElement && borderElement.animate(lineParams, animateParams);
                        element.area.animate(areaParams, animateParams, complete)
                    } else {
                        borderElement && borderElement.attr(lineParams);
                        element.area.attr(areaParams)
                    }
                },
                _removeElement: function(element) {
                    element.line && element.line.remove();
                    element.area.remove()
                },
                _drawElement: function(segment) {
                    return {
                        line: this._bordersGroup && this._createBorderElement(segment.line, {
                            "stroke-width": this._styles.normal.border["stroke-width"]
                        }).append(this._bordersGroup),
                        area: this._createMainElement(segment.area).append(this._elementsGroup)
                    }
                },
                _applyStyle: function(style) {
                    var that = this;
                    that._elementsGroup && that._elementsGroup.attr(style.elements);
                    that._bordersGroup && that._bordersGroup.attr(style.border);
                    $.each(that._graphics || [], function(_, graphic) {
                        graphic.line && graphic.line.attr({
                            "stroke-width": style.border["stroke-width"]
                        }).sharp()
                    })
                },
                _createPattern: function(color, hatching) {
                    if (hatching && commonUtils.isObject(hatching)) {
                        var pattern = this._renderer.pattern(color, hatching);
                        this._patterns.push(pattern);
                        return pattern.id
                    }
                    return color
                },
                _parseStyle: function(options, defaultColor, defaultBorderColor) {
                    var borderOptions = options.border || {},
                        borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);
                    borderStyle["stroke-width"] = borderOptions.visible ? borderStyle["stroke-width"] : 0;
                    return {
                        border: borderStyle,
                        elements: {
                            stroke: "none",
                            fill: this._createPattern(options.color || defaultColor, options.hatching),
                            opacity: options.opacity
                        }
                    }
                },
                _areBordersVisible: function() {
                    var options = this._options;
                    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "area").attr(settings)
                },
                _getTrackerSettings: function(segment) {
                    return {
                        "stroke-width": segment.singlePointSegment ? this._defaultTrackerWidth : 0
                    }
                },
                _getMainPointsFromSegment: function(segment) {
                    return segment.area
                }
            };
            exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {
                _prepareSegment: function(points, rotated) {
                    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);
                    return {
                        line: processedPoints,
                        area: _map(processedPoints, function(pt) {
                            return pt.getCoords()
                        }).concat(_map(processedPoints.slice().reverse(), function(pt) {
                            return pt.getCoords(true)
                        })),
                        singlePointSegment: processedPoints !== points
                    }
                },
                _processSinglePointsAreaSegment: function(points, rotated) {
                    if (1 === points.length) {
                        var p = points[0],
                            p1 = objectUtils.clone(p);
                        p1[rotated ? "y" : "x"] += 1;
                        p1.argument = null;
                        return [p, p1]
                    }
                    return points
                }
            });
            exports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {
                _prepareSegment: function(points, rotated, lastSegment) {
                    lastSegment && polarLineSeries._closeSegment.call(this, points);
                    var preparedPoints = exports.chart.area._prepareSegment.call(this, points);
                    return preparedPoints
                },
                _processSinglePointsAreaSegment: function(points) {
                    return lineSeries.polar.line._prepareSegment.call(this, points).line
                }
            });
            exports.chart.steparea = _extend({}, exports.chart.area, {
                _prepareSegment: function(points, rotated) {
                    points = exports.chart.area._processSinglePointsAreaSegment(points, rotated);
                    return exports.chart.area._prepareSegment.call(this, lineSeries.chart.stepline._calculateStepLinePoints(points))
                }
            });
            exports.chart.splinearea = _extend({}, exports.chart.area, {
                _areaPointsToSplineAreaPoints: function(areaPoints) {
                    var lastFwPoint = areaPoints[areaPoints.length / 2 - 1],
                        firstBwPoint = areaPoints[areaPoints.length / 2];
                    areaPoints.splice(areaPoints.length / 2, 0, {
                        x: lastFwPoint.x,
                        y: lastFwPoint.y
                    }, {
                        x: firstBwPoint.x,
                        y: firstBwPoint.y
                    });
                    if (lastFwPoint.defaultCoords) {
                        areaPoints[areaPoints.length / 2].defaultCoords = true
                    }
                    if (firstBwPoint.defaultCoords) {
                        areaPoints[areaPoints.length / 2 - 1].defaultCoords = true
                    }
                },
                _prepareSegment: function(points, rotated) {
                    var areaSeries = exports.chart.area,
                        processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated),
                        areaSegment = areaSeries._prepareSegment.call(this, lineSeries.chart.spline._calculateBezierPoints(processedPoints, rotated));
                    this._areaPointsToSplineAreaPoints(areaSegment.area);
                    areaSegment.singlePointSegment = processedPoints !== points;
                    return areaSegment
                },
                _getDefaultSegment: function(segment) {
                    var areaDefaultSegment = exports.chart.area._getDefaultSegment(segment);
                    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
                    return areaDefaultSegment
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "bezierarea").attr(settings)
                },
                _createBorderElement: lineSeries.chart.spline._createMainElement
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************************!*\
      !*** ./Scripts/viz/series/helpers/range_data_calculator.js ***!
      \*************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _math = Math,
                _abs = _math.abs,
                _min = _math.min,
                _max = _math.max,
                _each = $.each,
                _isEmptyObject = $.isEmptyObject,
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _isFinite = isFinite,
                unique = __webpack_require__( /*! ../../core/utils */ 6).unique,
                MIN_VISIBLE = "minVisible",
                MAX_VISIBLE = "maxVisible",
                DISCRETE = "discrete";

            function _truncateValue(data, value) {
                var min = data.min,
                    max = data.max;
                data.min = value < min || !_isDefined(min) ? value : min;
                data.max = value > max || !_isDefined(max) ? value : max
            }

            function _processValue(series, type, value, prevValue, calcInterval) {
                var interval, isDiscrete = ("arg" === type ? series.argumentAxisType : series.valueAxisType) === DISCRETE,
                    data = series._rangeData[type],
                    minInterval = data.interval;
                if (isDiscrete && "val" === type) {
                    data.categories = data.categories || [];
                    data.categories.push(value)
                } else {
                    if (!isDiscrete) {
                        _truncateValue(data, value);
                        if ("arg" === type) {
                            interval = (_isDefined(prevValue) ? _abs(calcInterval ? calcInterval(value, prevValue) : value - prevValue) : interval) || minInterval;
                            data.interval = _isDefined(interval) && (interval < minInterval || !_isDefined(minInterval)) ? interval : minInterval
                        }
                    }
                }
            }

            function _addToVisibleRange(series, value) {
                var data = series._rangeData.val,
                    isDiscrete = series.valueAxisType === DISCRETE;
                if (!isDiscrete) {
                    if (value < data.minVisible || !_isDefined(data.minVisible)) {
                        data.minVisible = value
                    }
                    if (value > data.maxVisible || !_isDefined(data.maxVisible)) {
                        data.maxVisible = value
                    }
                }
            }

            function _processRangeValue(series, val, minVal) {
                var data = series._rangeData.val;
                if (series.valueAxisType === DISCRETE) {
                    data.categories = data.categories || [];
                    data.categories.push(val, minVal)
                } else {
                    _truncateValue(data, val);
                    _truncateValue(data, minVal)
                }
            }

            function _processZoomArgument(series, zoomArgs, isDiscrete) {
                var minArg, maxArg, data = series._rangeData.arg;
                if (isDiscrete) {
                    data.minVisible = zoomArgs.minArg;
                    data.maxVisible = zoomArgs.maxArg;
                    return
                }
                minArg = zoomArgs.minArg < zoomArgs.maxArg ? zoomArgs.minArg : zoomArgs.maxArg;
                maxArg = zoomArgs.maxArg > zoomArgs.minArg ? zoomArgs.maxArg : zoomArgs.minArg;
                data.min = minArg < data.min ? minArg : data.min;
                data.max = maxArg > data.max ? maxArg : data.max;
                data.minVisible = minArg;
                data.maxVisible = maxArg
            }

            function _correctZoomValue(series, zoomArgs) {
                var minVal, maxVal;
                if (_isDefined(zoomArgs.minVal) && _isDefined(zoomArgs.maxVal)) {
                    minVal = zoomArgs.minVal < zoomArgs.maxVal ? zoomArgs.minVal : zoomArgs.maxVal;
                    maxVal = zoomArgs.maxVal > zoomArgs.minVal ? zoomArgs.maxVal : zoomArgs.minVal
                }
                if (_isDefined(zoomArgs.minVal)) {
                    series._rangeData.val.min = minVal < series._rangeData.val.min ? minVal : series._rangeData.val.min;
                    series._rangeData.val.minVisible = minVal
                }
                if (_isDefined(zoomArgs.maxVal)) {
                    series._rangeData.val.max = maxVal > series._rangeData.val.max ? maxVal : series._rangeData.val.max;
                    series._rangeData.val.maxVisible = maxVal
                }
            }

            function _processZoomValue(series, zoomArgs) {
                var lastVisibleIndex, adjustOnZoom = zoomArgs.adjustOnZoom,
                    points = series._points || [],
                    prevPointAdded = false,
                    rangeData = series._rangeData,
                    errorBarCorrector = series.getErrorBarRangeCorrector();
                _each(points, function(index, point) {
                    var arg = point.argument,
                        prevPoint = index > 0 ? points[index - 1] : null;
                    if (adjustOnZoom && series.argumentAxisType !== DISCRETE && arg >= rangeData.arg.minVisible && arg <= rangeData.arg.maxVisible) {
                        if (!prevPointAdded) {
                            if (prevPoint && prevPoint.hasValue()) {
                                _addToVisibleRange(series, prevPoint.value);
                                _correctMinMaxByErrorBar(rangeData.val, prevPoint, errorBarCorrector, MIN_VISIBLE, MAX_VISIBLE)
                            }
                            prevPointAdded = true
                        }
                        if (point.hasValue()) {
                            _addToVisibleRange(series, point.value);
                            _correctMinMaxByErrorBar(rangeData.val, point, errorBarCorrector, MIN_VISIBLE, MAX_VISIBLE)
                        }
                        lastVisibleIndex = index
                    }
                });
                if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue()) {
                    _addToVisibleRange(series, points[lastVisibleIndex + 1].value)
                }
                _correctZoomValue(series, zoomArgs)
            }

            function _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName) {
                var lastVisibleIndex, adjustOnZoom = zoomArgs.adjustOnZoom,
                    points = series._points || [],
                    argRangeData = series._rangeData.arg,
                    prevPointAdded = false;
                _each(points, function(index, point) {
                    var arg = point.argument,
                        prevPoint = index > 0 ? points[index - 1] : null;
                    if (adjustOnZoom && series.argumentAxisType !== DISCRETE && arg >= argRangeData.minVisible && arg <= argRangeData.maxVisible) {
                        if (!prevPointAdded) {
                            if (prevPoint && prevPoint.hasValue()) {
                                _addToVisibleRange(series, prevPoint[maxValueName]);
                                _addToVisibleRange(series, prevPoint[minValueName])
                            }
                            prevPointAdded = true
                        }
                        if (point.hasValue()) {
                            _addToVisibleRange(series, point[maxValueName]);
                            _addToVisibleRange(series, point[minValueName])
                        }
                        lastVisibleIndex = index
                    }
                });
                if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue()) {
                    _addToVisibleRange(series, points[lastVisibleIndex + 1].value)
                }
                _correctZoomValue(series, zoomArgs)
            }

            function _processNewInterval(series, calcInterval) {
                var data = series._rangeData,
                    points = series._points || [],
                    isArgumentAxisDiscrete = series.argumentAxisType === DISCRETE;
                delete data.arg.interval;
                _each(points, function(index, point) {
                    var arg = point.argument,
                        prevPoint = index > 0 ? points[index - 1] : null,
                        prevArg = prevPoint && prevPoint.argument;
                    !isArgumentAxisDiscrete && _processValue(series, "arg", arg, prevArg, calcInterval)
                })
            }

            function _fillRangeData(series) {
                var data = series._rangeData;
                data.arg.categories && (data.arg.categories = unique(data.arg.categories));
                data.val.categories && (data.val.categories = unique(data.val.categories));
                data.arg.axisType = series.argumentAxisType;
                data.arg.dataType = series.argumentType;
                data.val.axisType = series.valueAxisType;
                data.val.dataType = series.valueType
            }

            function processTwoValues(series, point, prevPoint, highValueName, lowValueName) {
                var val = point[highValueName],
                    minVal = point[lowValueName],
                    arg = point.argument,
                    prevVal = prevPoint && prevPoint[highValueName],
                    prevMinVal = prevPoint && prevPoint[lowValueName],
                    prevArg = prevPoint && prevPoint.argument;
                point.hasValue() && _processRangeValue(series, val, minVal, prevVal, prevMinVal);
                _processValue(series, "arg", arg, prevArg)
            }

            function calculateRangeMinValue(series, zoomArgs) {
                var data = series._rangeData.val,
                    minVisible = data[MIN_VISIBLE],
                    maxVisible = data[MAX_VISIBLE];
                zoomArgs = zoomArgs || {};
                if (data) {
                    if ("logarithmic" !== series.valueAxisType && "datetime" !== series.valueType && false !== series.showZero) {
                        data[MIN_VISIBLE] = minVisible > (zoomArgs.minVal || 0) ? zoomArgs.minVal || 0 : minVisible;
                        data[MAX_VISIBLE] = maxVisible < (zoomArgs.maxVal || 0) ? zoomArgs.maxVal || 0 : maxVisible;
                        data.min = data.min > 0 ? 0 : data.min;
                        data.max = data.max < 0 ? 0 : data.max
                    }
                }
            }

            function processFullStackedRange(series) {
                var data = series._rangeData.val,
                    isRangeEmpty = _isEmptyObject(data);
                data.percentStick = true;
                if (!isRangeEmpty) {
                    data.min = data.min > 0 ? 0 : data.min;
                    data.max = data.max < 0 ? 0 : data.max
                }
            }

            function _correctMinMaxByErrorBar(data, point, getMinMaxCorrector, minSelector, maxSelector) {
                if (!getMinMaxCorrector) {
                    return
                }
                var correctionData = getMinMaxCorrector(point),
                    minError = _min.apply(void 0, correctionData),
                    maxError = _max.apply(void 0, correctionData);
                if (_isFinite(minError) && data[minSelector] > minError) {
                    data[minSelector] = minError
                }
                if (_isFinite(maxError) && data[maxSelector] < maxError) {
                    data[maxSelector] = maxError
                }
            }

            function processRange(series, point, prevPoint, getMinMaxCorrector) {
                var val = point.value,
                    arg = point.argument,
                    prevVal = prevPoint && prevPoint.value,
                    prevArg = prevPoint && prevPoint.argument;
                point.hasValue() && _processValue(series, "val", val, prevVal);
                _processValue(series, "arg", arg, prevArg);
                _correctMinMaxByErrorBar(series._rangeData.val, point, getMinMaxCorrector, "min", "max")
            }

            function addLabelPaddings(series) {
                var valueData, labelOptions = series.getOptions().label;
                if (series.areLabelsVisible() && labelOptions && labelOptions.visible && "inside" !== labelOptions.position) {
                    valueData = series._rangeData.val;
                    if (valueData.min < 0) {
                        valueData.minSpaceCorrection = true
                    }
                    if (valueData.max > 0) {
                        valueData.maxSpaceCorrection = true
                    }
                }
            }

            function addRangeSeriesLabelPaddings(series) {
                var data = series._rangeData.val;
                if (series.areLabelsVisible() && series._options.label.visible && "inside" !== series._options.label.position) {
                    data.minSpaceCorrection = data.maxSpaceCorrection = true
                }
            }

            function calculateRangeData(series, zoomArgs, calcIntervalFunction, maxValueName, minValueName) {
                var valueData = series._rangeData.val,
                    isRangeSeries = !!maxValueName && !!minValueName,
                    isDiscrete = series.argumentAxisType === DISCRETE;
                if (zoomArgs && _isDefined(zoomArgs.minArg) && _isDefined(zoomArgs.maxArg)) {
                    if (!isDiscrete) {
                        valueData[MIN_VISIBLE] = zoomArgs.minVal;
                        valueData[MAX_VISIBLE] = zoomArgs.maxVal
                    }
                    _processZoomArgument(series, zoomArgs, isDiscrete);
                    if (isRangeSeries) {
                        _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName)
                    } else {
                        _processZoomValue(series, zoomArgs)
                    }
                } else {
                    if (!zoomArgs && calcIntervalFunction) {
                        _processNewInterval(series, calcIntervalFunction)
                    }
                }
                _fillRangeData(series)
            }
            module.exports = {
                processRange: processRange,
                calculateRangeData: calculateRangeData,
                addLabelPaddings: addLabelPaddings,
                addRangeSeriesLabelPaddings: addRangeSeriesLabelPaddings,
                processFullStackedRange: processFullStackedRange,
                calculateRangeMinValue: calculateRangeMinValue,
                processTwoValues: processTwoValues
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/viz/tree_map/node.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _extend = __webpack_require__( /*! jquery */ 1).extend;

            function Node() {}
            _extend(Node.prototype, {
                value: 0,
                isNode: function() {
                    return !!(this.nodes && this.level < this.ctx.maxLevel)
                },
                isActive: function() {
                    var ctx = this.ctx;
                    return this.level >= ctx.minLevel && this.level <= ctx.maxLevel
                },
                updateStyles: function() {
                    var that = this,
                        isNode = Number(that.isNode());
                    that.state = that._buildState(that.ctx.settings[isNode].state, !isNode && that.color && {
                        fill: that.color
                    })
                },
                _buildState: function(state, extra) {
                    var base = _extend({}, state);
                    return extra ? _extend(base, extra) : base
                },
                updateLabelStyle: function() {
                    var settings = this.ctx.settings[Number(this.isNode())];
                    this.labelState = settings.labelState;
                    this.labelParams = settings.labelParams
                },
                _getState: function() {
                    return this.state
                },
                applyState: function() {
                    updateTile[Number(this.isNode())](this.tile, this._getState())
                }
            });
            var updateTile = [updateLeaf, updateGroup];

            function updateLeaf(content, attrs) {
                content.smartAttr(attrs)
            }

            function updateGroup(content, attrs) {
                content.outer.attr({
                    stroke: attrs.stroke,
                    "stroke-width": attrs["stroke-width"],
                    "stroke-opacity": attrs["stroke-opacity"]
                });
                content.inner.smartAttr({
                    fill: attrs.fill,
                    opacity: attrs.opacity,
                    hatching: attrs.hatching
                })
            }
            module.exports = Node
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , ,
    /*!***************************************!*\
      !*** ./Scripts/events/contextmenu.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                support = __webpack_require__( /*! ../core/utils/support */ 18),
                devices = __webpack_require__( /*! ../core/devices */ 7),
                Class = __webpack_require__( /*! ../core/class */ 5),
                registerEvent = __webpack_require__( /*! ./core/event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                holdEvent = __webpack_require__( /*! ./hold */ 63);
            var CONTEXTMENU_NAMESPACE = "dxContexMenu",
                CONTEXTMENU_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE),
                HOLD_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(holdEvent.name, CONTEXTMENU_NAMESPACE),
                CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
            var ContextMenu = Class.inherit({
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(CONTEXTMENU_NAMESPACED_EVENT_NAME, $.proxy(this._contextMenuHandler, this));
                    if (support.touch || devices.isSimulator()) {
                        $element.on(HOLD_NAMESPACED_EVENT_NAME, $.proxy(this._holdHandler, this))
                    }
                },
                _holdHandler: function(e) {
                    if (eventUtils.isMouseEvent(e) && !devices.isSimulator()) {
                        return
                    }
                    this._fireContextMenu(e)
                },
                _contextMenuHandler: function(e) {
                    this._fireContextMenu(e)
                },
                _fireContextMenu: function(e) {
                    return eventUtils.fireEvent({
                        type: CONTEXTMENU_EVENT_NAME,
                        originalEvent: e
                    })
                },
                teardown: function(element) {
                    $(element).off("." + CONTEXTMENU_NAMESPACE)
                }
            });
            registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu);
            exports.name = CONTEXTMENU_EVENT_NAME
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!****************************************************!*\
      !*** ./Scripts/ui/widget/ui.keyboard_processor.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4);
            var KeyboardProcessor = Class.inherit({
                _keydown: eventUtils.addNamespace("keydown", "KeyboardProcessor"),
                codes: {
                    8: "backspace",
                    9: "tab",
                    13: "enter",
                    27: "escape",
                    33: "pageUp",
                    34: "pageDown",
                    35: "end",
                    36: "home",
                    37: "leftArrow",
                    38: "upArrow",
                    39: "rightArrow",
                    40: "downArrow",
                    46: "del",
                    32: "space",
                    70: "F",
                    65: "A",
                    106: "asterisk",
                    109: "minus"
                },
                ctor: function(options) {
                    var _this = this;
                    options = options || {};
                    if (options.element) {
                        this._element = $(options.element)
                    }
                    if (options.focusTarget) {
                        this._focusTarget = options.focusTarget
                    }
                    this._handler = options.handler;
                    this._context = options.context;
                    this._childProcessors = [];
                    if (this._element) {
                        this._processFunction = function(e) {
                            _this.process(e)
                        };
                        this._element.on(this._keydown, this._processFunction)
                    }
                },
                dispose: function() {
                    if (this._element) {
                        this._element.off(this._keydown, this._processFunction)
                    }
                    this._element = void 0;
                    this._handler = void 0;
                    this._context = void 0;
                    this._childProcessors = void 0
                },
                clearChildren: function() {
                    this._childProcessors = []
                },
                push: function(child) {
                    if (!this._childProcessors) {
                        this.clearChildren()
                    }
                    this._childProcessors.push(child);
                    return child
                },
                attachChildProcessor: function() {
                    var childProcessor = new KeyboardProcessor;
                    this._childProcessors.push(childProcessor);
                    return childProcessor
                },
                reinitialize: function(childHandler, childContext) {
                    this._context = childContext;
                    this._handler = childHandler;
                    return this
                },
                process: function(e) {
                    if (this._focusTarget && this._focusTarget !== e.target && $.inArray(e.target, this._focusTarget) < 0) {
                        return false
                    }
                    var args = {
                        key: this.codes[e.which] || e.which,
                        ctrl: e.ctrlKey,
                        shift: e.shiftKey,
                        alt: e.altKey,
                        originalEvent: e
                    };
                    var handlerResult = this._handler && this._handler.call(this._context, args);
                    if (handlerResult && this._childProcessors) {
                        $.each(this._childProcessors, function(index, childProcessor) {
                            childProcessor.process(e)
                        })
                    }
                }
            });
            module.exports = KeyboardProcessor
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/viz/core/renderers/renderer.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var browser = __webpack_require__( /*! ../../../core/utils/browser */ 22);

            function isSvg() {
                return !(browser.msie && browser.version < 9) || !!document.createElementNS && !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect
            }
            if (!isSvg()) {
                if (document.namespaces && !document.namespaces.vml) {
                    document.namespaces.add("vml", "urn:schemas-microsoft-com:vml");
                    document.createStyleSheet().cssText = "vml\\:* { behavior:url(#default#VML); display: inline-block; } "
                }
                exports.Renderer = __webpack_require__( /*! ./vml_renderer */ 519).VmlRenderer
            } else {
                exports.Renderer = __webpack_require__( /*! ./svg_renderer */ 261).SvgRenderer
            }
            exports.isSvg = isSvg
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/ui/resizable.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                stringUtils = __webpack_require__( /*! ../core/utils/string */ 26),
                translator = __webpack_require__( /*! ../animation/translator */ 15),
                fitIntoRange = __webpack_require__( /*! ../core/utils/math */ 66).fitIntoRange,
                DOMComponent = __webpack_require__( /*! ../core/dom_component */ 39),
                eventUtils = __webpack_require__( /*! ../events/utils */ 4),
                dragEvents = __webpack_require__( /*! ../events/drag */ 62);
            var RESIZABLE = "dxResizable",
                RESIZABLE_CLASS = "dx-resizable",
                RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing",
                RESIZABLE_HANDLE_CLASS = "dx-resizable-handle",
                RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top",
                RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom",
                RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left",
                RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right",
                RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner",
                DRAGSTART_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, RESIZABLE),
                DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, RESIZABLE),
                DRAGSTART_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, RESIZABLE);
            var Resizable = DOMComponent.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        handles: "all",
                        step: "1",
                        area: void 0,
                        minWidth: 30,
                        maxWidth: 1 / 0,
                        minHeight: 30,
                        maxHeight: 1 / 0,
                        onResizeStart: null,
                        onResize: null,
                        onResizeEnd: null
                    })
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(RESIZABLE_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this._renderActions();
                    this._renderHandles()
                },
                _renderActions: function() {
                    this._resizeStartAction = this._createActionByOption("onResizeStart");
                    this._resizeEndAction = this._createActionByOption("onResizeEnd");
                    this._resizeAction = this._createActionByOption("onResize")
                },
                _renderHandles: function() {
                    var handles = this.option("handles");
                    if ("none" === handles) {
                        return
                    }
                    var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
                    $.each(directions, $.proxy(function(index, handleName) {
                        this._renderHandle(handleName)
                    }, this));
                    $.inArray("bottom", directions) + 1 && $.inArray("right", directions) + 1 && this._renderHandle("corner-bottom-right");
                    $.inArray("bottom", directions) + 1 && $.inArray("left", directions) + 1 && this._renderHandle("corner-bottom-left");
                    $.inArray("top", directions) + 1 && $.inArray("right", directions) + 1 && this._renderHandle("corner-top-right");
                    $.inArray("top", directions) + 1 && $.inArray("left", directions) + 1 && this._renderHandle("corner-top-left")
                },
                _renderHandle: function(handleName) {
                    var $element = this.element(),
                        $handle = $("<div>");
                    $handle.addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo($element);
                    this._attachEventHandlers($handle)
                },
                _attachEventHandlers: function($handle) {
                    if (this.option("disabled")) {
                        return
                    }
                    var handlers = {};
                    handlers[DRAGSTART_START_EVENT_NAME] = $.proxy(this._dragStartHandler, this);
                    handlers[DRAGSTART_EVENT_NAME] = $.proxy(this._dragHandler, this);
                    handlers[DRAGSTART_END_EVENT_NAME] = $.proxy(this._dragEndHandler, this);
                    $handle.on(handlers, {
                        direction: "both",
                        immediate: true
                    })
                },
                _dragStartHandler: function(e) {
                    var $element = this.element();
                    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
                        e.cancel = true;
                        return
                    }
                    this._toggleResizingClass(true);
                    this._movingSides = this._getMovingSides(e);
                    this._elementLocation = translator.locate($element);
                    this._elementSize = {
                        width: $element.outerWidth(),
                        height: $element.outerHeight()
                    };
                    this._renderDragOffsets(e);
                    this._resizeStartAction({
                        jQueryEvent: e,
                        width: this._elementSize.width,
                        height: this._elementSize.height,
                        handles: this._movingSides
                    });
                    e.targetElements = null
                },
                _toggleResizingClass: function(value) {
                    this.element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
                },
                _renderDragOffsets: function(e) {
                    var area = this._getArea();
                    if (!area) {
                        return
                    }
                    var $handle = $(e.target).closest("." + RESIZABLE_HANDLE_CLASS),
                        handleWidth = $handle.outerWidth(),
                        handleHeight = $handle.outerHeight(),
                        handleOffset = $handle.offset(),
                        areaOffset = area.offset;
                    e.maxLeftOffset = handleOffset.left - areaOffset.left;
                    e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth;
                    e.maxTopOffset = handleOffset.top - areaOffset.top;
                    e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight
                },
                _getBorderWidth: function($element, direction) {
                    var borderWidth = $element.css("border-" + direction + "-width");
                    return parseInt(borderWidth) || 0
                },
                _dragHandler: function(e) {
                    var $element = this.element(),
                        offset = this._getOffset(e),
                        sides = this._movingSides;
                    var location = this._elementLocation,
                        size = this._elementSize;
                    var width = size.width + offset.x * (sides.left ? -1 : 1),
                        height = size.height + offset.y * (sides.top ? -1 : 1);
                    if (offset.x) {
                        this._renderWidth(width)
                    }
                    if (offset.y) {
                        this._renderHeight(height)
                    }
                    var offsetTop = offset.y - ((this.element().outerHeight() || height) - height),
                        offsetLeft = offset.x - ((this.element().outerWidth() || width) - width);
                    translator.move($element, {
                        top: location.top + (sides.top ? offsetTop : 0),
                        left: location.left + (sides.left ? offsetLeft : 0)
                    });
                    this._resizeAction({
                        jQueryEvent: e,
                        width: width,
                        height: height,
                        handles: this._movingSides
                    })
                },
                _getOffset: function(e) {
                    var offset = e.offset,
                        steps = stringUtils.pairToObject(this.option("step")),
                        sides = this._getMovingSides(e);
                    if (!sides.left && !sides.right) {
                        offset.x = 0
                    }
                    if (!sides.top && !sides.bottom) {
                        offset.y = 0
                    }
                    return {
                        x: offset.x - offset.x % steps.h,
                        y: offset.y - offset.y % steps.v
                    }
                },
                _getMovingSides: function(e) {
                    var $target = $(e.target),
                        hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left"),
                        hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right"),
                        hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left"),
                        hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
                    return {
                        top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
                        left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
                        bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
                        right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
                    }
                },
                _getArea: function() {
                    var area = this.option("area");
                    if ($.isFunction(area)) {
                        area = area.call(this)
                    }
                    if ($.isPlainObject(area)) {
                        return this._getAreaFromObject(area)
                    }
                    return this._getAreaFromElement(area)
                },
                _getAreaFromObject: function(area) {
                    var result = {
                        width: area.right - area.left,
                        height: area.bottom - area.top,
                        offset: {
                            left: area.left,
                            top: area.top
                        }
                    };
                    this._correctAreaGeometry(result);
                    return result
                },
                _getAreaFromElement: function(area) {
                    var result, $area = $(area);
                    if ($area.length) {
                        result = {};
                        result.width = $area.innerWidth();
                        result.height = $area.innerHeight();
                        result.offset = $area.offset();
                        this._correctAreaGeometry(result, $area)
                    }
                    return result
                },
                _correctAreaGeometry: function(result, $area) {
                    var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0,
                        areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
                    result.offset.left += areaBorderLeft + this._getBorderWidth(this.element(), "left");
                    result.offset.top += areaBorderTop + this._getBorderWidth(this.element(), "top");
                    result.width -= this.element().outerWidth() - this.element().innerWidth();
                    result.height -= this.element().outerHeight() - this.element().innerHeight()
                },
                _dragEndHandler: function(e) {
                    var $element = this.element();
                    this._resizeEndAction({
                        jQueryEvent: e,
                        width: $element.outerWidth(),
                        height: $element.outerHeight(),
                        handles: this._movingSides
                    });
                    this._toggleResizingClass(false)
                },
                _renderWidth: function(width) {
                    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")))
                },
                _renderHeight: function(height) {
                    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")))
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case "disabled":
                        case "handles":
                            this._invalidate();
                            break;
                        case "minWidth":
                        case "maxWidth":
                            this._renderWidth(this.element().outerWidth());
                            break;
                        case "minHeight":
                        case "maxHeight":
                            this._renderHeight(this.element().outerHeight());
                            break;
                        case "onResize":
                        case "onResizeStart":
                        case "onResizeEnd":
                            this._renderActions();
                            break;
                        case "gridStepHorizontal":
                        case "gridStepVertical":
                        case "area":
                        case "step":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _clean: function() {
                    this.element().find("." + RESIZABLE_HANDLE_CLASS).remove()
                }
            });
            registerComponent(RESIZABLE, Resizable);
            module.exports = Resizable
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/events/dblclick.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                domUtils = __webpack_require__( /*! ../core/utils/dom */ 11),
                Class = __webpack_require__( /*! ../core/class */ 5),
                registerEvent = __webpack_require__( /*! ./core/event_registrator */ 43),
                clickEvent = __webpack_require__( /*! ./click */ 9),
                eventUtils = __webpack_require__( /*! ./utils */ 4);
            var DBLCLICK_EVENT_NAME = "dxdblclick",
                DBLCLICK_NAMESPACE = "dxDblClick",
                NAMESPACED_CLICK_EVENT = eventUtils.addNamespace(clickEvent.name, DBLCLICK_NAMESPACE),
                DBLCLICK_TIMEOUT = 300;
            var DblClick = Class.inherit({
                ctor: function() {
                    this._handlerCount = 0;
                    this._forgetLastClick()
                },
                _forgetLastClick: function() {
                    this._firstClickTarget = null;
                    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
                },
                add: function() {
                    if (this._handlerCount <= 0) {
                        $(document).on(NAMESPACED_CLICK_EVENT, $.proxy(this._clickHandler, this))
                    }
                    this._handlerCount++
                },
                _clickHandler: function(e) {
                    var timeStamp = e.timeStamp || $.now();
                    if (timeStamp - this._lastClickTimeStamp < DBLCLICK_TIMEOUT) {
                        eventUtils.fireEvent({
                            type: DBLCLICK_EVENT_NAME,
                            target: domUtils.closestCommonParent(this._firstClickTarget, e.target),
                            originalEvent: e
                        });
                        this._forgetLastClick()
                    } else {
                        this._firstClickTarget = e.target;
                        this._lastClickTimeStamp = timeStamp
                    }
                },
                remove: function() {
                    this._handlerCount--;
                    if (this._handlerCount <= 0) {
                        this._forgetLastClick();
                        $(document).off(NAMESPACED_CLICK_EVENT)
                    }
                }
            });
            registerEvent(DBLCLICK_EVENT_NAME, new DblClick);
            exports.name = DBLCLICK_EVENT_NAME
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , , ,
    /*!**************************************************!*\
      !*** ./Scripts/ui/widget/ui.template.dynamic.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47);
            var DynamicTemplate = TemplateBase.inherit({
                ctor: function(compileFunction, owner) {
                    this.callBase($(), owner);
                    this._compileFunction = compileFunction
                },
                _renderCore: function(data, index, container) {
                    if (void 0 === data && void 0 === index) {
                        data = container;
                        container = void 0
                    }
                    var compiledTemplate = void 0 === index ? this._compileFunction(data, container) : this._compileFunction(data, index, container);
                    var renderResult = compiledTemplate.render(data, container, index);
                    if (compiledTemplate.owner() === this) {
                        compiledTemplate.dispose()
                    }
                    return renderResult
                }
            });
            module.exports = DynamicTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/ui/widget/ui.template.move.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47);
            var MoveTemplate = TemplateBase.inherit({
                _renderCore: function() {
                    return this._element
                }
            });
            module.exports = MoveTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/axes/numeric_tick_manager.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _adjustValue = vizUtils.adjustValue,
                _math = Math,
                _abs = _math.abs,
                _ceil = _math.ceil,
                _floor = _math.floor,
                _noop = $.noop,
                MINOR_TICKS_COUNT_LIMIT = 200,
                DEFAULT_MINOR_NUMBER_MULTIPLIERS = [2, 4, 5, 8, 10];
            exports.continuous = {
                _hasUnitBeginningTickCorrection: _noop,
                _checkBoundedDatesOverlapping: _noop,
                _correctInterval: function(step) {
                    this._tickInterval *= step
                },
                _correctMax: function(tickInterval) {
                    this._max = this._adjustNumericTickValue(_ceil(this._max / tickInterval) * tickInterval, tickInterval, this._min)
                },
                _correctMin: function(tickInterval) {
                    this._min = this._adjustNumericTickValue(_floor(this._min / tickInterval) * tickInterval, tickInterval, this._min)
                },
                _findBusinessDelta: function(min, max) {
                    return _adjustValue(_abs(min - max))
                },
                _findTickIntervalForCustomTicks: function() {
                    return _abs(this._customTicks[1] - this._customTicks[0])
                },
                _getBoundInterval: function() {
                    var that = this,
                        boundCoef = that._options.boundCoef;
                    return _isDefined(boundCoef) && isFinite(boundCoef) ? that._tickInterval * _abs(boundCoef) : that._tickInterval / 2
                },
                _getInterval: function(deltaCoef, numberMultipliers) {
                    var factor, newResult, i, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
                        multipliers = numberMultipliers || this._options.numberMultipliers,
                        result = 0,
                        hasResult = false;
                    if (interval > 1) {
                        for (factor = 1; !hasResult; factor *= 10) {
                            for (i = 0; i < multipliers.length; i++) {
                                result = multipliers[i] * factor;
                                if (interval <= result) {
                                    hasResult = true;
                                    break
                                }
                            }
                        }
                    } else {
                        if (interval > 0) {
                            result = 1;
                            for (factor = .1; !hasResult; factor /= 10) {
                                for (i = multipliers.length - 1; i >= 0; i--) {
                                    newResult = multipliers[i] * factor;
                                    if (interval > newResult) {
                                        hasResult = true;
                                        break
                                    }
                                    result = newResult
                                }
                            }
                        }
                    }
                    return _adjustValue(result)
                },
                _getMarginValue: function(min, max, margin) {
                    return vizUtils.applyPrecisionByMinDelta(min, margin, _abs(max - min) * margin)
                },
                _getDefaultMinorInterval: function(screenDelta, businessDelta) {
                    var result, deltaCoef = this._getDeltaCoef(screenDelta, businessDelta, this._options.minorGridSpacingFactor),
                        multipliers = DEFAULT_MINOR_NUMBER_MULTIPLIERS,
                        i = multipliers.length - 1;
                    for (i; i >= 0; i--) {
                        result = businessDelta / multipliers[i];
                        if (deltaCoef <= result) {
                            return _adjustValue(result)
                        }
                    }
                    return 0
                },
                _getMinorInterval: function(screenDelta, businessDelta) {
                    var interval, intervalsCount, count, that = this,
                        options = that._options,
                        minorTickInterval = options.minorTickInterval,
                        minorTickCount = options.minorTickCount;
                    if (isFinite(minorTickInterval) && that._isTickIntervalCorrect(minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
                        interval = minorTickInterval;
                        count = interval < businessDelta ? _ceil(businessDelta / interval) - 1 : 0
                    } else {
                        if (_isDefined(minorTickCount)) {
                            intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
                            count = intervalsCount - 1;
                            interval = count > 0 ? businessDelta / intervalsCount : 0
                        } else {
                            interval = that._getDefaultMinorInterval(screenDelta, businessDelta);
                            count = interval < businessDelta ? _floor(businessDelta / interval) - 1 : 0
                        }
                    }
                    that._minorTickInterval = interval;
                    that._minorTickCount = count
                },
                _getNextTickValue: function(value, tickInterval, isTickIntervalNegative) {
                    tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval;
                    value += tickInterval;
                    return this._adjustNumericTickValue(value, tickInterval, this._min)
                },
                _isTickIntervalValid: function(tickInterval) {
                    return _isDefined(tickInterval) && isFinite(tickInterval) && 0 !== tickInterval
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/viz/core/layout_element.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _round = Math.round,
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                defaultOffset = {
                    horizontal: 0,
                    vertical: 0
                },
                alignFactors = {
                    center: .5,
                    right: 1,
                    bottom: 1,
                    left: 0,
                    top: 0
                };

            function LayoutElement(options) {
                this._options = options
            }
            LayoutElement.prototype = {
                constructor: LayoutElement,
                position: function(options) {
                    var that = this,
                        ofBBox = options.of.getLayoutOptions(),
                        myBBox = that.getLayoutOptions(),
                        at = options.at,
                        my = options.my,
                        offset = options.offset || defaultOffset,
                        shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal),
                        shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
                    that.shift(_round(shiftX), _round(shiftY))
                },
                getLayoutOptions: $.noop,
                getVerticalCuttedSize: function(canvas) {
                    var that = this,
                        height = canvas.height,
                        top = canvas.top,
                        bottom = canvas.bottom,
                        layoutOptions = that.getLayoutOptions();
                    if (layoutOptions) {
                        that.draw(canvas.width, canvas.height);
                        layoutOptions = that.getLayoutOptions();
                        if (layoutOptions) {
                            height -= layoutOptions.height;
                            if ("bottom" === layoutOptions.position.vertical) {
                                bottom += layoutOptions.height
                            } else {
                                top += layoutOptions.height
                            }
                        }
                    }
                    return {
                        left: canvas.left,
                        right: canvas.right,
                        top: top,
                        bottom: bottom,
                        width: canvas.width,
                        height: height
                    }
                }
            };

            function WrapperLayoutElement(renderElement, bbox) {
                this._renderElement = renderElement;
                this._cacheBBox = bbox
            }
            var wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = objectUtils.clone(LayoutElement.prototype);
            wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;
            wrapperLayoutElementPrototype.getLayoutOptions = function() {
                return this._cacheBBox || this._renderElement.getBBox()
            };
            wrapperLayoutElementPrototype.shift = function(shiftX, shiftY) {
                var bbox = this.getLayoutOptions();
                this._renderElement.move(_round(shiftX - bbox.x), _round(shiftY - bbox.y))
            };
            exports.LayoutElement = LayoutElement;
            exports.WrapperLayoutElement = WrapperLayoutElement
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/viz/gauges/common.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 128).dxBaseGauge,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _isArray = commonUtils.isArray,
                _isNumber = commonUtils.isNumber,
                rangeModule = __webpack_require__( /*! ../translators/range */ 89),
                axisModule = __webpack_require__( /*! ../axes/base_axis */ 231),
                _map = __webpack_require__( /*! ../core/utils */ 6).map,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _compareArrays = __webpack_require__( /*! ./base_gauge */ 128).compareArrays,
                _isFinite = isFinite,
                _Number = Number,
                _min = Math.min,
                _max = Math.max,
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop,
                OPTION_VALUE = "value",
                OPTION_SUBVALUES = "subvalues",
                DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 5,
                DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 5];

            function processValue(value, fallbackValue) {
                return _isFinite(value) ? _Number(value) : fallbackValue
            }

            function parseArrayOfNumbers(arg) {
                return _isArray(arg) ? arg : _isNumber(arg) ? [arg] : null
            }
            exports.dxGauge = dxBaseGauge.inherit({
                _initCore: function() {
                    var that = this,
                        renderer = that._renderer;
                    that._setupValue(that.option(OPTION_VALUE));
                    that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));
                    that._setupSubvalues(that.__subvalues);
                    selectMode(that);
                    that.callBase.apply(that, arguments);
                    that._rangeContainer = new that._factory.RangeContainer({
                        renderer: renderer,
                        container: renderer.root,
                        translator: that._translator,
                        themeManager: that._themeManager
                    });
                    that._initScale()
                },
                _initScale: function() {
                    var that = this;
                    that._scaleGroup = that._renderer.g().attr({
                        "class": "dxg-scale"
                    }).linkOn(that._renderer.root, "scale");
                    that._scale = new axisModule.Axis({
                        incidentOccurred: that._incidentOccurred,
                        renderer: that._renderer,
                        axesContainerGroup: that._scaleGroup,
                        axisType: that._scaleTypes.type,
                        drawingType: that._scaleTypes.drawingType,
                        widgetClass: "dxg"
                    });
                    that._scaleTranslator = that._initScaleTranslator(new rangeModule.Range({
                        axisType: "continuous",
                        dataType: "numeric",
                        stick: true
                    }))
                },
                _disposeCore: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._scale.dispose();
                    that._scaleGroup.linkOff();
                    that._rangeContainer.dispose();
                    that._disposeValueIndicators();
                    that._scale = that._scaleGroup = that._scaleTranslators = that._rangeContainer = null
                },
                _disposeValueIndicators: function() {
                    var that = this;
                    that._valueIndicator && that._valueIndicator.dispose();
                    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
                    that._valueIndicator = that._subvalueIndicatorsSet = null
                },
                _setupDomainCore: function() {
                    var that = this,
                        scaleOption = that.option("scale") || {},
                        startValue = that.option("startValue"),
                        endValue = that.option("endValue");
                    startValue = _isNumber(startValue) ? _Number(startValue) : _isNumber(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
                    endValue = _isNumber(endValue) ? _Number(endValue) : _isNumber(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
                    that._baseValue = startValue < endValue ? startValue : endValue;
                    that._translator.setDomain(startValue, endValue)
                },
                _cleanContent: function() {
                    var that = this;
                    that._rangeContainer.clean();
                    that._cleanValueIndicators()
                },
                _measureScale: function(scaleOptions) {
                    var textParams, layoutValue, result, coefs, innerCoef, outerCoef, that = this,
                        majorTick = scaleOptions.tick,
                        majorTickEnabled = majorTick.visible && majorTick.length > 0 && majorTick.width > 0,
                        minorTick = scaleOptions.minorTick,
                        minorTickEnabled = minorTick.visible && minorTick.length > 0 && minorTick.width > 0,
                        label = scaleOptions.label,
                        indentFromTick = Number(label.indentFromTick);
                    if (!majorTickEnabled && !minorTickEnabled && !label.visible) {
                        return {}
                    }
                    textParams = that._scale.measureLabels();
                    layoutValue = that._getScaleLayoutValue();
                    result = {
                        min: layoutValue,
                        max: layoutValue
                    };
                    coefs = that._getTicksCoefficients(scaleOptions);
                    innerCoef = coefs.inner;
                    outerCoef = coefs.outer;
                    if (majorTickEnabled) {
                        result.min = _min(result.min, layoutValue - innerCoef * majorTick.length);
                        result.max = _max(result.max, layoutValue + outerCoef * majorTick.length)
                    }
                    if (minorTickEnabled) {
                        result.min = _min(result.min, layoutValue - innerCoef * minorTick.length);
                        result.max = _max(result.max, layoutValue + outerCoef * minorTick.length)
                    }
                    label.visible && that._correctScaleIndents(result, indentFromTick, textParams);
                    return result
                },
                _renderContent: function() {
                    var elements, that = this,
                        scaleOptions = that._prepareScaleSettings();
                    that._rangeContainer.render(_extend(that._getOption("rangeContainer"), {
                        vertical: that._area.vertical
                    }));
                    that._renderScale(scaleOptions);
                    elements = _map([that._rangeContainer].concat(that._prepareValueIndicators()), function(element) {
                        return element && element.enabled ? element : null
                    });
                    that._applyMainLayout(elements, that._measureScale(scaleOptions));
                    _each(elements, function(_, element) {
                        element.resize(that._getElementLayout(element.getOffset()))
                    });
                    that._shiftScale(that._getElementLayout(0), scaleOptions);
                    that._beginValueChanging();
                    that._updateActiveElements();
                    that._endValueChanging()
                },
                _prepareScaleSettings: function() {
                    var that = this,
                        scaleOptions = $.extend(true, {}, that._themeManager.theme("scale"), that.option("scale")),
                        useAutoArrangement = scaleOptions.label.overlappingBehavior.useAutoArrangement,
                        scaleMajorTick = scaleOptions.majorTick,
                        scaleMinorTick = scaleOptions.minorTick,
                        overlappingBehavior = scaleOptions.label.overlappingBehavior;
                    if (scaleMajorTick) {
                        scaleOptions.tick = _extend(scaleOptions.tick, scaleMajorTick);
                        useAutoArrangement = void 0 !== scaleMajorTick.useTickAutoArrangement ? scaleMajorTick.useTickAutoArrangement : true;
                        void 0 !== scaleMajorTick.tickInterval && (scaleOptions.tickInterval = scaleMajorTick.tickInterval);
                        void 0 !== scaleMajorTick.customTickValues && (scaleOptions.customTicks = scaleMajorTick.customTickValues);
                        if (scaleOptions.customTicks) {
                            scaleOptions.tick.showCalculatedTicks = void 0 !== scaleMajorTick.showCalculatedTicks ? scaleMajorTick.showCalculatedTicks : true
                        } else {
                            scaleOptions.tick.showCalculatedTicks = false
                        }
                    }
                    overlappingBehavior.hideFirstTick = scaleOptions.hideFirstTick;
                    overlappingBehavior.hideFirstLabel = scaleOptions.hideFirstLabel;
                    overlappingBehavior.hideLastTick = scaleOptions.hideLastTick;
                    overlappingBehavior.hideLastLabel = scaleOptions.hideLastLabel;
                    void 0 !== scaleMinorTick.customTickValues && (scaleOptions.customMinorTicks = scaleOptions.minorTick.customTickValues);
                    void 0 !== scaleMinorTick.tickInterval && (scaleOptions.minorTickInterval = scaleOptions.minorTick.tickInterval);
                    if (scaleOptions.customMinorTicks) {
                        scaleMinorTick.showCalculatedTicks = void 0 !== scaleMinorTick.showCalculatedTicks ? scaleMinorTick.showCalculatedTicks : true
                    } else {
                        scaleMinorTick.showCalculatedTicks = false
                    }
                    scaleOptions.label.indentFromAxis = 0;
                    scaleOptions.isHorizontal = !that._area.vertical;
                    overlappingBehavior.mode = useAutoArrangement ? "enlargeTickInterval" : "ignore";
                    scaleOptions.axisDivisionFactor = that._gridSpacingFactor;
                    scaleOptions.minorAxisDivisionFactor = DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
                    scaleOptions.numberMultipliers = DEFAULT_NUMBER_MULTIPLIERS;
                    scaleOptions.tickOrientation = that._getTicksOrientation(scaleOptions);
                    if (scaleOptions.label.useRangeColors) {
                        scaleOptions.label.customizeColor = function() {
                            return that._rangeContainer.getColorForValue(this.value)
                        }
                    }
                    return scaleOptions
                },
                _renderScale: function(scaleOptions) {
                    var that = this,
                        bounds = that._translator.getDomain(),
                        startValue = bounds[0],
                        endValue = bounds[1];
                    scaleOptions.min = startValue;
                    scaleOptions.max = endValue;
                    that._scale.updateOptions(scaleOptions);
                    that._updateScaleTranslator(startValue, endValue);
                    that._updateScaleTickIndent(scaleOptions);
                    that._scaleGroup.linkAppend();
                    that._scale.draw()
                },
                _updateScaleTranslator: function(startValue, endValue) {
                    var that = this,
                        argTranslator = that._getScaleTranslatorComponent("arg");
                    that._updateScaleAngles();
                    argTranslator.updateBusinessRange(_extend(argTranslator.getBusinessRange(), {
                        minVisible: startValue,
                        maxVisible: endValue,
                        invert: startValue > endValue
                    }));
                    that._scale.setTranslator(argTranslator, that._getScaleTranslatorComponent("val"))
                },
                _updateIndicatorSettings: function(settings) {
                    var that = this;
                    settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
                    settings.vertical = that._area.vertical;
                    if (settings.text && !settings.text.format && !settings.text.precision) {
                        settings.text.format = that._defaultFormatOptions
                    }
                },
                _prepareIndicatorSettings: function(options, defaultTypeField) {
                    var that = this,
                        theme = that._themeManager.theme("valueIndicators"),
                        type = _normalizeEnum(options.type || that._themeManager.theme(defaultTypeField)),
                        settings = _extend(true, {}, theme._default, theme[type], options);
                    settings.type = type;
                    settings.animation = that._animationSettings;
                    settings.containerBackgroundColor = that._containerBackgroundColor;
                    that._updateIndicatorSettings(settings);
                    return settings
                },
                _cleanValueIndicators: function() {
                    this._valueIndicator && this._valueIndicator.clean();
                    this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean()
                },
                _prepareValueIndicators: function() {
                    var that = this;
                    that._prepareValueIndicator();
                    null !== that.__subvalues && that._prepareSubvalueIndicators();
                    return [that._valueIndicator, that._subvalueIndicatorsSet]
                },
                _updateActiveElements: function() {
                    this._updateValueIndicator();
                    this._updateSubvalueIndicators()
                },
                _prepareValueIndicator: function() {
                    var that = this,
                        target = that._valueIndicator,
                        settings = that._prepareIndicatorSettings(that.option("valueIndicator") || {}, "valueIndicatorType");
                    if (target && target.type !== settings.type) {
                        target.dispose();
                        target = null
                    }
                    if (!target) {
                        target = that._valueIndicator = that._createIndicator(settings.type, that._renderer.root, "dxg-value-indicator", "value-indicator")
                    }
                    target.render(settings)
                },
                _createSubvalueIndicatorsSet: function() {
                    var that = this,
                        root = that._renderer.root;
                    return new ValueIndicatorsSet({
                        createIndicator: function(type, i) {
                            return that._createIndicator(type, root, "dxg-subvalue-indicator", "subvalue-indicator", i)
                        },
                        createPalette: function(palette) {
                            return that._themeManager.createPalette(palette)
                        }
                    })
                },
                _prepareSubvalueIndicators: function() {
                    var isRecreate, dummy, that = this,
                        target = that._subvalueIndicatorsSet,
                        settings = that._prepareIndicatorSettings(that.option("subvalueIndicator") || {}, "subvalueIndicatorType");
                    if (!target) {
                        target = that._subvalueIndicatorsSet = that._createSubvalueIndicatorsSet()
                    }
                    isRecreate = settings.type !== target.type;
                    target.type = settings.type;
                    dummy = that._createIndicator(settings.type, that._renderer.root);
                    if (dummy) {
                        dummy.dispose();
                        target.render(settings, isRecreate)
                    }
                },
                _setupValue: function(value) {
                    this.__value = processValue(value, this.__value)
                },
                _setupSubvalues: function(subvalues) {
                    var i, ii, list, vals = void 0 === subvalues ? this.__subvalues : parseArrayOfNumbers(subvalues);
                    if (null === vals) {
                        return
                    }
                    for (i = 0, ii = vals.length, list = []; i < ii; ++i) {
                        list.push(processValue(vals[i], this.__subvalues[i]))
                    }
                    this.__subvalues = list
                },
                _updateValueIndicator: function() {
                    var that = this;
                    that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation)
                },
                _updateSubvalueIndicators: function() {
                    var that = this;
                    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation)
                },
                value: function(arg) {
                    if (void 0 !== arg) {
                        this._changeValue(arg);
                        return this
                    }
                    return this.__value
                },
                subvalues: function(arg) {
                    if (void 0 !== arg) {
                        this._changeSubvalues(arg);
                        return this
                    }
                    return null !== this.__subvalues ? this.__subvalues.slice() : void 0
                },
                _changeValue: function(value) {
                    var that = this;
                    that._setupValue(value);
                    that._beginValueChanging();
                    that._updateValueIndicator();
                    if (that.__value !== that.option(OPTION_VALUE)) {
                        that.option(OPTION_VALUE, that.__value)
                    }
                    that._endValueChanging()
                },
                _changeSubvalues: function(subvalues) {
                    var that = this;
                    if (null !== that.__subvalues) {
                        that._setupSubvalues(subvalues);
                        that._beginValueChanging();
                        that._updateSubvalueIndicators();
                        if (!_compareArrays(that.__subvalues, that.option(OPTION_SUBVALUES))) {
                            that.option(OPTION_SUBVALUES, that.__subvalues)
                        }
                        that._endValueChanging()
                    }
                },
                _optionChangesMap: {
                    scale: "DOMAIN",
                    rangeContainer: "MOSTLY_TOTAL",
                    valueIndicator: "MOSTLY_TOTAL",
                    subvalueIndicator: "MOSTLY_TOTAL",
                    containerBackgroundColor: "MOSTLY_TOTAL",
                    value: "VALUE",
                    subvalues: "SUBVALUES",
                    valueIndicators: "MOSTLY_TOTAL"
                },
                _customChangesOrder: ["VALUE", "SUBVALUES"],
                _change_VALUE: function() {
                    this._changeValue(this.option(OPTION_VALUE))
                },
                _change_SUBVALUES: function() {
                    this._changeSubvalues(this.option(OPTION_SUBVALUES))
                },
                _applyMainLayout: null,
                _getElementLayout: null,
                _createIndicator: function(type, owner, className, trackerType, trackerIndex, _strict) {
                    var that = this,
                        indicator = that._factory.createIndicator({
                            renderer: that._renderer,
                            translator: that._translator,
                            owner: owner,
                            tracker: that._tracker,
                            className: className
                        }, type, _strict);
                    if (indicator) {
                        indicator.type = type;
                        indicator._trackerInfo = {
                            type: trackerType,
                            index: trackerIndex
                        }
                    }
                    return indicator
                },
                _getApproximateScreenRange: null
            });

            function valueGetter(arg) {
                return arg ? arg.value : null
            }

            function setupValues(that, fieldName, optionItems) {
                var currentValues = that[fieldName],
                    newValues = _isArray(optionItems) ? _map(optionItems, valueGetter) : [],
                    i = 0,
                    ii = newValues.length,
                    list = [];
                for (; i < ii; ++i) {
                    list.push(processValue(newValues[i], currentValues[i]))
                }
                that[fieldName] = list
            }

            function selectMode(gauge) {
                if (void 0 === gauge.option(OPTION_VALUE) && void 0 === gauge.option(OPTION_SUBVALUES)) {
                    if (void 0 !== gauge.option("valueIndicators")) {
                        disableDefaultMode(gauge);
                        selectHardMode(gauge)
                    }
                }
            }

            function disableDefaultMode(that) {
                that.value = that.subvalues = _noop;
                that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null
            }

            function selectHardMode(that) {
                that._indicatorValues = [];
                setupValues(that, "_indicatorValues", that.option("valueIndicators"));
                that._valueIndicators = [];
                var _applyMostlyTotalChange = that._applyMostlyTotalChange;
                that._applyMostlyTotalChange = function() {
                    setupValues(this, "_indicatorValues", this.option("valueIndicators"));
                    _applyMostlyTotalChange.call(this)
                };
                that._updateActiveElements = updateActiveElements_hardMode;
                that._prepareValueIndicators = prepareValueIndicators_hardMode;
                that._disposeValueIndicators = disposeValueIndicators_hardMode;
                that._cleanValueIndicators = cleanValueIndicators_hardMode;
                that.indicatorValue = indicatorValue_hardMode
            }

            function updateActiveElements_hardMode() {
                var that = this;
                _each(that._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.value(that._indicatorValues[valueIndicator.index], that._noAnimation)
                })
            }

            function prepareValueIndicators_hardMode() {
                var ii, that = this,
                    valueIndicators = that._valueIndicators || [],
                    userOptions = that.option("valueIndicators"),
                    optionList = [],
                    i = 0;
                for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i) {
                    optionList.push(userOptions[i])
                }
                for (ii = valueIndicators.length; i < ii; ++i) {
                    optionList.push(null)
                }
                var newValueIndicators = [];
                _each(optionList, function(i, userSettings) {
                    var valueIndicator = valueIndicators[i];
                    if (!userSettings) {
                        valueIndicator && valueIndicator.dispose();
                        return
                    }
                    var settings = that._prepareIndicatorSettings(userSettings, "valueIndicatorType");
                    if (valueIndicator && valueIndicator.type !== settings.type) {
                        valueIndicator.dispose();
                        valueIndicator = null
                    }
                    if (!valueIndicator) {
                        valueIndicator = that._createIndicator(settings.type, that._renderer.root, "dxg-value-indicator", "value-indicator", i, true)
                    }
                    if (valueIndicator) {
                        valueIndicator.index = i;
                        valueIndicator.render(settings);
                        newValueIndicators.push(valueIndicator)
                    }
                });
                that._valueIndicators = newValueIndicators;
                return that._valueIndicators
            }

            function disposeValueIndicators_hardMode() {
                _each(this._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.dispose()
                });
                this._valueIndicators = null
            }

            function cleanValueIndicators_hardMode() {
                _each(this._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.clean()
                })
            }

            function indicatorValue_hardMode(index, value) {
                return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value)
            }

            function accessPointerValue(that, pointers, values, index, value) {
                if (void 0 !== value) {
                    if (void 0 !== values[index]) {
                        values[index] = processValue(value, values[index]);
                        pointers[index] && pointers[index].value(values[index])
                    }
                    return that
                } else {
                    return values[index]
                }
            }

            function ValueIndicatorsSet(parameters) {
                this._parameters = parameters;
                this._indicators = []
            }
            ValueIndicatorsSet.prototype = {
                constructor: ValueIndicatorsSet,
                dispose: function() {
                    var that = this;
                    _each(that._indicators, function(_, indicator) {
                        indicator.dispose()
                    });
                    that._parameters = that._options = that._indicators = that._colorPalette = that._palette = null;
                    return that
                },
                clean: function() {
                    var that = this;
                    that._sample && that._sample.clean().dispose();
                    _each(that._indicators, function(_, indicator) {
                        indicator.clean()
                    });
                    that._sample = that._options = that._palette = null;
                    return that
                },
                render: function(options, isRecreate) {
                    var that = this;
                    that._options = options;
                    that._sample = that._parameters.createIndicator(that.type);
                    that._sample.render(options);
                    that.enabled = that._sample.enabled;
                    that._palette = _isDefined(options.palette) ? that._parameters.createPalette(options.palette) : null;
                    if (that.enabled) {
                        that._generatePalette(that._indicators.length);
                        that._indicators = _map(that._indicators, function(indicator, i) {
                            if (isRecreate) {
                                indicator.dispose();
                                indicator = that._parameters.createIndicator(that.type, i)
                            }
                            indicator.render(that._getIndicatorOptions(i));
                            return indicator
                        })
                    }
                    return that
                },
                getOffset: function() {
                    return _Number(this._options.offset) || 0
                },
                resize: function(layout) {
                    var that = this;
                    that._layout = layout;
                    _each(that._indicators, function(_, indicator) {
                        indicator.resize(layout)
                    });
                    return that
                },
                measure: function(layout) {
                    return this._sample.measure(layout)
                },
                _getIndicatorOptions: function(index) {
                    var result = this._options;
                    if (this._colorPalette) {
                        result = _extend({}, result, {
                            color: this._colorPalette[index]
                        })
                    }
                    return result
                },
                _generatePalette: function(count) {
                    var that = this,
                        colors = null;
                    if (that._palette) {
                        colors = [];
                        that._palette.reset();
                        var i = 0;
                        for (; i < count; ++i) {
                            colors.push(that._palette.getNextColor())
                        }
                    }
                    that._colorPalette = colors
                },
                _adjustIndicatorsCount: function(count) {
                    var i, ii, indicator, that = this,
                        indicators = that._indicators,
                        indicatorsLen = indicators.length;
                    if (indicatorsLen > count) {
                        for (i = count, ii = indicatorsLen; i < ii; ++i) {
                            indicators[i].clean().dispose()
                        }
                        that._indicators = indicators.slice(0, count);
                        that._generatePalette(indicators.length)
                    } else {
                        if (indicatorsLen < count) {
                            that._generatePalette(count);
                            for (i = indicatorsLen, ii = count; i < ii; ++i) {
                                indicator = that._parameters.createIndicator(that.type, i);
                                indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
                                indicators.push(indicator)
                            }
                        }
                    }
                },
                values: function(arg, _noAnimation) {
                    var that = this;
                    if (!that.enabled) {
                        return
                    }
                    if (void 0 !== arg) {
                        if (!_isArray(arg)) {
                            arg = _isFinite(arg) ? [Number(arg)] : null
                        }
                        if (arg) {
                            that._adjustIndicatorsCount(arg.length);
                            _each(that._indicators, function(i, indicator) {
                                indicator.value(arg[i], _noAnimation)
                            })
                        }
                        return that
                    }
                    return _map(that._indicators, function(indicator) {
                        return indicator.value()
                    })
                }
            };
            exports.createIndicatorCreator = function(indicators) {
                return function(parameters, type, _strict) {
                    var indicatorType = indicators[_normalizeEnum(type)] || !_strict && indicators._default;
                    return indicatorType ? new indicatorType(parameters) : null
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/range_selector/common.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _format = __webpack_require__( /*! ../core/format */ 162),
                isFunction = __webpack_require__( /*! ../../core/utils/common */ 2).isFunction,
                HEIGHT_COMPACT_MODE = 24,
                POINTER_SIZE = 4,
                EMPTY_SLIDER_MARKER_TEXT = ". . .";
            var utils = {
                trackerSettings: {
                    fill: "grey",
                    stroke: "grey",
                    opacity: 1e-4
                },
                animationSettings: {
                    duration: 250
                }
            };
            var consts = {
                emptySliderMarkerText: EMPTY_SLIDER_MARKER_TEXT,
                pointerSize: POINTER_SIZE
            };
            var formatValue = function(value, formatOptions) {
                var formatObject = {
                    value: value,
                    valueText: _format(value, formatOptions)
                };
                return String(isFunction(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText)
            };
            exports.utils = utils;
            exports.consts = consts;
            exports.formatValue = formatValue;
            exports.HEIGHT_COMPACT_MODE = HEIGHT_COMPACT_MODE
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/series/line_series.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                series = __webpack_require__( /*! ./scatter_series */ 88),
                chartScatterSeries = series.chart,
                polarScatterSeries = series.polar,
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                normalizeAngle = vizUtils.normalizeAngle,
                CANVAS_POSITION_START = "canvas_position_start",
                CANVAS_POSITION_TOP = "canvas_position_top",
                DISCRETE = "discrete",
                _map = vizUtils.map,
                _extend = $.extend,
                _each = $.each;
            exports.chart = {};
            exports.polar = {};

            function clonePoint(point, newX, newY, newAngle) {
                var p = objectUtils.clone(point);
                p.x = newX;
                p.y = newY;
                p.angle = newAngle;
                return p
            }

            function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
                var correctAngle = point.angle + nextStepAngle,
                    cossin = vizUtils.getCosAndSin(correctAngle),
                    x = centerPoint.x + (point.radius + tan * nextStepAngle) * cossin.cos,
                    y = centerPoint.y - (point.radius + tan * nextStepAngle) * cossin.sin;
                return clonePoint(prevPoint, x, y, correctAngle)
            }
            var lineMethods = {
                _applyGroupSettings: function(style, settings, group) {
                    var that = this;
                    settings = _extend(settings, style);
                    that._applyElementsClipRect(settings);
                    group.attr(settings)
                },
                _setGroupsSettings: function(animationEnabled) {
                    var that = this,
                        style = that._styles.normal;
                    that._applyGroupSettings(style.elements, {
                        "class": "dxc-elements"
                    }, that._elementsGroup);
                    that._bordersGroup && that._applyGroupSettings(style.border, {
                        "class": "dxc-borders"
                    }, that._bordersGroup);
                    chartScatterSeries._setGroupsSettings.call(that, animationEnabled);
                    animationEnabled && that._markersGroup && that._markersGroup.attr({
                        opacity: .001
                    })
                },
                _createGroups: function() {
                    var that = this;
                    that._createGroup("_elementsGroup", that, that._group);
                    that._areBordersVisible() && that._createGroup("_bordersGroup", that, that._group);
                    chartScatterSeries._createGroups.call(that)
                },
                _areBordersVisible: function() {
                    return false
                },
                _getDefaultSegment: function(segment) {
                    return {
                        line: _map(segment.line || [], function(pt) {
                            return pt.getDefaultCoords()
                        })
                    }
                },
                _prepareSegment: function(points) {
                    return {
                        line: points
                    }
                },
                _parseLineOptions: function(options, defaultColor) {
                    return {
                        stroke: options.color || defaultColor,
                        "stroke-width": options.width,
                        dashStyle: options.dashStyle || "solid"
                    }
                },
                _parseStyle: function(options, defaultColor) {
                    return {
                        elements: this._parseLineOptions(options, defaultColor)
                    }
                },
                _applyStyle: function(style) {
                    var that = this;
                    that._elementsGroup && that._elementsGroup.attr(style.elements);
                    _each(that._graphics || [], function(_, graphic) {
                        graphic.line && graphic.line.attr({
                            "stroke-width": style.elements["stroke-width"]
                        }).sharp()
                    })
                },
                _drawElement: function(segment, group) {
                    return {
                        line: this._createMainElement(segment.line, {
                            "stroke-width": this._styles.normal.elements["stroke-width"]
                        }).append(group)
                    }
                },
                _removeElement: function(element) {
                    element.line.remove()
                },
                _generateDefaultSegments: function() {
                    var that = this;
                    return _map(that._segments || [], function(segment) {
                        return that._getDefaultSegment(segment)
                    })
                },
                _updateElement: function(element, segment, animate, animateParams, complete) {
                    var params = {
                            points: segment.line
                        },
                        lineElement = element.line;
                    animate ? lineElement.animate(params, animateParams, complete) : lineElement.attr(params)
                },
                _clearingAnimation: function(translator, drawComplete) {
                    var that = this,
                        lastIndex = that._graphics.length - 1,
                        settings = {
                            opacity: .001
                        },
                        options = {
                            duration: that._defaultDuration,
                            partitionDuration: .5
                        };
                    that._labelsGroup && that._labelsGroup.animate(settings, options, function() {
                        that._markersGroup && that._markersGroup.animate(settings, options, function() {
                            _each(that._defaultSegments || [], function(i, segment) {
                                that._oldUpdateElement(that._graphics[i], segment, true, {
                                    partitionDuration: .5
                                }, i === lastIndex ? drawComplete : void 0)
                            })
                        })
                    })
                },
                _animateComplete: function() {
                    var that = this;
                    chartScatterSeries._animateComplete.call(this);
                    that._markersGroup && that._markersGroup.animate({
                        opacity: 1
                    }, {
                        duration: that._defaultDuration
                    })
                },
                _animate: function() {
                    var that = this,
                        lastIndex = that._graphics.length - 1;
                    _each(that._graphics || [], function(i, elem) {
                        that._updateElement(elem, that._segments[i], true, {
                            complete: i === lastIndex ? function() {
                                that._animateComplete()
                            } : void 0
                        })
                    })
                },
                _drawPoint: function(options) {
                    chartScatterSeries._drawPoint.call(this, {
                        point: options.point,
                        groups: options.groups
                    })
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "line").attr(settings).sharp()
                },
                _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {
                    var that = this,
                        segment = that._prepareSegment(points, that._options.rotated, lastSegment);
                    that._segments.push(segment);
                    if (!that._graphics[segmentCount]) {
                        that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)
                    } else {
                        if (!animationEnabled) {
                            that._updateElement(that._graphics[segmentCount], segment)
                        }
                    }
                },
                _getTrackerSettings: function() {
                    var that = this,
                        defaultTrackerWidth = that._defaultTrackerWidth,
                        strokeWidthFromElements = that._styles.normal.elements["stroke-width"];
                    return {
                        "stroke-width": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
                        fill: "none"
                    }
                },
                _getMainPointsFromSegment: function(segment) {
                    return segment.line
                },
                _drawTrackerElement: function(segment) {
                    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))
                },
                _updateTrackerElement: function(segment, element) {
                    var settings = this._getTrackerSettings(segment);
                    settings.points = this._getMainPointsFromSegment(segment);
                    element.attr(settings)
                }
            };
            exports.chart.line = _extend({}, chartScatterSeries, lineMethods);
            exports.chart.stepline = _extend({}, exports.chart.line, {
                _calculateStepLinePoints: function(points) {
                    var segment = [];
                    _each(points, function(i, pt) {
                        var stepY, point;
                        if (!i) {
                            segment.push(pt);
                            return
                        }
                        stepY = segment[segment.length - 1].y;
                        if (stepY !== pt.y) {
                            point = objectUtils.clone(pt);
                            point.y = stepY;
                            segment.push(point)
                        }
                        segment.push(pt)
                    });
                    return segment
                },
                _prepareSegment: function(points) {
                    return exports.chart.line._prepareSegment(this._calculateStepLinePoints(points))
                }
            });
            exports.chart.spline = _extend({}, exports.chart.line, {
                _calculateBezierPoints: function(src, rotated) {
                    var bezierPoints = [],
                        pointsCopy = src,
                        checkExtr = function(otherPointCoord, pointCoord, controlCoord) {
                            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
                        };
                    if (1 !== pointsCopy.length) {
                        _each(pointsCopy, function(i, curPoint) {
                            var leftControlX, leftControlY, rightControlX, rightControlY, prevPoint, nextPoint, xCur, yCur, x1, x2, y1, y2, curIsExtremum, leftPoint, rightPoint, a, b, c, xc, yc, shift, lambda = .5;
                            if (!i) {
                                bezierPoints.push(curPoint);
                                bezierPoints.push(curPoint);
                                return
                            }
                            prevPoint = pointsCopy[i - 1];
                            if (i < pointsCopy.length - 1) {
                                nextPoint = pointsCopy[i + 1];
                                xCur = curPoint.x;
                                yCur = curPoint.y;
                                x1 = prevPoint.x;
                                x2 = nextPoint.x;
                                y1 = prevPoint.y;
                                y2 = nextPoint.y;
                                curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
                                if (curIsExtremum) {
                                    if (!rotated) {
                                        rightControlY = leftControlY = yCur;
                                        rightControlX = (xCur + nextPoint.x) / 2;
                                        leftControlX = (xCur + prevPoint.x) / 2
                                    } else {
                                        rightControlX = leftControlX = xCur;
                                        rightControlY = (yCur + nextPoint.y) / 2;
                                        leftControlY = (yCur + prevPoint.y) / 2
                                    }
                                } else {
                                    a = y2 - y1;
                                    b = x1 - x2;
                                    c = y1 * x2 - x1 * y2;
                                    if (!rotated) {
                                        xc = xCur;
                                        yc = -1 * (a * xc + c) / b;
                                        shift = yc - yCur || 0;
                                        y1 -= shift;
                                        y2 -= shift
                                    } else {
                                        yc = yCur;
                                        xc = -1 * (b * yc + c) / a;
                                        shift = xc - xCur || 0;
                                        x1 -= shift;
                                        x2 -= shift
                                    }
                                    rightControlX = (xCur + lambda * x2) / (1 + lambda);
                                    rightControlY = (yCur + lambda * y2) / (1 + lambda);
                                    leftControlX = (xCur + lambda * x1) / (1 + lambda);
                                    leftControlY = (yCur + lambda * y1) / (1 + lambda)
                                }
                                if (!rotated) {
                                    leftControlY = checkExtr(prevPoint.y, yCur, leftControlY);
                                    rightControlY = checkExtr(nextPoint.y, yCur, rightControlY)
                                } else {
                                    leftControlX = checkExtr(prevPoint.x, xCur, leftControlX);
                                    rightControlX = checkExtr(nextPoint.x, xCur, rightControlX)
                                }
                                leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
                                rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
                                bezierPoints.push(leftPoint, curPoint, rightPoint)
                            } else {
                                bezierPoints.push(curPoint, curPoint);
                                return
                            }
                        })
                    } else {
                        bezierPoints.push(pointsCopy[0])
                    }
                    return bezierPoints
                },
                _prepareSegment: function(points, rotated) {
                    return exports.chart.line._prepareSegment(this._calculateBezierPoints(points, rotated))
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "bezier").attr(settings).sharp()
                }
            });
            exports.polar.line = _extend({}, polarScatterSeries, lineMethods, {
                _prepareSegment: function(points, rotated, lastSegment) {
                    var i, preparedPoints = [],
                        centerPoint = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                    lastSegment && this._closeSegment(points);
                    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
                        for (i = 1; i < points.length; i++) {
                            preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))
                        }
                        if (!preparedPoints.length) {
                            preparedPoints = points
                        }
                    } else {
                        return exports.chart.line._prepareSegment.apply(this, arguments)
                    }
                    return {
                        line: preparedPoints
                    }
                },
                _getRemainingAngle: function(angle) {
                    var normAngle = normalizeAngle(angle);
                    return angle >= 0 ? 360 - normAngle : -normAngle
                },
                _closeSegment: function(points) {
                    var point, differenceAngle;
                    if (this._segments.length) {
                        point = this._segments[0].line[0]
                    } else {
                        point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)
                    }
                    if (points[points.length - 1].angle !== point.angle) {
                        if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {
                            point.angle = points[points.length - 1].angle
                        } else {
                            differenceAngle = points[points.length - 1].angle - point.angle;
                            point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle)
                        }
                        points.push(point)
                    }
                },
                _getTangentPoints: function(point, prevPoint, centerPoint) {
                    var i, tangentPoints = [],
                        betweenAngle = Math.round(prevPoint.angle - point.angle),
                        tan = (prevPoint.radius - point.radius) / betweenAngle;
                    if (0 === betweenAngle) {
                        tangentPoints = [prevPoint, point]
                    } else {
                        if (betweenAngle > 0) {
                            for (i = betweenAngle; i >= 0; i--) {
                                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))
                            }
                        } else {
                            for (i = 0; i >= betweenAngle; i--) {
                                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))
                            }
                        }
                    }
                    return tangentPoints
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/viz/series/points/bar_point.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _extend = $.extend,
                _math = Math,
                _floor = _math.floor,
                _abs = _math.abs,
                _min = _math.min,
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                CANVAS_POSITION_DEFAULT = "canvas_position_default",
                DEFAULT_BAR_TRACKER_SIZE = 9,
                CORRECTING_BAR_TRACKER_VALUE = 4,
                RIGHT = "right",
                LEFT = "left",
                TOP = "top",
                BOTTOM = "bottom";
            module.exports = _extend({}, symbolPoint, {
                correctCoordinates: function(correctOptions) {
                    var correction = _floor(correctOptions.offset - correctOptions.width / 2),
                        rotated = this._options.rotated,
                        valueSelector = rotated ? "height" : "width",
                        correctionSelector = (rotated ? "y" : "x") + "Correction";
                    this[valueSelector] = correctOptions.width;
                    this[correctionSelector] = correction
                },
                _getGraphicBbox: function() {
                    var that = this,
                        bbox = {};
                    bbox.x = that.x;
                    bbox.y = that.y;
                    bbox.width = that.width;
                    bbox.height = that.height;
                    return bbox
                },
                _getLabelConnector: function(location) {
                    return this._getGraphicBbox(location)
                },
                _getLabelPosition: function() {
                    var position, that = this,
                        translators = that.translators,
                        initialValue = that.initialValue,
                        invertX = translators.x.getBusinessRange().invert,
                        invertY = translators.y.getBusinessRange().invert,
                        isDiscreteValue = "discrete" === that.series.valueAxisType,
                        isFullStacked = that.series.isFullStackedSeries(),
                        notVerticalInverted = !isDiscreteValue && (initialValue >= 0 && !invertY || initialValue < 0 && invertY) || isDiscreteValue && !invertY || isFullStacked,
                        notHorizontalInverted = !isDiscreteValue && (initialValue >= 0 && !invertX || initialValue < 0 && invertX) || isDiscreteValue && !invertX || isFullStacked;
                    if (!that._options.rotated) {
                        position = notVerticalInverted ? TOP : BOTTOM
                    } else {
                        position = notHorizontalInverted ? RIGHT : LEFT
                    }
                    return position
                },
                _getLabelCoords: function(label) {
                    var coords, that = this;
                    if (0 === that.initialValue && that.series.isFullStackedSeries()) {
                        if (!this._options.rotated) {
                            coords = that._getLabelCoordOfPosition(label, TOP)
                        } else {
                            coords = that._getLabelCoordOfPosition(label, RIGHT)
                        }
                    } else {
                        if ("inside" === label.getLayoutOptions().position) {
                            coords = that._getLabelCoordOfPosition(label, "inside")
                        } else {
                            coords = symbolPoint._getLabelCoords.call(this, label)
                        }
                    }
                    return coords
                },
                _checkLabelPosition: function(label, coord) {
                    var that = this,
                        visibleArea = that._getVisibleArea();
                    if (that._isPointInVisibleArea(visibleArea, that._getGraphicBbox())) {
                        return that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
                    }
                    return coord
                },
                _isLabelInsidePoint: function(label) {
                    var that = this,
                        graphicBbox = that._getGraphicBbox(),
                        labelBbox = label.getBoundingRect();
                    if (that._options.resolveLabelsOverlapping && "inside" === label.getLayoutOptions().position) {
                        if (labelBbox.width > graphicBbox.width || labelBbox.height > graphicBbox.height) {
                            label.hide();
                            return true
                        }
                    }
                    return false
                },
                _moveLabelOnCanvas: function(coord, visibleArea, labelBbox) {
                    var x = coord.x,
                        y = coord.y;
                    if (visibleArea.minX > x) {
                        x = visibleArea.minX
                    }
                    if (visibleArea.maxX < x + labelBbox.width) {
                        x = visibleArea.maxX - labelBbox.width
                    }
                    if (visibleArea.minY > y) {
                        y = visibleArea.minY
                    }
                    if (visibleArea.maxY < y + labelBbox.height) {
                        y = visibleArea.maxY - labelBbox.height
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _showForZeroValues: function() {
                    return this._options.label.showForZeroValues || this.initialValue
                },
                _drawMarker: function(renderer, group, animationEnabled) {
                    var that = this,
                        style = that._getStyle(),
                        x = that.x,
                        y = that.y,
                        width = that.width,
                        height = that.height,
                        r = that._options.cornerRadius;
                    if (animationEnabled) {
                        if (that._options.rotated) {
                            width = 0;
                            x = that.defaultX
                        } else {
                            height = 0;
                            y = that.defaultY
                        }
                    }
                    that.graphic = renderer.rect(x, y, width, height).attr({
                        rx: r,
                        ry: r
                    }).attr(style).data({
                        "chart-data-point": that
                    }).append(group)
                },
                _getSettingsForTracker: function() {
                    var that = this,
                        y = that.y,
                        height = that.height,
                        x = that.x,
                        width = that.width;
                    if (that._options.rotated) {
                        if (1 === width) {
                            width = DEFAULT_BAR_TRACKER_SIZE;
                            x -= CORRECTING_BAR_TRACKER_VALUE
                        }
                    } else {
                        if (1 === height) {
                            height = DEFAULT_BAR_TRACKER_SIZE;
                            y -= CORRECTING_BAR_TRACKER_VALUE
                        }
                    }
                    return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
                },
                getGraphicSettings: function() {
                    var graphic = this.graphic;
                    return {
                        x: graphic.attr("x"),
                        y: graphic.attr("y"),
                        height: graphic.attr("height"),
                        width: graphic.attr("width")
                    }
                },
                _getEdgeTooltipParams: function(x, y, width, height) {
                    var xCoord, yCoord, isPositive = this.value >= 0,
                        invertedY = this.translators.y.getBusinessRange().invert,
                        invertedX = this.translators.x.getBusinessRange().invert;
                    if (this._options.rotated) {
                        yCoord = y + height / 2;
                        if (invertedX) {
                            xCoord = isPositive ? x : x + width
                        } else {
                            xCoord = isPositive ? x + width : x
                        }
                    } else {
                        xCoord = x + width / 2;
                        if (invertedY) {
                            yCoord = isPositive ? y + height : y
                        } else {
                            yCoord = isPositive ? y : y + height
                        }
                    }
                    return {
                        x: xCoord,
                        y: yCoord,
                        offset: 0
                    }
                },
                getTooltipParams: function(location) {
                    var x = this.x,
                        y = this.y,
                        width = this.width,
                        height = this.height;
                    return "edge" === location ? this._getEdgeTooltipParams(x, y, width, height) : {
                        x: x + width / 2,
                        y: y + height / 2,
                        offset: 0
                    }
                },
                _truncateCoord: function(coord, minBounce, maxBounce) {
                    if (coord < minBounce) {
                        return minBounce
                    }
                    if (coord > maxBounce) {
                        return maxBounce
                    }
                    return coord
                },
                _translateErrorBars: function(valueTranslator, argVisibleArea) {
                    symbolPoint._translateErrorBars.call(this, valueTranslator);
                    if (this._errorBarPos < argVisibleArea.min || this._errorBarPos > argVisibleArea.max) {
                        this._errorBarPos = void 0
                    }
                },
                _translate: function(translators) {
                    var arg, minArg, val, minVal, that = this,
                        rotated = that._options.rotated,
                        valAxis = rotated ? "x" : "y",
                        argAxis = rotated ? "y" : "x",
                        valIntervalName = rotated ? "width" : "height",
                        argIntervalName = rotated ? "height" : "width",
                        argTranslator = translators[argAxis],
                        valTranslator = translators[valAxis],
                        argVisibleArea = argTranslator.getCanvasVisibleArea(),
                        valVisibleArea = valTranslator.getCanvasVisibleArea();
                    arg = minArg = argTranslator.translate(that.argument) + (that[argAxis + "Correction"] || 0);
                    val = valTranslator.translate(that.value);
                    minVal = valTranslator.translate(that.minValue);
                    that["v" + valAxis] = val;
                    that["v" + argAxis] = arg + that[argIntervalName] / 2;
                    that[valIntervalName] = _abs(val - minVal);
                    that._calculateVisibility(rotated ? _min(val, minVal) : _min(arg, minArg), rotated ? _min(arg, minArg) : _min(val, minVal), that.width, that.height);
                    val = that._truncateCoord(val, valVisibleArea.min, valVisibleArea.max);
                    minVal = that._truncateCoord(minVal, valVisibleArea.min, valVisibleArea.max);
                    that[argAxis] = arg;
                    that["min" + argAxis.toUpperCase()] = minArg;
                    that[valIntervalName] = _abs(val - minVal);
                    that[valAxis] = _min(val, minVal) + (that[valAxis + "Correction"] || 0);
                    that["min" + valAxis.toUpperCase()] = minVal + (that[valAxis + "Correction"] || 0);
                    that["default" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
                    that._translateErrorBars(valTranslator, argVisibleArea);
                    if (that.inVisibleArea) {
                        if (that[argAxis] < argVisibleArea.min) {
                            that[argIntervalName] = that[argIntervalName] - (argVisibleArea.min - that[argAxis]);
                            that[argAxis] = argVisibleArea.min;
                            that["min" + argAxis.toUpperCase()] = argVisibleArea.min
                        }
                        if (that[argAxis] + that[argIntervalName] > argVisibleArea.max) {
                            that[argIntervalName] = argVisibleArea.max - that[argAxis]
                        }
                    }
                },
                _updateMarker: function(animationEnabled, style) {
                    this.graphic.attr(_extend({}, style || this._getStyle(), !animationEnabled ? this.getMarkerCoords() : {}))
                },
                getMarkerCoords: function() {
                    return {
                        x: this.x,
                        y: this.y,
                        width: this.width,
                        height: this.height
                    }
                },
                coordsIn: function(x, y) {
                    var that = this;
                    return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!*****************************************!*\
      !*** ./Scripts/bundles/modules/data.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var DevExpress = __webpack_require__( /*! ./core */ 97);
            module.exports = DevExpress.data = DevExpress.data || {};
            Object.defineProperty(DevExpress.data, "errorHandler", {
                get: function() { /*! ../../data/errors */
                    return __webpack_require__(25).errorHandler
                },
                set: function(value) {
                    __webpack_require__( /*! ../../data/errors */ 25).errorHandler = value
                }
            });
            Object.defineProperty(DevExpress.data, "_errorHandler", {
                get: function() { /*! ../../data/errors */
                    return __webpack_require__(25)._errorHandler
                },
                set: function(value) {
                    __webpack_require__( /*! ../../data/errors */ 25)._errorHandler = value
                }
            });
            DevExpress.data.DataSource = __webpack_require__( /*! ../../data/data_source */ 269);
            DevExpress.data.query = __webpack_require__( /*! ../../data/query */ 34);
            DevExpress.data.Store = __webpack_require__( /*! ../../data/abstract_store */ 50);
            DevExpress.data.ArrayStore = __webpack_require__( /*! ../../data/array_store */ 58);
            DevExpress.data.CustomStore = __webpack_require__( /*! ../../data/custom_store */ 202);
            DevExpress.data.LocalStore = __webpack_require__( /*! ../../data/local_store */ 271);
            DevExpress.data.base64_encode = __webpack_require__( /*! ../../data/utils */ 28).base64_encode;
            DevExpress.data.Guid = __webpack_require__( /*! ../../core/guid */ 33);
            DevExpress.data.utils = {};
            DevExpress.data.utils.compileGetter = __webpack_require__( /*! ../../core/utils/data */ 16).compileGetter;
            DevExpress.data.utils.compileSetter = __webpack_require__( /*! ../../core/utils/data */ 16).compileSetter;
            DevExpress.EndpointSelector = __webpack_require__( /*! ../../data/endpoint_selector */ 270);
            DevExpress.data.queryImpl = __webpack_require__( /*! ../../data/query */ 34).queryImpl;
            DevExpress.data.queryAdapters = __webpack_require__( /*! ../../data/query_adapters */ 144);
            var dataUtils = __webpack_require__( /*! ../../data/utils */ 28);
            DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
            DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
            DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
            DevExpress.data.utils.aggregators = dataUtils.aggregators;
            DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
            DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
            DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
            DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
            DevExpress.data.utils.toComparable = __webpack_require__( /*! ../../core/utils/data */ 16).toComparable;
            DevExpress.data.utils.multiLevelGroup = __webpack_require__( /*! ../../data/abstract_store */ 50).multiLevelGroup;
            DevExpress.data.utils.arrangeSortingInfo = __webpack_require__( /*! ../../data/abstract_store */ 50).arrangeSortingInfo;
            DevExpress.data.utils.normalizeDataSourceOptions = __webpack_require__( /*! ../../data/data_source/data_source */ 37).normalizeDataSourceOptions
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/client_exporter/file_saver.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../ui/widget/ui.errors */ 20),
                browser = __webpack_require__( /*! ../core/utils/browser */ 22),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                FILE_EXTESIONS = {
                    EXCEL: "xlsx",
                    CSS: "css",
                    PNG: "png",
                    JPEG: "jpeg",
                    GIF: "gif",
                    SVG: "svg",
                    PDF: "pdf"
                };
            var MIME_TYPES = exports.MIME_TYPES = {
                CSS: "text/css",
                EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                PNG: "image/png",
                JPEG: "image/jpeg",
                GIF: "image/gif",
                SVG: "image/svg+xml",
                PDF: "application/pdf"
            };
            exports.fileSaver = {
                _getDataUri: function(format, data) {
                    return "data:" + MIME_TYPES[format] + ";base64," + data
                },
                _linkDownloader: function(fileName, href, callback) {
                    var exportLinkElement = document.createElement("a"),
                        attributes = {
                            download: fileName,
                            href: href
                        };
                    if (commonUtils.isDefined(callback)) {
                        attributes.onclick = callback
                    }
                    document.body.appendChild(exportLinkElement);
                    $(exportLinkElement).css({
                        display: "none"
                    }).text("load").attr(attributes)[0].click();
                    return exportLinkElement
                },
                _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
                    var formAttributes = {
                            method: "post",
                            action: proxyUrl,
                            enctype: "multipart/form-data"
                        },
                        exportForm = $("<form>").css({
                            display: "none"
                        }).attr(formAttributes);
                    if (commonUtils.isDefined(callback)) {
                        exportForm.submit(callback)
                    }
                    exportForm.append('<input type="hidden" name="fileName" value="' + fileName + '" />');
                    exportForm.append('<input type="hidden" name="contentType" value="' + contentType + '" />');
                    exportForm.append('<input type="hidden" name="data" value="' + data + '" />');
                    exportForm.appendTo("body");
                    exportForm.submit();
                    if (exportForm.submit()) {
                        exportForm.remove()
                    }
                    return exportForm
                },
                _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
                    return this._formDownloader(proxyUrl, fileName, MIME_TYPES[format], data, callback)
                },
                _winJSBlobSave: function(blob, fileName, format) {
                    var savePicker = new Windows.Storage.Pickers.FileSavePicker;
                    savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
                    savePicker.fileTypeChoices.insert(MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
                    savePicker.suggestedFileName = fileName;
                    savePicker.pickSaveFileAsync().then(function(file) {
                        if (file) {
                            file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
                                var inputStream = blob.msDetachStream();
                                Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                                    outputStream.flushAsync().done(function() {
                                        inputStream.close();
                                        outputStream.close()
                                    })
                                })
                            })
                        }
                    })
                },
                _saveBlobAs: function(fileName, format, data, linkClick) {
                    this._blobSaved = false;
                    if (commonUtils.isDefined(navigator.msSaveOrOpenBlob)) {
                        navigator.msSaveOrOpenBlob(data, fileName);
                        this._blobSaved = true
                    } else {
                        if (commonUtils.isDefined(window.WinJS)) {
                            this._winJSBlobSave(data, fileName, format);
                            this._blobSaved = true
                        } else {
                            var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                            linkClick = commonUtils.isDefined(linkClick) ? linkClick : function() {
                                var link = $("#dxExportLink");
                                URL.revokeObjectURL(link.attr("href"));
                                link.remove()
                            };
                            if (commonUtils.isDefined(URL)) {
                                return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
                            }
                        }
                    }
                },
                saveAs: function(fileName, format, data, proxyURL, linkClick) {
                    fileName += "." + FILE_EXTESIONS[format];
                    if (commonUtils.isFunction(window.Blob)) {
                        this._saveBlobAs(fileName, format, data)
                    } else {
                        if (commonUtils.isDefined(proxyURL) && !commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
                            this._saveByProxy(proxyURL, fileName, format, data)
                        } else {
                            if (!commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
                                errors.log("E1034")
                            }
                            if (browser.msie && parseInt(browser.version) < 10) {
                                return
                            }
                            this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
                        }
                    }
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/client_exporter/pdf_creator.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var pdfString, $ = __webpack_require__( /*! jquery */ 1),
                imageCreator = __webpack_require__( /*! ./image_creator */ 139).imageCreator,
                browser = __webpack_require__( /*! ../core/utils/browser */ 22),
                _each = $.each,
                DEFAULT_MARGIN_SIZE = {
                    x: 30,
                    y: 20
                },
                objectsCount = 0,
                globalOffset = 0,
                PAGES_POINTER = 1,
                RESOURCES_POINTER = 2,
                MAIN_PAGE_POINTER = 3,
                CONTENT_POINTER = 4,
                IMAGE_POINTER = 5,
                INFO_POINTER = 6,
                ROOT_POINTER = 7;

            function addObject(pdfDoc, pointer, content, stream) {
                pdfDoc.content.push({
                    type: stream ? "stream" : "object",
                    name: pointer + " 0 obj",
                    content: content,
                    stream: stream
                });
                objectsCount++
            }

            function _pxToPt(px) {
                return .75 * px
            }

            function addMainPage(pdfDoc, options) {
                var width = _pxToPt(options.width + 2 * DEFAULT_MARGIN_SIZE.x).toFixed(2),
                    height = _pxToPt(options.height + 2 * DEFAULT_MARGIN_SIZE.y).toFixed(2);
                addObject(pdfDoc, MAIN_PAGE_POINTER, {
                    "/Type": "/Page",
                    "/Parent": PAGES_POINTER + " 0 R",
                    "/Resources": RESOURCES_POINTER + " 0 R",
                    "/MediaBox": "[0 0 " + width + " " + height + "]",
                    "/Contents": CONTENT_POINTER + " 0 R"
                })
            }

            function addContents(pdfDoc, options) {
                var width = _pxToPt(options.width + 2 * DEFAULT_MARGIN_SIZE.x),
                    height = _pxToPt(options.height + 2 * DEFAULT_MARGIN_SIZE.y);
                addObject(pdfDoc, CONTENT_POINTER, {
                    "/Length": 54
                }, "0.20 w\n0 G\nq " + width.toFixed(2) + " 0 0 " + height.toFixed(2) + " 0.00 0.00 cm /I0 Do Q")
            }

            function addPages(pdfDoc) {
                addObject(pdfDoc, PAGES_POINTER, {
                    "/Type": "/Pages",
                    "/Kids": "[" + MAIN_PAGE_POINTER + " 0 R]",
                    "/Count": "1"
                })
            }

            function addInfo(pdfDoc) {
                addObject(pdfDoc, INFO_POINTER, {
                    "/Producer": "DevExtreme",
                    "/CreationDate": exports.pdfCreator.generateCurrentDate()
                })
            }

            function addRoot(pdfDoc) {
                addObject(pdfDoc, ROOT_POINTER, {
                    "/Type": "/Catalog",
                    "/Pages": "1 0 R",
                    "/OpenAction": "[3 0 R /FitH null]",
                    "/PageLayout": "/OneColumn"
                })
            }

            function addResources(pdfDoc) {
                addObject(pdfDoc, RESOURCES_POINTER, {
                    "/ProcSet": "[/PDF /ImageB /ImageC /ImageI]",
                    "/XObject": "<<\n/I0 5 0 R\n>>"
                })
            }

            function addImage(pdfDoc, imageString, options) {
                addObject(pdfDoc, IMAGE_POINTER, {
                    "/Type": "/XObject",
                    "/Subtype": "/Image",
                    "/Width": options.width + 2 * DEFAULT_MARGIN_SIZE.x,
                    "/Height": options.height + 2 * DEFAULT_MARGIN_SIZE.y,
                    "/ColorSpace": "/DeviceRGB",
                    "/BitsPerComponent": 8,
                    "/Filter": "/DCTDecode",
                    "/Length": imageString.length
                }, imageString)
            }

            function generateXREF(pdfDoc) {
                var cr = exports.pdfCreator;
                cr.addLine("xref");
                cr.addLine("0 " + objectsCount);
                cr.addLine("0000000000 65535 f");
                _each(pdfDoc.content, function(_, section) {
                    var i, zeroString = "",
                        offset = section.offset;
                    for (i = String(offset).length; i < 10; i++) {
                        zeroString += "0"
                    }
                    cr.addLine(zeroString + offset + " 00000 n")
                })
            }

            function generateContent(pdfDoc) {
                var cr = exports.pdfCreator;
                _each(pdfDoc.content, function(_, section) {
                    cr.addLine(section.name);
                    cr.addLine("<<");
                    _each(section.content, function(key, value) {
                        cr.addLine(key + " " + value)
                    });
                    cr.addLine(">>");
                    if ("stream" === section.type) {
                        cr.addLine("stream");
                        cr.addLine(section.stream);
                        cr.addLine("endstream")
                    }
                    cr.addLine("endobj");
                    section.offset = globalOffset;
                    globalOffset = pdfString.length
                })
            }

            function generateTrailer(pdfDoc) {
                var cr = exports.pdfCreator;
                cr.addLine("trailer");
                cr.addLine("<<");
                cr.addLine("/Size 8");
                cr.addLine("/Root 7 0 R");
                cr.addLine("/Info 6 0 R");
                cr.addLine(">>");
                cr.addLine("startxref");
                cr.addLine(pdfString.length)
            }
            exports.pdfCreator = {
                createPdfDoc: function(imageString, options) {
                    var pdfDoc = {
                        content: []
                    };
                    addMainPage(pdfDoc, options);
                    addContents(pdfDoc, options);
                    addPages(pdfDoc);
                    addImage(pdfDoc, imageString, options);
                    addResources(pdfDoc);
                    addInfo(pdfDoc);
                    addRoot(pdfDoc);
                    return pdfDoc
                },
                addLine: function(line) {
                    pdfString += line + "\n"
                },
                closeLine: function() {
                    pdfString += "%%EOF"
                },
                generateCurrentDate: function() {
                    return new Date
                },
                generatePdfString: function(pdfDoc) {
                    exports.pdfCreator.addLine("%PDF-1.3");
                    globalOffset += pdfString.length;
                    generateContent(pdfDoc);
                    generateXREF(pdfDoc);
                    generateTrailer(pdfDoc);
                    exports.pdfCreator.closeLine();
                    return pdfString
                },
                getBlob: function(data, options, isFullMode) {
                    pdfString = "";
                    globalOffset = 0;
                    objectsCount = 1;
                    var imageData = imageCreator.getImageData(data, $.extend({}, options, {
                            format: "jpeg"
                        }), isFullMode),
                        blob = $.Deferred();
                    $.when(imageData).done(function(imageString) {
                        var arrayBuffer, blobData, pdfDoc = exports.pdfCreator.createPdfDoc(imageString, options),
                            i = 0;
                        exports.pdfCreator.generatePdfString(pdfDoc);
                        arrayBuffer = new ArrayBuffer(pdfString.length);
                        blobData = new Uint8Array(arrayBuffer);
                        for (i; i < blobData.length; i++) {
                            blobData[i] = pdfString.charCodeAt(i)
                        }
                        blob.resolve(new Blob([arrayBuffer], {
                            type: "application/pdf"
                        }))
                    });
                    return blob
                }
            };
            exports.getBlob = function(data, options, callback) {
                exports.pdfCreator.getBlob(data, options, browser.msie).done(callback)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/client_exporter/svg_creator.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            exports.svgCreator = {
                _markup: "",
                _imageArray: {},
                _imageDeferreds: [],
                _getBinaryFile: function(src, callback) {
                    var xhr = new XMLHttpRequest;
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === xhr.DONE) {
                            if (200 === xhr.status && xhr.response) {
                                callback(xhr.response)
                            } else {
                                callback(false)
                            }
                        }
                    };
                    xhr.open("GET", src, true);
                    xhr.responseType = "arraybuffer";
                    xhr.send()
                },
                _loadImages: function() {
                    var that = this;
                    $.each(that._imageArray, function(src) {
                        var deferred = new $.Deferred;
                        that._imageDeferreds.push(deferred);
                        that._getBinaryFile(src, function(response) {
                            if (!response) {
                                delete that._imageArray[src];
                                deferred.resolve();
                                return
                            }
                            var i, binary = "",
                                bytes = new Uint8Array(response),
                                length = bytes.byteLength;
                            for (i = 0; i < length; i++) {
                                binary += String.fromCharCode(bytes[i])
                            }
                            that._imageArray[src] = "data:image/png;base64," + btoa(binary);
                            deferred.resolve()
                        })
                    })
                },
                _parseImages: function(element) {
                    var href, that = this;
                    if ("image" === element.tagName) {
                        href = $(element).attr("xlink:href");
                        if (!that._imageArray[href]) {
                            that._imageArray[href] = ""
                        }
                    }
                    $.each(element.childNodes, function(_, element) {
                        that._parseImages(element)
                    })
                },
                _prepareImages: function(svgElem) {
                    this._parseImages(svgElem);
                    this._loadImages();
                    return $.when.apply($, this._imageDeferreds)
                },
                getBlob: function(data, options) {
                    var markup, that = this,
                        xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>',
                        blob = $.Deferred(),
                        parser = new DOMParser,
                        elem = parser.parseFromString(data, "image/svg+xml"),
                        svgElem = elem.childNodes[0],
                        $svgObject = $(svgElem);
                    $svgObject.css("background-color", options.backgroundColor);
                    markup = xmlVersion + $("<html />").append($svgObject[0]).html();
                    that._prepareImages(svgElem).done(function() {
                        $.each(that._imageArray, function(href, dataURI) {
                            markup = markup.split(href).join(dataURI)
                        });
                        blob.resolve(that._svgBlob(markup))
                    });
                    return blob
                },
                _svgBlob: function(markup) {
                    return new Blob([markup], {
                        type: "image/svg+xml"
                    })
                }
            };
            exports.getBlob = function(data, options, callback) {
                exports.svgCreator.getBlob(data, options).done(callback)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/core/utils/locker.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errors = __webpack_require__( /*! ../errors */ 10);
            var Locker = function() {
                var info = {};
                var currentCount = function(lockName) {
                    return info[lockName] || 0
                };
                return {
                    obtain: function(lockName) {
                        info[lockName] = currentCount(lockName) + 1
                    },
                    release: function(lockName) {
                        var count = currentCount(lockName);
                        if (count < 1) {
                            throw errors.Error("E0014")
                        }
                        if (1 === count) {
                            delete info[lockName]
                        } else {
                            info[lockName] = count - 1
                        }
                    },
                    locked: function(lockName) {
                        return currentCount(lockName) > 0
                    }
                }
            };
            module.exports = Locker
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/array_query.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                compileGetter = __webpack_require__( /*! ../core/utils/data */ 16).compileGetter,
                toComparable = __webpack_require__( /*! ../core/utils/data */ 16).toComparable,
                errorsModule = __webpack_require__( /*! ./errors */ 25),
                dataUtils = __webpack_require__( /*! ./utils */ 28);
            var Iterator = Class.inherit({
                toArray: function() {
                    var result = [];
                    this.reset();
                    while (this.next()) {
                        result.push(this.current())
                    }
                    return result
                },
                countable: function() {
                    return false
                }
            });
            var ArrayIterator = Iterator.inherit({
                ctor: function(array) {
                    this.array = array;
                    this.index = -1
                },
                next: function() {
                    if (this.index + 1 < this.array.length) {
                        this.index++;
                        return true
                    }
                    return false
                },
                current: function() {
                    return this.array[this.index]
                },
                reset: function() {
                    this.index = -1
                },
                toArray: function() {
                    return this.array.slice(0)
                },
                countable: function() {
                    return true
                },
                count: function() {
                    return this.array.length
                }
            });
            var WrappedIterator = Iterator.inherit({
                ctor: function(iter) {
                    this.iter = iter
                },
                next: function() {
                    return this.iter.next()
                },
                current: function() {
                    return this.iter.current()
                },
                reset: function() {
                    return this.iter.reset()
                }
            });
            var MapIterator = WrappedIterator.inherit({
                ctor: function(iter, mapper) {
                    this.callBase(iter);
                    this.index = -1;
                    this.mapper = mapper
                },
                current: function() {
                    return this.mapper(this.callBase(), this.index)
                },
                next: function() {
                    var hasNext = this.callBase();
                    if (hasNext) {
                        this.index++
                    }
                    return hasNext
                }
            });
            var SortIterator = Iterator.inherit({
                ctor: function(iter, getter, desc) {
                    if (!(iter instanceof MapIterator)) {
                        iter = new MapIterator(iter, this._wrap)
                    }
                    this.iter = iter;
                    this.rules = [{
                        getter: getter,
                        desc: desc
                    }]
                },
                thenBy: function(getter, desc) {
                    var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
                    if (!this.sortedIter) {
                        result.rules = this.rules.concat(result.rules)
                    }
                    return result
                },
                next: function() {
                    this._ensureSorted();
                    return this.sortedIter.next()
                },
                current: function() {
                    this._ensureSorted();
                    return this.sortedIter.current()
                },
                reset: function() {
                    delete this.sortedIter
                },
                countable: function() {
                    return this.sortedIter || this.iter.countable()
                },
                count: function() {
                    if (this.sortedIter) {
                        return this.sortedIter.count()
                    }
                    return this.iter.count()
                },
                _ensureSorted: function() {
                    var that = this;
                    if (that.sortedIter) {
                        return
                    }
                    $.each(that.rules, function() {
                        this.getter = compileGetter(this.getter)
                    });
                    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
                        return that._compare(x, y)
                    })), that._unwrap)
                },
                _wrap: function(record, index) {
                    return {
                        index: index,
                        value: record
                    }
                },
                _unwrap: function(wrappedItem) {
                    return wrappedItem.value
                },
                _compare: function(x, y) {
                    var xIndex = x.index,
                        yIndex = y.index;
                    x = x.value;
                    y = y.value;
                    if (x === y) {
                        return xIndex - yIndex
                    }
                    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                        var rule = this.rules[i],
                            xValue = toComparable(rule.getter(x)),
                            yValue = toComparable(rule.getter(y)),
                            factor = rule.desc ? -1 : 1;
                        if (null === xValue && null !== yValue) {
                            return -factor
                        }
                        if (null !== xValue && null === yValue) {
                            return factor
                        }
                        if (void 0 === xValue && void 0 !== yValue) {
                            return factor
                        }
                        if (void 0 !== xValue && void 0 === yValue) {
                            return -factor
                        }
                        if (xValue < yValue) {
                            return -factor
                        }
                        if (xValue > yValue) {
                            return factor
                        }
                    }
                    return xIndex - yIndex
                }
            });
            var compileCriteria = function() {
                var compileGroup = function(crit) {
                    var groupOperator, nextGroupOperator, idx = 0,
                        bag = [],
                        ops = [];
                    $.each(crit, function() {
                        if ($.isArray(this) || $.isFunction(this)) {
                            if (bag.length > 1 && groupOperator !== nextGroupOperator) {
                                throw new errorsModule.errors.Error("E4019")
                            }
                            ops.push(compileCriteria(this));
                            bag.push("op[" + idx + "](d)");
                            idx++;
                            groupOperator = nextGroupOperator;
                            nextGroupOperator = "&&"
                        } else {
                            nextGroupOperator = dataUtils.isConjunctiveOperator(this) ? "&&" : "||"
                        }
                    });
                    return new Function("op", "return function(d) { return " + bag.join(" " + groupOperator + " ") + " }")(ops)
                };
                var toString = function(value) {
                    return commonUtils.isDefined(value) ? value.toString() : ""
                };
                var compileBinary = function(crit) {
                    crit = dataUtils.normalizeBinaryCriterion(crit);
                    var getter = compileGetter(crit[0]),
                        op = crit[1],
                        value = crit[2];
                    value = toComparable(value);
                    switch (op.toLowerCase()) {
                        case "=":
                            return compileEquals(getter, value);
                        case "<>":
                            return compileEquals(getter, value, true);
                        case ">":
                            return function(obj) {
                                return toComparable(getter(obj)) > value
                            };
                        case "<":
                            return function(obj) {
                                return toComparable(getter(obj)) < value
                            };
                        case ">=":
                            return function(obj) {
                                return toComparable(getter(obj)) >= value
                            };
                        case "<=":
                            return function(obj) {
                                return toComparable(getter(obj)) <= value
                            };
                        case "startswith":
                            return function(obj) {
                                return 0 === toComparable(toString(getter(obj))).indexOf(value)
                            };
                        case "endswith":
                            return function(obj) {
                                var getterValue = toComparable(toString(getter(obj))),
                                    searchValue = toString(value);
                                if (getterValue.length < searchValue.length) {
                                    return false
                                }
                                return getterValue.lastIndexOf(value) === getterValue.length - value.length
                            };
                        case "contains":
                            return function(obj) {
                                return toComparable(toString(getter(obj))).indexOf(value) > -1
                            };
                        case "notcontains":
                            return function(obj) {
                                return -1 === toComparable(toString(getter(obj))).indexOf(value)
                            }
                    }
                    throw errorsModule.errors.Error("E4003", op)
                };

                function compileEquals(getter, value, negate) {
                    return function(obj) {
                        obj = toComparable(getter(obj));
                        var result = useStrictComparison(value) ? obj === value : obj == value;
                        if (negate) {
                            result = !result
                        }
                        return result
                    }
                }

                function useStrictComparison(value) {
                    return "" === value || 0 === value || false === value
                }
                return function(crit) {
                    if ($.isFunction(crit)) {
                        return crit
                    }
                    if ($.isArray(crit[0])) {
                        return compileGroup(crit)
                    }
                    return compileBinary(crit)
                }
            }();
            var FilterIterator = WrappedIterator.inherit({
                ctor: function(iter, criteria) {
                    this.callBase(iter);
                    this.criteria = compileCriteria(criteria)
                },
                next: function() {
                    while (this.iter.next()) {
                        if (this.criteria(this.current())) {
                            return true
                        }
                    }
                    return false
                }
            });
            var GroupIterator = Iterator.inherit({
                ctor: function(iter, getter) {
                    this.iter = iter;
                    this.getter = getter
                },
                next: function() {
                    this._ensureGrouped();
                    return this.groupedIter.next()
                },
                current: function() {
                    this._ensureGrouped();
                    return this.groupedIter.current()
                },
                reset: function() {
                    delete this.groupedIter
                },
                countable: function() {
                    return !!this.groupedIter
                },
                count: function() {
                    return this.groupedIter.count()
                },
                _ensureGrouped: function() {
                    if (this.groupedIter) {
                        return
                    }
                    var hash = {},
                        keys = [],
                        iter = this.iter,
                        getter = compileGetter(this.getter);
                    iter.reset();
                    while (iter.next()) {
                        var current = iter.current(),
                            key = getter(current);
                        if (key in hash) {
                            hash[key].push(current)
                        } else {
                            hash[key] = [current];
                            keys.push(key)
                        }
                    }
                    this.groupedIter = new ArrayIterator($.map(keys, function(key) {
                        return {
                            key: key,
                            items: hash[key]
                        }
                    }))
                }
            });
            var SelectIterator = WrappedIterator.inherit({
                ctor: function(iter, getter) {
                    this.callBase(iter);
                    this.getter = compileGetter(getter)
                },
                current: function() {
                    return this.getter(this.callBase())
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return this.iter.count()
                }
            });
            var SliceIterator = WrappedIterator.inherit({
                ctor: function(iter, skip, take) {
                    this.callBase(iter);
                    this.skip = Math.max(0, skip);
                    this.take = Math.max(0, take);
                    this.pos = 0
                },
                next: function() {
                    if (this.pos >= this.skip + this.take) {
                        return false
                    }
                    while (this.pos < this.skip && this.iter.next()) {
                        this.pos++
                    }
                    this.pos++;
                    return this.iter.next()
                },
                reset: function() {
                    this.callBase();
                    this.pos = 0
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return Math.min(this.iter.count() - this.skip, this.take)
                }
            });
            var arrayQueryImpl = function(iter, queryOptions) {
                queryOptions = queryOptions || {};
                if (!(iter instanceof Iterator)) {
                    iter = new ArrayIterator(iter)
                }
                var handleError = function(error) {
                    var handler = queryOptions.errorHandler;
                    if (handler) {
                        handler(error)
                    }
                    errorsModule._errorHandler(error)
                };
                var aggregateCore = function(aggregator) {
                    var seed, d = $.Deferred().fail(handleError),
                        step = aggregator.step,
                        finalize = aggregator.finalize;
                    try {
                        iter.reset();
                        if ("seed" in aggregator) {
                            seed = aggregator.seed
                        } else {
                            seed = iter.next() ? iter.current() : NaN
                        }
                        var accumulator = seed;
                        while (iter.next()) {
                            accumulator = step(accumulator, iter.current())
                        }
                        d.resolve(finalize ? finalize(accumulator) : accumulator)
                    } catch (x) {
                        d.reject(x)
                    }
                    return d.promise()
                };
                var aggregate = function(seed, step, finalize) {
                    if (arguments.length < 2) {
                        return aggregateCore({
                            step: arguments[0]
                        })
                    }
                    return aggregateCore({
                        seed: seed,
                        step: step,
                        finalize: finalize
                    })
                };
                var standardAggregate = function(name) {
                    return aggregateCore(dataUtils.aggregators[name])
                };
                var select = function(getter) {
                    if (!$.isFunction(getter) && !$.isArray(getter)) {
                        getter = $.makeArray(arguments)
                    }
                    return chainQuery(new SelectIterator(iter, getter))
                };
                var selectProp = function(name) {
                    return select(compileGetter(name))
                };
                var chainQuery = function(iter) {
                    return arrayQueryImpl(iter, queryOptions)
                };
                return {
                    toArray: function() {
                        return iter.toArray()
                    },
                    enumerate: function() {
                        var d = $.Deferred().fail(handleError);
                        try {
                            d.resolve(iter.toArray())
                        } catch (x) {
                            d.reject(x)
                        }
                        return d.promise()
                    },
                    sortBy: function(getter, desc) {
                        return chainQuery(new SortIterator(iter, getter, desc))
                    },
                    thenBy: function(getter, desc) {
                        if (iter instanceof SortIterator) {
                            return chainQuery(iter.thenBy(getter, desc))
                        }
                        throw errorsModule.errors.Error("E4004")
                    },
                    filter: function(criteria) {
                        if (!$.isArray(criteria)) {
                            criteria = $.makeArray(arguments)
                        }
                        return chainQuery(new FilterIterator(iter, criteria))
                    },
                    slice: function(skip, take) {
                        if (void 0 === take) {
                            take = Number.MAX_VALUE
                        }
                        return chainQuery(new SliceIterator(iter, skip, take))
                    },
                    select: select,
                    groupBy: function(getter) {
                        return chainQuery(new GroupIterator(iter, getter))
                    },
                    aggregate: aggregate,
                    count: function() {
                        if (iter.countable()) {
                            var d = $.Deferred().fail(handleError);
                            try {
                                d.resolve(iter.count())
                            } catch (x) {
                                d.reject(x)
                            }
                            return d.promise()
                        }
                        return standardAggregate("count")
                    },
                    sum: function(getter) {
                        if (getter) {
                            return selectProp(getter).sum()
                        }
                        return standardAggregate("sum")
                    },
                    min: function(getter) {
                        if (getter) {
                            return selectProp(getter).min()
                        }
                        return standardAggregate("min")
                    },
                    max: function(getter) {
                        if (getter) {
                            return selectProp(getter).max()
                        }
                        return standardAggregate("max")
                    },
                    avg: function(getter) {
                        if (getter) {
                            return selectProp(getter).avg()
                        }
                        return standardAggregate("avg")
                    }
                }
            };
            module.exports = arrayQueryImpl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/data/custom_store.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dataUtils = __webpack_require__( /*! ./utils */ 28),
                errors = __webpack_require__( /*! ./errors */ 25).errors,
                Store = __webpack_require__( /*! ./abstract_store */ 50);
            var TOTAL_COUNT = "totalCount",
                LOAD = "load",
                BY_KEY = "byKey",
                INSERT = "insert",
                UPDATE = "update",
                REMOVE = "remove";

            function isPromise(obj) {
                return obj && $.isFunction(obj.then)
            }

            function trivialPromise(value) {
                return $.Deferred().resolve(value).promise()
            }

            function ensureRequiredFuncOption(name, obj) {
                if (!$.isFunction(obj)) {
                    throw errors.Error("E4011", name)
                }
            }

            function throwInvalidUserFuncResult(name) {
                throw errors.Error("E4012", name)
            }

            function createUserFuncFailureHandler(pendingDeferred) {
                function errorMessageFromXhr(promiseArguments) {
                    var xhr = promiseArguments[0],
                        textStatus = promiseArguments[1];
                    if (!xhr || !xhr.getResponseHeader) {
                        return null
                    }
                    return dataUtils.errorMessageFromXhr(xhr, textStatus)
                }
                return function(arg) {
                    var error;
                    if (arg instanceof Error) {
                        error = arg
                    } else {
                        error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error")
                    }
                    pendingDeferred.reject(error)
                }
            }
            var CustomStore = Store.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.callBase(options);
                    this._useDefaultSearch = !!options.useDefaultSearch;
                    this._loadFunc = options[LOAD];
                    this._totalCountFunc = options[TOTAL_COUNT];
                    this._byKeyFunc = options[BY_KEY];
                    this._insertFunc = options[INSERT];
                    this._updateFunc = options[UPDATE];
                    this._removeFunc = options[REMOVE]
                },
                createQuery: function() {
                    throw errors.Error("E4010")
                },
                _totalCountImpl: function(options) {
                    var userResult, userFunc = this._totalCountFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(TOTAL_COUNT, userFunc);
                    userResult = userFunc.apply(this, [options]);
                    if (!isPromise(userResult)) {
                        userResult = Number(userResult);
                        if (!isFinite(userResult)) {
                            throwInvalidUserFuncResult(TOTAL_COUNT)
                        }
                        userResult = trivialPromise(userResult)
                    }
                    userResult.then(function(count) {
                        d.resolve(Number(count))
                    }, createUserFuncFailureHandler(d));
                    return this._addFailHandlers(d.promise())
                },
                _loadImpl: function(options) {
                    var userResult, userFunc = this._loadFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(LOAD, userFunc);
                    userResult = userFunc.apply(this, [options]);
                    if ($.isArray(userResult)) {
                        userResult = trivialPromise(userResult)
                    } else {
                        if (null === userResult || void 0 === userResult) {
                            userResult = trivialPromise([])
                        } else {
                            if (!isPromise(userResult)) {
                                throwInvalidUserFuncResult(LOAD)
                            }
                        }
                    }
                    userResult.then(function(data, extra) {
                        d.resolve(data, extra)
                    }, createUserFuncFailureHandler(d));
                    return this._addFailHandlers(d.promise())
                },
                _byKeyImpl: function(key, extraOptions) {
                    var userResult, userFunc = this._byKeyFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(BY_KEY, userFunc);
                    userResult = userFunc.apply(this, [key, extraOptions]);
                    if (!isPromise(userResult)) {
                        userResult = trivialPromise(userResult)
                    }
                    userResult.then(function(obj) {
                        d.resolve(obj)
                    }, createUserFuncFailureHandler(d));
                    return d.promise()
                },
                _insertImpl: function(values) {
                    var userResult, userFunc = this._insertFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(INSERT, userFunc);
                    userResult = userFunc.apply(this, [values]);
                    if (!isPromise(userResult)) {
                        userResult = trivialPromise(userResult)
                    }
                    userResult.then(function(newKey) {
                        d.resolve(values, newKey)
                    }, createUserFuncFailureHandler(d));
                    return d.promise()
                },
                _updateImpl: function(key, values) {
                    var userResult, userFunc = this._updateFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(UPDATE, userFunc);
                    userResult = userFunc.apply(this, [key, values]);
                    if (!isPromise(userResult)) {
                        userResult = trivialPromise()
                    }
                    userResult.then(function() {
                        d.resolve(key, values)
                    }, createUserFuncFailureHandler(d));
                    return d.promise()
                },
                _removeImpl: function(key) {
                    var userResult, userFunc = this._removeFunc,
                        d = $.Deferred();
                    ensureRequiredFuncOption(REMOVE, userFunc);
                    userResult = userFunc.apply(this, [key]);
                    if (!isPromise(userResult)) {
                        userResult = trivialPromise()
                    }
                    userResult.then(function() {
                        d.resolve(key)
                    }, createUserFuncFailureHandler(d));
                    return d.promise()
                }
            });
            module.exports = CustomStore
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/data/odata/mixins.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                stringUtils = __webpack_require__( /*! ../../core/utils/string */ 26),
                odataUtils = __webpack_require__( /*! ./utils */ 71);
            __webpack_require__( /*! ./query_adapter */ 112);
            var DEFAULT_PROTOCOL_VERSION = 2;
            var formatFunctionInvocationUrl = function(baseUrl, args) {
                return stringUtils.format("{0}({1})", baseUrl, $.map(args || {}, function(value, key) {
                    return stringUtils.format("{0}={1}", key, value)
                }).join(","))
            };
            var escapeServiceOperationParams = function(params, version) {
                if (!params) {
                    return params
                }
                var result = {};
                $.each(params, function(k, v) {
                    result[k] = odataUtils.serializeValue(v, version)
                });
                return result
            };
            var SharedMethods = {
                _extractServiceOptions: function(options) {
                    options = options || {};
                    this._url = String(options.url).replace(/\/+$/, "");
                    this._beforeSend = options.beforeSend;
                    this._jsonp = options.jsonp;
                    this._version = options.version || DEFAULT_PROTOCOL_VERSION;
                    this._withCredentials = options.withCredentials;
                    this._deserializeDates = options.deserializeDates
                },
                _sendRequest: function(url, method, params, payload) {
                    return odataUtils.sendRequest(this.version(), {
                        url: url,
                        method: method,
                        params: params || {},
                        payload: payload
                    }, {
                        beforeSend: this._beforeSend,
                        jsonp: this._jsonp,
                        withCredentials: this._withCredentials
                    }, this._deserializeDates)
                },
                version: function() {
                    return this._version
                }
            };
            exports.SharedMethods = SharedMethods;
            exports.escapeServiceOperationParams = escapeServiceOperationParams;
            exports.formatFunctionInvocationUrl = formatFunctionInvocationUrl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/odata/store.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                odataUtils = __webpack_require__( /*! ./utils */ 71),
                proxyUrlFormatter = __webpack_require__( /*! ../proxy_url_formatter */ 205),
                errorsModule = __webpack_require__( /*! ../errors */ 25),
                query = __webpack_require__( /*! ../query */ 34),
                Store = __webpack_require__( /*! ../abstract_store */ 50),
                mixins = __webpack_require__( /*! ./mixins */ 203);
            __webpack_require__( /*! ./query_adapter */ 112);
            var convertSimpleKey = function(keyType, keyValue) {
                var converter = odataUtils.keyConverters[keyType];
                if (!converter) {
                    throw errorsModule.errors.Error("E4014", keyType)
                }
                return converter(keyValue)
            };
            var ODataStore = Store.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this._extractServiceOptions(options);
                    this._keyType = options.keyType;
                    if (2 === this.version()) {
                        this._updateMethod = "MERGE"
                    } else {
                        this._updateMethod = "PATCH"
                    }
                },
                _customLoadOptions: function() {
                    return ["expand", "customQueryParams"]
                },
                _byKeyImpl: function(key, extraOptions) {
                    var params = {};
                    if (extraOptions) {
                        if (extraOptions.expand) {
                            params.$expand = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join()
                        }
                    }
                    return this._sendRequest(this._byKeyUrl(key), "GET", params)
                },
                createQuery: function(loadOptions) {
                    var url, queryOptions;
                    loadOptions = loadOptions || {};
                    queryOptions = {
                        adapter: "odata",
                        beforeSend: this._beforeSend,
                        errorHandler: this._errorHandler,
                        jsonp: this._jsonp,
                        version: this._version,
                        withCredentials: this._withCredentials,
                        deserializeDates: this._deserializeDates,
                        expand: loadOptions.expand,
                        requireTotalCount: loadOptions.requireTotalCount
                    };
                    if (commonUtils.isDefined(loadOptions.urlOverride)) {
                        url = loadOptions.urlOverride
                    } else {
                        url = this._url
                    }
                    if ("customQueryParams" in loadOptions) {
                        var params = mixins.escapeServiceOperationParams(loadOptions.customQueryParams, this.version());
                        if (4 === this.version()) {
                            url = mixins.formatFunctionInvocationUrl(url, params)
                        } else {
                            queryOptions.params = params
                        }
                    }
                    return query(url, queryOptions)
                },
                _insertImpl: function(values) {
                    this._requireKey();
                    var that = this,
                        d = $.Deferred();
                    $.when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
                        d.resolve(values, that.keyOf(serverResponse))
                    }).fail(d.reject);
                    return d.promise()
                },
                _updateImpl: function(key, values) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function() {
                        d.resolve(key, values)
                    }).fail(d.reject);
                    return d.promise()
                },
                _removeImpl: function(key) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                        d.resolve(key)
                    }).fail(d.reject);
                    return d.promise()
                },
                _byKeyUrl: function(key, useOriginalHost) {
                    var keyObj = key,
                        keyType = this._keyType,
                        baseUrl = useOriginalHost ? proxyUrlFormatter.formatLocalUrl(this._url) : this._url;
                    if ($.isPlainObject(keyType)) {
                        keyObj = {};
                        $.each(keyType, function(subKeyName, subKeyType) {
                            keyObj[subKeyName] = convertSimpleKey(subKeyType, key[subKeyName])
                        })
                    } else {
                        if (keyType) {
                            keyObj = convertSimpleKey(keyType, key)
                        }
                    }
                    return baseUrl + "(" + encodeURIComponent(odataUtils.serializeKey(keyObj, this._version)) + ")"
                }
            }, "odata").include(mixins.SharedMethods);
            module.exports = ODataStore
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/data/proxy_url_formatter.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                location = window.location,
                DXPROXY_HOST = "dxproxy.devexpress.com:8000",
                IS_DXPROXY_ORIGIN = location.host === DXPROXY_HOST,
                urlMapping = {};
            var parseUrl = function() {
                var a = document.createElement("a"),
                    props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
                var normalizePath = function(value) {
                    if ("/" !== value.charAt(0)) {
                        value = "/" + value
                    }
                    return value
                };
                return function(url) {
                    a.href = url;
                    var result = {};
                    $.each(props, function() {
                        result[this] = a[this]
                    });
                    result.pathname = normalizePath(result.pathname);
                    return result
                }
            }();
            var extractProxyAppId = function() {
                return location.pathname.split("/")[1]
            };
            module.exports = {
                parseUrl: parseUrl,
                isProxyUsed: function() {
                    return IS_DXPROXY_ORIGIN
                },
                formatProxyUrl: function(localUrl) {
                    var urlData = parseUrl(localUrl);
                    if (!/^(localhost$|127\.)/i.test(urlData.hostname)) {
                        return localUrl
                    }
                    var proxyUrlPart = DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port;
                    urlMapping[proxyUrlPart] = urlData.hostname + ":" + urlData.port;
                    var resultUrl = "http://" + proxyUrlPart + urlData.pathname + urlData.search;
                    return resultUrl
                },
                formatLocalUrl: function(proxyUrl) {
                    if (proxyUrl.indexOf(DXPROXY_HOST) < 0) {
                        return proxyUrl
                    }
                    var resultUrl = proxyUrl;
                    for (var proxyUrlPart in urlMapping) {
                        if (urlMapping.hasOwnProperty(proxyUrlPart)) {
                            if (proxyUrl.indexOf(proxyUrlPart) >= 0) {
                                resultUrl = proxyUrl.replace(proxyUrlPart, urlMapping[proxyUrlPart]);
                                break
                            }
                        }
                    }
                    return resultUrl
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/events/pointer/mouse.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseStrategy = __webpack_require__( /*! ./base */ 113),
                Observer = __webpack_require__( /*! ./observer */ 207);
            var eventMap = {
                dxpointerdown: "mousedown",
                dxpointermove: "mousemove",
                dxpointerup: "mouseup",
                dxpointercancel: "",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
            var normalizeMouseEvent = function(e) {
                e.pointerId = 1;
                return {
                    pointers: observer.pointers(),
                    pointerId: 1
                }
            };
            var observer;
            var activated = false;
            var activateStrategy = function() {
                if (activated) {
                    return
                }
                observer = new Observer(eventMap, function(a, b) {
                    return true
                });
                activated = true
            };
            var MouseStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend(normalizeMouseEvent(args.originalEvent), args))
                }
            });
            MouseStrategy.map = eventMap;
            MouseStrategy.normalize = normalizeMouseEvent;
            MouseStrategy.activate = activateStrategy;
            MouseStrategy.resetObserver = function() {
                observer.reset()
            };
            module.exports = MouseStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/events/pointer/observer.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var addEventsListener = function(events, handler) {
                events = events.split(" ");
                $.each(events, function(_, event) {
                    if (document.addEventListener) {
                        document.addEventListener(event, handler, true)
                    } else {
                        document.attachEvent("on" + event, handler)
                    }
                })
            };
            var Observer = function(eventMap, pointerEquals, onPointerAdding) {
                onPointerAdding = onPointerAdding || function() {};
                var pointers = [];
                var getPointerIndex = function(e) {
                    var index = -1;
                    $.each(pointers, function(i, pointer) {
                        if (!pointerEquals(e, pointer)) {
                            return true
                        }
                        index = i;
                        return false
                    });
                    return index
                };
                var addPointer = function(e) {
                    if (-1 === getPointerIndex(e)) {
                        onPointerAdding(e);
                        pointers.push(e)
                    }
                };
                var removePointer = function(e) {
                    var index = getPointerIndex(e);
                    if (index > -1) {
                        pointers.splice(index, 1)
                    }
                };
                var updatePointer = function(e) {
                    pointers[getPointerIndex(e)] = e
                };
                addEventsListener(eventMap.dxpointerdown, addPointer);
                addEventsListener(eventMap.dxpointermove, updatePointer);
                addEventsListener(eventMap.dxpointerup, removePointer);
                addEventsListener(eventMap.dxpointercancel, removePointer);
                this.pointers = function() {
                    return pointers
                };
                this.reset = function() {
                    pointers = []
                }
            };
            module.exports = Observer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/events/pointer/touch.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                BaseStrategy = __webpack_require__( /*! ./base */ 113);
            __webpack_require__( /*! ./touch_hooks */ 277);
            var eventMap = {
                dxpointerdown: "touchstart",
                dxpointermove: "touchmove",
                dxpointerup: "touchend",
                dxpointercancel: "touchcancel",
                dxpointerover: "",
                dxpointerout: "",
                dxpointerenter: "",
                dxpointerleave: ""
            };
            var normalizeTouchEvent = function(e) {
                var pointers = [];
                $.each(e.touches, function(_, touch) {
                    pointers.push($.extend({
                        pointerId: touch.identifier
                    }, touch))
                });
                return {
                    pointers: pointers,
                    pointerId: e.changedTouches[0].identifier
                }
            };
            var skipTouchWithSameIdentifier = function(pointerEvent) {
                return "ios" === devices.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent)
            };
            var TouchStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._pointerId = 0
                },
                _handler: function(e) {
                    if (skipTouchWithSameIdentifier(this._eventName)) {
                        var touch = e.changedTouches[0];
                        if (this._pointerId === touch.identifier && 0 !== this._pointerId) {
                            return
                        }
                        this._pointerId = touch.identifier
                    }
                    return this.callBase.apply(this, arguments)
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend(normalizeTouchEvent(args.originalEvent), args))
                }
            });
            TouchStrategy.map = eventMap;
            TouchStrategy.normalize = normalizeTouchEvent;
            module.exports = TouchStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/framework/action_executors.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dataCoreUtils = __webpack_require__( /*! ../core/utils/data */ 16),
                Route = __webpack_require__( /*! ./router */ 116).Route;

            function prepareNavigateOptions(options, actionArguments) {
                if (actionArguments.args) {
                    var sourceEventArguments = actionArguments.args[0];
                    options.jQueryEvent = sourceEventArguments.jQueryEvent
                }
                if ("dxCommand" === (actionArguments.component || {}).NAME) {
                    $.extend(options, actionArguments.component.option())
                }
            }

            function preventDefaultLinkBehaviour(e) {
                if (!e) {
                    return
                }
                var $targetElement = $(e.target);
                if ($targetElement.attr("href")) {
                    e.preventDefault()
                }
            }
            var createActionExecutors = function(app) {
                return {
                    routing: {
                        execute: function(e) {
                            var routeValues, uri, action = e.action,
                                options = {};
                            if ($.isPlainObject(action)) {
                                routeValues = action.routeValues;
                                if (routeValues && $.isPlainObject(routeValues)) {
                                    options = action.options
                                } else {
                                    routeValues = action
                                }
                                uri = app.router.format(routeValues);
                                prepareNavigateOptions(options, e);
                                preventDefaultLinkBehaviour(options.jQueryEvent);
                                app.navigate(uri, options);
                                e.handled = true
                            }
                        }
                    },
                    hash: {
                        execute: function(e) {
                            if ("string" !== typeof e.action || "#" !== e.action.charAt(0)) {
                                return
                            }
                            var uriTemplate = e.action.substr(1),
                                args = e.args[0],
                                uri = uriTemplate;
                            var defaultEvaluate = function(expr) {
                                var getter = dataCoreUtils.compileGetter(expr),
                                    model = e.args[0].model;
                                return getter(model)
                            };
                            var evaluate = args.evaluate || defaultEvaluate;
                            uri = uriTemplate.replace(/\{([^}]+)\}/g, function(entry, expr) {
                                expr = $.trim(expr);
                                if (expr.indexOf(",") > -1) {
                                    expr = $.map(expr.split(","), $.trim)
                                }
                                var value = evaluate(expr);
                                if (void 0 === value) {
                                    value = ""
                                }
                                value = Route.prototype.formatSegment(value);
                                return value
                            });
                            var options = {};
                            prepareNavigateOptions(options, e);
                            preventDefaultLinkBehaviour(options.jQueryEvent);
                            app.navigate(uri, options);
                            e.handled = true
                        }
                    },
                    url: {
                        execute: function(e) {
                            if ("string" === typeof e.action && "#" !== e.action.charAt(0)) {
                                document.location = e.action
                            }
                        }
                    }
                }
            };
            exports.createActionExecutors = createActionExecutors
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/framework/application.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BACK_COMMAND_TITLE, $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                abstract = Class.abstract,
                Action = __webpack_require__( /*! ../core/action */ 54),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                mergeCommands = __webpack_require__( /*! ./utils */ 84).utils.mergeCommands,
                createActionExecutors = __webpack_require__( /*! ./action_executors */ 209).createActionExecutors,
                Router = __webpack_require__( /*! ./router */ 116),
                NavigationManager = __webpack_require__( /*! ./navigation_manager */ 83),
                StateManager = __webpack_require__( /*! ./state_manager */ 150),
                dxCommand = __webpack_require__( /*! ./command */ 145),
                messageLocalization = __webpack_require__( /*! ../localization/message */ 8),
                CommandMapping = __webpack_require__( /*! ./command_mapping */ 146),
                ViewCache = __webpack_require__( /*! ./view_cache */ 59),
                EventsMixin = __webpack_require__( /*! ../core/events_mixin */ 32),
                sessionStorage = __webpack_require__( /*! ../core/utils/storage */ 122).sessionStorage,
                dataUtils = __webpack_require__( /*! ../data/utils */ 28),
                errors = __webpack_require__( /*! ./errors */ 44),
                INIT_IN_PROGRESS = "InProgress",
                INIT_COMPLETE = "Inited";
            var Application = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._options = options;
                    this.namespace = options.namespace || window;
                    this._applicationMode = options.mode ? options.mode : "mobileApp";
                    this.components = [];
                    BACK_COMMAND_TITLE = messageLocalization.localizeString("@Back");
                    this.router = options.router || new Router;
                    var navigationManagers = {
                        mobileApp: NavigationManager.StackBasedNavigationManager,
                        webSite: NavigationManager.HistoryBasedNavigationManager
                    };
                    this.navigationManager = options.navigationManager || new navigationManagers[this._applicationMode]({
                        keepPositionInStack: "keepHistory" === options.navigateToRootViewMode
                    });
                    this.navigationManager.on("navigating", $.proxy(this._onNavigating, this));
                    this.navigationManager.on("navigatingBack", $.proxy(this._onNavigatingBack, this));
                    this.navigationManager.on("navigated", $.proxy(this._onNavigated, this));
                    this.navigationManager.on("navigationCanceled", $.proxy(this._onNavigationCanceled, this));
                    this.stateManager = options.stateManager || new StateManager({
                        storage: options.stateStorage || sessionStorage()
                    });
                    this.stateManager.addStateSource(this.navigationManager);
                    this.viewCache = this._createViewCache(options);
                    this.commandMapping = this._createCommandMapping(options.commandMapping);
                    this.createNavigation(options.navigation);
                    this._isNavigating = false;
                    this._viewLinksHash = {};
                    Action.registerExecutor(createActionExecutors(this));
                    this.components.push(this.router);
                    this.components.push(this.navigationManager)
                },
                _createViewCache: function(options) {
                    var result;
                    if (options.viewCache) {
                        result = options.viewCache
                    } else {
                        if (options.disableViewCache) {
                            result = new ViewCache.NullViewCache
                        } else {
                            result = new ViewCache.CapacityViewCacheDecorator({
                                size: options.viewCacheSize,
                                viewCache: new ViewCache
                            })
                        }
                    }
                    result.on("viewRemoved", $.proxy(function(e) {
                        this._releaseViewLink(e.viewInfo)
                    }, this));
                    return result
                },
                _createCommandMapping: function(commandMapping) {
                    var result = commandMapping;
                    if (!(commandMapping instanceof CommandMapping)) {
                        result = new CommandMapping;
                        result.load(CommandMapping.defaultMapping || {}).load(commandMapping || {})
                    }
                    return result
                },
                createNavigation: function(navigationConfig) {
                    this.navigation = this._createNavigationCommands(navigationConfig);
                    this._mapNavigationCommands(this.navigation, this.commandMapping)
                },
                _createNavigationCommands: function(commandConfig) {
                    if (!commandConfig) {
                        return []
                    }
                    var generatedIdCount = 0;
                    return $.map(commandConfig, function(item) {
                        var command;
                        if (item instanceof dxCommand) {
                            command = item
                        } else {
                            command = new dxCommand($.extend({
                                root: true
                            }, item))
                        }
                        if (!command.option("id")) {
                            command.option("id", "navigation_" + generatedIdCount++)
                        }
                        return command
                    })
                },
                _mapNavigationCommands: function(navigationCommands, commandMapping) {
                    var navigationCommandIds = $.map(navigationCommands, function(command) {
                        return command.option("id")
                    });
                    commandMapping.mapCommands("global-navigation", navigationCommandIds)
                },
                _callComponentMethod: function(methodName, args) {
                    var tasks = [];
                    $.each(this.components, function(index, component) {
                        if (component[methodName] && $.isFunction(component[methodName])) {
                            var result = component[methodName](args);
                            if (result && result.done) {
                                tasks.push(result)
                            }
                        }
                    });
                    return $.when.apply($, tasks)
                },
                init: function() {
                    var that = this;
                    that._initState = INIT_IN_PROGRESS;
                    return that._callComponentMethod("init").done(function() {
                        that._initState = INIT_COMPLETE;
                        that._processEvent("initialized")
                    }).fail(function(error) {
                        throw error || errors.Error("E3022")
                    })
                },
                _onNavigatingBack: function(args) {
                    this._processEvent("navigatingBack", args)
                },
                _onNavigating: function(args) {
                    var that = this;
                    if (that._isNavigating) {
                        that._pendingNavigationArgs = args;
                        args.cancel = true;
                        return
                    } else {
                        that._isNavigating = true;
                        delete that._pendingNavigationArgs
                    }
                    var routeData = this.router.parse(args.uri);
                    if (!routeData) {
                        throw errors.Error("E3001", args.uri)
                    }
                    var uri = this.router.format(routeData);
                    if (args.uri !== uri && uri) {
                        args.cancel = true;
                        args.cancelReason = "redirect";
                        commonUtils.executeAsync(function() {
                            that.navigate(uri, args.options)
                        })
                    } else {
                        that._processEvent("navigating", args)
                    }
                },
                _onNavigated: function(args) {
                    var resultDeferred, that = this,
                        direction = args.options.direction,
                        viewInfo = that._acquireViewInfo(args.item, args.options);
                    if (!viewInfo.model) {
                        this._processEvent("beforeViewSetup", {
                            viewInfo: viewInfo
                        });
                        that._createViewModel(viewInfo);
                        that._createViewCommands(viewInfo);
                        this._processEvent("afterViewSetup", {
                            viewInfo: viewInfo
                        })
                    }
                    that._highlightCurrentNavigationCommand(viewInfo);
                    resultDeferred = that._showView(viewInfo, direction).always(function() {
                        that._isNavigating = false;
                        var pendingArgs = that._pendingNavigationArgs;
                        if (pendingArgs) {
                            commonUtils.executeAsync(function() {
                                that.navigate(pendingArgs.uri, pendingArgs.options)
                            })
                        }
                    });
                    return resultDeferred
                },
                _isViewReadyToShow: function(viewInfo) {
                    return !!viewInfo.model
                },
                _onNavigationCanceled: function(args) {
                    var that = this;
                    if (!that._pendingNavigationArgs || that._pendingNavigationArgs.uri !== args.uri) {
                        var currentItem = that.navigationManager.currentItem();
                        if (currentItem) {
                            commonUtils.executeAsync(function() {
                                var viewInfo = that._acquireViewInfo(currentItem, args.options);
                                that._highlightCurrentNavigationCommand(viewInfo, true)
                            })
                        }
                        that._isNavigating = false
                    }
                },
                _disposeRemovedViews: function() {
                    var args, that = this;
                    $.each(that._viewLinksHash, function(key, link) {
                        if (!link.linkCount) {
                            args = {
                                viewInfo: link.viewInfo
                            };
                            that._processEvent("viewDisposing", args, args.viewInfo.model);
                            that._disposeView(link.viewInfo);
                            that._processEvent("viewDisposed", args, args.viewInfo.model);
                            delete that._viewLinksHash[key]
                        }
                    })
                },
                _onViewHidden: function(viewInfo) {
                    var args = {
                        viewInfo: viewInfo
                    };
                    this._processEvent("viewHidden", args, args.viewInfo.model)
                },
                _disposeView: function(viewInfo) {
                    var commands = viewInfo.commands || [];
                    $.each(commands, function(index, command) {
                        command._dispose()
                    })
                },
                _acquireViewInfo: function(navigationItem, navigateOptions) {
                    var routeData = this.router.parse(navigationItem.uri),
                        viewInfoKey = this._getViewInfoKey(navigationItem, routeData),
                        viewInfo = this.viewCache.getView(viewInfoKey);
                    if (!viewInfo) {
                        viewInfo = this._createViewInfo(navigationItem, navigateOptions);
                        this._obtainViewLink(viewInfo);
                        this.viewCache.setView(viewInfoKey, viewInfo)
                    } else {
                        this._updateViewInfo(viewInfo, navigationItem, navigateOptions)
                    }
                    return viewInfo
                },
                _getViewInfoKey: function(navigationItem, routeData) {
                    var args = {
                        key: navigationItem.key,
                        navigationItem: navigationItem,
                        routeData: routeData
                    };
                    this._processEvent("resolveViewCacheKey", args);
                    return args.key
                },
                _processEvent: function(eventName, args, model) {
                    this._callComponentMethod(eventName, args);
                    this.fireEvent(eventName, args && [args]);
                    var modelMethod = (model || {})[eventName];
                    if (modelMethod) {
                        modelMethod.call(model, args)
                    }
                },
                _updateViewInfo: function(viewInfo, navigationItem, navigateOptions) {
                    var uri = navigationItem.uri,
                        routeData = this.router.parse(uri);
                    viewInfo.viewName = routeData.view;
                    viewInfo.routeData = routeData;
                    viewInfo.uri = uri;
                    viewInfo.navigateOptions = navigateOptions;
                    viewInfo.canBack = this.canBack(navigateOptions.stack);
                    viewInfo.previousViewInfo = this._getPreviousViewInfo(navigateOptions)
                },
                _createViewInfo: function(navigationItem, navigateOptions) {
                    var uri = navigationItem.uri,
                        routeData = this.router.parse(uri),
                        viewInfo = {
                            key: this._getViewInfoKey(navigationItem, routeData)
                        };
                    this._updateViewInfo(viewInfo, navigationItem, navigateOptions);
                    return viewInfo
                },
                _createViewModel: function(viewInfo) {
                    viewInfo.model = viewInfo.model || this._callViewCodeBehind(viewInfo)
                },
                _createViewCommands: function(viewInfo) {
                    viewInfo.commands = viewInfo.model.commands || [];
                    if (viewInfo.canBack && "webSite" !== this._applicationMode) {
                        this._appendBackCommand(viewInfo)
                    }
                },
                _callViewCodeBehind: function(viewInfo) {
                    var setupFunc = $.noop,
                        routeData = viewInfo.routeData;
                    if (routeData.view in this.namespace) {
                        setupFunc = this.namespace[routeData.view]
                    }
                    return setupFunc.call(this.namespace, routeData, viewInfo) || {}
                },
                _appendBackCommand: function(viewInfo) {
                    var commands = viewInfo.commands,
                        that = this,
                        backTitle = BACK_COMMAND_TITLE;
                    if (that._options.useViewTitleAsBackText) {
                        backTitle = ((viewInfo.previousViewInfo || {}).model || {}).title || backTitle
                    }
                    var toMergeTo = [new dxCommand({
                        id: "back",
                        title: backTitle,
                        behavior: "back",
                        onExecute: function() {
                            that.back({
                                stack: viewInfo.navigateOptions.stack
                            })
                        },
                        icon: "arrowleft",
                        type: "back",
                        renderStage: that._options.useViewTitleAsBackText ? "onViewRendering" : "onViewShown"
                    })];
                    var result = mergeCommands(toMergeTo, commands);
                    commands.length = 0;
                    commands.push.apply(commands, result)
                },
                _showView: function(viewInfo, direction) {
                    var that = this;
                    var eventArgs = {
                        viewInfo: viewInfo,
                        direction: direction,
                        params: viewInfo.routeData
                    };
                    dataUtils.processRequestResultLock.obtain();
                    return that._showViewImpl(eventArgs.viewInfo, eventArgs.direction).done(function() {
                        commonUtils.executeAsync(function() {
                            dataUtils.processRequestResultLock.release();
                            that._processEvent("viewShown", eventArgs, viewInfo.model);
                            that._disposeRemovedViews()
                        })
                    })
                },
                _highlightCurrentNavigationCommand: function(viewInfo, forceUpdate) {
                    var selectedCommand, that = this,
                        currentNavigationItemId = viewInfo.model && viewInfo.model.currentNavigationItemId;
                    if (void 0 !== currentNavigationItemId) {
                        $.each(this.navigation, function(index, command) {
                            if (command.option("id") === currentNavigationItemId) {
                                selectedCommand = command;
                                return false
                            }
                        })
                    }
                    if (!selectedCommand) {
                        $.each(this.navigation, function(index, command) {
                            var commandUri = command.option("onExecute");
                            if (commonUtils.isString(commandUri)) {
                                commandUri = commandUri.replace(/^#+/, "");
                                if (commandUri === that.navigationManager.rootUri()) {
                                    selectedCommand = command;
                                    return false
                                }
                            }
                        })
                    }
                    $.each(this.navigation, function(index, command) {
                        if (forceUpdate && command === selectedCommand && command.option("highlighted")) {
                            command.fireEvent("optionChanged", [{
                                name: "highlighted",
                                value: true,
                                previousValue: true
                            }])
                        }
                        command.option("highlighted", command === selectedCommand)
                    })
                },
                _showViewImpl: abstract,
                _obtainViewLink: function(viewInfo) {
                    var key = viewInfo.key;
                    if (!this._viewLinksHash[key]) {
                        this._viewLinksHash[key] = {
                            viewInfo: viewInfo,
                            linkCount: 1
                        }
                    } else {
                        this._viewLinksHash[key].linkCount++
                    }
                },
                _releaseViewLink: function(viewInfo) {
                    if (void 0 === this._viewLinksHash[viewInfo.key]) {
                        errors.log("W3001", viewInfo.key)
                    }
                    if (0 === this._viewLinksHash[viewInfo.key].linkCount) {
                        errors.log("W3002", viewInfo.key)
                    }
                    this._viewLinksHash[viewInfo.key].linkCount--
                },
                navigate: function(uri, options) {
                    var that = this;
                    if ($.isPlainObject(uri)) {
                        uri = that.router.format(uri);
                        if (false === uri) {
                            throw errors.Error("E3002")
                        }
                    }
                    if (!that._initState) {
                        that.init().done(function() {
                            that.restoreState();
                            that.navigate(uri, options)
                        })
                    } else {
                        if (that._initState === INIT_COMPLETE) {
                            if (!that._isNavigating || uri) {
                                that.navigationManager.navigate(uri, options)
                            }
                        } else {
                            throw errors.Error("E3003")
                        }
                    }
                },
                canBack: function(stackKey) {
                    return this.navigationManager.canBack(stackKey)
                },
                _getPreviousViewInfo: function(navigateOptions) {
                    var result, previousNavigationItem = this.navigationManager.previousItem(navigateOptions.stack);
                    if (previousNavigationItem) {
                        var routeData = this.router.parse(previousNavigationItem.uri);
                        result = this.viewCache.getView(this._getViewInfoKey(previousNavigationItem, routeData))
                    }
                    return result
                },
                back: function(options) {
                    this.navigationManager.back(options)
                },
                saveState: function() {
                    this.stateManager.saveState()
                },
                restoreState: function() {
                    this.stateManager.restoreState()
                },
                clearState: function() {
                    this.stateManager.clearState()
                }
            }).include(EventsMixin);
            exports.Application = Application
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/framework/browser_adapters.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                queue = __webpack_require__( /*! ../core/utils/queue */ 143);
            var ROOT_PAGE_URL = "__root__",
                BUGGY_ANDROID_BUFFER_PAGE_URL = "__buffer__";
            var DefaultBrowserAdapter = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._window = options.window || window;
                    this.popState = $.Callbacks();
                    $(this._window).on("hashchange", $.proxy(this._onHashChange, this));
                    this._tasks = queue.create();
                    this.canWorkInPureBrowser = true
                },
                replaceState: function(uri) {
                    var that = this;
                    return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.replaceState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
                },
                pushState: function(uri) {
                    var that = this;
                    return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.pushState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
                },
                createRootPage: function() {
                    return this.replaceState(ROOT_PAGE_URL)
                },
                _onHashChange: function() {
                    if (this._currentTask) {
                        this._currentTask.resolve()
                    }
                    this.popState.fire()
                },
                back: function() {
                    var that = this;
                    return this._addTask(function() {
                        that._window.history.back()
                    })
                },
                getHash: function() {
                    return this._normalizeUri(this._window.location.hash)
                },
                isRootPage: function() {
                    return this.getHash() === ROOT_PAGE_URL
                },
                _normalizeUri: function(uri) {
                    return (uri || "").replace(/^#+/, "")
                },
                _addTask: function(task) {
                    var that = this,
                        d = $.Deferred();
                    this._tasks.add(function() {
                        that._currentTask = d;
                        task();
                        return d
                    });
                    return d.promise()
                }
            });
            var OldBrowserAdapter = DefaultBrowserAdapter.inherit({
                ctor: function() {
                    this._innerEventCount = 0;
                    this.callBase.apply(this, arguments);
                    this._skipNextEvent = false
                },
                replaceState: function(uri) {
                    var that = this;
                    uri = that._normalizeUri(uri);
                    if (that.getHash() !== uri) {
                        that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.history.back()
                        });
                        return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        })
                    }
                    return $.Deferred().resolve().promise()
                },
                pushState: function(uri) {
                    var that = this;
                    uri = this._normalizeUri(uri);
                    if (this.getHash() !== uri) {
                        return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        })
                    }
                    return $.Deferred().resolve().promise()
                },
                createRootPage: function() {
                    return this.pushState(ROOT_PAGE_URL)
                },
                _onHashChange: function() {
                    var currentTask = this._currentTask;
                    this._currentTask = null;
                    if (this._skipNextEvent) {
                        this._skipNextEvent = false
                    } else {
                        this.popState.fire()
                    }
                    if (currentTask) {
                        currentTask.resolve()
                    }
                }
            });
            var BuggyAndroidBrowserAdapter = OldBrowserAdapter.inherit({
                createRootPage: function() {
                    this.pushState(BUGGY_ANDROID_BUFFER_PAGE_URL);
                    return this.callBase()
                }
            });
            var HistorylessBrowserAdapter = DefaultBrowserAdapter.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._window = options.window || window;
                    this.popState = $.Callbacks();
                    $(this._window).on("dxback", $.proxy(this._onHashChange, this));
                    this._currentHash = this._window.location.hash
                },
                replaceState: function(uri) {
                    this._currentHash = this._normalizeUri(uri);
                    return $.Deferred().resolve().promise()
                },
                pushState: function(uri) {
                    return this.replaceState(uri)
                },
                createRootPage: function() {
                    return this.replaceState(ROOT_PAGE_URL)
                },
                getHash: function() {
                    return this._normalizeUri(this._currentHash)
                },
                back: function() {
                    return this.replaceState(ROOT_PAGE_URL)
                },
                _onHashChange: function() {
                    var promise = this.back();
                    this.popState.fire();
                    return promise
                }
            });
            var BuggyCordovaWP81BrowserAdapter = DefaultBrowserAdapter.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this.canWorkInPureBrowser = false
                }
            });
            exports.DefaultBrowserAdapter = DefaultBrowserAdapter;
            exports.OldBrowserAdapter = OldBrowserAdapter;
            exports.BuggyAndroidBrowserAdapter = BuggyAndroidBrowserAdapter;
            exports.HistorylessBrowserAdapter = HistorylessBrowserAdapter;
            exports.BuggyCordovaWP81BrowserAdapter = BuggyCordovaWP81BrowserAdapter
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/framework/html/command_manager.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                errors = __webpack_require__( /*! ../errors */ 44),
                CommandMapping = __webpack_require__( /*! ../command_mapping */ 146),
                commandToDXWidgetAdapters = __webpack_require__( /*! ./widget_command_adapters */ 215);
            __webpack_require__( /*! ../command */ 145);
            __webpack_require__( /*! ./command_container */ 147);
            var CommandManager = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.defaultWidgetAdapter = options.defaultWidgetAdapter || this._getDefaultWidgetAdapter();
                    this.commandMapping = options.commandMapping || new CommandMapping
                },
                _getDefaultWidgetAdapter: function() {
                    return {
                        addCommand: $.noop,
                        clearContainer: $.noop
                    }
                },
                _getContainerAdapter: function($container) {
                    var componentNames = $container.data("dxComponents"),
                        adapters = commandToDXWidgetAdapters;
                    if (componentNames) {
                        for (var index in componentNames) {
                            var widgetName = componentNames[index];
                            if (widgetName in adapters) {
                                return adapters[widgetName]
                            }
                        }
                    }
                    return this.defaultWidgetAdapter
                },
                findCommands: function($view) {
                    var result = $.map($view.addBack().find(".dx-command"), function(element) {
                        return $(element).dxCommand("instance")
                    });
                    return result
                },
                findCommandContainers: function($markup) {
                    var result = $.map($markup.find(".dx-command-container"), function(element) {
                        return $(element).dxCommandContainer("instance")
                    });
                    return result
                },
                _checkCommandId: function(id, command) {
                    if (null === id) {
                        throw errors.Error("E3010", command.element().get(0).outerHTML)
                    }
                },
                renderCommandsToContainers: function(commands, containers) {
                    var that = this,
                        commandHash = {},
                        commandIds = [],
                        deferreds = [];
                    $.each(commands, function(i, command) {
                        var id = command.option("id");
                        that._checkCommandId(id, command);
                        commandIds.push(id);
                        commandHash[id] = command
                    });
                    that.commandMapping.checkCommandsExist(commandIds);
                    $.each(containers, function(k, container) {
                        var commandInfos = [];
                        $.each(commandHash, function(id, command) {
                            var commandId = id;
                            var commandOptions = that.commandMapping.getCommandMappingForContainer(commandId, container.option("id"));
                            if (commandOptions) {
                                commandInfos.push({
                                    command: command,
                                    options: commandOptions
                                })
                            }
                        });
                        if (commandInfos.length) {
                            var deferred = that._attachCommandsToContainer(container.element(), commandInfos);
                            if (deferred) {
                                deferreds.push(deferred)
                            }
                        }
                    });
                    return $.when.apply($, deferreds)
                },
                clearContainer: function(container) {
                    var $container = container.element(),
                        adapter = this._getContainerAdapter($container);
                    adapter.clearContainer($container)
                },
                _arrangeCommandsToContainers: function(commands, containers) {
                    errors.log("W0002", "CommandManager", "_arrangeCommandsToContainers", "14.1", "Use the 'renderCommandsToContainers' method instead.");
                    this.renderCommandsToContainers(commands, containers)
                },
                _attachCommandsToContainer: function($container, commandInfos) {
                    var result, adapter = this._getContainerAdapter($container);
                    if (adapter.beginUpdate) {
                        adapter.beginUpdate($container)
                    }
                    $.each(commandInfos, function(index, commandInfo) {
                        adapter.addCommand($container, commandInfo.command, commandInfo.options)
                    });
                    if (adapter.endUpdate) {
                        result = adapter.endUpdate($container)
                    }
                    return result
                }
            });
            module.exports = CommandManager
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/framework/html/html_application.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                Component = __webpack_require__( /*! ../../core/component */ 92),
                errors = __webpack_require__( /*! ../errors */ 44),
                Application = __webpack_require__( /*! ../application */ 210).Application,
                ConditionalViewCacheDecorator = __webpack_require__( /*! ../view_cache */ 59).ConditionalViewCacheDecorator,
                html = __webpack_require__( /*! ./presets */ 114),
                CommandManager = __webpack_require__( /*! ./command_manager */ 212),
                ViewEngine = __webpack_require__( /*! ./view_engine */ 214).ViewEngine,
                messageLocalization = __webpack_require__( /*! ../../localization/message */ 8),
                viewPort = __webpack_require__( /*! ../../core/utils/view_port */ 52).value,
                initMobileViewportModule = __webpack_require__( /*! ../../mobile/init_mobile_viewport/init_mobile_viewport */ 218),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                feedbackEvents = __webpack_require__( /*! ../../events/core/emitter.feedback */ 70),
                TransitionExecutorModule = __webpack_require__( /*! ../../animation/transition_executor/transition_executor */ 91),
                animationPresetsModule = __webpack_require__( /*! ../../animation/presets/presets */ 110);
            __webpack_require__( /*! ./layout_controller */ 148);
            var VIEW_PORT_CLASSNAME = "dx-viewport",
                LAYOUT_CHANGE_ANIMATION_NAME = "layout-change";
            var HtmlApplication = Application.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.callBase(options);
                    this._$root = $(options.rootNode || document.body);
                    this._initViewport(options.viewPort);
                    if ("mobileApp" === this._applicationMode) {
                        initMobileViewportModule.initMobileViewport(options.viewPort)
                    }
                    this.device = options.device || devices.current();
                    this.commandManager = options.commandManager || new CommandManager({
                        commandMapping: this.commandMapping
                    });
                    this._initTemplateContext();
                    this.viewEngine = options.viewEngine || new ViewEngine({
                        $root: this._$root,
                        device: this.device,
                        templateCacheStorage: options.templateCacheStorage || window.localStorage,
                        templatesVersion: options.templatesVersion,
                        templateContext: this._templateContext
                    });
                    this.components.push(this.viewEngine);
                    this._initMarkupFilters(this.viewEngine);
                    this._layoutSet = options.layoutSet || html.layoutSets.default;
                    this._animationSet = options.animationSet || html.animationSets.default;
                    this._availableLayoutControllers = [];
                    this._activeLayoutControllersStack = [];
                    this.transitionExecutor = new TransitionExecutorModule.TransitionExecutor;
                    this._initAnimations(this._animationSet)
                },
                _initAnimations: function(animationSet) {
                    if (!animationSet) {
                        return
                    }
                    $.each(animationSet, function(name, configs) {
                        $.each(configs, function(index, config) {
                            animationPresetsModule.presets.registerPreset(name, config)
                        })
                    });
                    animationPresetsModule.presets.applyChanges()
                },
                _localizeMarkup: function($markup) {
                    messageLocalization.localizeNode($markup)
                },
                _notifyIfBadMarkup: function($markup) {
                    $markup.each(function() {
                        var html = $(this).html();
                        if (/href="#/.test(html)) {
                            errors.log("W3005", html)
                        }
                    })
                },
                _initMarkupFilters: function(viewEngine) {
                    var filters = [];
                    filters.push(this._localizeMarkup);
                    if ("mobileApp" === this._applicationMode) {
                        filters.push(this._notifyIfBadMarkup)
                    }
                    if (viewEngine.markupLoaded) {
                        viewEngine.markupLoaded.add(function(args) {
                            $.each(filters, function(_, filter) {
                                filter(args.markup)
                            })
                        })
                    }
                },
                _createViewCache: function(options) {
                    var result = this.callBase(options);
                    if (!options.viewCache) {
                        result = new ConditionalViewCacheDecorator({
                            filter: function(key, viewInfo) {
                                return !viewInfo.viewTemplateInfo.disableCache
                            },
                            viewCache: result
                        })
                    }
                    return result
                },
                _initViewport: function() {
                    this._$viewPort = this._getViewPort();
                    viewPort(this._$viewPort)
                },
                _getViewPort: function() {
                    var $viewPort = $("." + VIEW_PORT_CLASSNAME);
                    if (!$viewPort.length) {
                        $viewPort = $("<div>").addClass(VIEW_PORT_CLASSNAME).appendTo(this._$root)
                    }
                    return $viewPort
                },
                _initTemplateContext: function() {
                    this._templateContext = new Component({
                        orientation: devices.orientation()
                    });
                    devices.on("orientationChanged", $.proxy(function(args) {
                        this._templateContext.option("orientation", args.orientation)
                    }, this))
                },
                _showViewImpl: function(viewInfo, direction) {
                    var that = this,
                        deferred = $.Deferred(),
                        result = deferred.promise(),
                        layoutController = viewInfo.layoutController;
                    that._obtainViewLink(viewInfo);
                    layoutController.showView(viewInfo, direction).done(function() {
                        that._activateLayoutController(layoutController, that._getTargetNode(viewInfo), direction).done(function() {
                            deferred.resolve()
                        })
                    });
                    feedbackEvents.lock(result);
                    return result
                },
                _resolveLayoutController: function(viewInfo) {
                    var args = {
                        viewInfo: viewInfo,
                        layoutController: null,
                        availableLayoutControllers: this._availableLayoutControllers
                    };
                    this._processEvent("resolveLayoutController", args, viewInfo.model);
                    this._checkLayoutControllerIsInitialized(args.layoutController);
                    return args.layoutController || this._resolveLayoutControllerImpl(viewInfo)
                },
                _checkLayoutControllerIsInitialized: function(layoutController) {
                    if (layoutController) {
                        var isControllerInited = false;
                        $.each(this._layoutSet, function(_, controllerInfo) {
                            if (controllerInfo.controller === layoutController) {
                                isControllerInited = true;
                                return false
                            }
                        });
                        if (!isControllerInited) {
                            throw errors.Error("E3024")
                        }
                    }
                },
                _ensureOneLayoutControllerFound: function(target, matches) {
                    var toJSONInterceptor = function(key, value) {
                        if ("controller" === key) {
                            return "[controller]: { name:" + value.name + " }"
                        }
                        return value
                    };
                    if (!matches.length) {
                        errors.log("W3003", JSON.stringify(target, null, 4), JSON.stringify(this._availableLayoutControllers, toJSONInterceptor, 4));
                        throw errors.Error("E3011")
                    }
                    if (matches.length > 1) {
                        errors.log("W3004", JSON.stringify(target, null, 4), JSON.stringify(matches, toJSONInterceptor, 4));
                        throw errors.Error("E3012")
                    }
                },
                _resolveLayoutControllerImpl: function(viewInfo) {
                    var templateInfo = viewInfo.viewTemplateInfo || {},
                        navigateOptions = viewInfo.navigateOptions || {},
                        target = $.extend({
                            root: !viewInfo.canBack,
                            customResolveRequired: false,
                            pane: templateInfo.pane,
                            modal: void 0 !== navigateOptions.modal ? navigateOptions.modal : templateInfo.modal || false
                        }, devices.current());
                    var matches = commonUtils.findBestMatches(target, this._availableLayoutControllers);
                    this._ensureOneLayoutControllerFound(target, matches);
                    return matches[0].controller
                },
                _onNavigatingBack: function(args) {
                    this.callBase.apply(this, arguments);
                    if (!args.cancel && !this.canBack() && this._activeLayoutControllersStack.length > 1) {
                        var previousActiveLayoutController = this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 2],
                            previousViewInfo = previousActiveLayoutController.activeViewInfo();
                        args.cancel = true;
                        this._activateLayoutController(previousActiveLayoutController, void 0, "backward");
                        this.navigationManager.currentItem(previousViewInfo.key)
                    }
                },
                _activeLayoutController: function() {
                    return this._activeLayoutControllersStack.length ? this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 1] : void 0
                },
                _getTargetNode: function(viewInfo) {
                    var jQueryEvent = (viewInfo.navigateOptions || {}).jQueryEvent;
                    return jQueryEvent ? $(jQueryEvent.target) : void 0
                },
                _activateLayoutController: function(layoutController, targetNode, direction) {
                    var that = this,
                        previousLayoutController = that._activeLayoutController();
                    if (previousLayoutController === layoutController) {
                        return $.Deferred().resolve().promise()
                    }
                    return layoutController.ensureActive(targetNode).then($.proxy(this._deactivatePreviousLayoutControllers, this, layoutController, direction)).then(function() {
                        that._activeLayoutControllersStack.push(layoutController)
                    })
                },
                _deactivatePreviousLayoutControllers: function(layoutController, direction) {
                    var that = this,
                        tasks = [],
                        controllerToDeactivate = that._activeLayoutControllersStack.pop();
                    if (!controllerToDeactivate) {
                        return $.Deferred().resolve().promise()
                    }
                    if (layoutController.isOverlay) {
                        that._activeLayoutControllersStack.push(controllerToDeactivate);
                        tasks.push(controllerToDeactivate.disable())
                    } else {
                        var transitionDeferred = $.Deferred(),
                            skipAnimation = false;
                        var getControllerDeactivator = function(controllerToDeactivate, d) {
                            return function() {
                                controllerToDeactivate.deactivate().done(function() {
                                    d.resolve()
                                })
                            }
                        };
                        while (controllerToDeactivate && controllerToDeactivate !== layoutController) {
                            var d = $.Deferred();
                            if (controllerToDeactivate.isOverlay) {
                                skipAnimation = true
                            } else {
                                that.transitionExecutor.leave(controllerToDeactivate.element(), LAYOUT_CHANGE_ANIMATION_NAME, {
                                    direction: direction
                                })
                            }
                            transitionDeferred.promise().done(getControllerDeactivator(controllerToDeactivate, d));
                            tasks.push(d.promise());
                            controllerToDeactivate = that._activeLayoutControllersStack.pop()
                        }
                        if (skipAnimation) {
                            transitionDeferred.resolve()
                        } else {
                            that.transitionExecutor.enter(layoutController.element(), LAYOUT_CHANGE_ANIMATION_NAME, {
                                direction: direction
                            });
                            that.transitionExecutor.start().done(function() {
                                transitionDeferred.resolve()
                            })
                        }
                    }
                    return $.when.apply($, tasks)
                },
                init: function() {
                    var that = this,
                        result = this.callBase();
                    result.done(function() {
                        that._initLayoutControllers();
                        that.renderNavigation()
                    });
                    return result
                },
                _disposeView: function(viewInfo) {
                    if (viewInfo.layoutController.disposeView) {
                        viewInfo.layoutController.disposeView(viewInfo)
                    }
                    this.callBase(viewInfo)
                },
                viewPort: function() {
                    return this._$viewPort
                },
                _createViewInfo: function(navigationItem, navigateOptions) {
                    var viewInfo = this.callBase.apply(this, arguments),
                        templateInfo = this.getViewTemplateInfo(viewInfo.viewName);
                    if (!templateInfo) {
                        throw errors.Error("E3013", "dxView", viewInfo.viewName)
                    }
                    viewInfo.viewTemplateInfo = templateInfo;
                    viewInfo.layoutController = this._resolveLayoutController(viewInfo);
                    return viewInfo
                },
                _createViewModel: function(viewInfo) {
                    this.callBase(viewInfo);
                    objectUtils.extendFromObject(viewInfo.model, viewInfo.viewTemplateInfo)
                },
                _initLayoutControllers: function() {
                    var that = this;
                    $.each(that._layoutSet, function(index, controllerInfo) {
                        var controller = controllerInfo.controller,
                            target = devices.current();
                        if (commonUtils.findBestMatches(target, [controllerInfo]).length) {
                            that._availableLayoutControllers.push(controllerInfo);
                            if (controller.init) {
                                controller.init({
                                    app: that,
                                    $viewPort: that._$viewPort,
                                    navigationManager: that.navigationManager,
                                    viewEngine: that.viewEngine,
                                    templateContext: that._templateContext,
                                    commandManager: that.commandManager
                                })
                            }
                            if (controller.on) {
                                controller.on("viewReleased", function(viewInfo) {
                                    that._onViewReleased(viewInfo)
                                });
                                controller.on("viewHidden", function(viewInfo) {
                                    that._onViewHidden(viewInfo)
                                });
                                controller.on("viewRendered", function(viewInfo) {
                                    that._processEvent("viewRendered", {
                                        viewInfo: viewInfo
                                    }, viewInfo.model)
                                });
                                controller.on("viewShowing", function(viewInfo, direction) {
                                    that._processEvent("viewShowing", {
                                        viewInfo: viewInfo,
                                        direction: direction,
                                        params: viewInfo.routeData
                                    }, viewInfo.model)
                                });
                                controller.on("viewShown", function(viewInfo, direction) {
                                    that._processEvent("viewShown", {
                                        viewInfo: viewInfo,
                                        direction: direction,
                                        params: viewInfo.routeData
                                    }, viewInfo.model)
                                })
                            }
                        }
                    })
                },
                _onViewReleased: function(viewInfo) {
                    this._releaseViewLink(viewInfo)
                },
                renderNavigation: function() {
                    var that = this;
                    $.each(that._availableLayoutControllers, function(index, controllerInfo) {
                        var controller = controllerInfo.controller;
                        if (controller.renderNavigation) {
                            controller.renderNavigation(that.navigation)
                        }
                    })
                },
                getViewTemplate: function(viewName) {
                    return this.viewEngine.getViewTemplate(viewName)
                },
                getViewTemplateInfo: function(viewName) {
                    var viewComponent = this.viewEngine.getViewTemplateInfo(viewName);
                    return viewComponent && viewComponent.option()
                },
                loadTemplates: function(source) {
                    return this.viewEngine.loadTemplates(source)
                },
                templateContext: function() {
                    return this._templateContext
                }
            });
            module.exports = HtmlApplication
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/framework/html/view_engine.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                version = __webpack_require__( /*! ../../core/version */ 123),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                errors = __webpack_require__( /*! ../errors */ 44),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                _VIEW_ROLE = "dxView",
                _LAYOUT_ROLE = "dxLayout",
                MARKUP_TEMPLATE_MARKER = "MarkupTemplate:";
            __webpack_require__( /*! ./view_engine_components */ 45);
            var ViewEngine = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this.$root = options.$root;
                    this.device = options.device || {};
                    this.dataOptionsAttributeName = options.dataOptionsAttributeName || "data-options";
                    this._templateMap = {};
                    this._pendingViewContainer = null;
                    this.markupLoaded = $.Callbacks();
                    this._templateContext = options.templateContext;
                    this._$skippedMarkup = $();
                    if (void 0 !== options.templatesVersion && options.templateCacheStorage && this._isReleaseVersion()) {
                        this._templateCacheEnabled = true;
                        this._templatesVersion = "v_" + options.templatesVersion;
                        this._templateCacheStorage = options.templateCacheStorage;
                        this._templateCacheKey = "dxTemplateCache_" + version + "_" + JSON.stringify(this.device)
                    }
                },
                _isReleaseVersion: function() {
                    return !/http:\/\/localhost/.test(location.href)
                },
                _enumerateTemplates: function(processFn) {
                    var that = this;
                    $.each(that._templateMap, function(name, templatesByRoleMap) {
                        $.each(templatesByRoleMap, function(role, templates) {
                            $.each(templates, function(index, template) {
                                processFn(template)
                            })
                        })
                    })
                },
                _findComponent: function(name, role) {
                    var components = (this._templateMap[name] || {})[role] || [],
                        filter = this._templateContext && this._templateContext.option() || {};
                    components = this._filterTemplates(filter, components);
                    this._checkMatchedTemplates(components);
                    return components[0]
                },
                _findTemplate: function(name, role) {
                    var component = this._findComponent(name, role);
                    if (!component) {
                        this._clearCache();
                        throw errors.Error("E3013", role, name)
                    }
                    var $result, $template = component.element();
                    if (!component._isStaticComponentsCreated) {
                        domUtils.createComponents($template, ["dxContent", "dxContentPlaceholder", "dxTransition"]);
                        component._isStaticComponentsCreated = true
                    }
                    $result = $template.clone().removeClass("dx-hidden");
                    return $result
                },
                _clearCache: function() {
                    this._templateCacheStorage.removeItem(this._templateCacheKey)
                },
                _loadTemplatesFromMarkupCore: function($markup) {
                    var that = this;
                    if ($markup.find("[data-dx-role]").length) {
                        throw errors.Error("E3019")
                    }
                    that.markupLoaded.fire({
                        markup: $markup
                    });
                    var components = domUtils.createComponents($markup, [_VIEW_ROLE, _LAYOUT_ROLE]);
                    $.each(components, function(index, component) {
                        var $element = component.element();
                        $element.addClass("dx-hidden");
                        that._registerTemplateComponent(component);
                        component.element().detach()
                    });
                    var $skipped = $markup.filter("script");
                    $skipped.appendTo(that.$root);
                    that._$skippedMarkup = that._$skippedMarkup.add($skipped)
                },
                _registerTemplateComponent: function(component) {
                    var role = component.NAME,
                        options = component.option(),
                        templateName = options.name,
                        componentsByRoleMap = this._templateMap[templateName] || {};
                    componentsByRoleMap[role] = componentsByRoleMap[role] || [];
                    componentsByRoleMap[role].push(component);
                    this._templateMap[templateName] = componentsByRoleMap
                },
                _applyPartialViews: function($render) {
                    var that = this;
                    domUtils.createComponents($render, ["dxViewPlaceholder"]);
                    $.each($render.find(".dx-view-placeholder"), function() {
                        var $partialPlaceholder = $(this);
                        if ($partialPlaceholder.children().length) {
                            return
                        }
                        var viewName = $partialPlaceholder.data("dxViewPlaceholder").option("viewName"),
                            $view = that._findTemplate(viewName, _VIEW_ROLE);
                        that._applyPartialViews($view);
                        $partialPlaceholder.append($view);
                        $view.removeClass("dx-hidden")
                    })
                },
                _ajaxImpl: function() {
                    return $.ajax.apply($, arguments)
                },
                _loadTemplatesFromURL: function(url) {
                    var that = this,
                        options = this._getLoadOptions(),
                        deferred = $.Deferred();
                    url = options.winPhonePrefix + url;
                    this._ajaxImpl({
                        url: url,
                        isLocal: options.isLocal,
                        dataType: "html"
                    }).done(function(data) {
                        that._loadTemplatesFromMarkupCore(domUtils.createMarkupFromString(data));
                        deferred.resolve()
                    }).fail(function(jqXHR, textStatus, errorThrown) {
                        var error = errors.Error("E3021", url, errorThrown);
                        deferred.reject(error)
                    });
                    return deferred.promise()
                },
                _getLoadOptions: function() {
                    if (location.protocol.indexOf("wmapp") >= 0) {
                        return {
                            winPhonePrefix: location.protocol + "www/",
                            isLocal: true
                        }
                    }
                    return {
                        winPhonePrefix: "",
                        isLocal: void 0
                    }
                },
                _loadExternalTemplates: function() {
                    var tasks = [],
                        that = this;
                    $("head").find("link[rel='dx-template']").each(function(index, link) {
                        var task = that._loadTemplatesFromURL($(link).attr("href"));
                        tasks.push(task)
                    });
                    return $.when.apply($, tasks)
                },
                _processTemplates: function() {
                    var that = this;
                    $.each(that._templateMap, function(name, templatesByRoleMap) {
                        $.each(templatesByRoleMap, function(role, templates) {
                            that._filterTemplatesByDevice(templates)
                        })
                    });
                    that._enumerateTemplates(function(template) {
                        that._applyPartialViews(template.element())
                    })
                },
                _filterTemplatesByDevice: function(components) {
                    var filteredComponents = this._filterTemplates(this.device, components);
                    $.each(components, function(index, component) {
                        if ($.inArray(component, filteredComponents) < 0) {
                            component.element().remove()
                        }
                    });
                    components.length = 0;
                    components.push.apply(components, filteredComponents)
                },
                _filterTemplates: function(filter, components) {
                    return commonUtils.findBestMatches(filter, components, function(component) {
                        return component.option()
                    })
                },
                _checkMatchedTemplates: function(bestMatches) {
                    if (bestMatches.length > 1) {
                        var message = "";
                        $.each(bestMatches, function(index, match) {
                            message += match.element().attr("data-options") + "\r\n"
                        });
                        throw errors.Error("E3020", message, JSON.stringify(this.device))
                    }
                },
                _wrapViewDefaultContent: function($viewTemplate) {
                    $viewTemplate.wrapInner('<div class="dx-full-height"></div>');
                    $viewTemplate.children().eq(0).dxContent({
                        targetPlaceholder: "content"
                    })
                },
                _initDefaultLayout: function() {
                    this._$defaultLayoutTemplate = $('<div class="dx-full-height" data-options="dxLayout : { name: \'default\' } "> \n    <div class="dx-full-height" data-options="dxContentPlaceholder : { name: \'content\' } " ></div> \n</div>');
                    domUtils.createComponents(this._$defaultLayoutTemplate)
                },
                _getDefaultLayoutTemplate: function() {
                    return this._$defaultLayoutTemplate.clone()
                },
                applyLayout: function($view, $layout) {
                    if (void 0 === $layout || 0 === $layout.length) {
                        $layout = this._getDefaultLayoutTemplate()
                    }
                    if (0 === $view.children(".dx-content").length) {
                        this._wrapViewDefaultContent($view)
                    }
                    var $toMerge = $().add($layout).add($view);
                    var $placeholderContents = $toMerge.find(".dx-content");
                    $.each($placeholderContents, function() {
                        var $placeholderContent = $(this);
                        var placeholderId = $placeholderContent.attr("data-dx-target-placeholder-id");
                        var $placeholder = $toMerge.find(".dx-content-placeholder-" + placeholderId);
                        $placeholder.empty();
                        $placeholder.append($placeholderContent)
                    });
                    $placeholderContents.filter(":not(.dx-content-placeholder .dx-content)").remove();
                    return $layout
                },
                _loadTemplatesFromCache: function() {
                    if (!this._templateCacheEnabled) {
                        return
                    }
                    var cache;
                    var fromJSONInterceptor = function(key, value) {
                        if ("string" === typeof value && 0 === value.indexOf(MARKUP_TEMPLATE_MARKER)) {
                            var data = JSON.parse(value.substr(MARKUP_TEMPLATE_MARKER.length)),
                                type = data.type,
                                options = data.options,
                                $markup = domUtils.createMarkupFromString(data.markup);
                            options.fromCache = true;
                            return $markup[type](options)[type]("instance")
                        } else {
                            if ("skippedMarkup" === key) {
                                return $("<div>").append(domUtils.createMarkupFromString(value)).contents()
                            }
                        }
                        return value
                    };
                    var toParse = this._templateCacheStorage.getItem(this._templateCacheKey);
                    if (toParse) {
                        try {
                            var cacheContainer = JSON.parse(toParse, fromJSONInterceptor);
                            cache = cacheContainer[this._templatesVersion]
                        } catch (e) {
                            this._clearCache()
                        }
                    }
                    if (!cache) {
                        return
                    }
                    this._templateMap = cache.templates;
                    this.$root.append(cache.skippedMarkup);
                    return true
                },
                _putTemplatesToCache: function() {
                    if (!this._templateCacheEnabled) {
                        return
                    }
                    var toJSONInterceptor = function(key, value) {
                        if (value && value.element) {
                            return MARKUP_TEMPLATE_MARKER + JSON.stringify({
                                markup: value.element().prop("outerHTML"),
                                options: value.option(),
                                type: value.NAME
                            })
                        } else {
                            if ("skippedMarkup" === key) {
                                return $("<div>").append(value.clone()).html()
                            }
                        }
                        return value
                    };
                    var cacheContainer = {};
                    cacheContainer[this._templatesVersion] = {
                        templates: this._templateMap,
                        skippedMarkup: this._$skippedMarkup
                    };
                    this._templateCacheStorage.setItem(this._templateCacheKey, JSON.stringify(cacheContainer, toJSONInterceptor, 4))
                },
                init: function() {
                    var that = this;
                    this._initDefaultLayout();
                    if (!this._loadTemplatesFromCache()) {
                        that._loadTemplatesFromMarkupCore(that.$root.children());
                        return this._loadExternalTemplates().done(function() {
                            that._processTemplates();
                            that._putTemplatesToCache()
                        })
                    } else {
                        return $.Deferred().resolve().promise()
                    }
                },
                getViewTemplate: function(viewName) {
                    return this._findTemplate(viewName, _VIEW_ROLE)
                },
                getViewTemplateInfo: function(name) {
                    return this._findComponent(name, _VIEW_ROLE)
                },
                getLayoutTemplate: function(layoutName) {
                    if (!layoutName) {
                        return this._getDefaultLayoutTemplate()
                    }
                    return this._findTemplate(layoutName, _LAYOUT_ROLE)
                },
                getLayoutTemplateInfo: function(name) {
                    return this._findComponent(name, _LAYOUT_ROLE)
                },
                loadTemplates: function(source) {
                    var result;
                    if ("string" === typeof source) {
                        result = this._loadTemplatesFromURL(source)
                    } else {
                        this._loadTemplatesFromMarkupCore(source);
                        result = $.Deferred().resolve().promise()
                    }
                    return result.done($.proxy(this._processTemplates, this))
                }
            });
            exports.ViewEngine = ViewEngine
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************************!*\
      !*** ./Scripts/framework/html/widget_command_adapters.js ***!
      \***********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commandToContainer = __webpack_require__( /*! ../utils */ 84).utils.commandToContainer,
                fx = __webpack_require__( /*! ../../animation/fx */ 21),
                TransitionExecutorModule = __webpack_require__( /*! ../../animation/transition_executor/transition_executor */ 91),
                DX_COMMAND_TO_WIDGET_ADAPTER = "dxCommandToWidgetAdapter";
            var WidgetItemWrapperBase = Class.inherit({
                ctor: function(command, containerOptions) {
                    this.command = command;
                    this.widgetItem = this._createWidgetItem(command, containerOptions)
                },
                _createWidgetItem: function(command, containerOptions) {
                    var result, itemOptions = $.extend({}, containerOptions, command.option()),
                        executeCommandCallback = function(e) {
                            command.execute(e)
                        };
                    itemOptions.text = commandToContainer.resolveTextValue(command, containerOptions);
                    itemOptions.icon = commandToContainer.resolveIconValue(command, containerOptions);
                    itemOptions.type = commandToContainer.resolvePropertyValue(command, containerOptions, "type");
                    itemOptions.location = commandToContainer.resolvePropertyValue(command, containerOptions, "location");
                    itemOptions.locateInMenu = commandToContainer.resolvePropertyValue(command, containerOptions, "locateInMenu");
                    result = this._createWidgetItemCore(itemOptions, executeCommandCallback);
                    result.command = command;
                    return result
                },
                _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    return itemOptions
                },
                dispose: function() {
                    delete this.command;
                    delete this.widgetItem
                }
            });
            var WidgetAdapterBase = Class.inherit({
                ctor: function($widgetElement) {
                    this._commandToWidgetItemOptionNames = {};
                    this.$widgetElement = $widgetElement;
                    this.$widgetElement.data(DX_COMMAND_TO_WIDGET_ADAPTER, this);
                    this.widget = this._getWidgetByElement($widgetElement);
                    this._widgetWidgetContentReadyHandler = $.proxy(this._onWidgetContentReady, this);
                    this._widgetWidgetItemRenderedHandler = $.proxy(this._onWidgetItemRendered, this);
                    this._widgetDisposingHandler = $.proxy(this._onWidgetDisposing, this);
                    this.widget.on("itemRendered", this._widgetWidgetItemRenderedHandler);
                    this.widget.on("contentReady", this._widgetWidgetContentReadyHandler);
                    this.widget.on("disposing", this._widgetDisposingHandler);
                    this.itemWrappers = [];
                    this._transitionExecutor = new TransitionExecutorModule.TransitionExecutor
                },
                addCommand: function(command, containerOptions) {
                    var itemWrapper = this._createItemWrapper(command, containerOptions);
                    this.itemWrappers.push(itemWrapper);
                    this._addItemToWidget(itemWrapper);
                    this._commandChangedHandler = $.proxy(this._onCommandChanged, this);
                    itemWrapper.command.on("optionChanged", this._commandChangedHandler)
                },
                beginUpdate: function() {
                    this.widget.beginUpdate()
                },
                endUpdate: function() {
                    this.widget.endUpdate();
                    return this.animationDeferred
                },
                _onWidgetItemRendered: function(e) {
                    if (e.itemData.isJustAdded && e.itemData.command && e.itemData.command.option("visible") && this._commandRenderedAnimation) {
                        this._transitionExecutor.enter(e.itemElement, this._commandRenderedAnimation);
                        delete e.itemData.isJustAdded
                    }
                },
                _onWidgetContentReady: function(e) {
                    this.animationDeferred = this._transitionExecutor.start()
                },
                _onWidgetDisposing: function() {
                    this.dispose(true)
                },
                _setWidgetItemOption: function(optionName, optionValue, itemCommand) {
                    var items = this.widget.option("items"),
                        itemIndex = $.inArray(itemCommand, $.map(items, function(item) {
                            return item.command || {}
                        }));
                    if (itemIndex > -1) {
                        var optionPath = "items[" + itemIndex + "].";
                        if (!this._requireWidgetRefresh(optionName) && this.widget.option("items[" + itemIndex + "]").options) {
                            optionPath += "options."
                        }
                        optionPath += this._commandToWidgetItemOptionNames[optionName] || optionName;
                        this.widget.option(optionPath, optionValue)
                    }
                },
                _requireWidgetRefresh: function(optionName) {
                    return "visible" === optionName || "locateInMenu" === optionName || "location" === optionName
                },
                _onCommandChanged: function(args) {
                    if ("highlighted" === args.name || args.component.isOptionDeprecated(args.name)) {
                        return
                    }
                    this._setWidgetItemOption(args.name, args.value, args.component)
                },
                _addItemToWidget: function(itemWrapper) {
                    var items = this.widget.option("items");
                    items.push(itemWrapper.widgetItem);
                    if (this.widget.element().is(":visible")) {
                        itemWrapper.widgetItem.isJustAdded = true
                    }
                    this.widget.option("items", items)
                },
                refresh: function() {
                    var items = this.widget.option("items");
                    this.widget.option("items", items)
                },
                clear: function(widgetDisposing) {
                    var that = this;
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        itemWrapper.command.off("optionChanged", that._commandChangedHandler);
                        itemWrapper.dispose()
                    });
                    this.itemWrappers.length = 0;
                    if (!widgetDisposing) {
                        this._clearWidgetItems()
                    }
                },
                _clearWidgetItems: function() {
                    this.widget.option("items", [])
                },
                dispose: function(widgetDisposing) {
                    this.clear(widgetDisposing);
                    if (this.widget) {
                        this.widget.off("itemRendered", this._widgetWidgetItemRenderedHandler);
                        this.widget.off("contentReady", this._widgetContentReadyHandler);
                        this.widget.off("disposing", this._widgetDisposingHandler);
                        this.$widgetElement.removeData(DX_COMMAND_TO_WIDGET_ADAPTER);
                        delete this.widget;
                        delete this.$widgetElement
                    }
                }
            });
            var CommandToWidgetAdapter = Class.inherit({
                ctor: function(createAdapter) {
                    this.createAdapter = createAdapter
                },
                _getWidgetAdapter: function($container) {
                    var widgetAdapter = $container.data(DX_COMMAND_TO_WIDGET_ADAPTER);
                    if (!widgetAdapter) {
                        widgetAdapter = this.createAdapter($container)
                    }
                    return widgetAdapter
                },
                addCommand: function($container, command, containerOptions) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.addCommand(command, containerOptions)
                },
                clearContainer: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.clear()
                },
                beginUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.beginUpdate()
                },
                endUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    return widgetAdapter.endUpdate()
                }
            });
            var dxToolbarItemWrapper = WidgetItemWrapperBase.inherit({
                _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    var widgetItem;
                    itemOptions.onClick = executeCommandCallback;
                    if ("menu" === itemOptions.location || "always" === itemOptions.locateInMenu) {
                        widgetItem = itemOptions
                    } else {
                        widgetItem = {
                            locateInMenu: itemOptions.locateInMenu,
                            location: itemOptions.location,
                            visible: itemOptions.visible,
                            options: itemOptions,
                            widget: "dxButton"
                        };
                        itemOptions.visible = true;
                        delete itemOptions.location
                    }
                    return widgetItem
                }
            });
            var dxToolbarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {
                        title: "text"
                    };
                    if ("topToolbar" === this.widget.option("renderAs")) {
                        this._commandRenderedAnimation = "command-rendered-top"
                    } else {
                        this._commandRenderedAnimation = "command-rendered-bottom"
                    }
                },
                _getWidgetByElement: function($element) {
                    return $element.dxToolbar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxToolbarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.widget.option("visible", true);
                    this.callBase(command, containerOptions)
                }
            });
            var dxListItemWrapper = WidgetItemWrapperBase.inherit({
                _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    itemOptions.title = itemOptions.text;
                    itemOptions.onClick = executeCommandCallback;
                    return itemOptions
                }
            });
            var dxListAdapter = WidgetAdapterBase.inherit({
                _createItemWrapper: function(command, containerOptions) {
                    return new dxListItemWrapper(command, containerOptions)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxList("instance")
                }
            });
            var dxNavBarItemWrapper = WidgetItemWrapperBase.inherit({});
            var dxNavBarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {
                        title: "text"
                    };
                    this.widget.option("onItemClick", $.proxy(this._onNavBarItemClick, this))
                },
                _onNavBarItemClick: function(e) {
                    var items = this.widget.option("items");
                    for (var i = items.length; --i;) {
                        items[i].command.option("highlighted", false)
                    }
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxNavBar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxNavBarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if ("highlighted" === optionName && newValue) {
                        this._updateSelectedIndex()
                    }
                    this.callBase(args)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items");
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                    }
                }
            });
            var dxPivotItemWrapper = WidgetItemWrapperBase.inherit({
                _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    itemOptions.title = itemOptions.text;
                    return itemOptions
                }
            });
            var dxPivotAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this.widget.option("onSelectionChanged", $.proxy(this._onPivotSelectionChange, this))
                },
                _onPivotSelectionChange: function(e) {
                    if (e.addedItems.length && e.removedItems.length && e.addedItems[0] && e.addedItems[0].command) {
                        e.addedItems[0].command.execute(e)
                    }
                },
                _getWidgetByElement: function($element) {
                    return $element.dxPivot("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxPivotItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if ("visible" === optionName) {
                        this._rerenderPivot()
                    } else {
                        if ("highlighted" === optionName && newValue) {
                            this._updateSelectedIndex()
                        }
                    }
                    this.callBase(args)
                },
                _addItemToWidget: function(itemWrapper) {
                    if (itemWrapper.command.option("visible")) {
                        this.callBase(itemWrapper)
                    }
                },
                _updateSelectedIndex: function() {
                    var pivot = this.widget,
                        items = pivot.option("items") || [];
                    fx.off = true;
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            pivot.option("selectedIndex", i);
                            break
                        }
                    }
                    fx.off = false
                },
                _rerenderPivot: function() {
                    var that = this;
                    that.widget.option("items", []);
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        if (itemWrapper.command.option("visible")) {
                            that._addItemToWidget(itemWrapper)
                        }
                    });
                    that.refresh();
                    that._updateSelectedIndex()
                }
            });
            var dxSlideOutItemWrapper = WidgetItemWrapperBase.inherit({});
            var dxSlideOutAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {
                        title: "text"
                    };
                    this.widget.option("onItemClick", $.proxy(this._onSlideOutItemClick, this))
                },
                _onSlideOutItemClick: function(e) {
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxSlideOut("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxSlideOutItemWrapper(command, containerOptions)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items") || [];
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                    }
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if ("highlighted" === optionName && newValue) {
                        this._updateSelectedIndex()
                    }
                    this.callBase(args)
                }
            });
            exports.dxToolbar = new CommandToWidgetAdapter(function($widgetElement) {
                return new dxToolbarAdapter($widgetElement)
            });
            exports.dxList = new CommandToWidgetAdapter(function($widgetElement) {
                return new dxListAdapter($widgetElement)
            });
            exports.dxNavBar = new CommandToWidgetAdapter(function($widgetElement) {
                return new dxNavBarAdapter($widgetElement)
            });
            exports.dxPivot = new CommandToWidgetAdapter(function($widgetElement) {
                return new dxPivotAdapter($widgetElement)
            });
            exports.dxSlideOut = new CommandToWidgetAdapter(function($widgetElement) {
                return new dxSlideOutAdapter($widgetElement)
            });
            exports.WidgetItemWrapperBase = WidgetItemWrapperBase;
            exports.WidgetAdapterBase = WidgetAdapterBase
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************************!*\
      !*** ./Scripts/integration/knockout/template_provider.js ***!
      \***********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                templateProvider = __webpack_require__( /*! ../../ui/widget/jquery.template_provider */ 160),
                KoTemplate = __webpack_require__( /*! ./template */ 293),
                defaultTemplates = __webpack_require__( /*! ./default_templates */ 291);
            var KoTemplateProvider = templateProvider.constructor.inherit({
                createTemplate: function(element, owner) {
                    return new KoTemplate(element, owner)
                },
                applyTemplate: function(element, model) {
                    ko.applyBindings(model, element)
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName];
                    if (!templateGenerators) {
                        return this.callBase(widgetName)
                    }
                    var templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        var $markup = domUtils.createMarkupFromString(generator());
                        if ("itemFrame" !== name) {
                            $markup = $markup.contents()
                        }
                        templates[name] = new KoTemplate($markup, koTemplateProvider)
                    });
                    return templates
                }
            });
            var koTemplateProvider = new KoTemplateProvider;
            module.exports = koTemplateProvider
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/localization/core.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {}.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************************************!*\
      !*** ./Scripts/mobile/init_mobile_viewport/init_mobile_viewport.js ***!
      \*********************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                resizeCallbacks = __webpack_require__( /*! ../../core/utils/window */ 57).resizeCallbacks,
                support = __webpack_require__( /*! ../../core/utils/support */ 18),
                devices = __webpack_require__( /*! ../../core/devices */ 7);
            var initMobileViewport = function(options) {
                options = $.extend({}, options);
                var realDevice = devices.real();
                var allowZoom = options.allowZoom;
                var allowPan = options.allowPan;
                var allowSelection = "allowSelection" in options ? options.allowSelection : "generic" === realDevice.platform;
                var metaSelector = "meta[name=viewport]";
                if (!$(metaSelector).length) {
                    $("<meta />").attr("name", "viewport").appendTo("head")
                }
                var metaVerbs = ["width=device-width"],
                    msTouchVerbs = [];
                if (allowZoom) {
                    msTouchVerbs.push("pinch-zoom")
                } else {
                    metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no")
                }
                if (allowPan) {
                    msTouchVerbs.push("pan-x", "pan-y")
                }
                if (!allowPan && !allowZoom) {
                    $("html, body").css({
                        "-ms-content-zooming": "none",
                        "-ms-user-select": "none",
                        overflow: "hidden"
                    })
                } else {
                    $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar")
                }
                if (!allowSelection && support.supportProp("user-select")) {
                    $(".dx-viewport").css(support.styleProp("user-select"), "none")
                }
                $(metaSelector).attr("content", metaVerbs.join());
                $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
                realDevice = devices.real();
                if (support.touch && !("win" === realDevice.platform && 10 === realDevice.version[0])) {
                    $(document).off(".dxInitMobileViewport").on("dxpointermove.dxInitMobileViewport", function(e) {
                        var count = e.pointers.length,
                            isTouchEvent = "touch" === e.pointerType,
                            zoomDisabled = !allowZoom && count > 1,
                            panDisabled = !allowPan && 1 === count && !e.isScrollingEvent;
                        if (isTouchEvent && (zoomDisabled || panDisabled)) {
                            e.preventDefault()
                        }
                    })
                }
                if (realDevice.ios) {
                    var isPhoneGap = "file:" === document.location.protocol;
                    if (!isPhoneGap) {
                        resizeCallbacks.add(function() {
                            var windowWidth = $(window).width();
                            $("body").width(windowWidth)
                        })
                    }
                }
                if (realDevice.android) {
                    resizeCallbacks.add(function() {
                        setTimeout(function() {
                            document.activeElement.scrollIntoViewIfNeeded()
                        })
                    })
                }
            };
            exports.initMobileViewport = initMobileViewport
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/mobile/process_hardware_back_button.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                hardwareBack = $.Callbacks();
            module.exports = function() {
                hardwareBack.fire()
            };
            module.exports.processCallback = hardwareBack
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, ,
    /*!***********************************************!*\
      !*** ./Scripts/bundles/modules/parts/core.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var DevExpress = __webpack_require__( /*! ../../../bundles/modules/core */ 97);
            DevExpress.framework = __webpack_require__( /*! ../../../bundles/modules/framework */ 267);
            __webpack_require__( /*! ../../../integration/angular */ 279);
            __webpack_require__( /*! ../../../integration/knockout */ 85);
            __webpack_require__( /*! ../../../localization/globalize/core */ 86);
            __webpack_require__( /*! ../../../localization/globalize/message */ 302);
            __webpack_require__( /*! ../../../localization/globalize/number */ 152);
            __webpack_require__( /*! ../../../localization/globalize/date */ 301);
            __webpack_require__( /*! ../../../localization/globalize/currency */ 300);
            __webpack_require__( /*! ../../../events/click */ 9);
            __webpack_require__( /*! ../../../events/contextmenu */ 173);
            __webpack_require__( /*! ../../../events/dblclick */ 178);
            __webpack_require__( /*! ../../../events/drag */ 62);
            __webpack_require__( /*! ../../../events/hold */ 63);
            __webpack_require__( /*! ../../../events/hover */ 133);
            __webpack_require__( /*! ../../../events/pointer */ 13);
            __webpack_require__( /*! ../../../events/swipe */ 82);
            __webpack_require__( /*! ../../../events/transform */ 278);
            module.exports = DevExpress
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/ui/widget/jquery.template.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../../core/errors */ 10),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
            var templateEngines = {};
            var registerTemplateEngine = function(name, templateEngine) {
                templateEngines[name] = templateEngine
            };
            var outerHtml = function(element) {
                element = $(element);
                var templateTag = element.length && element[0].nodeName.toLowerCase();
                if ("script" === templateTag) {
                    return element.html()
                } else {
                    element = $("<div>").append(element);
                    return element.html()
                }
            };
            registerTemplateEngine("default", {
                compile: function(element) {
                    return domUtils.normalizeTemplateElement(element)
                },
                render: function(template, data) {
                    return template.clone()
                }
            });
            registerTemplateEngine("jquery-tmpl", {
                compile: function(element) {
                    return outerHtml(element)
                },
                render: function(template, data) {
                    return $.tmpl(template, data)
                }
            });
            registerTemplateEngine("jsrender", {
                compile: function(element) {
                    return $.templates(outerHtml(element))
                },
                render: function(template, data) {
                    return template.render(data)
                }
            });
            registerTemplateEngine("mustache", {
                compile: function(element) {
                    return Mustache.compile(outerHtml(element))
                },
                render: function(template, data) {
                    return template(data)
                }
            });
            registerTemplateEngine("hogan", {
                compile: function(element) {
                    return Hogan.compile(outerHtml(element))
                },
                render: function(template, data) {
                    return template.render(data)
                }
            });
            registerTemplateEngine("underscore", {
                compile: function(element) {
                    return _.template(outerHtml(element))
                },
                render: function(template, data) {
                    return template(data)
                }
            });
            registerTemplateEngine("handlebars", {
                compile: function(element) {
                    return Handlebars.compile(outerHtml(element))
                },
                render: function(template, data) {
                    return template(data)
                }
            });
            registerTemplateEngine("doT", {
                compile: function(element) {
                    return doT.template(outerHtml(element))
                },
                render: function(template, data) {
                    return template(data)
                }
            });
            var currentTemplateEngine;
            var setTemplateEngine = function(templateEngine) {
                if (commonUtils.isString(templateEngine)) {
                    currentTemplateEngine = templateEngines[templateEngine];
                    if (!currentTemplateEngine) {
                        throw errors.Error("E0020", templateEngine)
                    }
                } else {
                    currentTemplateEngine = templateEngine
                }
            };
            setTemplateEngine("default");
            var Template = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this._compiledTemplate = currentTemplateEngine.compile(element)
                },
                _renderCore: function(data) {
                    return $("<div>").append(currentTemplateEngine.render(this._compiledTemplate, data)).contents()
                }
            });
            module.exports = Template;
            module.exports.setTemplateEngine = setTemplateEngine
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , ,
    /*!********************************************!*\
      !*** ./Scripts/viz/axes/axes_constants.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _map = __webpack_require__( /*! ../core/utils */ 6).map,
                _format = __webpack_require__( /*! ../core/format */ 162);

            function getFormatObject(value, options, axisMinMax, point) {
                var formatObject = {
                    value: value,
                    valueText: _format(value, options) || ""
                };
                if (axisMinMax) {
                    formatObject.min = axisMinMax.min;
                    formatObject.max = axisMinMax.max
                }
                if (point) {
                    formatObject.point = point
                }
                return formatObject
            }
            module.exports = {
                logarithmic: "logarithmic",
                discrete: "discrete",
                numeric: "numeric",
                left: "left",
                right: "right",
                top: "top",
                bottom: "bottom",
                center: "center",
                canvasPositionPrefix: "canvas_position_",
                canvasPositionTop: "canvas_position_top",
                canvasPositionBottom: "canvas_position_bottom",
                canvasPositionLeft: "canvas_position_left",
                canvasPositionRight: "canvas_position_right",
                canvasPositionStart: "canvas_position_start",
                canvasPositionEnd: "canvas_position_end",
                horizontal: "horizontal",
                vertical: "vertical",
                convertTicksToValues: function(ticks) {
                    return _map(ticks || [], function(item) {
                        return item.value
                    })
                },
                convertValuesToTicks: function(values) {
                    return _map(values || [], function(item) {
                        return {
                            value: item
                        }
                    })
                },
                validateOverlappingMode: function(mode) {
                    return "ignore" !== mode ? "enlargeTickInterval" : "ignore"
                },
                formatLabel: function(value, options, axisMinMax, point) {
                    var formatObject = getFormatObject(value, options, axisMinMax, point);
                    return $.isFunction(options.customizeText) ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText
                },
                formatHint: function(value, options, axisMinMax) {
                    var formatObject = getFormatObject(value, options, axisMinMax);
                    return $.isFunction(options.customizeHint) ? options.customizeHint.call(formatObject, formatObject) : void 0
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/viz/axes/base_axis.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var Axis, $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                constants = __webpack_require__( /*! ./axes_constants */ 230),
                parseUtils = __webpack_require__( /*! ../components/parse_utils */ 234),
                tickManagerModule = __webpack_require__( /*! ./base_tick_manager */ 325),
                formatLabel = constants.formatLabel,
                convertTicksToValues = constants.convertTicksToValues,
                convertValuesToTicks = constants.convertValuesToTicks,
                _isDefined = commonUtils.isDefined,
                _isNumber = commonUtils.isNumber,
                _getSignificantDigitPosition = vizUtils.getSignificantDigitPosition,
                _roundValue = vizUtils.roundValue,
                patchFontOptions = vizUtils.patchFontOptions,
                _math = Math,
                _abs = _math.abs,
                _round = _math.round,
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop,
                DEFAULT_AXIS_LABEL_SPACING = 5,
                MAX_GRID_BORDER_ADHENSION = 4,
                LABEL_BACKGROUND_PADDING_X = 8,
                LABEL_BACKGROUND_PADDING_Y = 4;

            function hasCategories(range) {
                return range.categories && range.categories.length
            }

            function validateAxisOptions(options) {
                var labelOptions = options.label,
                    position = options.position,
                    defaultPosition = options.isHorizontal ? constants.bottom : constants.left,
                    secondaryPosition = options.isHorizontal ? constants.top : constants.right;
                if (position !== defaultPosition && position !== secondaryPosition) {
                    position = defaultPosition
                }
                if (position === constants.right && !labelOptions.userAlignment) {
                    labelOptions.alignment = constants.left
                }
                options.position = position;
                options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : "none";
                labelOptions.minSpacing = _isDefined(labelOptions.minSpacing) ? labelOptions.minSpacing : DEFAULT_AXIS_LABEL_SPACING
            }

            function findSkippedIndexCategory(ticks, skippedCategory) {
                var i = ticks.length;
                if (void 0 !== skippedCategory) {
                    while (i--) {
                        if (ticks[i].value === skippedCategory) {
                            return i
                        }
                    }
                }
                return -1
            }
            Axis = exports.Axis = function(renderSettings) {
                var that = this;
                that._renderer = renderSettings.renderer;
                that._incidentOccurred = renderSettings.incidentOccurred;
                that._stripsGroup = renderSettings.stripsGroup;
                that._labelAxesGroup = renderSettings.labelAxesGroup;
                that._constantLinesGroup = renderSettings.constantLinesGroup;
                that._axesContainerGroup = renderSettings.axesContainerGroup;
                that._gridContainerGroup = renderSettings.gridGroup;
                that._axisCssPrefix = renderSettings.widgetClass + "-" + (renderSettings.axisClass ? renderSettings.axisClass + "-" : "");
                that._setType(renderSettings.axisType, renderSettings.drawingType);
                that._createAxisGroups();
                that._tickManager = that._createTickManager()
            };
            Axis.prototype = {
                constructor: Axis,
                _updateIntervalAndBounds: function() {
                    var i, ticks, length, minInterval, bounds, that = this,
                        translator = that._translator,
                        businessRange = translator.getBusinessRange();
                    if (!hasCategories(businessRange)) {
                        ticks = that.getMajorTicks(true);
                        length = ticks.length;
                        if (!businessRange.isSynchronized) {
                            bounds = this._tickManager.getTickBounds()
                        }
                        if (length > 1) {
                            minInterval = _abs(ticks[0].value - ticks[1].value);
                            for (i = 1; i < length - 1; i++) {
                                minInterval = Math.min(_abs(ticks[i].value - ticks[i + 1].value), minInterval)
                            }
                            bounds = _extend({
                                interval: minInterval
                            }, bounds)
                        }
                        if (bounds) {
                            businessRange.addRange(bounds);
                            translator.reinit()
                        }
                    }
                },
                _createAllTicks: function(businessRange) {
                    var that = this;
                    that._boundaryTicks = that._getBoundaryTicks();
                    that._majorTicks = that.getMajorTicks(that._options.withoutOverlappingBehavior);
                    that._decimatedTicks = hasCategories(businessRange) || "semidiscrete" === that._options.type ? that.getDecimatedTicks() : [];
                    that._minorTicks = that.getMinorTicks()
                },
                _drawAxis: function() {
                    var that = this,
                        options = that._options,
                        axis = that._createAxis({
                            "stroke-width": options.width,
                            stroke: options.color,
                            "stroke-opacity": options.opacity
                        });
                    axis.append(that._axisLineGroup)
                },
                _correctMinForTicks: function(min, max, screenDelta) {
                    var correctingValue, digitPosition = _getSignificantDigitPosition(_abs(max - min) / screenDelta),
                        newMin = _roundValue(Number(min), digitPosition);
                    if (newMin < min) {
                        correctingValue = _math.pow(10, -digitPosition);
                        newMin = vizUtils.applyPrecisionByMinDelta(newMin, correctingValue, newMin + correctingValue)
                    }
                    if (newMin > max) {
                        newMin = min
                    }
                    return newMin
                },
                _getTickManagerData: function() {
                    var that = this,
                        options = that._options,
                        screenDelta = that._getScreenDelta(),
                        min = that._minBound,
                        max = that._maxBound,
                        categories = that._translator.getVisibleCategories() || that._translator.getBusinessRange().categories,
                        customTicks = options.customTicks || (hasCategories({
                            categories: categories
                        }) ? categories : that._majorTicks && that._majorTicks.length && convertTicksToValues(that._majorTicks)),
                        customMinorTicks = options.customMinorTicks || that._minorTicks && that._minorTicks.length && convertTicksToValues(that._minorTicks);
                    if (_isNumber(min) && options.type !== constants.logarithmic) {
                        min = that._correctMinForTicks(min, max, screenDelta)
                    }
                    return {
                        min: min,
                        max: max,
                        customTicks: customTicks,
                        customMinorTicks: customMinorTicks,
                        customBoundTicks: options.customBoundTicks,
                        screenDelta: screenDelta
                    }
                },
                _getTickManagerTypes: function() {
                    return {
                        axisType: this._options.type,
                        dataType: this._options.dataType
                    }
                },
                _getTicksOptions: function() {
                    var options = this._options;
                    return {
                        base: options.type === constants.logarithmic ? options.logarithmBase : void 0,
                        tickInterval: this._translator.getBusinessRange().stubData ? null : options.tickInterval,
                        gridSpacingFactor: options.axisDivisionFactor,
                        minorGridSpacingFactor: options.minorAxisDivisionFactor,
                        numberMultipliers: options.numberMultipliers,
                        incidentOccurred: options.incidentOccurred,
                        setTicksAtUnitBeginning: options.setTicksAtUnitBeginning,
                        showMinorTicks: options.minorTick.visible || options.minorGrid.visible,
                        minorTickInterval: options.minorTickInterval,
                        minorTickCount: options.minorTickCount,
                        useTicksAutoArrangement: options.useTicksAutoArrangement,
                        showCalculatedTicks: options.tick.showCalculatedTicks,
                        showMinorCalculatedTicks: options.minorTick.showCalculatedTicks
                    }
                },
                _getBoundaryTicks: function() {
                    var categories = this._translator.getVisibleCategories() || this._translator.getBusinessRange().categories,
                        boundaryValues = hasCategories({
                            categories: categories
                        }) && this._tickOffset ? [categories[0], categories[categories.length - 1]] : this._tickManager.getBoundaryTicks();
                    return convertValuesToTicks(boundaryValues)
                },
                _createTickManager: function() {
                    return new tickManagerModule.TickManager({}, {}, {
                        overlappingBehaviorType: this._overlappingBehaviorType
                    })
                },
                _getMarginsOptions: function() {
                    var range = this._translator.getBusinessRange();
                    return {
                        stick: range.stick || this._options.stick,
                        minStickValue: range.minStickValue,
                        maxStickValue: range.maxStickValue,
                        percentStick: range.percentStick,
                        minValueMargin: this._options.minValueMargin,
                        maxValueMargin: this._options.maxValueMargin,
                        minSpaceCorrection: range.minSpaceCorrection,
                        maxSpaceCorrection: range.maxSpaceCorrection
                    }
                },
                _updateTickManager: function() {
                    var options, overlappingOptions = this._getOverlappingBehaviorOptions();
                    options = _extend(true, this._getMarginsOptions(), overlappingOptions, this._getTicksOptions());
                    this._tickManager.update(this._getTickManagerTypes(), this._getTickManagerData(), options)
                },
                _correctLabelAlignment: function() {
                    var that = this,
                        labelOptions = that._options.label,
                        overlappingBehavior = that._tickManager.getOverlappingBehavior();
                    if (overlappingBehavior && "rotate" === overlappingBehavior.mode) {
                        that._textOptions.rotate = overlappingBehavior.rotationAngle;
                        if (!labelOptions.userAlignment) {
                            that._textOptions.align = constants.left
                        }
                    } else {
                        if (!labelOptions.userAlignment) {
                            that._textOptions.align = labelOptions.alignment
                        }
                    }
                },
                _correctLabelFormat: function() {
                    this._options.label = this._tickManager.getOptions().labelOptions
                },
                _deleteLabels: function() {
                    this._axisElementsGroup && this._axisElementsGroup.clear()
                },
                _drawTicks: function(ticks) {
                    var that = this,
                        group = that._axisLineGroup;
                    _each(ticks || [], function(_, tick) {
                        var points, coord = that._getTickCoord(tick);
                        if (coord) {
                            points = that._isHorizontal ? [coord.x1, coord.y1, coord.x2, coord.y2] : [coord.y1, coord.x1, coord.y2, coord.x2];
                            tick.graphic = that._createPathElement(points, tick.tickStyle).append(group);
                            coord.angle && that._rotateTick(tick, coord.angle)
                        }
                    })
                },
                _createPathElement: function(points, attr) {
                    return this._renderer.path(points, "line").attr(attr).sharp(this._getSharpParam())
                },
                _createAxis: function(options) {
                    return this._createAxisElement().attr(options).sharp(this._getSharpParam(true))
                },
                _drawLabels: function() {
                    var that = this,
                        renderer = that._renderer,
                        group = that._axisElementsGroup,
                        emptyStrRegExp = /^\s+$/;
                    _each(that._majorTicks, function(_, tick) {
                        var xCoord, yCoord, text = tick.labelText;
                        if (_isDefined(text) && "" !== text && !emptyStrRegExp.test(text)) {
                            xCoord = that._isHorizontal ? tick.labelPos.x : tick.labelPos.y;
                            yCoord = that._isHorizontal ? tick.labelPos.y : tick.labelPos.x;
                            if (!tick.label) {
                                tick.label = renderer.text(text, xCoord, yCoord).css(tick.labelFontStyle).attr(tick.labelStyle).append(group)
                            } else {
                                tick.label.css(tick.labelFontStyle).attr(tick.labelStyle).attr({
                                    text: text,
                                    x: xCoord,
                                    y: yCoord
                                })
                            }
                            tick.label.data({
                                "chart-data-argument": tick.value
                            })
                        }
                    })
                },
                _getGridLineDrawer: function(borderOptions) {
                    var that = this,
                        translator = that._translator,
                        additionalTranslator = that._additionalTranslator,
                        isHorizontal = that._isHorizontal,
                        canvasStart = isHorizontal ? constants.left : constants.top,
                        canvasEnd = isHorizontal ? constants.right : constants.bottom,
                        positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
                        positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd),
                        firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? translator.translateSpecialCase(constants.canvasPositionPrefix + canvasStart) : void 0,
                        lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? translator.translateSpecialCase(constants.canvasPositionPrefix + canvasEnd) : void 0,
                        getPoints = isHorizontal ? function(tick) {
                            return null !== tick.posX ? [tick.posX, positionFrom, tick.posX, positionTo] : null
                        } : function(tick) {
                            return null !== tick.posX ? [positionFrom, tick.posX, positionTo, tick.posX] : null
                        },
                        minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition,
                        maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;
                    return function(tick) {
                        if (void 0 === tick.posX || tick.posX < minDelta || tick.posX > maxDelta) {
                            return
                        }
                        var points = getPoints(tick);
                        return points && that._createPathElement(points, tick.gridStyle)
                    }
                },
                _drawGrids: function(ticks, borderOptions) {
                    var tick, that = this,
                        group = that._axisGridGroup,
                        i = 0,
                        length = ticks.length,
                        drawLine = that._getGridLineDrawer(borderOptions || {
                            visible: false
                        });
                    for (i; i < length; i++) {
                        tick = ticks[i];
                        tick.grid = drawLine(tick);
                        tick.grid && tick.grid.append(group)
                    }
                },
                _getConstantLinePos: function(lineValue, canvasStart, canvasEnd) {
                    var parsedValue = this._validateUnit(lineValue, "E2105", "constantLine"),
                        value = this._getTranslatedCoord(parsedValue);
                    if (!_isDefined(value) || value < _math.min(canvasStart, canvasEnd) || value > _math.max(canvasStart, canvasEnd)) {
                        return {}
                    }
                    return {
                        value: value,
                        parsedValue: parsedValue
                    }
                },
                _createConstantLine: function(value, attr) {
                    var that = this,
                        additionalTranslator = this._additionalTranslator,
                        positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
                        positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd),
                        points = this._isHorizontal ? [value, positionTo, value, positionFrom] : [positionFrom, value, positionTo, value];
                    return that._createPathElement(points, attr)
                },
                _drawConstantLinesAndLabels: function(lineOptions, canvasStart, canvasEnd) {
                    if (!_isDefined(lineOptions.value)) {
                        return
                    }
                    var that = this,
                        pos = that._getConstantLinePos(lineOptions.value, canvasStart, canvasEnd),
                        labelOptions = lineOptions.label || {},
                        value = pos.value,
                        attr = {
                            stroke: lineOptions.color,
                            "stroke-width": lineOptions.width,
                            dashStyle: lineOptions.dashStyle
                        };
                    if (!_isDefined(value)) {
                        that._constantLines.push(null);
                        if (labelOptions.visible) {
                            that._constantLineLabels.push(null)
                        }
                        return
                    }
                    that._constantLines.push(that._createConstantLine(value, attr).append(that._axisConstantLineGroup));
                    that._constantLineLabels.push(labelOptions.visible ? that._drawConstantLineLabels(pos.parsedValue, labelOptions, value) : null)
                },
                _drawConstantLine: function() {
                    var that = this,
                        options = that._options,
                        data = options.constantLines,
                        canvas = that._getCanvasStartEnd();
                    if (that._translator.getBusinessRange().stubData) {
                        return
                    }
                    that._constantLines = [];
                    that._constantLineLabels = [];
                    _each(data, function(_, dataItem) {
                        that._drawConstantLinesAndLabels(dataItem, canvas.start, canvas.end)
                    })
                },
                _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value) {
                    var coords, that = this,
                        text = lineLabelOptions.text,
                        options = that._options,
                        labelOptions = options.label;
                    that._checkAlignmentConstantLineLabels(lineLabelOptions);
                    text = _isDefined(text) ? text : formatLabel(parsedValue, labelOptions);
                    coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
                    return that._renderer.text(text, coords.x, coords.y).css(patchFontOptions(_extend({}, labelOptions.font, lineLabelOptions.font))).attr({
                        align: coords.align
                    }).append(that._axisConstantLineGroup)
                },
                _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {
                    var start, end, startCategoryIndex, endCategoryIndex, isContinuous = !!(range.minVisible || range.maxVisible),
                        categories = range.categories || [],
                        firstValue = startValue,
                        lastValue = endValue,
                        min = range.minVisible;
                    if (!isContinuous) {
                        startCategoryIndex = $.inArray(startValue, categories);
                        endCategoryIndex = $.inArray(endValue, categories);
                        if (-1 === startCategoryIndex || -1 === endCategoryIndex) {
                            return {
                                stripFrom: 0,
                                stripTo: 0
                            }
                        }
                        if (startCategoryIndex > endCategoryIndex) {
                            firstValue = endValue;
                            lastValue = startValue
                        }
                    }
                    firstValue = this._validateUnit(firstValue, "E2105", "strip");
                    lastValue = this._validateUnit(lastValue, "E2105", "strip");
                    start = this._getTranslatedCoord(firstValue, -1);
                    end = this._getTranslatedCoord(lastValue, 1);
                    if (!_isDefined(start) && isContinuous) {
                        start = firstValue < min ? canvasStart : canvasEnd
                    }
                    if (!_isDefined(end) && isContinuous) {
                        end = lastValue < min ? canvasStart : canvasEnd
                    }
                    return start < end ? {
                        stripFrom: start,
                        stripTo: end
                    } : {
                        stripFrom: end,
                        stripTo: start
                    }
                },
                _createStrip: function(fromPoint, toPoint, attr) {
                    var x, y, width, height, additionalTranslator = this._additionalTranslator,
                        positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
                        positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd);
                    if (this._isHorizontal) {
                        x = fromPoint;
                        y = _math.min(positionFrom, positionTo);
                        width = toPoint - fromPoint;
                        height = _abs(positionFrom - positionTo)
                    } else {
                        x = _math.min(positionFrom, positionTo);
                        y = fromPoint;
                        width = _abs(positionFrom - positionTo);
                        height = _abs(fromPoint - toPoint)
                    }
                    return this._renderer.rect(x, y, width, height).attr(attr)
                },
                _drawStrip: function() {
                    var i, stripOptions, stripPos, stripLabelOptions, attr, that = this,
                        options = that._options,
                        stripData = options.strips,
                        canvas = this._getCanvasStartEnd(),
                        range = that._translator.getBusinessRange();
                    if (range.stubData) {
                        return
                    }
                    that._strips = [];
                    that._stripLabels = [];
                    for (i = 0; i < stripData.length; i++) {
                        stripOptions = stripData[i];
                        stripLabelOptions = stripOptions.label || {};
                        attr = {
                            fill: stripOptions.color
                        };
                        if (_isDefined(stripOptions.startValue) && _isDefined(stripOptions.endValue) && _isDefined(stripOptions.color)) {
                            stripPos = that._getStripPos(stripOptions.startValue, stripOptions.endValue, canvas.start, canvas.end, range);
                            if (stripPos.stripTo - stripPos.stripFrom === 0 || !_isDefined(stripPos.stripTo) || !_isDefined(stripPos.stripFrom)) {
                                that._strips.push(null);
                                if (stripLabelOptions.text) {
                                    that._stripLabels.push(null)
                                }
                                continue
                            }
                            that._strips.push(that._createStrip(stripPos.stripFrom, stripPos.stripTo, attr).append(that._axisStripGroup));
                            that._stripLabels.push(stripLabelOptions.text ? that._drawStripLabel(stripLabelOptions, stripPos.stripFrom, stripPos.stripTo) : null)
                        }
                    }
                },
                _drawStripLabel: function(stripLabelOptions, stripFrom, stripTo) {
                    var that = this,
                        options = that._options,
                        coords = that._getStripLabelCoords(stripLabelOptions, stripFrom, stripTo);
                    return that._renderer.text(stripLabelOptions.text, coords.x, coords.y).css(patchFontOptions(_extend({}, options.label.font, stripLabelOptions.font))).attr({
                        align: coords.align
                    }).append(that._axisLabelGroup)
                },
                _adjustStripLabels: function() {
                    var i, coords, that = this,
                        labels = that._stripLabels,
                        rects = that._strips;
                    if (void 0 === labels && void 0 === rects) {
                        return
                    }
                    for (i = 0; i < labels.length; i++) {
                        if (null !== labels[i]) {
                            coords = that._getAdjustedStripLabelCoords(that._options.strips[i], labels[i], rects[i]);
                            labels[i].move(coords.x, coords.y)
                        }
                    }
                },
                _adjustLabels: function() {
                    var label, labelHeight, isNeedLabelAdjustment, staggeringSpacing, i, box, that = this,
                        options = that._options,
                        majorTicks = that._majorTicks,
                        majorTicksLength = majorTicks.length,
                        isHorizontal = that._isHorizontal,
                        overlappingBehavior = that._tickManager ? that._tickManager.getOverlappingBehavior() : options.label.overlappingBehavior,
                        position = options.position,
                        hasLabels = false,
                        boxAxis = that._axisElementsGroup && that._axisElementsGroup.getBBox() || {};
                    _each(majorTicks, function(_, tick) {
                        if (tick.label) {
                            tick.label.attr(that._getLabelAdjustedCoord(tick, boxAxis));
                            hasLabels = true
                        }
                    });
                    isNeedLabelAdjustment = hasLabels && isHorizontal && overlappingBehavior && "stagger" === overlappingBehavior.mode;
                    if (isNeedLabelAdjustment) {
                        labelHeight = 0;
                        for (i = 0; i < majorTicksLength; i += 2) {
                            label = majorTicks[i].label;
                            box = label && label.getBBox() || {};
                            if (box.height > labelHeight) {
                                labelHeight = box.height
                            }
                        }
                        staggeringSpacing = overlappingBehavior.staggeringSpacing;
                        labelHeight = _round(labelHeight) + staggeringSpacing;
                        for (i = 1; i < majorTicksLength; i += 2) {
                            label = majorTicks[i].label;
                            if (label) {
                                if (position === constants.bottom) {
                                    label.move(0, labelHeight)
                                } else {
                                    if (position === constants.top) {
                                        label.move(0, -labelHeight)
                                    }
                                }
                            }
                        }
                        for (i = 0; i < majorTicksLength; i++) {
                            majorTicks[i].label && majorTicks[i].label.rotate(0)
                        }
                    }
                },
                _getLabelAdjustedCoord: function(tick, boxAxis) {
                    var x, y, that = this,
                        options = that._options,
                        box = tick.label.getBBox(),
                        isHorizontal = that._isHorizontal,
                        position = options.position,
                        shift = that.padding && that.padding[position] || 0,
                        textOptions = that._textOptions,
                        labelSettingsY = tick.label.attr("y");
                    if (isHorizontal && position === constants.bottom) {
                        y = 2 * labelSettingsY - box.y + shift
                    } else {
                        if (!isHorizontal) {
                            if (position === constants.left) {
                                if (textOptions.align === constants.right) {
                                    x = box.x + box.width - shift
                                } else {
                                    if (textOptions.align === constants.center) {
                                        x = box.x + box.width / 2 - shift - (boxAxis.width / 2 || 0)
                                    } else {
                                        x = box.x - shift - (boxAxis.width || 0)
                                    }
                                }
                            } else {
                                if (textOptions.align === constants.center) {
                                    x = box.x + box.width / 2 + (boxAxis.width / 2 || 0) + shift
                                } else {
                                    if (textOptions.align === constants.right) {
                                        x = box.x + box.width + (boxAxis.width || 0) + shift
                                    } else {
                                        x = box.x + shift
                                    }
                                }
                            }
                            y = labelSettingsY + ~~(labelSettingsY - box.y - box.height / 2)
                        } else {
                            if (isHorizontal && position === constants.top) {
                                y = 2 * labelSettingsY - box.y - box.height - shift
                            }
                        }
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _createAxisGroups: function() {
                    var that = this,
                        renderer = that._renderer,
                        classSelector = that._axisCssPrefix;
                    that._axisGroup = renderer.g().attr({
                        "class": classSelector + "axis"
                    });
                    that._axisStripGroup = renderer.g().attr({
                        "class": classSelector + "strips"
                    });
                    that._axisGridGroup = renderer.g().attr({
                        "class": classSelector + "grid"
                    });
                    that._axisElementsGroup = renderer.g().attr({
                        "class": classSelector + "elements"
                    }).append(that._axisGroup);
                    that._axisLineGroup = renderer.g().attr({
                        "class": classSelector + "line"
                    }).append(that._axisGroup);
                    that._axisTitleGroup = renderer.g().attr({
                        "class": classSelector + "title"
                    }).append(that._axisGroup);
                    that._axisConstantLineGroup = renderer.g().attr({
                        "class": classSelector + "constant-lines"
                    });
                    that._axisLabelGroup = renderer.g().attr({
                        "class": classSelector + "axis-labels"
                    })
                },
                _clearAxisGroups: function(adjustAxis) {
                    var that = this,
                        classSelector = that._axisCssPrefix;
                    that._axisGroup.remove();
                    that._axisStripGroup.remove();
                    that._axisLabelGroup.remove();
                    that._axisConstantLineGroup.remove();
                    that._axisGridGroup.remove();
                    if (that._axisTitleGroup) {
                        that._axisTitleGroup.clear()
                    } else {
                        if (!adjustAxis) {
                            that._axisTitleGroup = that._renderer.g().attr({
                                "class": classSelector + "title"
                            }).append(that._axisGroup)
                        }
                    }
                    if (that._axisElementsGroup) {
                        that._axisElementsGroup.clear()
                    } else {
                        if (!adjustAxis) {
                            that._axisElementsGroup = that._renderer.g().attr({
                                "class": classSelector + "elements"
                            }).append(that._axisGroup)
                        }
                    }
                    that._axisLineGroup && that._axisLineGroup.clear();
                    that._axisStripGroup && that._axisStripGroup.clear();
                    that._axisGridGroup && that._axisGridGroup.clear();
                    that._axisConstantLineGroup && that._axisConstantLineGroup.clear();
                    that._axisLabelGroup && that._axisLabelGroup.clear()
                },
                _initTickCoord: function(tick, offset) {
                    var coord = this._getTranslatedValue(tick.value, this._axisPosition, offset);
                    tick.posX = coord.x;
                    tick.posY = coord.y;
                    tick.angle = coord.angle
                },
                _initTickStyle: function(tick, style) {
                    tick.length = style.length;
                    tick.tickStyle = tick.withoutPath ? {
                        stroke: "none",
                        "stroke-width": 0,
                        "stroke-opacity": 0
                    } : style.tickStyle;
                    tick.gridStyle = style.gridStyle
                },
                _initTickLabel: function(tick, position) {
                    var that = this,
                        customizeColor = that._options.label.customizeColor;
                    tick.labelText = formatLabel(tick.value, that._options.label, {
                        min: that._minBound,
                        max: that._maxBound
                    });
                    tick.labelPos = that._getTranslatedValue(tick.value, position);
                    tick.labelStyle = that._textOptions;
                    tick.labelFontStyle = _extend({}, that._textFontStyles);
                    if (customizeColor && customizeColor.call) {
                        tick.labelFontStyle.fill = customizeColor.call(tick, tick)
                    }
                    tick.labelHint = constants.formatHint(tick.value, that._options.label, {
                        min: that._minBound,
                        max: that._maxBound
                    })
                },
                _getTickStyle: function(tickOptions, gridOptions) {
                    return {
                        tickStyle: {
                            stroke: tickOptions.color,
                            "stroke-width": tickOptions.width,
                            "stroke-opacity": tickOptions.opacity
                        },
                        gridStyle: {
                            stroke: gridOptions.color,
                            "stroke-width": gridOptions.width,
                            "stroke-opacity": gridOptions.opacity
                        },
                        length: tickOptions.length
                    }
                },
                _initTicks: function(ticks, style, withLabels, skippedCategory, offset, labelPosition) {
                    var tick, that = this,
                        i = 0,
                        length = ticks.length,
                        indexSkippedCategory = findSkippedIndexCategory(ticks, skippedCategory);
                    for (i; i < length; i++) {
                        tick = ticks[i];
                        i !== indexSkippedCategory && that._initTickCoord(tick, offset);
                        that._initTickStyle(tick, style);
                        withLabels && !tick.withoutLabel && that._initTickLabel(tick, labelPosition)
                    }
                },
                _initAllTicks: function() {
                    var that = this,
                        options = that._options,
                        majorTickStyle = that._getTickStyle(options.tick, options.grid),
                        minorTickStyle = that._getTickStyle(options.minorTick, options.minorGrid),
                        skippedCategory = that._getSkippedCategory(),
                        boundaryTicks = this._boundaryTicks,
                        withLabels = options.label.visible && that._axisElementsGroup && !that._translator.getBusinessRange().stubData,
                        labelPosition = that.getLabelsParams().pos,
                        offset = that._tickOffset;
                    that._initTicks(that._majorTicks, majorTickStyle, withLabels, skippedCategory, offset, labelPosition);
                    that._initTicks(that._minorTicks, minorTickStyle, false, void 0, offset);
                    that._initTicks(that._decimatedTicks, majorTickStyle, false, skippedCategory, offset);
                    if (options.showCustomBoundaryTicks && boundaryTicks.length) {
                        that._initTicks([boundaryTicks[0]], majorTickStyle, false, -1, -1);
                        boundaryTicks.length > 1 && that._initTicks([boundaryTicks[1]], majorTickStyle, false, -1, 1)
                    }
                },
                _buildTicks: function() {
                    var that = this;
                    that._createAllTicks(that._translator.getBusinessRange());
                    that._correctLabelAlignment();
                    that._correctLabelFormat()
                },
                _setTickOffset: function() {
                    var options = this._options,
                        discreteAxisDivisionMode = options.discreteAxisDivisionMode;
                    this._tickOffset = +("crossLabels" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)
                },
                _createHints: function() {
                    var that = this;
                    _each(that._majorTicks || [], function(_, tick) {
                        var labelHint = tick.labelHint;
                        if (_isDefined(labelHint) && "" !== labelHint) {
                            tick.label.setTitle(labelHint)
                        }
                    })
                },
                _setBoundingRect: function() {
                    var start, that = this,
                        options = that._options,
                        axisBox = that._axisElementsGroup ? that._axisElementsGroup.getBBox() : {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            isEmpty: true
                        },
                        lineBox = that._axisLineGroup.getBBox(),
                        placeholderSize = options.placeholderSize,
                        isHorizontal = that._isHorizontal,
                        coord = isHorizontal ? "y" : "x",
                        side = isHorizontal ? "height" : "width",
                        shiftCoords = options.crosshairEnabled ? isHorizontal ? LABEL_BACKGROUND_PADDING_Y : LABEL_BACKGROUND_PADDING_X : 0,
                        axisTitleBox = that._title && that._axisTitleGroup ? that._axisTitleGroup.getBBox() : axisBox;
                    if (axisBox.isEmpty && axisTitleBox.isEmpty && !placeholderSize) {
                        that.boundingRect = axisBox;
                        return
                    }
                    start = lineBox[coord] || that._axisPosition;
                    if (options.position === (isHorizontal && constants.bottom || constants.right)) {
                        axisBox[side] = placeholderSize || axisTitleBox[coord] + axisTitleBox[side] - start + shiftCoords;
                        axisBox[coord] = start
                    } else {
                        axisBox[side] = placeholderSize || lineBox[side] + start - axisTitleBox[coord] + shiftCoords;
                        axisBox[coord] = axisTitleBox.isEmpty ? start : axisTitleBox[coord] - shiftCoords
                    }
                    that.boundingRect = axisBox
                },
                _validateUnit: function(unit, idError, parameters) {
                    var that = this;
                    unit = that.parser(unit);
                    if (void 0 === unit && idError) {
                        that._incidentOccurred(idError, [parameters])
                    }
                    return unit
                },
                _setType: function(axisType, drawingType) {
                    var axisTypeMethods, that = this;
                    switch (axisType) {
                        case "xyAxes":
                            axisTypeMethods = __webpack_require__( /*! ./xy_axes */ 326);
                            break;
                        case "polarAxes":
                            axisTypeMethods = __webpack_require__( /*! ./polar_axes */ 501)
                    }
                    _each(axisTypeMethods[drawingType], function(methodName, method) {
                        that[methodName] = method
                    })
                },
                _getSharpParam: function() {
                    return true
                },
                dispose: function() {
                    var that = this;
                    that._axisElementsGroup && that._axisElementsGroup.dispose();
                    that._stripLabels = that._strips = null;
                    that._title = null;
                    that._axisStripGroup = that._axisConstantLineGroup = that._axisLabelGroup = null;
                    that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
                    that._axisGroup = that._axisTitleGroup = null;
                    that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = null;
                    that._renderer = that._options = that._textOptions = that._textFontStyles = null;
                    that._translator = that._additionalTranslator = null;
                    that._majorTicks = that._minorTicks = null;
                    that._tickManager = null
                },
                getOptions: function() {
                    return this._options
                },
                setPane: function(pane) {
                    this.pane = pane;
                    this._options.pane = pane
                },
                setTypes: function(type, axisType, typeSelector) {
                    this._options.type = type || this._options.type;
                    this._options[typeSelector] = axisType || this._options[typeSelector]
                },
                resetTypes: function(typeSelector) {
                    this._options.type = this._initTypes.type;
                    this._options[typeSelector] = this._initTypes[typeSelector]
                },
                getTranslator: function() {
                    return this._translator
                },
                updateOptions: function(options) {
                    var that = this,
                        labelOpt = options.label;
                    that._options = options;
                    options.tick = options.tick || {};
                    options.minorTick = options.minorTick || {};
                    options.grid = options.grid || {};
                    options.minorGrid = options.minorGrid || {};
                    options.title = options.title || {};
                    options.marker = options.marker || {};
                    that._initTypes = {
                        type: options.type,
                        argumentType: options.argumentType,
                        valueType: options.valueType
                    };
                    validateAxisOptions(options);
                    that._setTickOffset();
                    that._isHorizontal = options.isHorizontal;
                    that.pane = options.pane;
                    that.name = options.name;
                    that.priority = options.priority;
                    that._hasLabelFormat = "" !== labelOpt.format && _isDefined(labelOpt.format);
                    that._textOptions = {
                        align: labelOpt.alignment,
                        opacity: labelOpt.opacity
                    };
                    that._textFontStyles = vizUtils.patchFontOptions(labelOpt.font);
                    if (options.type === constants.logarithmic) {
                        if (options.logarithmBaseError) {
                            that._incidentOccurred("E2104");
                            delete options.logarithmBaseError
                        }
                        that.calcInterval = function(value, prevValue) {
                            return vizUtils.getLog(value / prevValue, options.logarithmBase)
                        }
                    }
                },
                updateSize: function(clearAxis) {
                    var that = this,
                        options = that._options,
                        direction = that._isHorizontal ? "horizontal" : "vertical";
                    if (options.title.text && that._axisTitleGroup) {
                        that._incidentOccurred("W2105", [direction]);
                        that._axisTitleGroup.dispose();
                        that._axisTitleGroup = null
                    }
                    if (clearAxis && that._axisElementsGroup && options.label.visible && !that._translator.getBusinessRange().stubData) {
                        that._incidentOccurred("W2106", [direction]);
                        that._axisElementsGroup.dispose();
                        that._axisElementsGroup = null
                    }
                    that._setBoundingRect()
                },
                setTranslator: function(translator, additionalTranslator) {
                    var that = this,
                        range = translator.getBusinessRange();
                    this._minBound = range.minVisible;
                    this._maxBound = range.maxVisible;
                    that._translator = translator;
                    that._additionalTranslator = additionalTranslator;
                    that.resetTicks();
                    that._updateIntervalAndBounds();
                    that._buildTicks()
                },
                resetTicks: function() {
                    this._deleteLabels();
                    this._majorTicks = this._minorTicks = null
                },
                getLabelsParams: function() {
                    var that = this,
                        options = that._options,
                        position = options.position,
                        labelOffset = options.label.indentFromAxis,
                        axisPosition = that._axisPosition,
                        axisElementsGroup = that._axisElementsGroup;
                    return {
                        pos: position === constants.top || position === constants.left ? axisPosition - labelOffset : axisPosition + labelOffset,
                        width: axisElementsGroup && axisElementsGroup.getBBox().width || 0
                    }
                },
                getFormattedValue: function(value, options, point) {
                    var labelOptions = this._options.label;
                    return _isDefined(value) ? formatLabel(value, _extend(true, {}, labelOptions, options), void 0, point) : null
                },
                getTicksValues: function() {
                    return {
                        majorTicksValues: convertTicksToValues(this._majorTicks || this.getMajorTicks()),
                        minorTicksValues: convertTicksToValues(this._minorTicks || this.getMinorTicks())
                    }
                },
                getMajorTicks: function(withoutOverlappingBehavior) {
                    var majorTicks, boundedOverlappedTicks, that = this,
                        overlappingBehavior = that._options.label.overlappingBehavior;
                    that._updateTickManager();
                    that._textOptions.rotate = 0;
                    majorTicks = convertValuesToTicks(that._tickManager.getTicks(withoutOverlappingBehavior));
                    if (majorTicks.length) {
                        if (overlappingBehavior.hideFirstTick || overlappingBehavior.hideLastTick || overlappingBehavior.hideFirstLabel || overlappingBehavior.hideLastLabel) {
                            overlappingBehavior.hideFirstLabel && (majorTicks[0].withoutLabel = true);
                            overlappingBehavior.hideLastLabel && (majorTicks[majorTicks.length - 1].withoutLabel = true);
                            overlappingBehavior.hideFirstTick && (majorTicks[0].withoutPath = true);
                            overlappingBehavior.hideLastTick && (majorTicks[majorTicks.length - 1].withoutPath = true)
                        } else {
                            if (!withoutOverlappingBehavior && "ignore" !== overlappingBehavior.mode) {
                                boundedOverlappedTicks = that._tickManager.checkBoundedTicksOverlapping();
                                boundedOverlappedTicks.overlappedDates && (majorTicks[1].withoutLabel = true);
                                if (boundedOverlappedTicks.overlappedStartEnd) {
                                    "first" === overlappingBehavior.hideFirstOrLast ? majorTicks[0].withoutLabel = true : majorTicks[majorTicks.length - 1].withoutLabel = true
                                }
                            }
                        }
                    }
                    that._addBoundaryTick(majorTicks);
                    return majorTicks
                },
                getMinorTicks: function() {
                    return convertValuesToTicks(this._tickManager.getMinorTicks())
                },
                getDecimatedTicks: function() {
                    return convertValuesToTicks(this._tickManager.getDecimatedTicks())
                },
                setTicks: function(ticks) {
                    this.resetTicks();
                    this._majorTicks = convertValuesToTicks(ticks.majorTicks);
                    this._minorTicks = convertValuesToTicks(ticks.minorTicks)
                },
                setPercentLabelFormat: function() {
                    if (!this._hasLabelFormat) {
                        this._options.label.format = "percent"
                    }
                },
                resetAutoLabelFormat: function() {
                    if (!this._hasLabelFormat) {
                        delete this._options.label.format
                    }
                },
                getMultipleAxesSpacing: function() {
                    return this._options.multipleAxesSpacing || 0
                },
                drawGrids: function(borderOptions) {
                    var that = this,
                        options = that._options;
                    borderOptions = borderOptions || {};
                    that._axisGridGroup.append(that._gridContainerGroup);
                    if (options.grid.visible) {
                        that._drawGrids(that._majorTicks.concat(that._decimatedTicks), borderOptions)
                    }
                    options.minorGrid.visible && that._drawGrids(that._minorTicks, borderOptions)
                },
                draw: function(adjustAxis) {
                    var areLabelsVisible, that = this,
                        options = that._options;
                    that._axisGroup && that._clearAxisGroups(adjustAxis);
                    areLabelsVisible = options.label.visible && that._axisElementsGroup && !that._translator.getBusinessRange().stubData;
                    that._updateIntervalAndBounds();
                    that._buildTicks();
                    that._initAxisPositions();
                    that._initAllTicks();
                    options.visible && that._drawAxis();
                    if (options.tick.visible) {
                        that._drawTicks(that._majorTicks);
                        that._drawTicks(that._decimatedTicks)
                    }
                    options.minorTick.visible && that._drawTicks(that._minorTicks);
                    areLabelsVisible && that._drawLabels();
                    options.showCustomBoundaryTicks && this._drawTicks(that._boundaryTicks);
                    that._drawTitle();
                    options.strips && that._drawStrip();
                    options.constantLines && that._drawConstantLine();
                    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
                    that._constantLinesGroup && that._axisConstantLineGroup.append(that._constantLinesGroup);
                    that._axisGroup.append(that._axesContainerGroup);
                    that._labelAxesGroup && that._axisLabelGroup.append(that._labelAxesGroup);
                    that._adjustConstantLineLabels();
                    areLabelsVisible && that._adjustLabels();
                    options.marker.visible && that._drawDateMarkers();
                    that._createHints();
                    that._adjustStripLabels();
                    that._adjustTitle();
                    that._setBoundingRect()
                },
                getBoundingRect: function() {
                    return this._axisElementsGroup ? this.boundingRect : {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                },
                shift: function(x, y) {
                    this._axisGroup.attr({
                        translateX: x,
                        translateY: y
                    })
                },
                applyClipRects: function(elementsClipID, canvasClipID) {
                    this._axisGroup.attr({
                        clipId: canvasClipID
                    });
                    this._axisStripGroup.attr({
                        clipId: elementsClipID
                    })
                },
                validate: function(isArgumentAxis) {
                    var that = this,
                        options = that._options,
                        dataType = isArgumentAxis ? options.argumentType : options.valueType,
                        parser = dataType ? parseUtils.getParser(dataType) : function(unit) {
                            return unit
                        };
                    that.parser = parser;
                    options.dataType = dataType;
                    if (void 0 !== options.min) {
                        options.min = that._validateUnit(options.min, "E2106")
                    }
                    if (void 0 !== options.max) {
                        options.max = that._validateUnit(options.max, "E2106")
                    }
                    if (void 0 !== that._minBound) {
                        that._minBound = that._validateUnit(that._minBound)
                    }
                    if (void 0 !== that._maxBound) {
                        that._maxBound = that._validateUnit(that._maxBound)
                    }
                },
                zoom: function(min, max, skipAdjusting) {
                    var that = this,
                        minOpt = that._options.min,
                        maxOpt = that._options.max;
                    skipAdjusting = skipAdjusting || that._options.type === constants.discrete;
                    min = that._validateUnit(min);
                    max = that._validateUnit(max);
                    if (!skipAdjusting) {
                        if (void 0 !== minOpt) {
                            min = minOpt > min ? minOpt : min;
                            max = minOpt > max ? minOpt : max
                        }
                        if (void 0 !== maxOpt) {
                            max = maxOpt < max ? maxOpt : max;
                            min = maxOpt < min ? maxOpt : min
                        }
                    }
                    that._zoomArgs = {
                        min: min,
                        max: max
                    };
                    return that._zoomArgs
                },
                resetZoom: function() {
                    this._zoomArgs = null
                },
                getRangeData: function() {
                    var rangeMin, rangeMax, rangeMinVisible, rangeMaxVisible, that = this,
                        options = that._options,
                        minMax = that._getMinMax(),
                        min = minMax.min,
                        max = minMax.max,
                        zoomArgs = that._zoomArgs || {},
                        type = options.type;
                    if (type === constants.logarithmic) {
                        min = min <= 0 ? void 0 : min;
                        max = max <= 0 ? void 0 : max
                    }
                    if (type !== constants.discrete) {
                        rangeMin = min;
                        rangeMax = max;
                        if (_isDefined(min) && _isDefined(max)) {
                            rangeMin = min < max ? min : max;
                            rangeMax = max > min ? max : min
                        }
                        rangeMinVisible = _isDefined(zoomArgs.min) ? zoomArgs.min : rangeMin;
                        rangeMaxVisible = _isDefined(zoomArgs.max) ? zoomArgs.max : rangeMax
                    } else {
                        rangeMinVisible = _isDefined(zoomArgs.min) ? zoomArgs.min : min;
                        rangeMaxVisible = _isDefined(zoomArgs.max) ? zoomArgs.max : max
                    }
                    return {
                        min: rangeMin,
                        max: rangeMax,
                        stick: that._getStick(),
                        categories: options.categories,
                        dataType: options.dataType,
                        axisType: type,
                        base: options.logarithmBase,
                        invert: options.inverted,
                        addSpiderCategory: that._getSpiderCategoryOption(),
                        minVisible: rangeMinVisible,
                        maxVisible: rangeMaxVisible
                    }
                },
                getFullTicks: function() {
                    return this._tickManager.getFullTicks()
                },
                _addBoundaryTick: _noop,
                getMarkerTrackers: _noop,
                measureLabels: _noop,
                _drawDateMarkers: _noop,
                coordsIn: _noop,
                _getSkippedCategory: _noop,
                _initAxisPositions: _noop,
                _drawTitle: _noop,
                _adjustConstantLineLabels: _noop,
                _adjustTitle: _noop,
                getSpiderTicks: _noop,
                setSpiderTicks: _noop,
                _getTickCoord: _noop
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/viz/chart_components/base_chart.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4),
                BaseWidget = __webpack_require__( /*! ../core/base_widget */ 109),
                legendModule = __webpack_require__( /*! ../components/legend */ 330),
                dataValidatorModule = __webpack_require__( /*! ../components/data_validator */ 233),
                seriesModule = __webpack_require__( /*! ../series/base_series */ 236),
                chartThemeManagerModule = __webpack_require__( /*! ../components/chart_theme_manager */ 329),
                LayoutManagerModule = __webpack_require__( /*! ./layout_manager */ 328),
                trackerModule = __webpack_require__( /*! ./tracker */ 510),
                headerBlockModule = __webpack_require__( /*! ./header_block */ 507),
                REINIT_REFRESH_ACTION = "_reinit",
                REINIT_DATA_SOURCE_REFRESH_ACTION = "_updateDataSource",
                DATA_INIT_REFRESH_ACTION = "_dataInit",
                FORCE_RENDER_REFRESH_ACTION = "_forceRender",
                RESIZE_REFRESH_ACTION = "_resize",
                ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION],
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _noop = $.noop,
                _map = vizUtils.map,
                _each = $.each,
                _extend = $.extend,
                _isArray = commonUtils.isArray,
                _isDefined = commonUtils.isDefined,
                _setCanvasValues = vizUtils.setCanvasValues,
                DEFAULT_OPACITY = .3,
                REINIT_REFRESH_ACTION_OPTIONS = ["adaptiveLayout", "crosshair", "equalBarWidth", "minBubbleSize", "maxBubbleSize", "barWidth", "negativesAsZeroes", "negativesAsZeros", "resolveLabelOverlapping", "seriesSelectionMode", "pointSelectionMode", "adjustOnZoom", "synchronizeMultiAxes", "zoomingMode", "scrollingMode", "useAggregation"];

            function checkHeightLabelsInCanvas(points, canvas, isRotated) {
                var label, bbox, commonLabelSize = 0,
                    canvasSize = canvas.end - canvas.start;
                for (var i = 0; i < points.length; i++) {
                    label = points[i].getLabel();
                    if (label.isVisible()) {
                        bbox = label.getBoundingRect();
                        commonLabelSize += isRotated ? bbox.width : bbox.height
                    } else {
                        points[i] = null
                    }
                }
                if (canvasSize > 0) {
                    while (commonLabelSize > canvasSize) {
                        commonLabelSize -= killSmallValues(points, isRotated)
                    }
                }
            }

            function killSmallValues(points, isRotated) {
                var label, bbox, indexOfPoint, smallestValuePoint = {
                    originalValue: 1 / 0
                };
                _each(points, function(index, point) {
                    if (point && smallestValuePoint.originalValue >= point.originalValue) {
                        smallestValuePoint = point;
                        indexOfPoint = index
                    }
                });
                if (null !== indexOfPoint) {
                    label = points[indexOfPoint].getLabel();
                    bbox = label.getBoundingRect();
                    label.hide();
                    points[indexOfPoint] = null;
                    return isRotated ? bbox.width : bbox.height
                }
                return 0
            }

            function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, shiftFunction) {
                var rollingStocks, stubCanvas = {
                    start: isRotated ? canvas.left : canvas.top,
                    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
                };
                checkHeightLabelsInCanvas(points, stubCanvas, isRotated);
                rollingStocks = _map(points, function(p) {
                    return p ? new RollingStock(p, isRotated, shiftFunction) : null
                });
                rollingStocks.sort(function(a, b) {
                    return a.getPointPosition() - b.getPointPosition()
                });
                if (!checkStackOverlap(rollingStocks)) {
                    return
                }
                rollingStocks.reverse();
                moveRollingStock(rollingStocks, stubCanvas)
            }

            function overlapRollingStock(firstRolling, secondRolling) {
                if (!firstRolling || !secondRolling) {
                    return
                }
                return firstRolling.getBoundingRect().end > secondRolling.getBoundingRect().start
            }

            function checkStackOverlap(rollingStocks) {
                var i, j, currentRollingStock, nextRollingStock, overlap;
                for (i = 0; i < rollingStocks.length; i++) {
                    currentRollingStock = rollingStocks[i];
                    for (j = i + 1; j < rollingStocks.length; j++) {
                        nextRollingStock = rollingStocks[j];
                        if (overlapRollingStock(currentRollingStock, nextRollingStock)) {
                            currentRollingStock.toChain(nextRollingStock);
                            overlap = true;
                            rollingStocks[j] = null
                        }
                    }
                }
                return overlap
            }

            function moveRollingStock(rollingStocks, canvas) {
                var i, j, currentRollingStock, nextRollingStock, currentBBox, nextBBox;
                for (i = 0; i < rollingStocks.length; i++) {
                    currentRollingStock = rollingStocks[i];
                    if (rollingStocksIsOut(currentRollingStock, canvas)) {
                        currentBBox = currentRollingStock.getBoundingRect();
                        for (j = i + 1; j < rollingStocks.length; j++) {
                            nextRollingStock = rollingStocks[j];
                            if (!nextRollingStock) {
                                continue
                            }
                            nextBBox = nextRollingStock.getBoundingRect();
                            if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
                                nextRollingStock.toChain(currentRollingStock);
                                rollingStocks[i] = currentRollingStock = null;
                                break
                            }
                        }
                    }
                    currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas)
                }
            }

            function rollingStocksIsOut(rollingStock, canvas) {
                return rollingStock && rollingStock.getBoundingRect().end > canvas.end
            }

            function RollingStock(point, isRotated, shiftFunction) {
                var label = point.getLabel(),
                    bbox = label.getBoundingRect();
                this.labels = [label];
                this.points = [point];
                this.shiftFunction = shiftFunction;
                this._bbox = {
                    start: isRotated ? bbox.x : bbox.y,
                    width: isRotated ? bbox.width : bbox.height,
                    end: isRotated ? bbox.x + bbox.width : bbox.y + bbox.height
                };
                this._pointPositionInitialize = isRotated ? point.getBoundaryCoords().x : point.getBoundaryCoords().y;
                return this
            }
            RollingStock.prototype = {
                toChain: function(nextRollingStock) {
                    var nextRollingStockBBox = nextRollingStock.getBoundingRect();
                    nextRollingStock.shift(nextRollingStockBBox.start - this._bbox.end);
                    this._changeBoxWidth(nextRollingStockBBox.width);
                    this.labels = this.labels.concat(nextRollingStock.labels);
                    this.points = this.points.concat(nextRollingStock.points)
                },
                getBoundingRect: function() {
                    return this._bbox
                },
                shift: function(shiftLength) {
                    var shiftFunction = this.shiftFunction;
                    _each(this.labels, function(index, label) {
                        var bbox = label.getBoundingRect(),
                            coords = shiftFunction(bbox, shiftLength, label);
                        label.shift(coords.x, coords.y)
                    });
                    this._bbox.end -= shiftLength;
                    this._bbox.start -= shiftLength
                },
                setRollingStockInCanvas: function(canvas) {
                    if (this._bbox.end > canvas.end) {
                        this.shift(this._bbox.end - canvas.end)
                    }
                },
                getPointPosition: function() {
                    return this._pointPositionInitialize
                },
                _changeBoxWidth: function(width) {
                    this._bbox.end += width;
                    this._bbox.width += width
                }
            };

            function getLegendFields(name) {
                return {
                    nameField: name + "Name",
                    colorField: name + "Color",
                    indexField: name + "Index"
                }
            }

            function getLegendSettings(legendDataField) {
                var formatObjectFields = getLegendFields(legendDataField);
                return {
                    getFormatObject: function(data) {
                        var res = {};
                        res[formatObjectFields.indexField] = data.id;
                        res[formatObjectFields.colorField] = data.states.normal.fill;
                        res[formatObjectFields.nameField] = data.text;
                        return res
                    },
                    textField: formatObjectFields.nameField
                }
            }

            function setTemplateFields(data, templateData, series) {
                _each(data, function(_, data) {
                    _each(series.getTemplateFields(), function(_, field) {
                        data[field.templateField] = data[field.originalField]
                    });
                    templateData.push(data)
                });
                series.updateTemplateFieldNames()
            }

            function checkOverlapping(firstRect, secondRect) {
                return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height)
            }
            var overlapping = {
                resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection
            };

            function suppressCommonLayout(layout) {
                layout.forward = function(rect) {
                    return rect
                };
                layout.backward = _noop
            }
            var BaseChart = BaseWidget.inherit({
                _eventsMap: {
                    onSeriesClick: {
                        name: "seriesClick"
                    },
                    onPointClick: {
                        name: "pointClick"
                    },
                    onArgumentAxisClick: {
                        name: "argumentAxisClick"
                    },
                    onLegendClick: {
                        name: "legendClick"
                    },
                    onSeriesSelectionChanged: {
                        name: "seriesSelectionChanged"
                    },
                    onPointSelectionChanged: {
                        name: "pointSelectionChanged"
                    },
                    onSeriesHoverChanged: {
                        name: "seriesHoverChanged"
                    },
                    onPointHoverChanged: {
                        name: "pointHoverChanged"
                    },
                    onTooltipShown: {
                        name: "tooltipShown"
                    },
                    onTooltipHidden: {
                        name: "tooltipHidden"
                    },
                    onDone: {
                        name: "done"
                    }
                },
                _rootClassPrefix: "dxc",
                _rootClass: "dxc-chart",
                _init: function() {
                    this._savedBusinessRange = {};
                    this.callBase.apply(this, arguments)
                },
                _initialChanges: ["REINIT"],
                _themeDependentChanges: ["REFRESH_SERIES_REINIT"],
                _createThemeManager: function() {
                    var option = this.option(),
                        themeManager = new chartThemeManagerModule.ThemeManager(option, this._chartType);
                    themeManager.setTheme(option.theme, option.rtlEnabled);
                    return themeManager
                },
                _initCore: function() {
                    var that = this;
                    suppressCommonLayout(that._layout);
                    that._canvasClipRect = that._renderer.clipRect();
                    that._createHtmlStructure();
                    that._headerBlock = new headerBlockModule.HeaderBlock;
                    that._createLegend();
                    that._createTracker();
                    that._needHandleRenderComplete = true;
                    that.layoutManager = new LayoutManagerModule.LayoutManager;
                    that._createScrollBar();
                    that._$element.on("contextmenu", function(event) {
                        that.eventType = "contextmenu";
                        if (eventUtils.isTouchEvent(event) || eventUtils.isPointerEvent(event)) {
                            event.preventDefault()
                        }
                    }).on("MSHoldVisual", function(event) {
                        that.eventType = "MSHoldVisual";
                        event.preventDefault()
                    })
                },
                _getLayoutItems: $.noop,
                _layoutManagerOptions: function() {
                    return this._themeManager.getOptions("adaptiveLayout")
                },
                _reinit: function() {
                    var that = this;
                    _setCanvasValues(that._canvas);
                    that._reinitAxes();
                    that._skipRender = true;
                    that._updateDataSource();
                    if (!that.series) {
                        that._dataSpecificInit(false)
                    }
                    that._skipRender = false;
                    that._correctAxes();
                    that._forceRender()
                },
                _correctAxes: _noop,
                _createHtmlStructure: function() {
                    var that = this,
                        renderer = that._renderer,
                        root = renderer.root;
                    that._backgroundRect = renderer.rect().attr({
                        fill: "gray",
                        opacity: 1e-4
                    }).append(root);
                    that._panesBackgroundGroup = renderer.g().attr({
                        "class": "dxc-background"
                    }).append(root);
                    that._stripsGroup = renderer.g().attr({
                        "class": "dxc-strips-group"
                    }).linkOn(root, "strips");
                    that._gridGroup = renderer.g().attr({
                        "class": "dxc-grids-group"
                    }).linkOn(root, "grids");
                    that._axesGroup = renderer.g().attr({
                        "class": "dxc-axes-group"
                    }).linkOn(root, "axes");
                    that._constantLinesGroup = renderer.g().attr({
                        "class": "dxc-constant-lines-group"
                    }).linkOn(root, "constant-lines");
                    that._labelAxesGroup = renderer.g().attr({
                        "class": "dxc-strips-labels-group"
                    }).linkOn(root, "strips-labels");
                    that._panesBorderGroup = renderer.g().attr({
                        "class": "dxc-border"
                    }).linkOn(root, "border");
                    that._seriesGroup = renderer.g().attr({
                        "class": "dxc-series-group"
                    }).linkOn(root, "series");
                    that._labelsGroup = renderer.g().attr({
                        "class": "dxc-labels-group"
                    }).linkOn(root, "labels");
                    that._crosshairCursorGroup = renderer.g().attr({
                        "class": "dxc-crosshair-cursor"
                    }).linkOn(root, "crosshair");
                    that._legendGroup = renderer.g().attr({
                        "class": "dxc-legend",
                        clipId: that._getCanvasClipRectID()
                    }).linkOn(root, "legend");
                    that._scrollBarGroup = renderer.g().attr({
                        "class": "dxc-scroll-bar"
                    }).linkOn(root, "scroll-bar")
                },
                _disposeObjectsInArray: function(propName, fieldNames) {
                    _each(this[propName] || [], function(_, item) {
                        if (fieldNames && item) {
                            _each(fieldNames, function(_, field) {
                                item[field] && item[field].dispose()
                            })
                        } else {
                            item && item.dispose()
                        }
                    });
                    this[propName] = null
                },
                _disposeCore: function() {
                    var that = this,
                        disposeObject = function(propName) {
                            if (that[propName]) {
                                that[propName].dispose();
                                that[propName] = null
                            }
                        },
                        unlinkGroup = function(name) {
                            that[name].linkOff()
                        },
                        disposeObjectsInArray = this._disposeObjectsInArray;
                    clearTimeout(that._delayedRedraw);
                    that._renderer.stopAllAnimations();
                    that.businessRanges = that.translators = null;
                    disposeObjectsInArray.call(that, "series");
                    disposeObject("_headerBlock");
                    disposeObject("_tracker");
                    disposeObject("_crosshair");
                    that.layoutManager = null;
                    that.paneAxis = null;
                    that._userOptions = null;
                    that._canvas = null;
                    unlinkGroup("_stripsGroup");
                    unlinkGroup("_gridGroup");
                    unlinkGroup("_axesGroup");
                    unlinkGroup("_constantLinesGroup");
                    unlinkGroup("_labelAxesGroup");
                    unlinkGroup("_panesBorderGroup");
                    unlinkGroup("_seriesGroup");
                    unlinkGroup("_labelsGroup");
                    unlinkGroup("_crosshairCursorGroup");
                    unlinkGroup("_legendGroup");
                    unlinkGroup("_scrollBarGroup");
                    disposeObject("_canvasClipRect");
                    disposeObject("_panesBackgroundGroup");
                    disposeObject("_stripsGroup");
                    disposeObject("_gridGroup");
                    disposeObject("_axesGroup");
                    disposeObject("_constantLinesGroup");
                    disposeObject("_labelAxesGroup");
                    disposeObject("_panesBorderGroup");
                    disposeObject("_seriesGroup");
                    disposeObject("_labelsGroup");
                    disposeObject("_crosshairCursorGroup");
                    disposeObject("_legendGroup");
                    disposeObject("_scrollBarGroup")
                },
                _getAnimationOptions: function() {
                    return this._themeManager.getOptions("animation")
                },
                _getDefaultSize: function() {
                    return {
                        width: 400,
                        height: 400
                    }
                },
                _getOption: function(name) {
                    return this._themeManager.getOptions(name)
                },
                _applySize: function() {
                    this._processRefreshData(RESIZE_REFRESH_ACTION)
                },
                _resize: function() {
                    this._doRender(this.__renderOptions || {
                        animate: false,
                        isResize: true
                    })
                },
                _trackerType: "ChartTracker",
                _createTracker: function() {
                    var that = this;
                    that._tracker = new trackerModule[that._trackerType]({
                        seriesGroup: that._seriesGroup,
                        renderer: that._renderer,
                        tooltip: that._tooltip,
                        legend: that._legend,
                        eventTrigger: that._eventTrigger
                    })
                },
                _getTrackerSettings: function() {
                    return {
                        seriesSelectionMode: this._themeManager.getOptions("seriesSelectionMode"),
                        pointSelectionMode: this._themeManager.getOptions("pointSelectionMode")
                    }
                },
                _updateTracker: function(trackerCanvases) {
                    var that = this;
                    that._tracker.update(that._getTrackerSettings());
                    that._tracker.setCanvases({
                        left: 0,
                        right: that._canvas.width,
                        top: 0,
                        bottom: that._canvas.height
                    }, trackerCanvases)
                },
                _doRender: function(_options) {
                    var drawOptions, recreateCanvas, that = this;
                    if ( /*!that._initialized || */ that._skipRender) {
                        return
                    }
                    if (0 === that._canvas.width && 0 === that._canvas.height) {
                        return
                    }
                    that._resetIsReady();
                    drawOptions = that._prepareDrawOptions(_options);
                    recreateCanvas = drawOptions.recreateCanvas;
                    clearTimeout(that._delayedRedraw);
                    that.__originalCanvas = that._canvas;
                    that._canvas = $.extend({}, that._canvas);
                    if (recreateCanvas) {
                        that.__currentCanvas = that._canvas
                    } else {
                        that._canvas = that.__currentCanvas
                    }
                    that.DEBUG_canvas = that._canvas;
                    recreateCanvas && that._updateCanvasClipRect(that._canvas);
                    that._renderer.stopAllAnimations(true);
                    _setCanvasValues(that._canvas);
                    that._cleanGroups(drawOptions);
                    that._renderElements(drawOptions)
                },
                _saveBusinessRange: _noop,
                _renderElements: function(drawOptions) {
                    var argBusinessRange, zoomMinArg, zoomMaxArg, that = this,
                        preparedOptions = that._prepareToRender(drawOptions),
                        isRotated = that._isRotated(),
                        isLegendInside = that._isLegendInside(),
                        trackerCanvases = [],
                        layoutTargets = that._getLayoutTargets(),
                        dirtyCanvas = $.extend({}, that._canvas),
                        drawElements = [],
                        layoutCanvas = drawOptions.drawTitle && drawOptions.drawLegend && drawOptions.adjustAxes;
                    that.DEBUG_dirtyCanvas = dirtyCanvas;
                    if (layoutCanvas) {
                        drawElements = that._getDrawElements(drawOptions, isLegendInside)
                    }
                    that._renderer.lock();
                    that._saveBusinessRange();
                    that.layoutManager.setOptions(that._layoutManagerOptions());
                    that.layoutManager.layoutElements(drawElements, that._canvas, that._getAxisDrawingMethods(drawOptions, preparedOptions, isRotated), layoutTargets, isRotated, that._getAxesForTransform(isRotated));
                    layoutCanvas && that._updateCanvasClipRect(dirtyCanvas);
                    that._applyClipRects(preparedOptions);
                    that._appendSeriesGroups();
                    that._createCrosshairCursor();
                    _each(layoutTargets, function() {
                        var canvas = this.canvas;
                        trackerCanvases.push({
                            left: canvas.left,
                            right: canvas.width - canvas.right,
                            top: canvas.top,
                            bottom: canvas.height - canvas.bottom
                        })
                    });
                    if (that._scrollBar) {
                        argBusinessRange = that.businessRanges[0].arg;
                        if ("discrete" === argBusinessRange.axisType && argBusinessRange.categories && argBusinessRange.categories.length <= 1) {
                            zoomMinArg = zoomMaxArg = void 0
                        } else {
                            zoomMinArg = argBusinessRange.minVisible;
                            zoomMaxArg = argBusinessRange.maxVisible
                        }
                        that._scrollBar.init(argBusinessRange, layoutTargets[0].canvas).setPosition(zoomMinArg, zoomMaxArg)
                    }
                    that._updateTracker(trackerCanvases);
                    that._updateLegendPosition(drawOptions, isLegendInside);
                    that._renderSeries(drawOptions, isRotated, isLegendInside);
                    that._renderer.unlock()
                },
                _createCrosshairCursor: _noop,
                _appendSeriesGroups: function() {
                    this._seriesGroup.linkAppend();
                    this._labelsGroup.linkAppend();
                    this._appendAdditionalSeriesGroups()
                },
                _renderSeries: function(drawOptions, isRotated, isLegendInside) {
                    var that = this,
                        themeManager = that._themeManager,
                        resolveLabelOverlapping = themeManager.getOptions("resolveLabelOverlapping");
                    drawOptions.hideLayoutLabels = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), isRotated) && !themeManager.getOptions("adaptiveLayout").keepLabels;
                    that._drawSeries(drawOptions, isRotated);
                    "none" !== resolveLabelOverlapping && that._resolveLabelOverlapping(resolveLabelOverlapping);
                    that._adjustSeries();
                    that._renderTrackers(isLegendInside);
                    that._tracker.repairTooltip();
                    that._canvas = that.__originalCanvas;
                    that._drawn();
                    that._renderCompleteHandler()
                },
                _drawSeries: function(drawOptions, isRotated) {
                    var i, singleSeries, that = this,
                        series = that.series,
                        seriesLength = series.length;
                    that._updateSeriesDimensions(drawOptions);
                    for (i = 0; i < seriesLength; i++) {
                        singleSeries = series[i];
                        that._applyExtraSettings(singleSeries, drawOptions);
                        singleSeries.draw(that._prepareTranslators(singleSeries, i, isRotated), drawOptions.animate && singleSeries.getPoints().length <= drawOptions.animationPointsLimit && that._renderer.animationEnabled(), drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries))
                    }
                },
                _resolveLabelOverlapping: function(resolveLabelOverlapping) {
                    var func;
                    switch (resolveLabelOverlapping) {
                        case "stack":
                            func = this._resolveLabelOverlappingStack;
                            break;
                        case "hide":
                            func = this._resolveLabelOverlappingHide;
                            break;
                        case "shift":
                            func = this._resolveLabelOverlappingShift
                    }
                    $.isFunction(func) && func.call(this)
                },
                _getVisibleSeries: function() {
                    return $.grep(this.getAllSeries(), function(series) {
                        return series.isVisible()
                    })
                },
                _resolveLabelOverlappingHide: function() {
                    var currentLabel, nextLabel, currentLabelRect, nextLabelRect, i, j, points, labels = [],
                        series = this._getVisibleSeries();
                    for (i = 0; i < series.length; i++) {
                        points = series[i].getVisiblePoints();
                        for (j = 0; j < points.length; j++) {
                            labels.push(points[j].getLabel())
                        }
                    }
                    labels = [].concat.apply([], labels);
                    for (i = 0; i < labels.length; i++) {
                        currentLabel = labels[i];
                        currentLabelRect = currentLabel.getBoundingRect();
                        if (!currentLabel.isVisible()) {
                            continue
                        }
                        for (j = i + 1; j < labels.length; j++) {
                            nextLabel = labels[j];
                            nextLabelRect = nextLabel.getBoundingRect();
                            if (checkOverlapping(currentLabelRect, nextLabelRect)) {
                                nextLabel.hide()
                            }
                        }
                    }
                },
                _cleanGroups: function(drawOptions) {
                    var that = this;
                    that._stripsGroup.linkRemove().clear();
                    that._gridGroup.linkRemove().clear();
                    that._axesGroup.linkRemove().clear();
                    that._constantLinesGroup.linkRemove().clear();
                    that._labelAxesGroup.linkRemove().clear();
                    that._labelsGroup.linkRemove().clear();
                    that._crosshairCursorGroup.linkRemove().clear()
                },
                _createLegend: function() {
                    var that = this,
                        legendSettings = getLegendSettings(that._legendDataField);
                    that._legend = new legendModule.Legend({
                        renderer: that._renderer,
                        group: that._legendGroup,
                        backgroundClass: "dxc-border",
                        itemGroupClass: "dxc-item",
                        textField: legendSettings.textField,
                        getFormatObject: legendSettings.getFormatObject
                    })
                },
                _updateLegend: function() {
                    var that = this,
                        themeManager = that._themeManager,
                        legendOptions = themeManager.getOptions("legend"),
                        legendData = that._getLegendData();
                    legendOptions.containerBackgroundColor = themeManager.getOptions("containerBackgroundColor");
                    legendOptions._incidentOccurred = that._incidentOccurred;
                    that._legend.update(legendData, legendOptions)
                },
                _prepareDrawOptions: function(drawOptions) {
                    var options, animationOptions = this._getAnimationOptions();
                    options = $.extend({}, {
                        force: false,
                        adjustAxes: true,
                        drawLegend: true,
                        drawTitle: true,
                        animate: animationOptions.enabled,
                        animationPointsLimit: animationOptions.maxPointCountSupported
                    }, drawOptions, this.__renderOptions);
                    if (!_isDefined(options.recreateCanvas)) {
                        options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle
                    }
                    return options
                },
                _processRefreshData: function(newRefreshAction) {
                    var currentRefreshActionPosition = $.inArray(this._currentRefreshData, ACTIONS_BY_PRIORITY),
                        newRefreshActionPosition = $.inArray(newRefreshAction, ACTIONS_BY_PRIORITY);
                    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
                        this._currentRefreshData = newRefreshAction
                    }
                },
                _getLegendData: function() {
                    return _map(this._getLegendTargets(), function(item) {
                        var legendData = item.legendData,
                            style = item.getLegendStyles,
                            opacity = style.normal.opacity;
                        if (!item.visible) {
                            if (!_isDefined(opacity) || opacity > DEFAULT_OPACITY) {
                                opacity = DEFAULT_OPACITY
                            }
                            legendData.textOpacity = DEFAULT_OPACITY
                        }
                        legendData.states = {
                            hover: style.hover,
                            selection: style.selection,
                            normal: _extend({}, style.normal, {
                                opacity: opacity
                            })
                        };
                        return legendData
                    })
                },
                _getLegendOptions: function(item) {
                    return {
                        legendData: {
                            text: item[this._legendItemTextField],
                            argument: item.argument,
                            id: item.index
                        },
                        getLegendStyles: item.getLegendStyles(),
                        visible: item.isVisible()
                    }
                },
                _disposeSeries: function() {
                    var that = this;
                    _each(that.series || [], function(_, series) {
                        series.dispose()
                    });
                    that.series = null;
                    _each(that.seriesFamilies || [], function(_, family) {
                        family.dispose()
                    });
                    that.seriesFamilies = null;
                    that._needHandleRenderComplete = true
                },
                _optionChanged: function(arg) {
                    this._themeManager.resetOptions(arg.name);
                    this.callBase.apply(this, arguments)
                },
                _applyChanges: function() {
                    var that = this;
                    that._themeManager.update(that._options);
                    that.callBase.apply(that, arguments);
                    that._doRefresh()
                },
                _optionChangesMap: {
                    animation: "ANIMATION",
                    dataSource: "DATA_SOURCE",
                    palette: "PALETTE",
                    series: "REFRESH_SERIES_DATA_INIT",
                    commonSeriesSettings: "REFRESH_SERIES_DATA_INIT",
                    containerBackgroundColor: "REFRESH_SERIES_DATA_INIT",
                    dataPrepareSettings: "REFRESH_SERIES_DATA_INIT",
                    legend: "DATA_INIT",
                    seriesTemplate: "DATA_INIT",
                    "export": "FORCE_RENDER",
                    valueAxis: "AXES_AND_PANES",
                    argumentAxis: "AXES_AND_PANES",
                    commonAxisSettings: "AXES_AND_PANES",
                    panes: "AXES_AND_PANES",
                    defaultPane: "AXES_AND_PANES",
                    rotated: "ROTATED",
                    customizePoint: "REFRESH_SERIES_REINIT",
                    customizeLabel: "REFRESH_SERIES_REINIT",
                    scrollBar: "SCROLL_BAR"
                },
                _customChangesOrder: ["ANIMATION", "DATA_SOURCE", "PALETTE", "REFRESH_SERIES_DATA_INIT", "DATA_INIT", "FORCE_RENDER", "AXES_AND_PANES", "ROTATED", "REFRESH_SERIES_REINIT", "SCROLL_BAR", "CHART_TOOLTIP", "REINIT"],
                _change_ANIMATION: function() {
                    this._renderer.updateAnimationOptions(this._getAnimationOptions())
                },
                _change_DATA_SOURCE: function() {
                    this._needHandleRenderComplete = true;
                    this._processRefreshData(REINIT_DATA_SOURCE_REFRESH_ACTION)
                },
                _change_PALETTE: function() {
                    this._themeManager.updatePalette(this.option("palette"));
                    this._refreshSeries(DATA_INIT_REFRESH_ACTION)
                },
                _change_REFRESH_SERIES_DATA_INIT: function() {
                    this._refreshSeries(DATA_INIT_REFRESH_ACTION)
                },
                _change_DATA_INIT: function() {
                    this._processRefreshData(DATA_INIT_REFRESH_ACTION)
                },
                _change_FORCE_RENDER: function() {
                    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
                },
                _change_AXES_AND_PANES: function() {
                    this._refreshSeries(REINIT_REFRESH_ACTION);
                    this.paneAxis = {}
                },
                _change_ROTATED: function() {
                    this._createScrollBar();
                    this._refreshSeries(REINIT_REFRESH_ACTION)
                },
                _change_REFRESH_SERIES_REINIT: function() {
                    this._refreshSeries(REINIT_REFRESH_ACTION)
                },
                _change_SCROLL_BAR: function() {
                    this._createScrollBar();
                    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
                },
                _change_CHART_TOOLTIP: function() {
                    this._organizeStackPoints()
                },
                _change_REINIT: function() {
                    this._processRefreshData(REINIT_REFRESH_ACTION)
                },
                _refreshSeries: function(actionName) {
                    this._disposeSeries();
                    this._processRefreshData(actionName)
                },
                _doRefresh: function() {
                    var methodName = this._currentRefreshData;
                    if (methodName) {
                        this._currentRefreshData = null;
                        this._renderer.stopAllAnimations(true);
                        this[methodName]()
                    }
                },
                _updateCanvasClipRect: function(canvas) {
                    var width, height, that = this;
                    width = Math.max(canvas.width - canvas.left - canvas.right, 0);
                    height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
                    that._canvasClipRect.attr({
                        x: canvas.left,
                        y: canvas.top,
                        width: width,
                        height: height
                    });
                    that._backgroundRect.attr({
                        x: canvas.left,
                        y: canvas.top,
                        width: width,
                        height: height
                    })
                },
                _getCanvasClipRectID: function() {
                    return this._canvasClipRect.id
                },
                _dataSourceChangedHandler: function() {
                    this._resetZoom();
                    this._dataInit()
                },
                _dataInit: function() {
                    clearTimeout(this._delayedRedraw);
                    this._dataSpecificInit(true)
                },
                _dataSpecificInit: function(needRedraw) {
                    var that = this;
                    that.series = that.series || that._populateSeries();
                    that._repopulateSeries();
                    that._seriesPopulatedHandlerCore();
                    that._populateBusinessRange();
                    that._collectPointsByArg();
                    that._tracker.updateSeries(that._getStoredSeries());
                    that._updateLegend();
                    needRedraw && that._forceRender()
                },
                _forceRender: function() {
                    this._doRender({
                        force: true
                    })
                },
                _repopulateSeries: function() {
                    var parsedData, that = this,
                        themeManager = that._themeManager,
                        data = that._dataSource.items(),
                        dataValidatorOptions = themeManager.getOptions("dataPrepareSettings"),
                        seriesTemplate = themeManager.getOptions("seriesTemplate");
                    if (seriesTemplate) {
                        that._templatedSeries = vizUtils.processSeriesTemplate(seriesTemplate, data);
                        that._populateSeries();
                        delete that._templatedSeries;
                        data = that.templateData || data
                    }
                    that._groupSeries();
                    parsedData = dataValidatorModule.validateData(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);
                    themeManager.resetPalette();
                    _each(that.series, function(_, singleSeries) {
                        singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);
                        that._processSingleSeries(singleSeries)
                    });
                    that._organizeStackPoints()
                },
                _organizeStackPoints: function() {
                    var that = this,
                        themeManager = that._themeManager,
                        sharedTooltip = themeManager.getOptions("tooltip").shared,
                        stackPoints = {};
                    _each(that.series || [], function(_, singleSeries) {
                        that._resetStackPoints(singleSeries);
                        sharedTooltip && that._prepareStackPoints(singleSeries, stackPoints)
                    })
                },
                _renderCompleteHandler: function() {
                    var that = this,
                        allSeriesInited = true;
                    if (that._needHandleRenderComplete) {
                        _each(that.series, function(_, s) {
                            allSeriesInited = allSeriesInited && s.canRenderCompleteHandle()
                        });
                        if (allSeriesInited) {
                            that._needHandleRenderComplete = false;
                            that._eventTrigger("done", {
                                target: that
                            })
                        }
                    }
                },
                _getDrawElements: function(drawOptions, legendHasInsidePosition) {
                    var that = this,
                        drawElements = [],
                        exportOptions = that._themeManager.getOptions("export"),
                        titleOptions = that._title.getLayoutOptions() || {},
                        headerElements = [];
                    that._exportMenu && exportOptions.enabled && headerElements.push(that._exportMenu);
                    if (drawOptions.drawTitle) {
                        "bottom" !== titleOptions.verticalAlignment && headerElements.length ? headerElements.push(that._title) : drawElements.push(that._title)
                    }
                    if (headerElements.length) {
                        that._headerBlock.update(headerElements, that._canvas);
                        drawElements.push(that._headerBlock)
                    }
                    if (drawOptions.drawLegend && that._legend) {
                        that._legendGroup.linkAppend();
                        !legendHasInsidePosition && drawElements.push(that._legend)
                    }
                    return drawElements
                },
                _resetZoom: _noop,
                _dataIsReady: function() {
                    return _isDefined(this.option("dataSource")) && this._dataSource.isLoaded()
                },
                _populateSeries: function() {
                    var particularSeriesOptions, particularSeries, seriesTheme, data, i, that = this,
                        themeManager = that._themeManager,
                        hasSeriesTemplate = !!themeManager.getOptions("seriesTemplate"),
                        seriesOptions = hasSeriesTemplate ? that._templatedSeries : that.option("series"),
                        allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [],
                        extraOptions = that._getExtraOptions(),
                        seriesVisibilityChanged = function() {
                            that._specialProcessSeries();
                            that._populateBusinessRange();
                            that._renderer.stopAllAnimations(true);
                            that._updateLegend();
                            that._doRender({
                                force: true
                            })
                        };
                    that._disposeSeries();
                    that.series = [];
                    that.templateData = [];
                    themeManager.resetPalette();
                    for (i = 0; i < allSeriesOptions.length; i++) {
                        particularSeriesOptions = _extend(true, {}, allSeriesOptions[i], extraOptions);
                        if (!particularSeriesOptions.name) {
                            particularSeriesOptions.name = "Series " + (i + 1).toString()
                        }
                        data = particularSeriesOptions.data;
                        particularSeriesOptions.data = null;
                        particularSeriesOptions.rotated = that._isRotated();
                        particularSeriesOptions.customizePoint = themeManager.getOptions("customizePoint");
                        particularSeriesOptions.customizeLabel = themeManager.getOptions("customizeLabel");
                        particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
                        particularSeriesOptions.incidentOccurred = that._incidentOccurred;
                        seriesTheme = themeManager.getOptions("series", particularSeriesOptions);
                        if (!that._checkPaneName(seriesTheme)) {
                            continue
                        }
                        particularSeries = new seriesModule.Series({
                            renderer: that._renderer,
                            seriesGroup: that._seriesGroup,
                            labelsGroup: that._labelsGroup
                        }, seriesTheme);
                        if (!particularSeries.isUpdated) {
                            that._incidentOccurred("E2101", [seriesTheme.type])
                        } else {
                            particularSeries.index = that.series.length;
                            that._processSingleSeries(particularSeries);
                            that.series.push(particularSeries);
                            if (hasSeriesTemplate) {
                                setTemplateFields(data, that.templateData, particularSeries)
                            }
                        }
                    }
                    return that.series
                },
                getAllSeries: function() {
                    return this.series.slice()
                },
                getSeriesByName: function(name) {
                    var found = null;
                    _each(this.series, function(i, singleSeries) {
                        if (singleSeries.name === name) {
                            found = singleSeries;
                            return false
                        }
                    });
                    return found
                },
                getSeriesByPos: function(pos) {
                    return this.series[pos]
                },
                clearSelection: function() {
                    this._tracker.clearSelection()
                },
                hideTooltip: function() {
                    this._tracker._hideTooltip()
                },
                render: function(renderOptions) {
                    var that = this;
                    that.__renderOptions = renderOptions;
                    that.__forceRender = renderOptions && renderOptions.force;
                    that.callBase.apply(that, arguments);
                    that.__renderOptions = that.__forceRender = null;
                    return that
                },
                getSize: function() {
                    var canvas = this._canvas || {};
                    return {
                        width: canvas.width,
                        height: canvas.height
                    }
                }
            });
            _each(REINIT_REFRESH_ACTION_OPTIONS, function(_, name) {
                BaseChart.prototype._optionChangesMap[name] = "REINIT"
            });
            exports.overlapping = overlapping;
            exports.BaseChart = BaseChart;
            BaseChart.addPlugin(__webpack_require__( /*! ../core/data_source */ 161).plugin);
            BaseChart.addPlugin(__webpack_require__( /*! ../core/export */ 127).plugin);
            BaseChart.addPlugin(__webpack_require__( /*! ../core/title */ 164).plugin);
            BaseChart.addPlugin(__webpack_require__( /*! ../core/tooltip */ 165).plugin);
            BaseChart.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 163).plugin);
            var _change_TITLE = BaseChart.prototype._change_TITLE;
            BaseChart.prototype._change_TITLE = function() {
                _change_TITLE.apply(this, arguments);
                this._change(["FORCE_RENDER"])
            };
            var _change_TOOLTIP = BaseChart.prototype._change_TOOLTIP;
            BaseChart.prototype._change_TOOLTIP = function() {
                _change_TOOLTIP.apply(this, arguments);
                this._change(["CHART_TOOLTIP"])
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/components/data_validator.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                STRING = "string",
                NUMERIC = "numeric",
                DATETIME = "datetime",
                DISCRETE = "discrete",
                SEMIDISCRETE = "semidiscrete",
                CONTINUOUS = "continuous",
                LOGARITHMIC = "logarithmic",
                VALUE_TYPE = "valueType",
                ARGUMENT_TYPE = "argumentType",
                axisTypeParser = __webpack_require__( /*! ../core/utils */ 6).enumParser([STRING, NUMERIC, DATETIME]),
                _getParser = __webpack_require__( /*! ./parse_utils */ 234).getParser,
                _isDefined = commonUtils.isDefined,
                _isFunction = commonUtils.isFunction,
                _isArray = commonUtils.isArray,
                _isString = commonUtils.isString,
                _isDate = commonUtils.isDate,
                _isNumber = commonUtils.isNumber,
                _isObject = commonUtils.isObject,
                _each = $.each;

            function groupingValues(data, others, valueField, index) {
                if (index >= 0) {
                    _each(data.slice(index), function(_, cell) {
                        if (_isDefined(cell[valueField])) {
                            others[valueField] += cell[valueField];
                            cell[valueField] = cell["original" + valueField] = void 0
                        }
                    })
                }
            }

            function processGroup(_, group) {
                group.valueType = group.valueAxisType = null;
                _each(group.series, processSeries);
                group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)
            }

            function parseCategories(categories, parser) {
                var newArray = [];
                _each(categories, function(_, category) {
                    var parsedCategory = parser(category);
                    void 0 !== parsedCategory && newArray.push(parsedCategory)
                });
                return newArray
            }

            function parseAxisCategories(groupsData, parsers) {
                var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories,
                    valueParser = parsers[1];
                _each(groupsData.groups, function(_, valueGroup) {
                    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;
                    if (categories) {
                        valueGroup.valueOptions.categories = parseCategories(categories, valueParser)
                    }
                });
                if (argumentCategories) {
                    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])
                }
            }

            function processSeries(_, series) {
                series.updateDataType({})
            }

            function resetAxisTypes(_, axis) {
                axis.resetTypes(ARGUMENT_TYPE)
            }

            function filterForLogAxis(val, field, incidentOccurred) {
                if (val <= 0) {
                    incidentOccurred("E2004", [field]);
                    val = null
                }
                return val
            }

            function eigen(x) {
                return x
            }

            function getType(unit, type) {
                var result = type;
                if (type === STRING || _isString(unit)) {
                    result = STRING
                } else {
                    if (type === DATETIME || _isDate(unit)) {
                        result = DATETIME
                    } else {
                        if (_isNumber(unit)) {
                            result = NUMERIC
                        }
                    }
                }
                return result
            }

            function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
                if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
                    incidentOccurred("E2002")
                }
                return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS
            }

            function validUnit(unit, field, incidentOccurred) {
                if (unit) {
                    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? "E2003" : "E2004", [field])
                }
            }

            function createParserUnit(type, axisType, ignoreEmptyPoints, skipFields, incidentOccurred) {
                var parser = type ? _getParser(type) : eigen,
                    filter = axisType === LOGARITHMIC ? filterForLogAxis : eigen;
                return function(unit, field) {
                    var parseUnit = filter(parser(unit), field, incidentOccurred);
                    null === parseUnit && ignoreEmptyPoints && (parseUnit = void 0);
                    if (void 0 === parseUnit) {
                        skipFields[field] = (skipFields[field] || 0) + 1;
                        validUnit(unit, field, incidentOccurred)
                    }
                    return parseUnit
                }
            }

            function prepareParsers(groupsData, skipFields, incidentOccurred) {
                var sizeParser, valueParser, iep, argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, false, skipFields, incidentOccurred),
                    categoryParsers = [argumentParser],
                    cache = {},
                    list = [];
                _each(groupsData.groups, function(_, group) {
                    _each(group.series, function(_, series) {
                        iep = series.getOptions().ignoreEmptyPoints;
                        valueParser = createParserUnit(group.valueType, group.valueAxisType, iep, skipFields, incidentOccurred);
                        sizeParser = createParserUnit(NUMERIC, CONTINUOUS, iep, skipFields, incidentOccurred);
                        cache[series.getArgumentField()] = argumentParser;
                        _each(series.getValueFields(), function(_, field) {
                            !categoryParsers[1] && (categoryParsers[1] = valueParser);
                            cache[field] = valueParser
                        });
                        if (series.getSizeField()) {
                            cache[series.getSizeField()] = sizeParser
                        }
                        if (series.getTagField()) {
                            cache[series.getTagField()] = eigen
                        }
                    })
                });
                _each(cache, function(field, parser) {
                    list.push([field, parser])
                });
                list.length && parseAxisCategories(groupsData, categoryParsers);
                return list
            }

            function getParsedCell(cell, parsers) {
                var i, field, value, ii = parsers.length,
                    obj = {};
                for (i = 0; i < ii; ++i) {
                    field = parsers[i][0];
                    value = cell[field];
                    obj[field] = parsers[i][1](value, field);
                    obj["original" + field] = value
                }
                return obj
            }

            function parse(data, parsers) {
                var i, parsedData = [],
                    ii = data.length;
                parsedData.length = ii;
                for (i = 0; i < ii; ++i) {
                    parsedData[i] = getParsedCell(data[i], parsers)
                }
                return parsedData
            }

            function findIndexByThreshold(data, valueField, threshold) {
                var i, value, ii = data.length;
                for (i = 0; i < ii; ++i) {
                    value = data[i][valueField];
                    if (_isDefined(value) && threshold > value) {
                        break
                    }
                }
                return i
            }

            function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
                smallValuesGrouping = smallValuesGrouping || {};
                var data, mode = smallValuesGrouping.mode,
                    others = {};
                if (!mode || "none" === mode) {
                    return
                }
                others[argumentField] = String(smallValuesGrouping.groupName || "others");
                others[valueField] = 0;
                data = originalData.slice();
                data.sort(function(a, b) {
                    var isA = _isDefined(a[valueField]) ? 1 : 0,
                        isB = _isDefined(b[valueField]) ? 1 : 0;
                    return isA && isB ? b[valueField] - a[valueField] : isB - isA
                });
                groupingValues(data, others, valueField, "smallValueThreshold" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
                others[valueField] && originalData.push(others)
            }

            function groupPieData(data, groupsData) {
                var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0],
                    isPie = firstSeries && ("pie" === firstSeries.type || "doughnut" === firstSeries.type || "donut" === firstSeries.type);
                if (!isPie) {
                    return
                }
                _each(groupsData.groups, function(_, group) {
                    _each(group.series, function(_, series) {
                        groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)
                    })
                })
            }

            function addUniqueItemToCollection(item, collection, itemsHash) {
                if (!itemsHash[item]) {
                    collection.push(item);
                    itemsHash[item] = true
                }
            }

            function getUniqueArgumentFields(groupsData) {
                var uniqueArgumentFields = [],
                    hash = {};
                _each(groupsData.groups, function(_, group) {
                    _each(group.series, function(__, series) {
                        addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)
                    })
                });
                return uniqueArgumentFields
            }

            function discreteDataProcessing(data, groupsData, userArgumentCategories, uniqueArgumentFields) {
                var categories = groupsData.categories = $.extend([], userArgumentCategories),
                    hash = {};
                categories.length && _each(categories, function(_, currentCategory) {
                    hash[currentCategory] = true
                });
                _each(uniqueArgumentFields, function(_, field) {
                    _each(data, function(_, item) {
                        _isDefined(item[field]) && addUniqueItemToCollection(item[field], categories, hash)
                    })
                })
            }

            function compareWithoutHash(argumentField) {
                return function(a, b) {
                    var cmpResult = a[argumentField] - b[argumentField];
                    if (isNaN(cmpResult)) {
                        if (!a[argumentField]) {
                            return 1
                        }
                        if (!b[argumentField]) {
                            return -1
                        }
                        return 0
                    }
                    return cmpResult
                }
            }

            function sort(data, groupsData, sortingMethodOption, uniqueArgumentFields) {
                var getSortingMethod, itemsHash = {},
                    dataByArguments = {},
                    getSortMethodByType = function(sortingByHash, hash) {
                        return sortingByHash ? function(argumentField) {
                            return function(a, b) {
                                return hash[a[argumentField]] - hash[b[argumentField]]
                            }
                        } : compareWithoutHash
                    };
                if (_isFunction(sortingMethodOption)) {
                    data.sort(sortingMethodOption)
                } else {
                    if (groupsData.categories) {
                        _each(groupsData.categories, function(index, value) {
                            itemsHash[value] = index
                        });
                        getSortingMethod = getSortMethodByType(true, itemsHash)
                    } else {
                        if (true === sortingMethodOption && groupsData.argumentType !== STRING) {
                            getSortingMethod = getSortMethodByType(false, itemsHash)
                        }
                    }
                }
                _each(uniqueArgumentFields, function(_, argumentField) {
                    var sortMethod, currentDataItem;
                    if (getSortingMethod) {
                        sortMethod = getSortingMethod(argumentField);
                        currentDataItem = data.slice().sort(sortMethod)
                    } else {
                        currentDataItem = data
                    }
                    dataByArguments[argumentField] = currentDataItem
                });
                return dataByArguments
            }

            function checkValueTypeOfGroup(group, cell) {
                _each(group.series, function(_, series) {
                    _each(series.getValueFields(), function(_, field) {
                        group.valueType = getType(cell[field], group.valueType)
                    })
                });
                return group.valueType
            }

            function checkArgumentTypeOfGroup(series, cell, groupsData) {
                _each(series, function(_, currentCeries) {
                    groupsData.argumentType = getType(cell[currentCeries.getArgumentField()], groupsData.argumentType)
                });
                return groupsData.argumentType
            }

            function checkType(data, groupsData, checkTypeForAllData) {
                var groupsWithUndefinedValueType = [],
                    groupsWithUndefinedArgumentType = [],
                    argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
                _each(groupsData.groups, function(_, group) {
                    if (!group.series.length) {
                        return null
                    }
                    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
                    group.valueType = valueTypeGroup;
                    groupsData.argumentType = argumentTypeGroup;
                    !valueTypeGroup && groupsWithUndefinedValueType.push(group);
                    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)
                });
                if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
                    _each(data, function(_, cell) {
                        var defineVal, defineArg;
                        _each(groupsWithUndefinedValueType, function(_, group) {
                            defineVal = checkValueTypeOfGroup(group, cell)
                        });
                        _each(groupsWithUndefinedArgumentType, function(_, group) {
                            defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)
                        });
                        if (!checkTypeForAllData && defineVal && defineArg) {
                            return false
                        }
                    })
                }
            }

            function checkAxisType(groupsData, userArgumentCategories, incidentOccurred) {
                var argumentOptions = groupsData.argumentOptions || {},
                    argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
                _each(groupsData.groups, function(_, group) {
                    var valueOptions = group.valueOptions || {},
                        valueCategories = valueOptions.categories || [],
                        valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
                    _each(group.series, function(_, series) {
                        var optionsSeries = {};
                        optionsSeries.argumentAxisType = argumentAxisType;
                        optionsSeries.valueAxisType = valueAxisType;
                        groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
                        group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
                        optionsSeries.argumentType = groupsData.argumentType;
                        optionsSeries.valueType = group.valueType;
                        optionsSeries.showZero = valueOptions.showZero;
                        series.updateDataType(optionsSeries)
                    });
                    group.valueAxisType = group.valueAxisType || valueAxisType;
                    if (group.valueAxis) {
                        group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
                        group.valueAxis.validate(false)
                    }
                });
                groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;
                if (groupsData.argumentAxes) {
                    _each(groupsData.argumentAxes, function(_, axis) {
                        axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
                        axis.validate(true)
                    })
                }
            }

            function verifyData(source, incidentOccurred) {
                var i, ii, k, item, data = [],
                    hasError = !_isArray(source);
                if (!hasError) {
                    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
                        item = source[i];
                        if (_isObject(item)) {
                            data[k++] = item
                        } else {
                            if (item) {
                                hasError = true
                            }
                        }
                    }
                }
                if (hasError) {
                    incidentOccurred("E2001")
                }
                return data
            }

            function validateData(data, groupsData, incidentOccurred, options) {
                var parsers, dataLength, categoriesInAxisType, dataByArgumentFields, skipFields = {},
                    argumentOptions = groupsData.argumentOptions,
                    userArgumentCategories = argumentOptions && argumentOptions.categories || [],
                    uniqueArgumentFields = getUniqueArgumentFields(groupsData);
                data = verifyData(data, incidentOccurred);
                groupsData.argumentType = groupsData.argumentAxisType = null;
                _each(groupsData.groups, processGroup);
                if (groupsData.argumentAxes) {
                    _each(groupsData.argumentAxes, resetAxisTypes)
                }
                checkType(data, groupsData, options.checkTypeForAllData);
                checkAxisType(groupsData, userArgumentCategories, incidentOccurred);
                if (options.convertToAxisDataType) {
                    parsers = prepareParsers(groupsData, skipFields, incidentOccurred);
                    data = parse(data, parsers)
                }
                groupPieData(data, groupsData);
                categoriesInAxisType = argumentOptions && argumentOptions.categories || [];
                groupsData.argumentAxisType === DISCRETE && discreteDataProcessing(data, groupsData, categoriesInAxisType, uniqueArgumentFields);
                dataByArgumentFields = sort(data, groupsData, options.sortingMethod, uniqueArgumentFields);
                dataLength = data.length;
                _each(skipFields, function(field, fieldValue) {
                    if (fieldValue === dataLength) {
                        incidentOccurred("W2002", [field])
                    }
                });
                return dataByArgumentFields
            }
            exports.validateData = validateData;
            exports.DEBUG_validateData_sort = sort
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/components/parse_utils.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                isDefined = commonUtils.isDefined,
                parsers = {
                    string: function(val) {
                        return isDefined(val) ? "" + val : val
                    },
                    numeric: function(val) {
                        if (!isDefined(val)) {
                            return val
                        }
                        var parsedVal = Number(val);
                        if (isNaN(parsedVal)) {
                            parsedVal = void 0
                        }
                        return parsedVal
                    },
                    datetime: function(val) {
                        if (!isDefined(val)) {
                            return val
                        }
                        var parsedVal, numVal = Number(val);
                        if (!isNaN(numVal)) {
                            parsedVal = new Date(numVal)
                        } else {
                            parsedVal = new Date(val)
                        }
                        if (isNaN(Number(parsedVal))) {
                            parsedVal = void 0
                        }
                        return parsedVal
                    }
                };

            function correctValueType(type) {
                return "numeric" === type || "datetime" === type || "string" === type ? type : ""
            }
            module.exports = {
                correctValueType: correctValueType,
                getParser: function(valueType) {
                    return parsers[correctValueType(valueType)] || $.noop
                }
            };
            module.exports.parsers = parsers
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/gauges/base_indicators.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _isFinite = isFinite,
                _Number = Number,
                _round = Math.round,
                baseGaugeModule = __webpack_require__( /*! ./base_gauge */ 128),
                _formatValue = baseGaugeModule.formatValue,
                _getSampleText = baseGaugeModule.getSampleText,
                _patchFontOptions = __webpack_require__( /*! ../core/utils */ 6).patchFontOptions,
                Class = __webpack_require__( /*! ../../core/class */ 5);
            var BaseElement = Class.inherit({
                ctor: function(parameters) {
                    var that = this;
                    $.each(parameters, function(name, value) {
                        that["_" + name] = value
                    });
                    that._init()
                },
                dispose: function() {
                    var that = this;
                    that._dispose();
                    $.each(that, function(name) {
                        that[name] = null
                    });
                    return that
                },
                getOffset: function() {
                    return _Number(this._options.offset) || 0
                }
            });
            var BaseIndicator = BaseElement.inherit({
                _init: function() {
                    var that = this;
                    that._rootElement = that._createRoot().linkOn(that._owner, {
                        name: "value-indicator",
                        after: "core"
                    });
                    that._trackerElement = that._createTracker()
                },
                _dispose: function() {
                    this._rootElement.linkOff()
                },
                _setupAnimation: function() {
                    var that = this;
                    if (that._options.animation) {
                        that._animation = {
                            step: function(pos) {
                                that._actualValue = that._animation.start + that._animation.delta * pos;
                                that._actualPosition = that._translator.translate(that._actualValue);
                                that._move()
                            },
                            duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
                            easing: that._options.animation.easing
                        }
                    }
                },
                _runAnimation: function(value) {
                    var that = this,
                        animation = that._animation;
                    animation.start = that._actualValue;
                    animation.delta = value - that._actualValue;
                    that._rootElement.animate({
                        _: 0
                    }, {
                        step: animation.step,
                        duration: animation.duration,
                        easing: animation.easing
                    })
                },
                _createRoot: function() {
                    return this._renderer.g().attr({
                        "class": this._className
                    })
                },
                _createTracker: function() {
                    return this._renderer.path([], "area")
                },
                _getTrackerSettings: $.noop,
                clean: function() {
                    var that = this;
                    that._animation && that._rootElement.stopAnimation();
                    that._rootElement.linkRemove().clear();
                    that._clear();
                    that._tracker.detach(that._trackerElement);
                    that._options = that.enabled = that._animation = null;
                    return that
                },
                render: function(options) {
                    var that = this;
                    that.type = options.type;
                    that._options = options;
                    that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
                    that.enabled = that._isEnabled();
                    if (that.enabled) {
                        that._setupAnimation();
                        that._rootElement.attr({
                            fill: that._options.color
                        }).linkAppend();
                        that._tracker.attach(that._trackerElement, that, that._trackerInfo)
                    }
                    return that
                },
                resize: function(layout) {
                    var that = this;
                    that._rootElement.clear();
                    that._clear();
                    that.visible = that._isVisible(layout);
                    if (that.visible) {
                        $.extend(that._options, layout);
                        that._actualPosition = that._translator.translate(that._actualValue);
                        that._render();
                        that._trackerElement.attr(that._getTrackerSettings());
                        that._move()
                    }
                    return that
                },
                value: function(arg, _noAnimation) {
                    var val, that = this;
                    if (void 0 !== arg) {
                        val = that._translator.adjust(arg);
                        if (that._currentValue !== val && _isFinite(val)) {
                            that._currentValue = val;
                            if (that.visible) {
                                if (that._animation && !_noAnimation) {
                                    that._runAnimation(val)
                                } else {
                                    that._actualValue = val;
                                    that._actualPosition = that._translator.translate(val);
                                    that._move()
                                }
                            }
                        }
                        return that
                    }
                    return that._currentValue
                },
                _isEnabled: null,
                _isVisible: null,
                _render: null,
                _clear: null,
                _move: null
            });
            var COEFFICIENTS_MAP = {};
            COEFFICIENTS_MAP["right-bottom"] = COEFFICIENTS_MAP.rb = [0, -1, -1, 0, 0, 1, 1, 0];
            COEFFICIENTS_MAP["bottom-right"] = COEFFICIENTS_MAP.br = [-1, 0, 0, -1, 1, 0, 0, 1];
            COEFFICIENTS_MAP["left-bottom"] = COEFFICIENTS_MAP.lb = [0, -1, 1, 0, 0, 1, -1, 0];
            COEFFICIENTS_MAP["bottom-left"] = COEFFICIENTS_MAP.bl = [1, 0, 0, -1, -1, 0, 0, 1];
            COEFFICIENTS_MAP["left-top"] = COEFFICIENTS_MAP.lt = [0, 1, 1, 0, 0, -1, -1, 0];
            COEFFICIENTS_MAP["top-left"] = COEFFICIENTS_MAP.tl = [1, 0, 0, 1, -1, 0, 0, -1];
            COEFFICIENTS_MAP["right-top"] = COEFFICIENTS_MAP.rt = [0, 1, -1, 0, 0, -1, 1, 0];
            COEFFICIENTS_MAP["top-right"] = COEFFICIENTS_MAP.tr = [-1, 0, 0, 1, 1, 0, 0, -1];

            function getTextCloudInfo(options) {
                var tailWidth, tailHeight, x = options.x,
                    y = options.y,
                    type = COEFFICIENTS_MAP[options.type],
                    cloudWidth = options.textWidth + 2 * options.horMargin,
                    cloudHeight = options.textHeight + 2 * options.verMargin,
                    cx = x,
                    cy = y;
                tailWidth = tailHeight = options.tailLength;
                if (1 & type[0]) {
                    tailHeight = Math.min(tailHeight, cloudHeight / 3)
                } else {
                    tailWidth = Math.min(tailWidth, cloudWidth / 3)
                }
                return {
                    cx: _round(cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2),
                    cy: _round(cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2),
                    points: [_round(x), _round(y), _round(x += type[0] * (cloudWidth + tailWidth)), _round(y += type[1] * (cloudHeight + tailHeight)), _round(x += type[2] * cloudWidth), _round(y += type[3] * cloudHeight), _round(x += type[4] * cloudWidth), _round(y += type[5] * cloudHeight), _round(x += type[6] * (cloudWidth - tailWidth)), _round(y += type[7] * (cloudHeight - tailHeight))]
                }
            }
            var BaseTextCloudMarker = BaseIndicator.inherit({
                _move: function() {
                    var bbox, info, that = this,
                        textCloudOptions = that._getTextCloudOptions(),
                        text = _formatValue(that._actualValue, that._options.text);
                    that._text.attr({
                        text: text
                    });
                    bbox = that._text.getBBox();
                    info = getTextCloudInfo({
                        x: textCloudOptions.x,
                        y: textCloudOptions.y,
                        textWidth: bbox.width || text.length * that._textUnitWidth,
                        textHeight: bbox.height || that._textHeight,
                        horMargin: that._options.horizontalOffset,
                        verMargin: that._options.verticalOffset,
                        tailLength: that._options.arrowLength,
                        type: textCloudOptions.type
                    });
                    that._text.attr({
                        x: info.cx,
                        y: info.cy + that._textVerticalOffset
                    });
                    that._cloud.attr({
                        points: info.points
                    });
                    that._trackerElement && that._trackerElement.attr({
                        points: info.points
                    })
                },
                _measureText: function() {
                    var root, text, bbox, sampleText, that = this;
                    if (!that._textVerticalOffset) {
                        root = that._createRoot().append(that._owner);
                        sampleText = _getSampleText(that._translator, that._options.text);
                        text = that._renderer.text(sampleText, 0, 0).attr({
                            align: "center"
                        }).css(_patchFontOptions(that._options.text.font)).append(root);
                        bbox = text.getBBox();
                        root.remove();
                        that._textVerticalOffset = -bbox.y - bbox.height / 2;
                        that._textWidth = bbox.width;
                        that._textHeight = bbox.height;
                        that._textUnitWidth = that._textWidth / sampleText.length;
                        that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
                        that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset
                    }
                },
                _render: function() {
                    var that = this;
                    that._measureText();
                    that._cloud = that._cloud || that._renderer.path([], "area").append(that._rootElement);
                    that._text = that._text || that._renderer.text().append(that._rootElement);
                    that._text.attr({
                        align: "center"
                    }).css(_patchFontOptions(that._options.text.font))
                },
                _clear: function() {
                    delete this._cloud;
                    delete this._text
                },
                getTooltipParameters: function() {
                    var position = this._getTextCloudOptions();
                    return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color
                    }
                }
            });
            var BaseRangeBar = BaseIndicator.inherit({
                _measureText: function() {
                    var root, text, bbox, that = this;
                    that._hasText = that._isTextVisible();
                    if (that._hasText && !that._textVerticalOffset) {
                        root = that._createRoot().append(that._owner);
                        text = that._renderer.text(_getSampleText(that._translator, that._options.text), 0, 0).attr({
                            "class": "dxg-text",
                            align: "center"
                        }).css(_patchFontOptions(that._options.text.font)).append(root);
                        bbox = text.getBBox();
                        root.remove();
                        that._textVerticalOffset = -bbox.y - bbox.height / 2;
                        that._textWidth = bbox.width;
                        that._textHeight = bbox.height
                    }
                },
                _move: function() {
                    var that = this;
                    that._updateBarItemsPositions();
                    if (that._hasText) {
                        that._text.attr({
                            text: _formatValue(that._actualValue, that._options.text)
                        });
                        that._updateTextPosition();
                        that._updateLinePosition()
                    }
                },
                _updateBarItems: function() {
                    var backgroundColor, spaceColor, that = this,
                        options = that._options,
                        translator = that._translator;
                    that._setBarSides();
                    that._startPosition = translator.translate(translator.getDomainStart());
                    that._endPosition = translator.translate(translator.getDomainEnd());
                    that._basePosition = translator.translate(options.baseValue);
                    that._space = that._getSpace();
                    backgroundColor = options.backgroundColor || "none";
                    if ("none" !== backgroundColor && that._space > 0) {
                        spaceColor = options.containerBackgroundColor || "none"
                    } else {
                        that._space = 0;
                        spaceColor = "none"
                    }
                    that._backItem1.attr({
                        fill: backgroundColor
                    });
                    that._backItem2.attr({
                        fill: backgroundColor
                    });
                    that._spaceItem1.attr({
                        fill: spaceColor
                    });
                    that._spaceItem2.attr({
                        fill: spaceColor
                    })
                },
                _getSpace: function() {
                    return 0
                },
                _updateTextItems: function() {
                    var that = this;
                    if (that._hasText) {
                        that._line = that._line || that._renderer.path([], "line").attr({
                            "class": "dxg-main-bar",
                            "stroke-linecap": "square"
                        }).append(that._rootElement);
                        that._text = that._text || that._renderer.text("", 0, 0).attr({
                            "class": "dxg-text"
                        }).append(that._rootElement);
                        that._text.attr({
                            align: that._getTextAlign()
                        }).css(that._getFontOptions());
                        that._setTextItemsSides()
                    } else {
                        if (that._line) {
                            that._line.remove();
                            delete that._line
                        }
                        if (that._text) {
                            that._text.remove();
                            delete that._text
                        }
                    }
                },
                _isTextVisible: function() {
                    return false
                },
                _getTextAlign: function() {
                    return "center"
                },
                _getFontOptions: function() {
                    var options = this._options,
                        font = options.text.font;
                    if (!font || !font.color) {
                        font = $.extend({}, font, {
                            color: options.color
                        })
                    }
                    return _patchFontOptions(font)
                },
                _updateBarItemsPositions: function() {
                    var that = this,
                        positions = that._getPositions();
                    that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));
                    that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));
                    that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));
                    that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));
                    that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));
                    that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2))
                },
                _render: function() {
                    var that = this;
                    that._measureText();
                    if (!that._backItem1) {
                        that._backItem1 = that._createBarItem();
                        that._backItem1.attr({
                            "class": "dxg-back-bar"
                        })
                    }
                    if (!that._backItem2) {
                        that._backItem2 = that._createBarItem();
                        that._backItem2.attr({
                            "class": "dxg-back-bar"
                        })
                    }
                    if (!that._spaceItem1) {
                        that._spaceItem1 = that._createBarItem();
                        that._spaceItem1.attr({
                            "class": "dxg-space-bar"
                        })
                    }
                    if (!that._spaceItem2) {
                        that._spaceItem2 = that._createBarItem();
                        that._spaceItem2.attr({
                            "class": "dxg-space-bar"
                        })
                    }
                    if (!that._mainItem) {
                        that._mainItem = that._createBarItem();
                        that._mainItem.attr({
                            "class": "dxg-main-bar"
                        })
                    }
                    that._updateBarItems();
                    that._updateTextItems()
                },
                _clear: function() {
                    var that = this;
                    delete that._backItem1;
                    delete that._backItem2;
                    delete that._spaceItem1;
                    delete that._spaceItem2;
                    delete that._mainItem;
                    delete that._hasText;
                    delete that._line;
                    delete that._text
                },
                getTooltipParameters: function() {
                    var position = this._getTooltipPosition();
                    return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color,
                        offset: 0
                    }
                }
            });
            exports.BaseElement = BaseElement;
            exports.BaseIndicator = BaseIndicator;
            exports.BaseTextCloudMarker = BaseTextCloudMarker;
            exports.BaseRangeBar = BaseRangeBar;
            exports.getTextCloudInfo = getTextCloudInfo
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/series/base_series.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                seriesNS = {},
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                pointModule = __webpack_require__( /*! ./points/base_point */ 544),
                _isDefined = commonUtils.isDefined,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _map = vizUtils.map,
                _each = $.each,
                _extend = $.extend,
                _isEmptyObject = $.isEmptyObject,
                _normalizeEnum = vizUtils.normalizeEnum,
                _Event = $.Event,
                _noop = $.noop,
                _inArray = $.inArray,
                states = __webpack_require__( /*! ../components/consts */ 126).states,
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88),
                lineSeries = __webpack_require__( /*! ./line_series */ 193),
                areaSeries = __webpack_require__( /*! ./area_series */ 166),
                barSeries = __webpack_require__( /*! ./bar_series */ 129),
                rangeSeries = __webpack_require__( /*! ./range_series */ 549),
                bubbleSeries = __webpack_require__( /*! ./bubble_series */ 541),
                pieSeries = __webpack_require__( /*! ./pie_series */ 543),
                financialSeries = __webpack_require__( /*! ./financial_series */ 542),
                stackedSeries = __webpack_require__( /*! ./stacked_series */ 550),
                DISCRETE = "discrete",
                SELECTED_STATE = states.selectedMark,
                HOVER_STATE = states.hoverMark,
                HOVER = states.hover,
                NORMAL = states.normal,
                SELECTION = states.selection,
                APPLY_SELECTED = states.applySelected,
                APPLY_HOVER = states.applyHover,
                RESET_ITEM = states.resetItem,
                NONE_MODE = "none",
                INCLUDE_POINTS = "includepoints",
                EXLUDE_POINTS = "excludepoints",
                NEAREST_POINT = "nearestpoint",
                getEmptyBusinessRange = function() {
                    return {
                        arg: {},
                        val: {}
                    }
                };

            function triggerEvent(element, event, point) {
                element && element.trigger(event, point)
            }
            seriesNS.mixins = {
                chart: {},
                pie: {},
                polar: {}
            };
            seriesNS.mixins.chart.scatter = scatterSeries.chart;
            seriesNS.mixins.polar.scatter = scatterSeries.polar;
            $.extend(seriesNS.mixins.pie, pieSeries);
            $.extend(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, rangeSeries.chart, bubbleSeries.chart, financialSeries, stackedSeries.chart);
            $.extend(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, rangeSeries.polar, bubbleSeries.polar, stackedSeries.polar);

            function includePointsMode(mode) {
                return mode === INCLUDE_POINTS || "allseriespoints" === mode
            }

            function getLabelOptions(labelOptions, defaultColor) {
                var opt = labelOptions || {},
                    labelFont = _extend({}, opt.font) || {},
                    labelBorder = opt.border || {},
                    labelConnector = opt.connector || {},
                    backgroundAttr = {
                        fill: opt.backgroundColor || defaultColor,
                        "stroke-width": labelBorder.visible ? labelBorder.width || 0 : 0,
                        stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : "none",
                        dashStyle: labelBorder.dashStyle
                    },
                    connectorAttr = {
                        stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : "none",
                        "stroke-width": labelConnector.visible ? labelConnector.width || 0 : 0
                    };
                labelFont.color = "none" === opt.backgroundColor && "#ffffff" === _normalizeEnum(labelFont.color) && "inside" !== opt.position ? defaultColor : labelFont.color;
                return {
                    alignment: opt.alignment,
                    format: opt.format,
                    argumentFormat: opt.argumentFormat,
                    precision: opt.precision,
                    argumentPrecision: opt.argumentPrecision,
                    percentPrecision: opt.percentPrecision,
                    customizeText: $.isFunction(opt.customizeText) ? opt.customizeText : void 0,
                    attributes: {
                        font: labelFont
                    },
                    visible: 0 !== labelFont.size ? opt.visible : false,
                    showForZeroValues: opt.showForZeroValues,
                    horizontalOffset: opt.horizontalOffset,
                    verticalOffset: opt.verticalOffset,
                    radialOffset: opt.radialOffset,
                    background: backgroundAttr,
                    position: opt.position,
                    connector: connectorAttr,
                    rotationAngle: opt.rotationAngle
                }
            }

            function applyPointStyle(point, styleName) {
                !point.isSelected() && !point.hasSelectedView && point.applyStyle(styleName)
            }

            function Series(renderSettings, options) {
                var that = this;
                that.fullState = 0;
                that._extGroups = renderSettings;
                that._renderer = renderSettings.renderer;
                that._group = renderSettings.renderer.g().attr({
                    "class": "dxc-series"
                });
                that.updateOptions(options)
            }
            exports.Series = Series;
            exports.mixins = seriesNS.mixins;
            Series.prototype = {
                constructor: Series,
                _createLegendState: _noop,
                getLegendStyles: function() {
                    return this._styles.legendStyles
                },
                _createStyles: function(options) {
                    var that = this,
                        mainSeriesColor = options.mainSeriesColor,
                        specialMainColor = that._getSpecialColor(mainSeriesColor);
                    that._styles = {
                        normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
                        hover: that._parseStyle(options.hoverStyle || {}, specialMainColor, mainSeriesColor),
                        selection: that._parseStyle(options.selectionStyle || {}, specialMainColor, mainSeriesColor),
                        legendStyles: {
                            normal: that._createLegendState(options, mainSeriesColor),
                            hover: that._createLegendState(options.hoverStyle || {}, specialMainColor),
                            selection: that._createLegendState(options.selectionStyle || {}, specialMainColor)
                        }
                    }
                },
                setClippingParams: function(baseId, wideId, forceClipping) {
                    this._paneClipRectID = baseId;
                    this._widePaneClipRectID = wideId;
                    this._forceClipping = forceClipping
                },
                applyClip: function() {
                    this._group.attr({
                        clipId: this._paneClipRectID
                    })
                },
                resetClip: function() {
                    this._group.attr({
                        clipId: null
                    })
                },
                getTagField: function() {
                    return this._options.tagField || "tag"
                },
                getValueFields: _noop,
                getSizeField: _noop,
                getArgumentField: _noop,
                getPoints: function() {
                    return this._points
                },
                _createPoint: function(data, pointsArray, index) {
                    data.index = index;
                    var options, arg, pba, that = this,
                        point = pointsArray[index],
                        pointsByArgument = that.pointsByArgument;
                    if (that._checkData(data)) {
                        options = that._customizePoint(data) || that._getCreatingPointOptions(data);
                        if (point) {
                            point.update(data, options)
                        } else {
                            point = new pointModule.Point(that, data, options);
                            pointsArray.push(point)
                        }
                        arg = point.argument.valueOf();
                        pba = pointsByArgument[arg];
                        if (pba) {
                            pba.push(point)
                        } else {
                            pointsByArgument[arg] = [point]
                        }
                        return true
                    }
                },
                getRangeData: function(zoomArgs, calcIntervalFunction) {
                    return this._visible ? _extend(true, {}, this._getRangeData(zoomArgs, calcIntervalFunction)) : getEmptyBusinessRange()
                },
                _deleteGroup: function(groupName) {
                    var group = this[groupName];
                    if (group) {
                        group.dispose();
                        this[groupName] = null
                    }
                },
                _saveOldAnimationMethods: function() {
                    var that = this;
                    that._oldClearingAnimation = that._clearingAnimation;
                    that._oldUpdateElement = that._updateElement;
                    that._oldgetAffineCoordOptions = that._getAffineCoordOptions
                },
                _deleteOldAnimationMethods: function() {
                    this._oldClearingAnimation = null;
                    this._oldUpdateElement = null;
                    this._oldgetAffineCoordOptions = null
                },
                updateOptions: function(newOptions) {
                    var that = this,
                        widgetType = newOptions.widgetType,
                        oldType = that.type,
                        newType = newOptions.type;
                    that.type = newType && _normalizeEnum(newType.toString());
                    if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
                        that.dispose();
                        that.isUpdated = false;
                        return
                    }
                    if (oldType !== that.type) {
                        that._firstDrawing = true;
                        that._saveOldAnimationMethods();
                        that._resetType(oldType, widgetType);
                        that._setType(that.type, widgetType)
                    }
                    that._options = newOptions;
                    that._pointOptions = null;
                    that._deletePatterns();
                    that.name = newOptions.name;
                    that.pane = newOptions.pane;
                    that.axis = newOptions.axis;
                    that.tag = newOptions.tag;
                    that._createStyles(newOptions);
                    that._updateOptions(newOptions);
                    that._visible = newOptions.visible;
                    that.isUpdated = true;
                    that._createGroups()
                },
                _disposePoints: function(points) {
                    _each(points || [], function(_, p) {
                        p.dispose()
                    })
                },
                _correctPointsLength: function(length, points) {
                    this._disposePoints(this._oldPoints);
                    this._oldPoints = points.splice(length, points.length)
                },
                getErrorBarRangeCorrector: _noop,
                updateDataType: function(settings) {
                    var that = this;
                    that.argumentType = settings.argumentType;
                    that.valueType = settings.valueType;
                    that.argumentAxisType = settings.argumentAxisType;
                    that.valueAxisType = settings.valueAxisType;
                    that.showZero = settings.showZero;
                    return that
                },
                getOptions: function() {
                    return this._options
                },
                _resetRangeData: function() {
                    this._rangeData = getEmptyBusinessRange()
                },
                updateData: function(data) {
                    var curPoint, that = this,
                        points = that._originalPoints || [],
                        lastPointIndex = 0,
                        options = that._options,
                        i = 0,
                        len = data.length,
                        lastPoint = null,
                        rangeCorrector = that.getErrorBarRangeCorrector();
                    that.pointsByArgument = {};
                    that._resetRangeData();
                    if (data && data.length) {
                        that._canRenderCompleteHandle = true
                    }
                    that._beginUpdateData(data);
                    while (i < len) {
                        if (that._createPoint(that._getPointData(data[i], options), points, lastPointIndex)) {
                            curPoint = points[lastPointIndex];
                            that._processRange(curPoint, lastPoint, rangeCorrector);
                            lastPoint = curPoint;
                            lastPointIndex++
                        }
                        i++
                    }
                    that._disposePoints(that._aggregatedPoints);
                    that._aggregatedPoints = null;
                    that._points = that._originalPoints = points;
                    that._correctPointsLength(lastPointIndex, points);
                    that._endUpdateData()
                },
                getTemplateFields: function() {
                    return this.getValueFields().concat(this.getTagField(), this.getSizeField()).map(function(field) {
                        return {
                            templateField: field + this.name,
                            originalField: field
                        }
                    }, this)
                },
                resamplePoints: function(argTranslator, min, max) {
                    var categories, discreteMin, discreteMax, count, tickInterval, that = this,
                        sizePoint = that._getPointSize(),
                        pointsLength = that.getAllPoints().length,
                        businessRange = argTranslator.getBusinessRange();
                    if (pointsLength && pointsLength > 1) {
                        count = argTranslator.canvasLength / sizePoint;
                        count = count <= 1 ? 1 : count;
                        if (that.argumentAxisType !== DISCRETE) {
                            tickInterval = (businessRange.maxVisible - businessRange.minVisible) / count;
                            if (that.valueAxisType === DISCRETE) {
                                tickInterval = Math.ceil(tickInterval)
                            }
                        } else {
                            categories = businessRange.categories;
                            discreteMin = _inArray(min, categories);
                            discreteMax = _inArray(max, categories);
                            if (-1 !== discreteMin && -1 !== discreteMax) {
                                categories = categories.slice(discreteMin, discreteMax + 1)
                            }
                            pointsLength = categories.length;
                            tickInterval = Math.ceil(pointsLength / count)
                        }
                        that._points = that._resample(tickInterval, min - tickInterval, max + tickInterval, _isDefined(min) && _isDefined(max))
                    }
                },
                _removeOldSegments: function(startIndex) {
                    var that = this;
                    _each(that._graphics.splice(startIndex, that._graphics.length) || [], function(_, elem) {
                        that._removeElement(elem)
                    });
                    if (that._trackers) {
                        _each(that._trackers.splice(startIndex, that._trackers.length) || [], function(_, elem) {
                            elem.remove()
                        })
                    }
                },
                draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
                    var drawComplete, that = this;
                    if (that._oldClearingAnimation && animationEnabled && that._firstDrawing) {
                        drawComplete = function() {
                            that._draw(translators, true, hideLayoutLabels)
                        };
                        that._oldClearingAnimation(translators, drawComplete)
                    } else {
                        that._draw(translators, animationEnabled, hideLayoutLabels, legendCallback)
                    }
                },
                _draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
                    var groupForPoint, that = this,
                        points = that._points || [],
                        segment = [],
                        segmentCount = 0,
                        firstDrawing = that._firstDrawing,
                        closeSegment = points[0] && points[0].hasValue() && that._options.closed;
                    that._graphics = that._graphics || [];
                    that._prepareSeriesToDrawing();
                    if (!that._visible) {
                        animationEnabled = false;
                        that._group.remove();
                        return
                    }
                    that._appendInGroup();
                    that.translators = translators;
                    that._applyVisibleArea();
                    that._setGroupsSettings(animationEnabled, firstDrawing);
                    that._segments = [];
                    that._drawnPoints = [];
                    that._firstDrawing = points.length ? false : true;
                    groupForPoint = {
                        markers: that._markersGroup,
                        errorBars: that._errorBarGroup
                    };
                    _each(points, function(i, p) {
                        p.translate(translators);
                        if (p.hasValue()) {
                            that._drawPoint({
                                point: p,
                                groups: groupForPoint,
                                hasAnimation: animationEnabled,
                                firstDrawing: firstDrawing,
                                legendCallback: legendCallback
                            });
                            segment.push(p)
                        } else {
                            if (segment.length) {
                                that._drawSegment(segment, animationEnabled, segmentCount++);
                                segment = []
                            }
                        }
                    });
                    segment.length && that._drawSegment(segment, animationEnabled, segmentCount++, closeSegment);
                    that._removeOldSegments(segmentCount);
                    that._defaultSegments = that._generateDefaultSegments();
                    hideLayoutLabels && that.hideLabels();
                    animationEnabled && that._animate(firstDrawing);
                    if (that.isSelected()) {
                        that._changeStyle(legendCallback, APPLY_SELECTED)
                    } else {
                        if (that.isHovered()) {
                            that._changeStyle(legendCallback, APPLY_HOVER)
                        }
                    }
                },
                _setLabelGroupSettings: function(animationEnabled) {
                    var settings = {
                        "class": "dxc-labels"
                    };
                    this._applyElementsClipRect(settings);
                    this._applyClearingSettings(settings);
                    animationEnabled && (settings.opacity = .001);
                    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup)
                },
                _checkType: function(widgetType) {
                    return !!seriesNS.mixins[widgetType][this.type]
                },
                _checkPolarBarType: function(widgetType, options) {
                    return "polar" === widgetType && options.spiderWidget && -1 !== this.type.indexOf("bar")
                },
                _resetType: function(seriesType, widgetType) {
                    var methodName, methods;
                    if (seriesType) {
                        methods = seriesNS.mixins[widgetType][seriesType];
                        for (methodName in methods) {
                            delete this[methodName]
                        }
                    }
                },
                _setType: function(seriesType, widgetType) {
                    var methodName, methods = seriesNS.mixins[widgetType][seriesType];
                    for (methodName in methods) {
                        this[methodName] = methods[methodName]
                    }
                },
                setSelectedState: function(state, mode, legendCallback) {
                    var that = this;
                    that.lastSelectionMode = _normalizeEnum(mode || that._options.selectionMode);
                    if (state && !that.isSelected()) {
                        that.fullState = that.fullState | SELECTED_STATE;
                        that._nearestPoint && applyPointStyle(that._nearestPoint, NORMAL);
                        that._nearestPoint = null;
                        that._changeStyle(legendCallback, APPLY_SELECTED)
                    } else {
                        if (!state && that.isSelected()) {
                            that.fullState = that.fullState & ~SELECTED_STATE;
                            if (that.isHovered()) {
                                that._changeStyle(legendCallback, APPLY_HOVER, SELECTION)
                            } else {
                                that._changeStyle(legendCallback, RESET_ITEM)
                            }
                        }
                    }
                },
                setHoverState: function(state, mode, legendCallback) {
                    var that = this;
                    that.lastHoverMode = _normalizeEnum(mode || that._options.hoverMode);
                    if (state && !that.isHovered()) {
                        that.fullState = that.fullState | HOVER_STATE;
                        !that.isSelected() && that._changeStyle(legendCallback, APPLY_HOVER)
                    } else {
                        if (!state && that.isHovered()) {
                            that._nearestPoint = null;
                            that.fullState = that.fullState & ~HOVER_STATE;
                            !that.isSelected() && that._changeStyle(legendCallback, RESET_ITEM)
                        }
                    }
                },
                setHoverView: function() {
                    if (this._canChangeView()) {
                        this._applyStyle(this._styles.hover);
                        return this
                    }
                    return null
                },
                releaseHoverView: function(legendCallback) {
                    this._canChangeView() && this._applyStyle(this._styles.normal)
                },
                isFullStackedSeries: function() {
                    return 0 === this.type.indexOf("fullstacked")
                },
                isStackedSeries: function() {
                    return 0 === this.type.indexOf("stacked")
                },
                isFinancialSeries: function() {
                    return "stock" === this.type || "candlestick" === this.type
                },
                _canChangeView: function() {
                    return !this.isSelected() && _normalizeEnum(this._options.hoverMode) !== NONE_MODE
                },
                _changeStyle: function(legendCallBack, legendAction, prevStyle) {
                    var pointStyle, that = this,
                        style = that._calcStyle(prevStyle);
                    if (style.mode === NONE_MODE) {
                        return
                    }
                    legendCallBack(legendAction);
                    if (includePointsMode(style.mode)) {
                        pointStyle = style.pointStyle;
                        _each(that._points || [], function(_, p) {
                            applyPointStyle(p, pointStyle)
                        })
                    }
                    that._applyStyle(style.series)
                },
                _calcStyle: function(prevStyle) {
                    var result, that = this,
                        styles = that._styles,
                        pointNormalState = false;
                    switch (that.fullState) {
                        case 0:
                            result = {
                                pointStyle: NORMAL,
                                mode: INCLUDE_POINTS,
                                series: styles.normal
                            };
                            break;
                        case 1:
                            pointNormalState = prevStyle && that.lastHoverMode === EXLUDE_POINTS || that.lastHoverMode === NEAREST_POINT && includePointsMode(that.lastSelectionMode);
                            result = {
                                pointStyle: pointNormalState ? NORMAL : HOVER,
                                mode: pointNormalState ? INCLUDE_POINTS : that.lastHoverMode,
                                series: styles.hover
                            };
                            break;
                        case 2:
                            result = {
                                pointStyle: SELECTION,
                                mode: that.lastSelectionMode,
                                series: styles.selection
                            };
                            break;
                        case 3:
                            pointNormalState = that.lastSelectionMode === EXLUDE_POINTS && includePointsMode(that.lastHoverMode);
                            result = {
                                pointStyle: pointNormalState ? NORMAL : SELECTION,
                                mode: pointNormalState ? INCLUDE_POINTS : that.lastSelectionMode,
                                series: styles.selection
                            }
                    }
                    return result
                },
                updateHover: function(x, y) {
                    var that = this,
                        currentNearestPoint = that._nearestPoint,
                        point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);
                    if (point !== currentNearestPoint && !that.isSelected()) {
                        currentNearestPoint && applyPointStyle(currentNearestPoint, NORMAL);
                        if (point) {
                            applyPointStyle(point, HOVER);
                            that._nearestPoint = point
                        }
                    }
                },
                _getMainAxisName: function() {
                    return this._options.rotated ? "X" : "Y"
                },
                areLabelsVisible: function() {
                    return !_isDefined(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount
                },
                getLabelVisibility: function() {
                    return this.areLabelsVisible() && this._options.label && this._options.label.visible
                },
                _customizePoint: function(pointData) {
                    var customizeObject, pointOptions, customLabelOptions, customOptions, useLabelCustomOptions, usePointCustomOptions, that = this,
                        options = that._options,
                        customizePoint = options.customizePoint,
                        customizeLabel = options.customizeLabel;
                    if (customizeLabel && customizeLabel.call) {
                        customizeObject = _extend({
                            seriesName: that.name
                        }, pointData);
                        customizeObject.series = that;
                        customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
                        useLabelCustomOptions = customLabelOptions && !_isEmptyObject(customLabelOptions);
                        customLabelOptions = useLabelCustomOptions ? _extend(true, {}, options.label, customLabelOptions) : null
                    }
                    if (customizePoint && customizePoint.call) {
                        customizeObject = customizeObject || _extend({
                            seriesName: that.name
                        }, pointData);
                        customizeObject.series = that;
                        customOptions = customizePoint.call(customizeObject, customizeObject);
                        usePointCustomOptions = customOptions && !_isEmptyObject(customOptions)
                    }
                    if (useLabelCustomOptions || usePointCustomOptions) {
                        pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData);
                        pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
                        pointOptions.styles.usePointCustomOptions = usePointCustomOptions
                    }
                    return pointOptions
                },
                show: function() {
                    if (!this._visible) {
                        this._changeVisibility(true)
                    }
                },
                hide: function() {
                    if (this._visible) {
                        this._changeVisibility(false)
                    }
                },
                _changeVisibility: function(visibility) {
                    var that = this;
                    that._visible = that._options.visible = visibility;
                    that._updatePointsVisibility();
                    that.hidePointTooltip();
                    that._options.visibilityChanged()
                },
                _updatePointsVisibility: _noop,
                hideLabels: function() {
                    _each(this._points, function(_, point) {
                        point._label.hide()
                    })
                },
                _parsePointOptions: function(pointOptions, labelOptions, data) {
                    var that = this,
                        options = that._options,
                        styles = that._createPointStyles(pointOptions, data),
                        parsedOptions = _extend(true, {}, pointOptions, {
                            type: options.type,
                            tag: that.tag,
                            rotated: options.rotated,
                            styles: styles,
                            widgetType: options.widgetType,
                            visibilityChanged: options.visibilityChanged
                        });
                    parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);
                    if (that.areErrorBarsVisible()) {
                        parsedOptions.errorBars = options.valueErrorBar
                    }
                    return parsedOptions
                },
                _preparePointOptions: function(customOptions) {
                    var point = this._getOptionsForPoint();
                    return customOptions ? _extend(true, {}, point, customOptions) : point
                },
                _getMarkerGroupOptions: function() {
                    return _extend(false, {}, this._getOptionsForPoint(), {
                        hoverStyle: {},
                        selectionStyle: {}
                    })
                },
                _resample: function(ticksInterval, min, max, isDefinedMinMax) {
                    var pointData, minTick, that = this,
                        fusPoints = [],
                        nowIndexTicks = 0,
                        lastPointIndex = 0,
                        state = 0,
                        originalPoints = that.getAllPoints();

                    function addFirstFusPoint(point) {
                        fusPoints.push(point);
                        minTick = point.argument;
                        if (isDefinedMinMax) {
                            if (point.argument < min) {
                                state = 1
                            } else {
                                if (point.argument > max) {
                                    state = 2
                                } else {
                                    state = 0
                                }
                            }
                        }
                    }
                    if (that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE) {
                        return _map(originalPoints, function(point, index) {
                            if (index % ticksInterval === 0) {
                                return point
                            }
                            point.setInvisibility();
                            return null
                        })
                    }
                    that._aggregatedPoints = that._aggregatedPoints || [];
                    _each(originalPoints, function(_, point) {
                        point.setInvisibility();
                        if (!fusPoints.length) {
                            addFirstFusPoint(point)
                        } else {
                            if (!state && Math.abs(minTick - point.argument) < ticksInterval) {
                                fusPoints.push(point)
                            } else {
                                if (!(1 === state && point.argument < min) && !(2 === state && point.argument > max)) {
                                    pointData = that._fusionPoints(fusPoints, minTick, nowIndexTicks);
                                    nowIndexTicks++;
                                    if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex)) {
                                        lastPointIndex++
                                    }
                                    fusPoints = [];
                                    addFirstFusPoint(point)
                                }
                            }
                        }
                    });
                    if (fusPoints.length) {
                        pointData = that._fusionPoints(fusPoints, minTick, nowIndexTicks);
                        if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex)) {
                            lastPointIndex++
                        }
                    }
                    that._correctPointsLength(lastPointIndex, that._aggregatedPoints);
                    that._endUpdateData();
                    return that._aggregatedPoints
                },
                canRenderCompleteHandle: function() {
                    var result = this._canRenderCompleteHandle;
                    delete this._canRenderCompleteHandle;
                    return !!result
                },
                isHovered: function() {
                    return !!(1 & this.fullState)
                },
                isSelected: function() {
                    return !!(2 & this.fullState)
                },
                isVisible: function() {
                    return this._visible
                },
                getAllPoints: function() {
                    return (this._originalPoints || []).slice()
                },
                getPointByPos: function(pos) {
                    return (this._points || [])[pos]
                },
                getVisiblePoints: function() {
                    return (this._drawnPoints || []).slice()
                },
                setPointHoverState: function(data) {
                    var point = data.point;
                    if (data.setState) {
                        point.fullState |= HOVER_STATE
                    }
                    if (!(this.isSelected() && includePointsMode(this.lastSelectionMode)) && !point.isSelected() && !point.hasSelectedView) {
                        point.applyStyle(HOVER)
                    }
                },
                releasePointHoverState: function(data) {
                    var that = this,
                        point = data.point;
                    if (data.setState) {
                        point.fullState &= ~HOVER_STATE
                    }
                    if (!(that.isSelected() && includePointsMode(that.lastSelectionMode)) && !point.isSelected() && !point.hasSelectedView) {
                        if (!(that.isHovered() && includePointsMode(that.lastHoverMode)) || that.isSelected() && that.lastSelectionMode === EXLUDE_POINTS) {
                            point.applyStyle(NORMAL)
                        }
                    }
                    point.releaseHoverState()
                },
                setPointSelectedState: function(data) {
                    var point = data.point;
                    if (data.setState) {
                        point.fullState |= SELECTED_STATE
                    } else {
                        point.hasSelectedView = true
                    }
                    point.applyStyle(SELECTION)
                },
                releasePointSelectedState: function(data) {
                    var pointStyle, that = this,
                        point = data.point;
                    if (data.setState) {
                        point.fullState &= ~SELECTED_STATE
                    } else {
                        point.hasSelectedView = false
                    }
                    if (that.isHovered() && includePointsMode(that.lastHoverMode) || point.isHovered()) {
                        pointStyle = HOVER
                    } else {
                        if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
                            pointStyle = SELECTION
                        } else {
                            pointStyle = NORMAL
                        }
                    }
                    point.applyStyle(pointStyle)
                },
                selectPoint: function(point) {
                    triggerEvent(this._extGroups.seriesGroup, new _Event("selectpoint"), point)
                },
                deselectPoint: function(point) {
                    triggerEvent(this._extGroups.seriesGroup, new _Event("deselectpoint"), point)
                },
                showPointTooltip: function(point) {
                    triggerEvent(this._extGroups.seriesGroup, new _Event("showpointtooltip"), point)
                },
                hidePointTooltip: function(point) {
                    triggerEvent(this._extGroups.seriesGroup, new _Event("hidepointtooltip"), point)
                },
                select: function() {
                    var that = this;
                    triggerEvent(that._extGroups.seriesGroup, new _Event("selectseries", {
                        target: that
                    }), that._options.selectionMode);
                    that._group.toForeground()
                },
                clearSelection: function() {
                    var that = this;
                    triggerEvent(that._extGroups.seriesGroup, new _Event("deselectseries", {
                        target: that
                    }), that._options.selectionMode)
                },
                getPointsByArg: function(arg) {
                    return this.pointsByArgument[arg.valueOf()] || []
                },
                _deletePoints: function() {
                    var that = this;
                    that._disposePoints(that._originalPoints);
                    that._disposePoints(that._aggregatedPoints);
                    that._disposePoints(that._oldPoints);
                    that._points = that._oldPoints = that._aggregatedPoints = that._originalPoints = that._drawnPoints = null
                },
                _deletePatterns: function() {
                    _each(this._patterns || [], function(_, pattern) {
                        pattern && pattern.dispose()
                    });
                    this._patterns = []
                },
                _deleteTrackers: function() {
                    var that = this;
                    _each(that._trackers || [], function(_, tracker) {
                        tracker.remove()
                    });
                    that._trackersGroup && that._trackersGroup.dispose();
                    that._trackers = that._trackersGroup = null
                },
                dispose: function() {
                    var that = this;
                    that._deletePoints();
                    that._group.dispose();
                    that._labelsGroup && that._labelsGroup.dispose();
                    that._errorBarGroup && that._errorBarGroup.dispose();
                    that._deletePatterns();
                    that._deleteTrackers();
                    that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that.translators = that._styles = that._options = that._pointOptions = that._drawnPoints = that._aggregatedPoints = that.pointsByArgument = that._segments = that._prevSeries = that._patterns = null
                },
                correctPosition: _noop,
                drawTrackers: _noop,
                getNeighborPoint: _noop,
                areErrorBarsVisible: _noop,
                getColor: function() {
                    return this.getLegendStyles().normal.fill
                },
                getOpacity: function() {
                    return this._options.opacity
                },
                getStackName: function() {
                    return "stackedbar" === this.type || "fullstackedbar" === this.type ? this._stackName : null
                },
                getPointByCoord: function(x, y) {
                    var point = this.getNeighborPoint(x, y);
                    return point && point.coordsIn(x, y) ? point : null
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************************!*\
      !*** ./Scripts/viz/translators/numeric_translator.js ***!
      \*******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                isDefined = commonUtils.isDefined,
                round = Math.round;
            module.exports = {
                translate: function(bp) {
                    var that = this,
                        canvasOptions = that._canvasOptions,
                        doubleError = canvasOptions.rangeDoubleError,
                        specialValue = that.translateSpecialCase(bp);
                    if (isDefined(specialValue)) {
                        return specialValue
                    }
                    if (isNaN(bp) || bp.valueOf() + doubleError < canvasOptions.rangeMin || bp.valueOf() - doubleError > canvasOptions.rangeMax) {
                        return null
                    }
                    return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible) * canvasOptions.ratioOfCanvasRange))
                },
                untranslate: function(pos, _directionOffset, enableOutOfCanvas) {
                    var canvasOptions = this._canvasOptions,
                        startPoint = canvasOptions.startPoint;
                    if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint) || !isDefined(canvasOptions.rangeMin) || !isDefined(canvasOptions.rangeMax)) {
                        return null
                    }
                    return this._calculateUnProjection((pos - startPoint) / canvasOptions.ratioOfCanvasRange)
                },
                getInterval: function() {
                    return round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
                },
                _getValue: function(val) {
                    return val
                },
                zoom: function(translate, scale) {
                    var that = this,
                        canvasOptions = that._canvasOptions,
                        startPoint = canvasOptions.startPoint,
                        endPoint = canvasOptions.endPoint,
                        newStart = (startPoint + translate) / scale,
                        newEnd = (endPoint + translate) / scale,
                        translatedRangeMinMax = [that.translate(that._getValue(canvasOptions.rangeMin)), that.translate(that._getValue(canvasOptions.rangeMax))],
                        minPoint = Math.min(translatedRangeMinMax[0], translatedRangeMinMax[1]),
                        maxPoint = Math.max(translatedRangeMinMax[0], translatedRangeMinMax[1]);
                    if (minPoint > newStart) {
                        newEnd -= newStart - minPoint;
                        newStart = minPoint
                    }
                    if (maxPoint < newEnd) {
                        newStart -= newEnd - maxPoint;
                        newEnd = maxPoint
                    }
                    if (maxPoint - minPoint < newEnd - newStart) {
                        newStart = minPoint;
                        newEnd = maxPoint
                    }
                    translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
                    scale = (startPoint + translate) / newStart || 1;
                    return {
                        min: that.untranslate(newStart, void 0, true),
                        max: that.untranslate(newEnd, void 0, true),
                        translate: translate,
                        scale: scale
                    }
                },
                getMinScale: function(zoom) {
                    return zoom ? 1.1 : .9
                },
                getScale: function(val1, val2) {
                    var canvasOptions = this._canvasOptions;
                    val1 = isDefined(val1) ? val1 : canvasOptions.rangeMin;
                    val2 = isDefined(val2) ? val2 : canvasOptions.rangeMax;
                    return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2)
                },
                isValid: function(value) {
                    var co = this._canvasOptions;
                    return null !== value && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax
                },
                parse: function(value) {
                    return Number(value)
                },
                to: function(value) {
                    return this._conversionValue(this._calculateProjection((value - this._canvasOptions.rangeMinVisible) * this._canvasOptions.ratioOfCanvasRange))
                },
                from: function(position) {
                    return this._calculateUnProjection((position - this._canvasOptions.startPoint) / this._canvasOptions.ratioOfCanvasRange)
                },
                _add: function(value, diff, coeff) {
                    return value + diff * coeff
                },
                isValueProlonged: false
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/bundles/modules/parts/data.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var DevExpress = __webpack_require__( /*! ./core */ 221);
            var data = DevExpress.data = __webpack_require__( /*! ../../../bundles/modules/data */ 196);
            data.odata = __webpack_require__( /*! ../../../bundles/modules/data.odata */ 266);
            module.exports = data
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , , , , , , , , , , , , , , , , ,
    /*!****************************************************!*\
      !*** ./Scripts/viz/core/renderers/svg_renderer.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                doc = document,
                animation = __webpack_require__( /*! ./animation */ 518),
                math = Math,
                mathMin = math.min,
                mathMax = math.max,
                mathFloor = math.floor,
                mathRound = math.round,
                mathSin = math.sin,
                mathCos = math.cos,
                mathAbs = math.abs,
                mathPI = math.PI,
                _isDefined = commonUtils.isDefined,
                vizUtils = __webpack_require__( /*! ../utils */ 6),
                _normalizeEnum = vizUtils.normalizeEnum,
                _normalizeBBox = vizUtils.normalizeBBox,
                _rotateBBox = vizUtils.rotateBBox,
                PI_DIV_180 = mathPI / 180,
                _parseInt = parseInt,
                SHARPING_CORRECTION = .5,
                ARC_COORD_PREC = 5;
            var pxAddingExceptions = {
                "column-count": true,
                "fill-opacity": true,
                "flex-grow": true,
                "flex-shrink": true,
                "font-weight": true,
                "line-height": true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                "z-index": true,
                zoom: true
            };
            var KEY_TEXT = "text",
                KEY_STROKE = "stroke",
                KEY_STROKE_WIDTH = "stroke-width",
                KEY_STROKE_OPACITY = "stroke-opacity",
                KEY_FONT_SIZE = "font-size",
                KEY_FONT_STYLE = "font-style",
                KEY_FONT_WEIGHT = "font-weight",
                KEY_TEXT_DECORATION = "text-decoration",
                NONE = "none";
            var objectCreate = function() {
                if (!Object.create) {
                    return function(proto) {
                        var F = function() {};
                        F.prototype = proto;
                        return new F
                    }
                } else {
                    return function(proto) {
                        return Object.create(proto)
                    }
                }
            }();
            var DEFAULTS = {
                scaleX: 1,
                scaleY: 1
            };
            var backupContainer = doc.createElement("div"),
                backupCounter = 0;
            backupContainer.style.left = "-9999px";
            backupContainer.style.position = "absolute";

            function backupRoot(root) {
                if (0 === backupCounter) {
                    doc.body.appendChild(backupContainer)
                }++backupCounter;
                root.append({
                    element: backupContainer
                })
            }

            function restoreRoot(root, container) {
                root.append({
                    element: container
                });
                --backupCounter;
                if (0 === backupCounter) {
                    doc.body.removeChild(backupContainer)
                }
            }
            var getNextDefsSvgId = function() {
                var numDefsSvgElements = 1;
                return function() {
                    return "DevExpress_" + numDefsSvgElements++
                }
            }();

            function isObjectArgument(value) {
                return value && "string" !== typeof value
            }

            function createElement(tagName) {
                return doc.createElementNS("http://www.w3.org/2000/svg", tagName)
            }

            function getPatternUrl(id, pathModified) {
                return null !== id ? "url(" + (pathModified ? window.location.href : "") + "#" + id + ")" : ""
            }

            function extend(target, source) {
                var key;
                for (key in source) {
                    target[key] = source[key]
                }
                return target
            }

            function roundValue(value, exp) {
                value = value.toString().split("e");
                value = mathRound(+(value[0] + "e" + (value[1] ? +value[1] + exp : exp)));
                value = value.toString().split("e");
                return +(value[0] + "e" + (value[1] ? +value[1] - exp : -exp))
            }
            var preserveAspectRatioMap = {
                full: NONE,
                lefttop: "xMinYMin",
                leftcenter: "xMinYMid",
                leftbottom: "xMinYMax",
                centertop: "xMidYMin",
                center: "xMidYMid",
                centerbottom: "xMidYMax",
                righttop: "xMaxYMin",
                rightcenter: "xMaxYMid",
                rightbottom: "xMaxYMax"
            };
            exports._normalizeArcParams = function(x, y, innerR, outerR, startAngle, endAngle) {
                var isCircle, noArc = true,
                    angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);
                if (angleDiff) {
                    if (mathAbs(angleDiff) % 360 === 0) {
                        startAngle = 0;
                        endAngle = 360;
                        isCircle = true;
                        endAngle -= .01
                    }
                    if (startAngle > 360) {
                        startAngle %= 360
                    }
                    if (endAngle > 360) {
                        endAngle %= 360
                    }
                    if (startAngle > endAngle) {
                        startAngle -= 360
                    }
                    noArc = false
                }
                startAngle *= PI_DIV_180;
                endAngle *= PI_DIV_180;
                return [x, y, mathMin(outerR, innerR), mathMax(outerR, innerR), mathCos(startAngle), mathSin(startAngle), mathCos(endAngle), mathSin(endAngle), isCircle, mathFloor(mathAbs(endAngle - startAngle) / mathPI) % 2 ? "1" : "0", noArc]
            };
            var applyEllipsis = getEllipsis(prepareLines, setNewText, removeTextSpan);
            var buildArcPath = function(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
                return ["M", (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), "A", outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? "M" : "L", (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), "A", innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), "Z"].join(" ")
            };

            function buildPathSegments(points, type) {
                var list = [
                    ["M", 0, 0]
                ];
                switch (type) {
                    case "line":
                        list = buildLineSegments(points);
                        break;
                    case "area":
                        list = buildLineSegments(points, true);
                        break;
                    case "bezier":
                        list = buildCurveSegments(points);
                        break;
                    case "bezierarea":
                        list = buildCurveSegments(points, true)
                }
                return list
            }

            function buildLineSegments(points, close) {
                return buildSegments(points, buildSimpleLineSegment, close)
            }

            function buildCurveSegments(points, close) {
                return buildSegments(points, buildSimpleCurveSegment, close)
            }

            function buildSegments(points, buildSimpleSegment, close) {
                var i, ii, list = [];
                if (points[0] && points[0].length) {
                    for (i = 0, ii = points.length; i < ii; ++i) {
                        buildSimpleSegment(points[i], close, list)
                    }
                } else {
                    buildSimpleSegment(points, close, list)
                }
                return list
            }

            function buildSimpleLineSegment(points, close, list) {
                var i = 0,
                    k0 = list.length,
                    k = k0,
                    ii = (points || []).length;
                if (ii) {
                    if (void 0 !== points[0].x) {
                        for (; i < ii;) {
                            list[k++] = ["L", points[i].x, points[i++].y]
                        }
                    } else {
                        for (; i < ii;) {
                            list[k++] = ["L", points[i++], points[i++]]
                        }
                    }
                    list[k0][0] = "M"
                } else {
                    list[k] = ["M", 0, 0]
                }
                close && list.push(["Z"]);
                return list
            }

            function buildSimpleCurveSegment(points, close, list) {
                var i, k = list.length,
                    ii = (points || []).length;
                if (ii) {
                    if (void 0 !== points[0].x) {
                        list[k++] = ["M", points[0].x, points[0].y];
                        for (i = 1; i < ii;) {
                            list[k++] = ["C", points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y]
                        }
                    } else {
                        list[k++] = ["M", points[0], points[1]];
                        for (i = 2; i < ii;) {
                            list[k++] = ["C", points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]]
                        }
                    }
                } else {
                    list[k] = ["M", 0, 0]
                }
                close && list.push(["Z"]);
                return list
            }

            function combinePathParam(segments) {
                var i, segment, j, jj, d = [],
                    k = 0,
                    ii = segments.length;
                for (i = 0; i < ii; ++i) {
                    segment = segments[i];
                    for (j = 0, jj = segment.length; j < jj; ++j) {
                        d[k++] = segment[j]
                    }
                }
                return d.join(" ")
            }

            function compensateSegments(oldSegments, newSegments, type) {
                var i, originalNewSegments, oldLength = oldSegments.length,
                    newLength = newSegments.length,
                    makeEqualSegments = -1 !== type.indexOf("area") ? makeEqualAreaSegments : makeEqualLineSegments;
                if (0 === oldLength) {
                    for (i = 0; i < newLength; i++) {
                        oldSegments.push(newSegments[i].slice(0))
                    }
                } else {
                    if (oldLength < newLength) {
                        makeEqualSegments(oldSegments, newSegments, type)
                    } else {
                        if (oldLength > newLength) {
                            originalNewSegments = newSegments.slice(0);
                            makeEqualSegments(newSegments, oldSegments, type)
                        }
                    }
                }
                return originalNewSegments
            }

            function prepareConstSegment(constSeg, type) {
                var x = constSeg[constSeg.length - 2],
                    y = constSeg[constSeg.length - 1];
                switch (type) {
                    case "line":
                    case "area":
                        constSeg[0] = "L";
                        break;
                    case "bezier":
                    case "bezierarea":
                        constSeg[0] = "C";
                        constSeg[1] = constSeg[3] = constSeg[5] = x;
                        constSeg[2] = constSeg[4] = constSeg[6] = y
                }
            }

            function makeEqualLineSegments(short, long, type) {
                var constSeg = short[short.length - 1].slice(),
                    i = short.length;
                prepareConstSegment(constSeg, type);
                for (; i < long.length; i++) {
                    short[i] = constSeg.slice(0)
                }
            }

            function makeEqualAreaSegments(short, long, type) {
                var i, head, constsSeg1, constsSeg2, shortLength = short.length,
                    longLength = long.length;
                if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
                    i = (shortLength - 1) / 2 - 1;
                    head = short.slice(0, i + 1);
                    constsSeg1 = head[head.length - 1].slice(0);
                    constsSeg2 = short.slice(i + 1)[0].slice(0);
                    prepareConstSegment(constsSeg1, type);
                    prepareConstSegment(constsSeg2, type);
                    for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
                        short.splice(j + 1, 0, constsSeg1);
                        short.splice(j + 3, 0, constsSeg2)
                    }
                }
            }

            function baseCss(that, styles) {
                var key, value, elemStyles = that._styles,
                    str = "";
                styles = styles || {};
                for (key in styles) {
                    value = styles[key];
                    if (_isDefined(value)) {
                        if ("number" === typeof value && !pxAddingExceptions[key]) {
                            value += "px"
                        }
                        elemStyles[key] = "" !== value ? value : null
                    }
                }
                for (key in elemStyles) {
                    value = elemStyles[key];
                    if (value) {
                        str += key + ":" + value + ";"
                    }
                }
                str && that.element.setAttribute("style", str);
                return that
            }

            function baseAttr(that, attrs, inh) {
                attrs = attrs || {};
                var key, value, hasTransformations, recalculateDashStyle, sw, i, settings = that._settings,
                    attributes = {},
                    elem = that.element,
                    renderer = that.renderer,
                    rtl = renderer.rtl;
                if (!isObjectArgument(attrs)) {
                    if (attrs in settings) {
                        return settings[attrs]
                    }
                    if (attrs in DEFAULTS) {
                        return DEFAULTS[attrs]
                    }
                    return 0
                }
                extend(attributes, attrs);
                for (key in attributes) {
                    value = attributes[key];
                    if (void 0 === value) {
                        continue
                    }
                    settings[key] = value;
                    if ("align" === key) {
                        key = "text-anchor";
                        value = {
                            left: rtl ? "end" : "start",
                            center: "middle",
                            right: rtl ? "start" : "end"
                        }[value] || ""
                    } else {
                        if ("dashStyle" === key) {
                            recalculateDashStyle = true;
                            continue
                        } else {
                            if (key === KEY_STROKE_WIDTH) {
                                recalculateDashStyle = true
                            } else {
                                if ("clipId" === key) {
                                    key = "clip-path";
                                    value = getPatternUrl(value, renderer.pathModified)
                                } else {
                                    if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp)$/i.test(key)) {
                                        hasTransformations = true;
                                        continue
                                    } else {
                                        if (/^(x|y|d)$/i.test(key)) {
                                            hasTransformations = true
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (null === value) {
                        elem.removeAttribute(key)
                    } else {
                        elem.setAttribute(key, value)
                    }
                }
                if (recalculateDashStyle && "dashStyle" in settings) {
                    value = settings.dashStyle;
                    sw = ("_originalSW" in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
                    key = "stroke-dasharray";
                    value = null === value ? "" : _normalizeEnum(value);
                    if ("" === value || "solid" === value || value === NONE) {
                        that.element.removeAttribute(key)
                    } else {
                        value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "").split(",");
                        i = value.length;
                        while (i--) {
                            value[i] = _parseInt(value[i]) * sw
                        }
                        that.element.setAttribute(key, value.join(","))
                    }
                }
                if (hasTransformations) {
                    that._applyTransformation()
                }
                return that
            }

            function createPathAttr(baseAttr) {
                return function(attrs, inh) {
                    var segments, that = this;
                    if (isObjectArgument(attrs)) {
                        attrs = extend({}, attrs);
                        segments = attrs.segments;
                        if ("points" in attrs) {
                            segments = buildPathSegments(attrs.points, that.type);
                            delete attrs.points
                        }
                        if (segments) {
                            attrs.d = combinePathParam(segments);
                            that.segments = segments;
                            delete attrs.segments
                        }
                    }
                    return baseAttr(that, attrs, inh)
                }
            }

            function createArcAttr(baseAttr, buildArcPath) {
                return function(attrs, inh) {
                    var x, y, innerRadius, outerRadius, startAngle, endAngle, settings = this._settings;
                    if (isObjectArgument(attrs)) {
                        attrs = extend({}, attrs);
                        if ("x" in attrs || "y" in attrs || "innerRadius" in attrs || "outerRadius" in attrs || "startAngle" in attrs || "endAngle" in attrs) {
                            settings.x = x = "x" in attrs ? attrs.x : settings.x;
                            delete attrs.x;
                            settings.y = y = "y" in attrs ? attrs.y : settings.y;
                            delete attrs.y;
                            settings.innerRadius = innerRadius = "innerRadius" in attrs ? attrs.innerRadius : settings.innerRadius;
                            delete attrs.innerRadius;
                            settings.outerRadius = outerRadius = "outerRadius" in attrs ? attrs.outerRadius : settings.outerRadius;
                            delete attrs.outerRadius;
                            settings.startAngle = startAngle = "startAngle" in attrs ? attrs.startAngle : settings.startAngle;
                            delete attrs.startAngle;
                            settings.endAngle = endAngle = "endAngle" in attrs ? attrs.endAngle : settings.endAngle;
                            delete attrs.endAngle;
                            attrs.d = buildArcPath.apply(null, exports._normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle))
                        }
                    }
                    return baseAttr(this, attrs, inh)
                }
            }

            function createRectAttr(baseAttr) {
                return function(attrs, inh) {
                    var x, y, width, height, sw, maxSW, newSW, that = this;
                    if (isObjectArgument(attrs)) {
                        attrs = extend({}, attrs);
                        if (!inh && (void 0 !== attrs.x || void 0 !== attrs.y || void 0 !== attrs.width || void 0 !== attrs.height || void 0 !== attrs[KEY_STROKE_WIDTH])) {
                            void 0 !== attrs.x ? x = that._originalX = attrs.x : x = that._originalX || 0;
                            void 0 !== attrs.y ? y = that._originalY = attrs.y : y = that._originalY || 0;
                            void 0 !== attrs.width ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
                            void 0 !== attrs.height ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
                            void 0 !== attrs[KEY_STROKE_WIDTH] ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
                            maxSW = ~~((width < height ? width : height) / 2);
                            newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
                            attrs.x = x + newSW / 2;
                            attrs.y = y + newSW / 2;
                            attrs.width = width - newSW;
                            attrs.height = height - newSW;
                            ((sw || 0) !== newSW || !(0 === newSW && void 0 === sw)) && (attrs[KEY_STROKE_WIDTH] = newSW)
                        }
                        if ("sharp" in attrs) {
                            delete attrs.sharp
                        }
                    }
                    return baseAttr(that, attrs, inh)
                }
            }
            var pathAttr = createPathAttr(baseAttr),
                arcAttr = createArcAttr(baseAttr, buildArcPath),
                rectAttr = createRectAttr(baseAttr);

            function textAttr(attrs) {
                var settings, isResetRequired, wasStroked, isStroked, that = this;
                if (!isObjectArgument(attrs)) {
                    return baseAttr(that, attrs)
                }
                attrs = extend({}, attrs);
                settings = that._settings;
                wasStroked = _isDefined(settings[KEY_STROKE]) && _isDefined(settings[KEY_STROKE_WIDTH]);
                if (void 0 !== attrs[KEY_TEXT]) {
                    settings[KEY_TEXT] = attrs[KEY_TEXT];
                    delete attrs[KEY_TEXT];
                    isResetRequired = true
                }
                if (void 0 !== attrs[KEY_STROKE]) {
                    settings[KEY_STROKE] = attrs[KEY_STROKE];
                    delete attrs[KEY_STROKE]
                }
                if (void 0 !== attrs[KEY_STROKE_WIDTH]) {
                    settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
                    delete attrs[KEY_STROKE_WIDTH]
                }
                if (void 0 !== attrs[KEY_STROKE_OPACITY]) {
                    settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
                    delete attrs[KEY_STROKE_OPACITY]
                }
                isStroked = _isDefined(settings[KEY_STROKE]) && _isDefined(settings[KEY_STROKE_WIDTH]);
                baseAttr(that, attrs);
                isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];
                if (isResetRequired) {
                    createTextNodes(that, settings.text, isStroked)
                }
                if (isResetRequired || void 0 !== attrs.x || void 0 !== attrs.y) {
                    locateTextNodes(that)
                }
                if (isStroked) {
                    strokeTextNodes(that)
                }
                return that
            }

            function textCss(styles) {
                styles = styles || {};
                baseCss(this, styles);
                if (KEY_FONT_SIZE in styles) {
                    locateTextNodes(this)
                }
                return this
            }

            function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
                var style, realStyle, i, ii, nodes;
                if (void 0 !== node.wholeText) {
                    list.push({
                        value: node.wholeText,
                        style: parentStyle,
                        className: parentClassName,
                        line: line,
                        height: parentStyle[KEY_FONT_SIZE] || 0
                    })
                } else {
                    if ("BR" === node.tagName) {
                        ++line
                    } else {
                        extend(style = {}, parentStyle);
                        switch (node.tagName) {
                            case "B":
                            case "STRONG":
                                style[KEY_FONT_WEIGHT] = "bold";
                                break;
                            case "I":
                            case "EM":
                                style[KEY_FONT_STYLE] = "italic";
                                break;
                            case "U":
                                style[KEY_TEXT_DECORATION] = "underline"
                        }
                        realStyle = node.style;
                        realStyle.color && (style.fill = realStyle.color);
                        realStyle.fontSize && (style[KEY_FONT_SIZE] = _parseInt(realStyle.fontSize, 10));
                        realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
                        realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
                        realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);
                        for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
                            line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName)
                        }
                    }
                }
                return line
            }

            function adjustLineHeights(items) {
                var i, ii, item, currentItem = items[0];
                for (i = 1, ii = items.length; i < ii; ++i) {
                    item = items[i];
                    if (item.line === currentItem.line) {
                        currentItem.height = mathMax(currentItem.height, item.height);
                        currentItem.inherits = currentItem.inherits || 0 === item.height;
                        item.height = NaN
                    } else {
                        currentItem = item
                    }
                }
            }

            function removeExtraAttrs(html) {
                var regex1 = /(<\S+)(\s+(?!(style))\S+\s*=\s*['"][^'"]*['"])*/gi,
                    regex2 = /<([a-z]*)(?:[^>]*?((?:\s(?:style)=\s*(["'])(?:(?!\3).)*\3)))[^>]*?(\/?)>/gi;
                return html.replace(regex1, "$1").replace(regex2, "<$1$2$4>")
            }

            function parseHTML(text) {
                var items = [],
                    div = doc.createElement("div");
                div.innerHTML = text.replace(/\r/g, "").replace(/\n/g, "<br/>");
                orderHtmlTree(items, 0, div, {}, "");
                adjustLineHeights(items);
                return items
            }

            function parseMultiline(text) {
                var texts = text.replace(/\r/g, "").split("\n"),
                    i = 0,
                    items = [];
                for (; i < texts.length; i++) {
                    items.push({
                        value: texts[i],
                        height: 0
                    })
                }
                return items
            }

            function createTspans(items, element, fieldName) {
                var i, ii, item;
                for (i = 0, ii = items.length; i < ii; ++i) {
                    item = items[i];
                    item[fieldName] = createElement("tspan");
                    item[fieldName].appendChild(doc.createTextNode(item.value));
                    item.style && baseCss({
                        element: item[fieldName],
                        _styles: {}
                    }, item.style);
                    item.className && item[fieldName].setAttribute("class", item.className);
                    element.appendChild(item[fieldName])
                }
            }

            function getEllipsis(prepareLines, setNewText, removeTextSpan) {
                return function(maxWidth) {
                    var lines, requiredLength, i, ii, lineParts, j, jj, text, element = this.element,
                        width = this.getBBox().width,
                        maxLength = 0,
                        hasEllipsis = false;
                    if (maxWidth < 0) {
                        maxWidth = 0
                    }
                    if (width > maxWidth) {
                        lines = prepareLines(element, this._texts);
                        for (i = 0, ii = lines.length; i < ii; ++i) {
                            maxLength = mathMax(maxLength, lines[i].commonLength)
                        }
                        if (1 === maxLength) {
                            return false
                        }
                        requiredLength = mathFloor(maxLength * maxWidth / width);
                        for (i = 0; i < ii; ++i) {
                            lineParts = lines[i].parts;
                            for (j = 0, jj = lineParts.length; j < jj; ++j) {
                                text = lineParts[j];
                                if (text.startIndex <= requiredLength && text.endIndex > requiredLength) {
                                    setNewText(text, requiredLength - text.startIndex - 4);
                                    hasEllipsis = true
                                } else {
                                    if (text.startIndex > requiredLength) {
                                        removeTextSpan(text)
                                    }
                                }
                            }
                        }
                    }
                    return hasEllipsis
                }
            }

            function prepareLines(element, texts) {
                var i, ii, text, lines = [];
                if (texts) {
                    for (i = 0, ii = texts.length; i < ii; ++i) {
                        text = texts[i];
                        if (!lines[text.line]) {
                            text.startIndex = 0;
                            text.endIndex = text.value.length;
                            lines.push({
                                commonLength: text.value.length,
                                parts: [text]
                            })
                        } else {
                            text.startIndex = lines[text.line].commonLength + 1;
                            text.endIndex = lines[text.line].commonLength + text.value.length;
                            lines[text.line].parts.push(text);
                            lines[text.line].commonLength += text.value.length
                        }
                    }
                } else {
                    lines = [{
                        commonLength: element.textContent.length,
                        parts: [{
                            value: element.textContent,
                            tspan: element,
                            startIndex: 0,
                            endIndex: element.textContent.length
                        }]
                    }]
                }
                return lines
            }

            function setNewText(text, index) {
                var newText = text.value.substr(0, index) + "...";
                text.tspan.textContent = newText;
                text.stroke && (text.stroke.textContent = newText)
            }

            function removeTextSpan(text) {
                text.tspan.parentNode.removeChild(text.tspan);
                text.stroke && text.stroke.parentNode.removeChild(text.stroke)
            }

            function createTextNodes(wrapper, text, isStroked) {
                var items, parsedHtml;
                wrapper._texts = null;
                wrapper.clear();
                if (null === text) {
                    return
                }
                text = "" + text;
                if (!wrapper.renderer.encodeHtml && (-1 !== text.indexOf("<") || -1 !== text.indexOf("&"))) {
                    parsedHtml = removeExtraAttrs(text);
                    items = parseHTML(parsedHtml);
                    wrapper.DEBUG_parsedHtml = parsedHtml
                } else {
                    if (-1 !== text.indexOf("\n")) {
                        items = parseMultiline(text)
                    } else {
                        if (isStroked) {
                            items = [{
                                value: text,
                                height: 0
                            }]
                        }
                    }
                }
                if (items) {
                    if (items.length) {
                        wrapper._texts = items;
                        if (isStroked) {
                            createTspans(items, wrapper.element, KEY_STROKE)
                        }
                        createTspans(items, wrapper.element, "tspan")
                    }
                } else {
                    wrapper.element.appendChild(doc.createTextNode(text))
                }
            }

            function setTextNodeAttribute(item, name, value) {
                item.tspan.setAttribute(name, value);
                item.stroke && item.stroke.setAttribute(name, value)
            }

            function locateTextNodes(wrapper) {
                if (!wrapper._texts) {
                    return
                }
                var i, ii, items = wrapper._texts,
                    x = wrapper._settings.x,
                    lineHeight = _parseInt(wrapper._styles[KEY_FONT_SIZE], 10) || 12,
                    item = items[0];
                setTextNodeAttribute(item, "x", x);
                setTextNodeAttribute(item, "y", wrapper._settings.y);
                for (i = 1, ii = items.length; i < ii; ++i) {
                    item = items[i];
                    if (item.height >= 0) {
                        setTextNodeAttribute(item, "x", x);
                        setTextNodeAttribute(item, "dy", item.inherits ? mathMax(item.height, lineHeight) : item.height || lineHeight)
                    }
                }
            }

            function strokeTextNodes(wrapper) {
                if (!wrapper._texts) {
                    return
                }
                var tspan, i, ii, items = wrapper._texts,
                    stroke = wrapper._settings[KEY_STROKE],
                    strokeWidth = wrapper._settings[KEY_STROKE_WIDTH],
                    strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
                for (i = 0, ii = items.length; i < ii; ++i) {
                    tspan = items[i].stroke;
                    tspan.setAttribute(KEY_STROKE, stroke);
                    tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
                    tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
                    tspan.setAttribute("stroke-linejoin", "round")
                }
            }

            function baseAnimate(that, params, options, complete) {
                options = options || {};
                var key, value, renderer = that.renderer,
                    settings = that._settings,
                    animationParams = {};
                var defaults = {
                    translateX: 0,
                    translateY: 0,
                    scaleX: 1,
                    scaleY: 1,
                    rotate: 0,
                    rotateX: 0,
                    rotateY: 0
                };
                if (complete) {
                    options.complete = complete
                }
                if (renderer.animationEnabled()) {
                    for (key in params) {
                        value = params[key];
                        if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
                            animationParams.transform = animationParams.transform || {
                                from: {},
                                to: {}
                            };
                            animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key];
                            animationParams.transform.to[key] = value
                        } else {
                            if ("arc" === key || "segments" === key) {
                                animationParams[key] = value
                            } else {
                                animationParams[key] = {
                                    from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
                                    to: value
                                }
                            }
                        }
                    }
                    renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options))
                } else {
                    options.step && options.step.call(that, 1, 1);
                    options.complete && options.complete.call(that);
                    that.attr(params)
                }
                return that
            }

            function pathAnimate(params, options, complete) {
                var newSegments, endSegments, that = this,
                    curSegments = that.segments || [];
                if (that.renderer.animationEnabled() && "points" in params) {
                    newSegments = buildPathSegments(params.points, that.type);
                    endSegments = compensateSegments(curSegments, newSegments, that.type);
                    params.segments = {
                        from: curSegments,
                        to: newSegments,
                        end: endSegments
                    };
                    delete params.points
                }
                return baseAnimate(that, params, options, complete)
            }

            function arcAnimate(params, options, complete) {
                var that = this,
                    settings = that._settings,
                    arcParams = {
                        from: {},
                        to: {}
                    };
                if (that.renderer.animationEnabled() && ("x" in params || "y" in params || "innerRadius" in params || "outerRadius" in params || "startAngle" in params || "endAngle" in params)) {
                    arcParams.from.x = settings.x || 0;
                    arcParams.from.y = settings.y || 0;
                    arcParams.from.innerRadius = settings.innerRadius || 0;
                    arcParams.from.outerRadius = settings.outerRadius || 0;
                    arcParams.from.startAngle = settings.startAngle || 0;
                    arcParams.from.endAngle = settings.endAngle || 0;
                    arcParams.to.x = "x" in params ? params.x : settings.x;
                    delete params.x;
                    arcParams.to.y = "y" in params ? params.y : settings.y;
                    delete params.y;
                    arcParams.to.innerRadius = "innerRadius" in params ? params.innerRadius : settings.innerRadius;
                    delete params.innerRadius;
                    arcParams.to.outerRadius = "outerRadius" in params ? params.outerRadius : settings.outerRadius;
                    delete params.outerRadius;
                    arcParams.to.startAngle = "startAngle" in params ? params.startAngle : settings.startAngle;
                    delete params.startAngle;
                    arcParams.to.endAngle = "endAngle" in params ? params.endAngle : settings.endAngle;
                    delete params.endAngle;
                    params.arc = arcParams
                }
                return baseAnimate(that, params, options, complete)
            }
            exports.DEBUG_set_getNextDefsSvgId = function(newFunction) {
                getNextDefsSvgId = newFunction
            };
            exports.DEBUG_removeBackupContainer = function() {
                if (backupCounter) {
                    backupCounter = 0;
                    doc.body.removeChild(backupContainer)
                }
            };

            function buildLink(target, parameters) {
                var obj = {
                    is: false,
                    name: parameters.name || parameters,
                    after: parameters.after
                };
                if (target) {
                    obj.to = target
                } else {
                    obj.virtual = true
                }
                return obj
            }

            function SvgElement(renderer, tagName, type) {
                var that = this;
                that.renderer = renderer;
                that.element = createElement(tagName);
                that._settings = {};
                that._styles = {};
                if ("path" === tagName) {
                    that.type = type || "line"
                }
            }
            exports.SvgElement = SvgElement;
            SvgElement.prototype = {
                constructor: SvgElement,
                _getJQElement: function() {
                    return this._$element || (this._$element = $(this.element))
                },
                dispose: function() {
                    this._getJQElement().remove();
                    return this
                },
                append: function(parent) {
                    (parent || this.renderer.root).element.appendChild(this.element);
                    return this
                },
                remove: function() {
                    var element = this.element;
                    element.parentNode && element.parentNode.removeChild(element);
                    return this
                },
                enableLinks: function() {
                    this._links = [];
                    return this
                },
                checkLinks: function() {
                    var i, count = 0,
                        links = this._links,
                        ii = links.length;
                    for (i = 0; i < ii; ++i) {
                        if (!links[i]._link.virtual) {
                            ++count
                        }
                    }
                    if (count > 0) {
                        throw new Error("There are non disposed links!")
                    }
                },
                virtualLink: function(parameters) {
                    linkItem({
                        _link: buildLink(null, parameters)
                    }, this);
                    return this
                },
                linkAfter: function(name) {
                    this._linkAfter = name;
                    return this
                },
                linkOn: function(target, parameters) {
                    this._link = buildLink(target, parameters);
                    linkItem(this, target);
                    return this
                },
                linkOff: function() {
                    unlinkItem(this);
                    this._link = null;
                    return this
                },
                linkAppend: function() {
                    var i, next, link = this._link,
                        items = link.to._links;
                    for (i = link.i + 1;
                        (next = items[i]) && !next._link.is; ++i) {}
                    this._insert(link.to, next);
                    link.is = true;
                    return this
                },
                _insert: function(parent, next) {
                    parent.element.insertBefore(this.element, next ? next.element : null)
                },
                linkRemove: function() {
                    this.remove();
                    this._link.is = false;
                    return this
                },
                clear: function() {
                    this._getJQElement().empty();
                    return this
                },
                toBackground: function() {
                    var elem = this.element,
                        parent = elem.parentNode;
                    parent && parent.insertBefore(elem, parent.firstChild);
                    return this
                },
                toForeground: function() {
                    var elem = this.element,
                        parent = elem.parentNode;
                    parent && parent.appendChild(elem);
                    return this
                },
                attr: function(attrs, inh) {
                    return baseAttr(this, attrs, inh)
                },
                smartAttr: function(attrs) {
                    var that = this;
                    if (attrs.hatching) {
                        attrs.fill = that._hatching = that.renderer.lockHatching(attrs.fill, attrs.hatching, that._hatching);
                        attrs.hatching = null
                    } else {
                        if (that._hatching) {
                            that.renderer.releaseHatching(that._hatching);
                            that._hatching = null
                        }
                    }
                    return baseAttr(that, attrs)
                },
                css: function(styles) {
                    return baseCss(this, styles)
                },
                animate: function(params, options, complete) {
                    return baseAnimate(this, params, options, complete)
                },
                sharp: function(pos) {
                    return this.attr({
                        sharp: pos || true
                    })
                },
                _applyTransformation: function() {
                    var scaleXDefined, scaleYDefined, rotateX, rotateY, tr = this._settings,
                        transformations = [],
                        sharpMode = tr.sharp,
                        strokeOdd = tr[KEY_STROKE_WIDTH] % 2,
                        correctionX = strokeOdd && ("h" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION : 0,
                        correctionY = strokeOdd && ("v" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION : 0;
                    transformations.push("translate(" + ((tr.translateX || 0) + correctionX) + "," + ((tr.translateY || 0) + correctionY) + ")");
                    if (tr.rotate) {
                        if ("rotateX" in tr) {
                            rotateX = tr.rotateX
                        } else {
                            rotateX = tr.x
                        }
                        if ("rotateY" in tr) {
                            rotateY = tr.rotateY
                        } else {
                            rotateY = tr.y
                        }
                        transformations.push("rotate(" + tr.rotate + "," + (rotateX || 0) + "," + (rotateY || 0) + ")")
                    }
                    scaleXDefined = _isDefined(tr.scaleX);
                    scaleYDefined = _isDefined(tr.scaleY);
                    if (scaleXDefined || scaleYDefined) {
                        transformations.push("scale(" + (scaleXDefined ? tr.scaleX : 1) + "," + (scaleYDefined ? tr.scaleY : 1) + ")")
                    }
                    if (transformations.length) {
                        this.element.setAttribute("transform", transformations.join(" "))
                    }
                },
                move: function(x, y, animate, animOptions) {
                    var obj = {};
                    _isDefined(x) && (obj.translateX = x);
                    _isDefined(y) && (obj.translateY = y);
                    if (!animate) {
                        this.attr(obj)
                    } else {
                        this.animate(obj, animOptions)
                    }
                    return this
                },
                rotate: function(angle, x, y, animate, animOptions) {
                    var obj = {
                        rotate: angle || 0
                    };
                    _isDefined(x) && (obj.rotateX = x);
                    _isDefined(y) && (obj.rotateY = y);
                    if (!animate) {
                        this.attr(obj)
                    } else {
                        this.animate(obj, animOptions)
                    }
                    return this
                },
                getBBox: function() {
                    var bBox, elem = this.element,
                        transformation = this._settings;
                    try {
                        bBox = elem.getBBox && elem.getBBox()
                    } catch (e) {}
                    bBox = bBox || {
                        x: 0,
                        y: 0,
                        width: elem.offsetWidth || 0,
                        height: elem.offsetHeight || 0
                    };
                    if (transformation.rotate) {
                        bBox = _rotateBBox(bBox, [("rotateX" in transformation ? transformation.rotateX : transformation.x) || 0, ("rotateY" in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate)
                    } else {
                        bBox = _normalizeBBox(bBox)
                    }
                    return bBox
                },
                markup: function() {
                    var temp = doc.createElement("div"),
                        node = this.element.cloneNode(true);
                    temp.appendChild(node);
                    return temp.innerHTML
                },
                getOffset: function() {
                    return this._getJQElement().offset()
                },
                stopAnimation: function(disableComplete) {
                    var animation = this.animation;
                    animation && animation.stop(disableComplete);
                    return this
                },
                setTitle: function(text) {
                    var titleElem = createElement("title");
                    titleElem.textContent = text || "";
                    this.element.appendChild(titleElem)
                },
                data: function(obj, val) {
                    var key, elem = this.element;
                    if (void 0 !== val) {
                        elem[obj] = val
                    } else {
                        for (key in obj) {
                            elem[key] = obj[key]
                        }
                    }
                    return this
                },
                on: function() {
                    $.fn.on.apply(this._getJQElement(), arguments);
                    return this
                },
                off: function() {
                    $.fn.off.apply(this._getJQElement(), arguments);
                    return this
                },
                trigger: function() {
                    $.fn.trigger.apply(this._getJQElement(), arguments);
                    return this
                }
            };

            function PathSvgElement(renderer, type) {
                SvgElement.call(this, renderer, "path", type)
            }
            exports.PathSvgElement = PathSvgElement;
            PathSvgElement.prototype = objectCreate(SvgElement.prototype);
            extend(PathSvgElement.prototype, {
                constructor: PathSvgElement,
                attr: pathAttr,
                animate: pathAnimate
            });

            function ArcSvgElement(renderer) {
                SvgElement.call(this, renderer, "path", "arc")
            }
            exports.ArcSvgElement = ArcSvgElement;
            ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
            extend(ArcSvgElement.prototype, {
                constructor: ArcSvgElement,
                attr: arcAttr,
                animate: arcAnimate
            });

            function RectSvgElement(renderer) {
                SvgElement.call(this, renderer, "rect")
            }
            exports.RectSvgElement = RectSvgElement;
            RectSvgElement.prototype = objectCreate(SvgElement.prototype);
            extend(RectSvgElement.prototype, {
                constructor: RectSvgElement,
                attr: rectAttr
            });

            function TextSvgElement(renderer) {
                SvgElement.call(this, renderer, "text")
            }
            exports.TextSvgElement = TextSvgElement;
            TextSvgElement.prototype = objectCreate(SvgElement.prototype);
            extend(TextSvgElement.prototype, {
                constructor: TextSvgElement,
                attr: textAttr,
                css: textCss,
                applyEllipsis: applyEllipsis
            });

            function updateIndexes(items, k) {
                var i, item;
                for (i = k; !!(item = items[i]); ++i) {
                    item._link.i = i
                }
            }

            function linkItem(target, container) {
                var i, item, items = container._links,
                    key = target._link.after = target._link.after || container._linkAfter;
                if (key) {
                    for (i = 0;
                        (item = items[i]) && item._link.name !== key; ++i) {}
                    if (item) {
                        for (++i;
                            (item = items[i]) && item._link.after === key; ++i) {}
                    }
                } else {
                    i = items.length
                }
                items.splice(i, 0, target);
                updateIndexes(items, i)
            }

            function unlinkItem(target) {
                var i, items = target._link.to._links;
                for (i = 0; items[i] !== target; ++i) {}
                items.splice(i, 1);
                updateIndexes(items, i)
            }

            function SvgRenderer(options) {
                var that = this;
                that.root = that._createElement(that._rootTag, that._rootAttr).attr({
                    "class": options.cssClass
                }).css(that._rootCss);
                that._init();
                that.pathModified = !!options.pathModified;
                that._$container = $(options.container);
                that.root.append({
                    element: options.container
                });
                that._locker = 0;
                that._backed = false
            }
            exports.SvgRenderer = SvgRenderer;
            SvgRenderer.prototype = {
                constructor: SvgRenderer,
                _rootTag: "svg",
                _rootAttr: {
                    xmlns: "http://www.w3.org/2000/svg",
                    "xmlns:xlink": "http://www.w3.org/1999/xlink",
                    version: "1.1",
                    fill: NONE,
                    stroke: NONE,
                    "stroke-width": 0
                },
                _rootCss: {
                    "line-height": "normal",
                    "-ms-user-select": NONE,
                    "-moz-user-select": NONE,
                    "-webkit-user-select": NONE,
                    "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)",
                    display: "block",
                    overflow: "hidden"
                },
                _init: function() {
                    var that = this;
                    that._defs = that._createElement("defs").append(that.root);
                    that._animationController = new animation.AnimationController(that.root.element);
                    that._animation = {
                        enabled: true,
                        duration: 1e3,
                        easing: "easeOutCubic"
                    }
                },
                setOptions: function(options) {
                    var that = this;
                    that.rtl = !!options.rtl;
                    that.encodeHtml = !!options.encodeHtml;
                    that.updateAnimationOptions(options.animation || {});
                    that.root.attr({
                        direction: that.rtl ? "rtl" : "ltr"
                    });
                    return that
                },
                _createElement: function(tagName, attr, type) {
                    var elem = new exports.SvgElement(this, tagName, type);
                    attr && elem.attr(attr);
                    return elem
                },
                lock: function() {
                    var that = this;
                    if (0 === that._locker) {
                        that._backed = !that._$container.is(":visible");
                        if (that._backed) {
                            backupRoot(that.root)
                        }
                    }++that._locker;
                    return that
                },
                unlock: function() {
                    var that = this;
                    --that._locker;
                    if (0 === that._locker) {
                        if (that._backed) {
                            restoreRoot(that.root, that._$container[0])
                        }
                        that._backed = false
                    }
                    return that
                },
                resize: function(width, height) {
                    if (width >= 0 && height >= 0) {
                        this.root.attr({
                            width: width,
                            height: height
                        })
                    }
                    return this
                },
                dispose: function() {
                    var key, that = this;
                    that.root.dispose();
                    that._defs.dispose();
                    that._animationController.dispose();
                    for (key in that) {
                        that[key] = null
                    }
                    return that
                },
                animationEnabled: function() {
                    return !!this._animation.enabled
                },
                updateAnimationOptions: function(newOptions) {
                    extend(this._animation, newOptions);
                    return this
                },
                stopAllAnimations: function(lock) {
                    this._animationController[lock ? "lock" : "stop"]();
                    return this
                },
                animateElement: function(element, params, options) {
                    this._animationController.animateElement(element, params, options);
                    return this
                },
                svg: function() {
                    return this.root.markup()
                },
                getRootOffset: function() {
                    return this.root.getOffset()
                },
                onEndAnimation: function(endAnimation) {
                    this._animationController.onEndAnimation(endAnimation)
                },
                rect: function(x, y, width, height) {
                    var elem = new exports.RectSvgElement(this);
                    return elem.attr({
                        x: x || 0,
                        y: y || 0,
                        width: width || 0,
                        height: height || 0
                    })
                },
                simpleRect: function() {
                    return this._createElement("rect")
                },
                circle: function(x, y, r) {
                    return this._createElement("circle", {
                        cx: x || 0,
                        cy: y || 0,
                        r: r || 0
                    })
                },
                g: function() {
                    return this._createElement("g")
                },
                image: function(x, y, w, h, href, location) {
                    var image = this._createElement("image", {
                        x: x || 0,
                        y: y || 0,
                        width: w || 0,
                        height: h || 0,
                        preserveAspectRatio: preserveAspectRatioMap[_normalizeEnum(location)] || NONE
                    });
                    image.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", href || "");
                    return image
                },
                path: function(points, type) {
                    var elem = new exports.PathSvgElement(this, type);
                    return elem.attr({
                        points: points || []
                    })
                },
                arc: function(x, y, innerRadius, outerRadius, startAngle, endAngle) {
                    var elem = new exports.ArcSvgElement(this);
                    return elem.attr({
                        x: x || 0,
                        y: y || 0,
                        innerRadius: innerRadius || 0,
                        outerRadius: outerRadius || 0,
                        startAngle: startAngle || 0,
                        endAngle: endAngle || 0
                    })
                },
                text: function(text, x, y) {
                    var elem = new exports.TextSvgElement(this);
                    return elem.attr({
                        text: text,
                        x: x || 0,
                        y: y || 0
                    })
                },
                pattern: function(color, hatching, _id) {
                    hatching = hatching || {};
                    var id, d, pattern, rect, path, that = this,
                        step = hatching.step || 6,
                        stepTo2 = step / 2,
                        stepBy15 = 1.5 * step,
                        direction = _normalizeEnum(hatching.direction);
                    if ("right" !== direction && "left" !== direction) {
                        return {
                            id: color,
                            append: function() {
                                return this
                            },
                            clear: function() {},
                            dispose: function() {},
                            remove: function() {}
                        }
                    }
                    id = _id || getNextDefsSvgId();
                    d = "right" === direction ? "M " + stepTo2 + " " + -stepTo2 + " L " + -stepTo2 + " " + stepTo2 + " M 0 " + step + " L " + step + " 0 M " + stepBy15 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 : "M 0 0 L " + step + " " + step + " M " + -stepTo2 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 + " M " + stepTo2 + " " + -stepTo2 + " L " + stepBy15 + " " + stepTo2;
                    pattern = that._createElement("pattern", {
                        id: id,
                        width: step,
                        height: step,
                        patternUnits: "userSpaceOnUse"
                    }).append(that._defs);
                    pattern.id = getPatternUrl(id, that.pathModified);
                    rect = that.rect(0, 0, step, step).attr({
                        fill: color,
                        opacity: hatching.opacity
                    }).append(pattern);
                    path = new exports.PathSvgElement(this).attr({
                        d: d,
                        "stroke-width": hatching.width || 1,
                        stroke: color
                    }).append(pattern);
                    pattern.rect = rect;
                    pattern.path = path;
                    return pattern
                },
                clipRect: function(x, y, width, height) {
                    var that = this,
                        id = getNextDefsSvgId(),
                        clipPath = that._createElement("clipPath", {
                            id: id
                        }).append(that._defs),
                        rect = that.rect(x, y, width, height).append(clipPath);
                    rect.id = id;
                    rect.clipPath = clipPath;
                    rect.remove = function() {
                        throw "Not implemented"
                    };
                    rect.dispose = function() {
                        clipPath.dispose();
                        clipPath = null;
                        return this
                    };
                    return rect
                },
                shadowFilter: function(x, y, width, height, offsetX, offsetY, blur, color, opacity) {
                    var that = this,
                        id = getNextDefsSvgId(),
                        filter = that._createElement("filter", {
                            id: id,
                            x: x || 0,
                            y: y || 0,
                            width: width || 0,
                            height: height || 0
                        }).append(that._defs),
                        gaussianBlur = that._createElement("feGaussianBlur", {
                            "in": "SourceGraphic",
                            result: "gaussianBlurResult",
                            stdDeviation: blur || 0
                        }).append(filter),
                        offset = that._createElement("feOffset", {
                            "in": "gaussianBlurResult",
                            result: "offsetResult",
                            dx: offsetX || 0,
                            dy: offsetY || 0
                        }).append(filter),
                        flood = that._createElement("feFlood", {
                            result: "floodResult",
                            "flood-color": color || "",
                            "flood-opacity": opacity
                        }).append(filter),
                        composite = that._createElement("feComposite", {
                            "in": "floodResult",
                            in2: "offsetResult",
                            operator: "in",
                            result: "compositeResult"
                        }).append(filter),
                        finalComposite = that._createElement("feComposite", {
                            "in": "SourceGraphic",
                            in2: "compositeResult",
                            operator: "over"
                        }).append(filter);
                    filter.ref = getPatternUrl(id, that.pathModified);
                    filter.gaussianBlur = gaussianBlur;
                    filter.offset = offset;
                    filter.flood = flood;
                    filter.composite = composite;
                    filter.finalComposite = finalComposite;
                    filter.attr = function(attrs) {
                        var that = this,
                            filterAttrs = {},
                            offsetAttrs = {},
                            floodAttrs = {};
                        "x" in attrs && (filterAttrs.x = attrs.x);
                        "y" in attrs && (filterAttrs.y = attrs.y);
                        "width" in attrs && (filterAttrs.width = attrs.width);
                        "height" in attrs && (filterAttrs.height = attrs.height);
                        baseAttr(that, filterAttrs);
                        "blur" in attrs && that.gaussianBlur.attr({
                            stdDeviation: attrs.blur
                        });
                        "offsetX" in attrs && (offsetAttrs.dx = attrs.offsetX);
                        "offsetY" in attrs && (offsetAttrs.dy = attrs.offsetY);
                        that.offset.attr(offsetAttrs);
                        "color" in attrs && (floodAttrs["flood-color"] = attrs.color);
                        "opacity" in attrs && (floodAttrs["flood-opacity"] = attrs.opacity);
                        that.flood.attr(floodAttrs);
                        return that
                    };
                    return filter
                },
                brightFilter: function(type, slope) {
                    var that = this,
                        filterId = getNextDefsSvgId(),
                        filter = that._createElement("filter", {
                            id: filterId
                        }).append(that._defs),
                        feComponentTransfer = that._createElement("feComponentTransfer").append(filter),
                        attrs = {
                            type: type,
                            slope: slope
                        };
                    filter.ref = getPatternUrl(filterId, that.pathModified);
                    that._createElement("feFuncR", attrs).append(feComponentTransfer);
                    that._createElement("feFuncG", attrs).append(feComponentTransfer);
                    that._createElement("feFuncB", attrs).append(feComponentTransfer);
                    return filter
                },
                initHatching: function() {
                    var name, storage = this._hatchingStorage = this._hatchingStorage || {
                            byHash: {},
                            baseId: getNextDefsSvgId()
                        },
                        byHash = storage.byHash;
                    for (name in byHash) {
                        byHash[name].pattern.dispose()
                    }
                    storage.byHash = {};
                    storage.refToHash = {};
                    storage.nextId = 0
                },
                lockHatching: function(color, hatching, ref) {
                    var storageItem, pattern, storage = this._hatchingStorage,
                        hash = getHatchingHash(color, hatching);
                    if (storage.refToHash[ref] !== hash) {
                        if (ref) {
                            this.releaseHatching(ref)
                        }
                        storageItem = storage.byHash[hash];
                        if (!storageItem) {
                            pattern = this.pattern(color, hatching, storage.baseId + "-hatching-" + storage.nextId++);
                            storageItem = storage.byHash[hash] = {
                                pattern: pattern,
                                count: 0
                            };
                            storage.refToHash[pattern.id] = hash
                        }++storageItem.count;
                        ref = storageItem.pattern.id
                    }
                    return ref
                },
                releaseHatching: function(ref) {
                    var storage = this._hatchingStorage,
                        hash = storage.refToHash[ref],
                        storageItem = storage.byHash[hash];
                    if (0 === --storageItem.count) {
                        storageItem.pattern.dispose();
                        delete storage.byHash[hash];
                        delete storage.refToHash[ref]
                    }
                }
            };

            function getHatchingHash(color, hatching) {
                return "@" + color + "::" + hatching.step + ":" + hatching.width + ":" + hatching.opacity + ":" + hatching.direction
            }
            exports._getEllipsis = getEllipsis;
            exports._createArcAttr = createArcAttr;
            exports._createPathAttr = createPathAttr;
            exports._createRectAttr = createRectAttr
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , ,
    /*!***********************************************!*\
      !*** ./Scripts/bundles/modules/data.odata.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./data */ 196);
            DevExpress.data.ODataStore = __webpack_require__( /*! ../../data/odata/store */ 204);
            DevExpress.data.ODataContext = __webpack_require__( /*! ../../data/odata/context */ 272);
            DevExpress.data.utils = DevExpress.data.utils || {};
            DevExpress.data.utils.odata = {};
            DevExpress.data.utils.odata.keyConverters = __webpack_require__( /*! ../../data/odata/utils */ 71).keyConverters;
            DevExpress.data.EdmLiteral = __webpack_require__( /*! ../../data/odata/utils */ 71).EdmLiteral;
            var ODataUtilsModule = __webpack_require__( /*! ../../data/odata/utils */ 71);
            DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
            DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
            DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
            DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
            DevExpress.data.OData__internals = ODataUtilsModule.OData__internals;
            DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
            DevExpress.data.queryAdapters.odata = __webpack_require__( /*! ../../data/odata/query_adapter */ 112).odata
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/bundles/modules/framework.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 97);
            __webpack_require__( /*! ../../integration/knockout */ 85);
            module.exports = DevExpress.framework = {};
            DevExpress.framework.dxCommand = __webpack_require__( /*! ../../framework/command */ 145);
            DevExpress.framework.Router = __webpack_require__( /*! ../../framework/router */ 116);
            DevExpress.framework.StateManager = __webpack_require__( /*! ../../framework/state_manager */ 150);
            DevExpress.framework.ViewCache = __webpack_require__( /*! ../../framework/view_cache */ 59);
            DevExpress.framework.NullViewCache = __webpack_require__( /*! ../../framework/view_cache */ 59).NullViewCache;
            DevExpress.framework.ConditionalViewCacheDecorator = __webpack_require__( /*! ../../framework/view_cache */ 59).ConditionalViewCacheDecorator;
            DevExpress.framework.CapacityViewCacheDecorator = __webpack_require__( /*! ../../framework/view_cache */ 59).CapacityViewCacheDecorator;
            DevExpress.framework.HistoryDependentViewCacheDecorator = __webpack_require__( /*! ../../framework/view_cache */ 59).HistoryDependentViewCacheDecorator;
            DevExpress.framework.dxCommandContainer = __webpack_require__( /*! ../../framework/html/command_container */ 147);
            DevExpress.framework.dxView = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxView;
            DevExpress.framework.dxLayout = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxLayout;
            DevExpress.framework.dxViewPlaceholder = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxViewPlaceholder;
            DevExpress.framework.dxContentPlaceholder = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxContentPlaceholder;
            DevExpress.framework.dxTransition = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxTransition;
            DevExpress.framework.dxContent = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45).dxContent;
            DevExpress.framework.html = {};
            DevExpress.framework.html.HtmlApplication = __webpack_require__( /*! ../../framework/html/html_application */ 213);
            DevExpress.framework.Route = __webpack_require__( /*! ../../framework/router */ 116).Route;
            DevExpress.framework.MemoryKeyValueStorage = __webpack_require__( /*! ../../framework/state_manager */ 150).MemoryKeyValueStorage;
            DevExpress.framework.NavigationDevices = __webpack_require__( /*! ../../framework/navigation_devices */ 115);
            DevExpress.framework.NavigationManager = __webpack_require__( /*! ../../framework/navigation_manager */ 83);
            DevExpress.framework.createActionExecutors = __webpack_require__( /*! ../../framework/action_executors */ 209).createActionExecutors;
            DevExpress.framework.Application = __webpack_require__( /*! ../../framework/application */ 210).Application;
            var browserAdapters = __webpack_require__( /*! ../../framework/browser_adapters */ 211);
            DevExpress.framework.DefaultBrowserAdapter = browserAdapters.DefaultBrowserAdapter;
            DevExpress.framework.OldBrowserAdapter = browserAdapters.OldBrowserAdapter;
            DevExpress.framework.BuggyAndroidBrowserAdapter = browserAdapters.BuggyAndroidBrowserAdapter;
            DevExpress.framework.HistorylessBrowserAdapter = browserAdapters.HistorylessBrowserAdapter;
            DevExpress.framework.BuggyCordovaWP81BrowserAdapter = browserAdapters.BuggyCordovaWP81BrowserAdapter;
            DevExpress.framework.CommandMapping = __webpack_require__( /*! ../../framework/command_mapping */ 146);
            DevExpress.framework.HistoryBasedNavigationDevice = __webpack_require__( /*! ../../framework/navigation_devices */ 115).HistoryBasedNavigationDevice;
            DevExpress.framework.StackBasedNavigationDevice = __webpack_require__( /*! ../../framework/navigation_devices */ 115).StackBasedNavigationDevice;
            DevExpress.framework.HistoryBasedNavigationManager = __webpack_require__( /*! ../../framework/navigation_manager */ 83).HistoryBasedNavigationManager;
            DevExpress.framework.StackBasedNavigationManager = __webpack_require__( /*! ../../framework/navigation_manager */ 83).StackBasedNavigationManager;
            DevExpress.framework.NavigationStack = __webpack_require__( /*! ../../framework/navigation_manager */ 83).NavigationStack;
            DevExpress.framework.utils = __webpack_require__( /*! ../../framework/utils */ 84).utils;
            DevExpress.framework.templateProvider = __webpack_require__( /*! ../../framework/utils */ 84).templateProvider;
            DevExpress.framework.html.CommandManager = __webpack_require__( /*! ../../framework/html/command_manager */ 212);
            DevExpress.framework.html.HtmlApplication = __webpack_require__( /*! ../../framework/html/html_application */ 213);
            DevExpress.framework.html.layoutSets = __webpack_require__( /*! ../../framework/html/presets */ 114).layoutSets;
            DevExpress.framework.html.animationSets = __webpack_require__( /*! ../../framework/html/presets */ 114).animationSets;
            DevExpress.framework.html.DefaultLayoutController = __webpack_require__( /*! ../../framework/html/layout_controller */ 148).DefaultLayoutController;
            DevExpress.framework.html.layoutSets = __webpack_require__( /*! ../../framework/html/layout_controller */ 148).layoutSets;
            DevExpress.framework.html.MarkupComponent = __webpack_require__( /*! ../../framework/html/markup_component */ 149).MarkupComponent;
            DevExpress.framework.html.ViewEngine = __webpack_require__( /*! ../../framework/html/view_engine */ 214).ViewEngine;
            DevExpress.framework.html.ViewEngineComponents = __webpack_require__( /*! ../../framework/html/view_engine_components */ 45);
            var widgetCommandAdaptersModule = __webpack_require__( /*! ../../framework/html/widget_command_adapters */ 215);
            DevExpress.framework.html.commandToDXWidgetAdapters = {
                dxToolbar: widgetCommandAdaptersModule.dxToolbar,
                dxList: widgetCommandAdaptersModule.dxList,
                dxNavBar: widgetCommandAdaptersModule.dxNavBar,
                dxPivot: widgetCommandAdaptersModule.dxPivot,
                dxSlideOut: widgetCommandAdaptersModule.dxSlideOut
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/core/utils/weak_map.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                WeakMap = window.WeakMap;
            if (!WeakMap) {
                WeakMap = function() {
                    var keys = [],
                        values = [];
                    this.set = function(key, value) {
                        var index = $.inArray(key, keys);
                        if (-1 === index) {
                            keys.push(key);
                            values.push(value)
                        } else {
                            values[index] = value
                        }
                    };
                    this.get = function(key) {
                        var index = $.inArray(key, keys);
                        if (-1 === index) {
                            return
                        }
                        return values[index]
                    };
                    this.has = function(key) {
                        var index = $.inArray(key, keys);
                        if (-1 === index) {
                            return false
                        }
                        return true
                    }
                }
            }
            module.exports = WeakMap
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/data_source.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./data_source/data_source */ 37).DataSource
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/data/endpoint_selector.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errors = __webpack_require__( /*! ../core/errors */ 10),
                proxyUrlFormatter = __webpack_require__( /*! ./proxy_url_formatter */ 205);
            var location = window.location,
                IS_WINJS_ORIGIN = "ms-appx:" === location.protocol,
                IS_LOCAL_ORIGIN = isLocalHostName(location.hostname);

            function isLocalHostName(url) {
                return /^(localhost$|127\.)/i.test(url)
            }
            var EndpointSelector = function(config) {
                this.config = config
            };
            EndpointSelector.prototype = {
                urlFor: function(key) {
                    var bag = this.config[key];
                    if (!bag) {
                        throw errors.Error("E0006")
                    }
                    if (proxyUrlFormatter.isProxyUsed()) {
                        return proxyUrlFormatter.formatProxyUrl(bag.local)
                    }
                    if (bag.production) {
                        if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
                            return bag.production
                        }
                    }
                    return bag.local
                }
            };
            module.exports = EndpointSelector
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/data/local_store.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../core/class */ 5),
                abstract = Class.abstract,
                errors = __webpack_require__( /*! ./errors */ 25).errors,
                ArrayStore = __webpack_require__( /*! ./array_store */ 58);
            var LocalStoreBackend = Class.inherit({
                ctor: function(store, storeOptions) {
                    this._store = store;
                    this._dirty = false;
                    var immediate = this._immediate = storeOptions.immediate;
                    var flushInterval = Math.max(100, storeOptions.flushInterval || 1e4);
                    if (!immediate) {
                        var saveProxy = $.proxy(this.save, this);
                        setInterval(saveProxy, flushInterval);
                        $(window).on("beforeunload", saveProxy);
                        if (window.cordova) {
                            document.addEventListener("pause", saveProxy, false)
                        }
                    }
                },
                notifyChanged: function() {
                    this._dirty = true;
                    if (this._immediate) {
                        this.save()
                    }
                },
                load: function() {
                    this._store._array = this._loadImpl();
                    this._dirty = false
                },
                save: function() {
                    if (!this._dirty) {
                        return
                    }
                    this._saveImpl(this._store._array);
                    this._dirty = false
                },
                _loadImpl: abstract,
                _saveImpl: abstract
            });
            var DomLocalStoreBackend = LocalStoreBackend.inherit({
                ctor: function(store, storeOptions) {
                    this.callBase(store, storeOptions);
                    var name = storeOptions.name;
                    if (!name) {
                        throw errors.Error("E4013")
                    }
                    this._key = "dx-data-localStore-" + name
                },
                _loadImpl: function() {
                    var raw = localStorage.getItem(this._key);
                    if (raw) {
                        return JSON.parse(raw)
                    }
                    return []
                },
                _saveImpl: function(array) {
                    if (!array.length) {
                        localStorage.removeItem(this._key)
                    } else {
                        localStorage.setItem(this._key, JSON.stringify(array))
                    }
                }
            });
            var localStoreBackends = {
                dom: DomLocalStoreBackend
            };
            var LocalStore = ArrayStore.inherit({
                ctor: function(options) {
                    if ("string" === typeof options) {
                        options = {
                            name: options
                        }
                    } else {
                        options = options || {}
                    }
                    this.callBase(options);
                    this._backend = new localStoreBackends[options.backend || "dom"](this, options);
                    this._backend.load()
                },
                clear: function() {
                    this.callBase();
                    this._backend.notifyChanged()
                },
                _insertImpl: function(values) {
                    var b = this._backend;
                    return this.callBase(values).done($.proxy(b.notifyChanged, b))
                },
                _updateImpl: function(key, values) {
                    var b = this._backend;
                    return this.callBase(key, values).done($.proxy(b.notifyChanged, b))
                },
                _removeImpl: function(key) {
                    var b = this._backend;
                    return this.callBase(key).done($.proxy(b.notifyChanged, b))
                }
            }, "local");
            module.exports = LocalStore
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/data/odata/context.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                errorsModule = __webpack_require__( /*! ../errors */ 25),
                ODataStore = __webpack_require__( /*! ./store */ 204),
                mixins = __webpack_require__( /*! ./mixins */ 203);
            __webpack_require__( /*! ./query_adapter */ 112);
            var ODataContext = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    that._extractServiceOptions(options);
                    that._errorHandler = options.errorHandler;
                    $.each(options.entities || [], function(entityAlias, entityOptions) {
                        that[entityAlias] = new ODataStore($.extend({}, options, {
                            url: that._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)
                        }, entityOptions))
                    })
                },
                get: function(operationName, params) {
                    return this.invoke(operationName, params, "GET")
                },
                invoke: function(operationName, params, httpMethod) {
                    params = params || {};
                    httpMethod = (httpMethod || "POST").toLowerCase();
                    var payload, d = $.Deferred(),
                        url = this._url + "/" + encodeURIComponent(operationName);
                    if (4 === this.version()) {
                        if ("get" === httpMethod) {
                            url = mixins.formatFunctionInvocationUrl(url, mixins.escapeServiceOperationParams(params, this.version()));
                            params = null
                        } else {
                            if ("post" === httpMethod) {
                                payload = params;
                                params = null
                            }
                        }
                    }
                    $.when(this._sendRequest(url, httpMethod, mixins.escapeServiceOperationParams(params, this.version()), payload)).done(function(r) {
                        if ($.isPlainObject(r) && operationName in r) {
                            r = r[operationName]
                        }
                        d.resolve(r)
                    }).fail([this._errorHandler, errorsModule._errorHandler, d.reject]);
                    return d.promise()
                },
                objectLink: function(entityAlias, key) {
                    var store = this[entityAlias];
                    if (!store) {
                        throw errorsModule.errors.Error("E4015", entityAlias)
                    }
                    if (!commonUtils.isDefined(key)) {
                        return null
                    }
                    return {
                        __metadata: {
                            uri: store._byKeyUrl(key, true)
                        }
                    }
                }
            }).include(mixins.SharedMethods);
            module.exports = ODataContext
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************!*\
      !*** ./Scripts/data/remote_query.js ***!
      \**************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                queryAdapters = __webpack_require__( /*! ./query_adapters */ 144),
                errorsModule = __webpack_require__( /*! ./errors */ 25),
                arrayQueryImpl = __webpack_require__( /*! ./array_query */ 201);
            var remoteQueryImpl = function(url, queryOptions, tasks) {
                tasks = tasks || [];
                queryOptions = queryOptions || {};
                var createTask = function(name, args) {
                    return {
                        name: name,
                        args: args
                    }
                };
                var exec = function(executorTask) {
                    var _adapterFactory, _adapter, _taskQueue, _currentTask, _mergedSortArgs, d = $.Deferred();
                    var rejectWithNotify = function(error) {
                        var handler = queryOptions.errorHandler;
                        if (handler) {
                            handler(error)
                        }
                        errorsModule._errorHandler(error);
                        d.reject(error)
                    };

                    function mergeSortTask(task) {
                        switch (task.name) {
                            case "sortBy":
                                _mergedSortArgs = [task.args];
                                return true;
                            case "thenBy":
                                if (!_mergedSortArgs) {
                                    throw errorsModule.errors.Error("E4004")
                                }
                                _mergedSortArgs.push(task.args);
                                return true
                        }
                        return false
                    }

                    function unmergeSortTasks() {
                        var head = _taskQueue[0],
                            unmergedTasks = [];
                        if (head && "multiSort" === head.name) {
                            _taskQueue.shift();
                            $.each(head.args[0], function() {
                                unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
                            })
                        }
                        _taskQueue = unmergedTasks.concat(_taskQueue)
                    }
                    try {
                        _adapterFactory = queryOptions.adapter;
                        if (!$.isFunction(_adapterFactory)) {
                            _adapterFactory = queryAdapters[_adapterFactory]
                        }
                        _adapter = _adapterFactory(queryOptions);
                        _taskQueue = [].concat(tasks).concat(executorTask);
                        while (_taskQueue.length) {
                            _currentTask = _taskQueue[0];
                            if (!mergeSortTask(_currentTask)) {
                                if (_mergedSortArgs) {
                                    _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                                    _mergedSortArgs = null;
                                    continue
                                }
                                if ("enumerate" !== String(_currentTask.name)) {
                                    if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
                                        break
                                    }
                                }
                            }
                            _taskQueue.shift()
                        }
                        unmergeSortTasks();
                        _adapter.exec(url).done(function(result, extra) {
                            if (!_taskQueue.length) {
                                d.resolve(result, extra)
                            } else {
                                var clientChain = arrayQueryImpl(result, {
                                    errorHandler: queryOptions.errorHandler
                                });
                                $.each(_taskQueue, function() {
                                    clientChain = clientChain[this.name].apply(clientChain, this.args)
                                });
                                clientChain.done(d.resolve).fail(d.reject)
                            }
                        }).fail(rejectWithNotify)
                    } catch (x) {
                        rejectWithNotify(x)
                    }
                    return d.promise()
                };
                var query = {};
                $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
                    var name = String(this);
                    query[name] = function() {
                        return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)))
                    }
                });
                $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
                    var name = String(this);
                    query[name] = function() {
                        return exec.call(this, createTask(name, arguments))
                    }
                });
                return query
            };
            module.exports = remoteQueryImpl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/events/pointer/mouse_and_touch.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseStrategy = __webpack_require__( /*! ./base */ 113),
                MouseStrategy = __webpack_require__( /*! ./mouse */ 206),
                TouchStrategy = __webpack_require__( /*! ./touch */ 208),
                eventUtils = __webpack_require__( /*! ../utils */ 4);
            var eventMap = {
                dxpointerdown: "touchstart mousedown",
                dxpointermove: "touchmove mousemove",
                dxpointerup: "touchend mouseup",
                dxpointercancel: "touchcancel",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
            var activated = false;
            var activateStrategy = function() {
                if (activated) {
                    return
                }
                MouseStrategy.activate();
                activated = true
            };
            var MouseAndTouchStrategy = BaseStrategy.inherit({
                EVENT_LOCK_TIMEOUT: 100,
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _handler: function(e) {
                    var isMouseEvent = eventUtils.isMouseEvent(e);
                    if (!isMouseEvent) {
                        this._skipNextEvents = true
                    }
                    if (isMouseEvent && this._mouseLocked) {
                        return
                    }
                    if (isMouseEvent && this._skipNextEvents) {
                        this._skipNextEvents = false;
                        this._mouseLocked = true;
                        clearTimeout(this._unlockMouseTimer);
                        var that = this;
                        this._unlockMouseTimer = setTimeout(function() {
                            that._mouseLocked = false
                        }, this.EVENT_LOCK_TIMEOUT);
                        return
                    }
                    return this.callBase(e)
                },
                _fireEvent: function(args) {
                    var isMouseEvent = eventUtils.isMouseEvent(args.originalEvent),
                        normalizer = isMouseEvent ? MouseStrategy.normalize : TouchStrategy.normalize;
                    return this.callBase($.extend(normalizer(args.originalEvent), args))
                },
                dispose: function() {
                    this.callBase();
                    this._skipNextEvents = false;
                    this._mouseLocked = false;
                    clearTimeout(this._unlockMouseTimer)
                }
            });
            MouseAndTouchStrategy.map = eventMap;
            MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
            module.exports = MouseAndTouchStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/events/pointer/mspointer.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseStrategy = __webpack_require__( /*! ./base */ 113),
                Observer = __webpack_require__( /*! ./observer */ 207),
                browser = __webpack_require__( /*! ../../core/utils/browser */ 22);
            __webpack_require__( /*! ./mspointer_hooks */ 276);
            var isIE10 = browser.msie && 10 === parseInt(browser.version);
            var eventMap = {
                dxpointerdown: "MSPointerDown pointerdown",
                dxpointermove: "MSPointerMove pointermove",
                dxpointerup: "MSPointerUp pointerup",
                dxpointercancel: "MSPointerCancel pointercancel",
                dxpointerover: "MSPointerOver pointerover",
                dxpointerout: "MSPointerOut pointerout",
                dxpointerenter: isIE10 ? "mouseenter" : "MSPointerEnter pointerenter",
                dxpointerleave: isIE10 ? "mouseleave" : "MSPointerLeave pointerleave"
            };
            var observer;
            var activated = false;
            var activateStrategy = function() {
                if (activated) {
                    return
                }
                observer = new Observer(eventMap, function(a, b) {
                    return a.pointerId === b.pointerId
                }, function(e) {
                    if (e.isPrimary) {
                        observer.reset()
                    }
                });
                activated = true
            };
            var MsPointerStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend({
                        pointers: observer.pointers(),
                        pointerId: args.originalEvent.pointerId
                    }, args))
                }
            });
            MsPointerStrategy.map = eventMap;
            MsPointerStrategy.resetObserver = function() {
                observer.reset()
            };
            module.exports = MsPointerStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/events/pointer/mspointer_hooks.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var POINTER_TYPE_MAP = {
                2: "touch",
                3: "pen",
                4: "mouse"
            };
            var pointerEventHook = {
                filter: function(event, originalEvent) {
                    var pointerType = originalEvent.pointerType;
                    if ($.isNumeric(pointerType)) {
                        event.pointerType = POINTER_TYPE_MAP[pointerType]
                    }
                    return event
                },
                props: $.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
            };
            $.each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
                $.event.fixHooks[this] = pointerEventHook
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/events/pointer/touch_hooks.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var touchEventHook = {
                filter: function(event, originalEvent) {
                    var touches = originalEvent.touches.length ? originalEvent.touches : originalEvent.changedTouches;
                    $.each(["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], function() {
                        event[this] = touches[0][this]
                    });
                    return event
                },
                props: $.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
            };
            $.each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
                $.event.fixHooks[this] = touchEventHook
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/events/transform.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                mathUtils = __webpack_require__( /*! ../core/utils/math */ 66),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                eventUtils = __webpack_require__( /*! ./utils */ 4),
                Emitter = __webpack_require__( /*! ./core/emitter */ 81),
                registerEmitter = __webpack_require__( /*! ./core/emitter_registrator */ 61);
            var DX_PREFIX = "dx",
                TRANSFORM = "transform",
                TRANSLATE = "translate",
                ZOOM = "zoom",
                PINCH = "pinch",
                ROTATE = "rotate",
                START_POSTFIX = "start",
                UPDATE_POSTFIX = "",
                END_POSTFIX = "end";
            var eventAliases = [];
            var addAlias = function(eventName, eventArgs) {
                eventAliases.push({
                    name: eventName,
                    args: eventArgs
                })
            };
            addAlias(TRANSFORM, {
                scale: true,
                deltaScale: true,
                rotation: true,
                deltaRotation: true,
                translation: true,
                deltaTranslation: true
            });
            addAlias(TRANSLATE, {
                translation: true,
                deltaTranslation: true
            });
            addAlias(ZOOM, {
                scale: true,
                deltaScale: true
            });
            addAlias(PINCH, {
                scale: true,
                deltaScale: true
            });
            addAlias(ROTATE, {
                rotation: true,
                deltaRotation: true
            });
            var getVector = function(first, second) {
                return {
                    x: second.pageX - first.pageX,
                    y: -second.pageY + first.pageY,
                    centerX: .5 * (second.pageX + first.pageX),
                    centerY: .5 * (second.pageY + first.pageY)
                }
            };
            var getEventVector = function(e) {
                var pointers = e.pointers;
                return getVector(pointers[0], pointers[1])
            };
            var getDistance = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
            };
            var getScale = function(firstVector, secondVector) {
                return getDistance(firstVector) / getDistance(secondVector)
            };
            var getRotation = function(firstVector, secondVector) {
                var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
                var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
                if (0 === distanceProduct) {
                    return 0
                }
                var sign = mathUtils.sign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
                var angle = Math.acos(mathUtils.fitIntoRange(scalarProduct / distanceProduct, -1, 1));
                return sign * angle
            };
            var getTranslation = function(firstVector, secondVector) {
                return {
                    x: firstVector.centerX - secondVector.centerX,
                    y: firstVector.centerY - secondVector.centerY
                }
            };
            var TransformEmitter = Emitter.inherit({
                configurate: function(data, eventName) {
                    if (eventName.indexOf(ZOOM) > -1) {
                        errors.log("W0005", eventName, "15.1", "Use '" + eventName.replace(ZOOM, PINCH) + "' event instead")
                    }
                    this.callBase(data)
                },
                validatePointers: function(e) {
                    return eventUtils.hasTouches(e) > 1
                },
                start: function(e) {
                    this._accept(e);
                    var startVector = getEventVector(e);
                    this._startVector = startVector;
                    this._prevVector = startVector;
                    this._fireEventAliases(START_POSTFIX, e)
                },
                move: function(e) {
                    var currentVector = getEventVector(e),
                        eventArgs = this._getEventArgs(currentVector);
                    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
                    this._prevVector = currentVector
                },
                end: function(e) {
                    var eventArgs = this._getEventArgs(this._prevVector);
                    this._fireEventAliases(END_POSTFIX, e, eventArgs)
                },
                _getEventArgs: function(vector) {
                    return {
                        scale: getScale(vector, this._startVector),
                        deltaScale: getScale(vector, this._prevVector),
                        rotation: getRotation(vector, this._startVector),
                        deltaRotation: getRotation(vector, this._prevVector),
                        translation: getTranslation(vector, this._startVector),
                        deltaTranslation: getTranslation(vector, this._prevVector)
                    }
                },
                _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {
                    eventArgs = eventArgs || {};
                    $.each(eventAliases, $.proxy(function(_, eventAlias) {
                        var args = {};
                        $.each(eventAlias.args, function(name) {
                            if (name in eventArgs) {
                                args[name] = eventArgs[name]
                            }
                        });
                        this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)
                    }, this))
                }
            });
            var eventNames = $.map(eventAliases, function(eventAlias) {
                var eventNames = [];
                $.each([START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX], function(_, eventPostfix) {
                    eventNames.push(DX_PREFIX + eventAlias.name + eventPostfix)
                });
                return eventNames
            });
            registerEmitter({
                emitter: TransformEmitter,
                events: eventNames
            });
            $.each(eventNames, function(_, eventName) {
                exports[eventName.substring(DX_PREFIX.length)] = eventName
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/integration/angular.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            if (!window.angular) {
                return
            }
            __webpack_require__( /*! ./angular/component_registrator */ 281);
            __webpack_require__( /*! ./angular/event_registrator */ 284);
            __webpack_require__( /*! ./angular/components */ 282);
            __webpack_require__( /*! ./angular/action_executors */ 280)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************************!*\
      !*** ./Scripts/integration/angular/action_executors.js ***!
      \*********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var Action = __webpack_require__( /*! ../../core/action */ 54);
            Action.registerExecutor({
                ngExpression: {
                    execute: function(e) {
                        if ("string" === typeof e.action) {
                            e.context.$eval(e.action)
                        }
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************************!*\
      !*** ./Scripts/integration/angular/component_registrator.js ***!
      \**************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                Locker = __webpack_require__( /*! ../../core/utils/locker */ 200),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                Widget = __webpack_require__( /*! ../../ui/widget/ui.widget */ 19),
                Editor = __webpack_require__( /*! ../../ui/editor/editor */ 31),
                NgTemplateProvider = __webpack_require__( /*! ./template_provider */ 286),
                ngModule = __webpack_require__( /*! ./module */ 151),
                removeEvent = __webpack_require__( /*! ../../core/remove_event */ 141),
                CollectionWidget = __webpack_require__( /*! ../../ui/collection/ui.collection_widget.edit */ 27),
                compileSetter = __webpack_require__( /*! ../../core/utils/data */ 16).compileSetter,
                compileGetter = __webpack_require__( /*! ../../core/utils/data */ 16).compileGetter,
                extendFromObject = __webpack_require__( /*! ../../core/utils/object */ 30).extendFromObject;
            var ITEM_ALIAS_ATTRIBUTE_NAME = "dxItemAlias",
                DEFAULT_MODEL_ALIAS = "dxTemplateModel",
                MODEL_IS_PRIMITIVE_FLAG_NAME = "dxTemplateModelIsPrimitive",
                SKIP_APPLY_ACTION_CATEGORIES = ["rendering"];
            var applyDeferred;
            var safeApply = function(func, scope) {
                if (scope.$root.$$phase) {
                    return func(scope)
                } else {
                    applyDeferred = new $.Deferred;
                    var result = scope.$apply(function() {
                        return func(scope)
                    });
                    applyDeferred.resolve();
                    return result
                }
            };
            var ComponentBuilder = Class.inherit({
                ctor: function(options) {
                    this._componentDisposing = $.Callbacks();
                    this._optionChangedCallbacks = $.Callbacks();
                    this._ngLocker = new Locker;
                    this._scope = options.scope;
                    this._$element = options.$element;
                    this._$templates = options.$templates;
                    this._componentClass = options.componentClass;
                    this._parse = options.parse;
                    this._compile = options.compile;
                    this._itemAlias = options.itemAlias;
                    this._transcludeFn = options.transcludeFn;
                    this._digestCallbacks = options.dxDigestCallbacks;
                    this._normalizeOptions(options.ngOptions);
                    this._initComponentBindings();
                    this._initComponent(this._scope);
                    if (options.ngOptions) {
                        this._triggerResizeEvent()
                    } else {
                        this._addOptionsStringWatcher(options.ngOptionsString)
                    }
                },
                _addOptionsStringWatcher: function(optionsString) {
                    var that = this;
                    var clearOptionsStringWatcher = that._scope.$watch(optionsString, function(newOptions) {
                        if (!newOptions) {
                            return
                        }
                        clearOptionsStringWatcher();
                        that._normalizeOptions(newOptions);
                        that._initComponentBindings();
                        that._component.option(that._evalOptions(that._scope));
                        that._triggerResizeEvent()
                    });
                    that._componentDisposing.add(clearOptionsStringWatcher)
                },
                _normalizeOptions: function(options) {
                    var that = this;
                    that._ngOptions = extendFromObject({}, options);
                    if (!options) {
                        return
                    }
                    if (options.bindingOptions) {
                        $.each(options.bindingOptions, function(key, value) {
                            if ("string" === $.type(value)) {
                                that._ngOptions.bindingOptions[key] = {
                                    dataPath: value
                                }
                            }
                        })
                    }
                },
                _triggerResizeEvent: function() {
                    var that = this;
                    clearTimeout(that._shownEventTimer);
                    that._shownEventTimer = setTimeout(function() {
                        domUtils.triggerResizeEvent(that._$element)
                    });
                    that._componentDisposing.add(function() {
                        clearTimeout(that._shownEventTimer)
                    })
                },
                _initComponent: function(scope) {
                    this._component = new this._componentClass(this._$element, this._evalOptions(scope));
                    this._component._isHidden = true;
                    this._handleDigestPhase()
                },
                _handleDigestPhase: function() {
                    var that = this,
                        beginUpdate = function() {
                            that._component.beginUpdate()
                        },
                        endUpdate = function() {
                            that._component.endUpdate()
                        };
                    that._digestCallbacks.begin.add(beginUpdate);
                    that._digestCallbacks.end.add(endUpdate);
                    that._componentDisposing.add(function() {
                        that._digestCallbacks.begin.remove(beginUpdate);
                        that._digestCallbacks.end.remove(endUpdate)
                    })
                },
                _initComponentBindings: function() {
                    var that = this,
                        optionDependencies = {};
                    if (!that._ngOptions.bindingOptions) {
                        return
                    }
                    $.each(that._ngOptions.bindingOptions, function(optionPath, value) {
                        var prevWatchMethod, clearWatcher, separatorIndex = optionPath.search(/\[|\./),
                            optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath,
                            valuePath = value.dataPath,
                            deepWatch = true,
                            forcePlainWatchMethod = false;
                        if (void 0 !== value.deep) {
                            forcePlainWatchMethod = deepWatch = !!value.deep
                        }
                        if (!optionDependencies[optionForSubscribe]) {
                            optionDependencies[optionForSubscribe] = {}
                        }
                        optionDependencies[optionForSubscribe][optionPath] = valuePath;
                        var watchCallback = function(newValue, oldValue) {
                            if (that._ngLocker.locked(optionPath)) {
                                if (!applyDeferred) {
                                    that._ngLocker.release(optionPath)
                                }
                                return
                            }
                            that._ngLocker.obtain(optionPath);
                            that._component.option(optionPath, newValue);
                            updateWatcher();
                            if (that._component._optionValuesEqual(optionPath, oldValue, newValue) && that._ngLocker.locked(optionPath)) {
                                that._ngLocker.release(optionPath)
                            }
                        };
                        var updateWatcher = function() {
                            var watchMethod = $.isArray(that._scope.$eval(valuePath)) && !forcePlainWatchMethod ? "$watchCollection" : "$watch";
                            if (prevWatchMethod !== watchMethod) {
                                if (clearWatcher) {
                                    clearWatcher()
                                }
                                clearWatcher = that._scope[watchMethod](valuePath, watchCallback, deepWatch);
                                prevWatchMethod = watchMethod
                            }
                        };
                        updateWatcher();
                        that._componentDisposing.add(clearWatcher)
                    });
                    that._optionChangedCallbacks.add(function(args) {
                        var optionName = args.name,
                            fullName = args.fullName,
                            component = args.component;
                        if (that._ngLocker.locked(fullName)) {
                            that._ngLocker.release(fullName);
                            return
                        }
                        if ("$digest" === that._scope.$root.$$phase || !optionDependencies || !optionDependencies[optionName]) {
                            return
                        }
                        that._ngLocker.obtain(fullName);
                        safeApply(function(scope) {
                            $.each(optionDependencies[optionName], function(optionPath, valuePath) {
                                var value = component.option(optionPath);
                                that._parse(valuePath).assign(that._scope, value);
                                var scopeValue = that._parse(valuePath)(that._scope);
                                if (scopeValue !== value) {
                                    that._component.option(optionPath, scopeValue)
                                }
                            })
                        }, that._scope);
                        if (applyDeferred) {
                            applyDeferred.done(function() {
                                that._ngLocker.release(fullName)
                            })
                        }
                    })
                },
                _compilerByTemplate: function(template) {
                    var that = this,
                        scopeItemsPath = this._getScopeItemsPath();
                    return function(data, index, $container) {
                        var $resultMarkup = $(template).clone(),
                            dataIsScope = data && data.constructor === that._scope.$root.constructor,
                            templateScope = dataIsScope ? data : that._createScopeWithData(data);
                        if (scopeItemsPath) {
                            that._synchronizeScopes(templateScope, scopeItemsPath, index)
                        }
                        $resultMarkup.appendTo($container).on("$destroy", function() {
                            var destroyAlreadyCalled = !templateScope.$parent;
                            if (destroyAlreadyCalled) {
                                return
                            }
                            templateScope.$destroy()
                        });
                        that._applyAsync(that._compile($resultMarkup, that._transcludeFn), templateScope);
                        return $resultMarkup
                    }
                },
                _applyAsync: function(func, scope) {
                    var that = this;
                    func(scope);
                    if (!scope.$root.$$phase) {
                        clearTimeout(that._renderingTimer);
                        that._renderingTimer = setTimeout(function() {
                            scope.$apply()
                        });
                        that._componentDisposing.add(function() {
                            clearTimeout(that._renderingTimer)
                        })
                    }
                },
                _getScopeItemsPath: function() {
                    if (this._componentClass.subclassOf(CollectionWidget) && this._ngOptions.bindingOptions && this._ngOptions.bindingOptions.items) {
                        return this._ngOptions.bindingOptions.items.dataPath
                    }
                },
                _createScopeWithData: function(data) {
                    var newScope = this._scope.$new(),
                        modelIsPrimitive = data && "object" !== typeof data && "function" !== typeof data;
                    newScope[DEFAULT_MODEL_ALIAS] = data;
                    newScope[MODEL_IS_PRIMITIVE_FLAG_NAME] = !!modelIsPrimitive;
                    if (this._itemAlias) {
                        newScope[this._itemAlias] = data
                    }
                    return newScope
                },
                _synchronizeScopes: function(itemScope, parentPrefix, itemIndex) {
                    var that = this,
                        fieldsToSynchronize = [DEFAULT_MODEL_ALIAS];
                    if (that._itemAlias && "object" !== typeof itemScope[that._itemAlias]) {
                        fieldsToSynchronize.push(that._itemAlias)
                    }
                    $.each(fieldsToSynchronize, function(i, fieldPath) {
                        that._synchronizeScopeField({
                            parentScope: that._scope,
                            childScope: itemScope,
                            fieldPath: fieldPath,
                            parentPrefix: parentPrefix,
                            itemIndex: itemIndex
                        })
                    })
                },
                _synchronizeScopeField: function(args) {
                    var parentScope = args.parentScope,
                        childScope = args.childScope,
                        fieldPath = args.fieldPath,
                        parentPrefix = args.parentPrefix,
                        itemIndex = args.itemIndex;
                    var optionOuterPath, innerPathSuffix = fieldPath === (this._itemAlias || DEFAULT_MODEL_ALIAS) ? "" : "." + fieldPath,
                        collectionField = void 0 !== itemIndex,
                        optionOuterBag = [parentPrefix];
                    if (collectionField) {
                        optionOuterBag.push("[", itemIndex, "]")
                    }
                    optionOuterBag.push(innerPathSuffix);
                    optionOuterPath = optionOuterBag.join("");
                    var clearParentWatcher = parentScope.$watch(optionOuterPath, function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            compileSetter(fieldPath)(childScope, newValue)
                        }
                    });
                    var clearItemWatcher = childScope.$watch(fieldPath, function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (collectionField && !compileGetter(parentPrefix)(parentScope)[itemIndex]) {
                                clearItemWatcher();
                                return
                            }
                            compileSetter(optionOuterPath)(parentScope, newValue)
                        }
                    });
                    this._componentDisposing.add([clearParentWatcher, clearItemWatcher])
                },
                _evalOptions: function(scope) {
                    var result = extendFromObject({}, this._ngOptions);
                    delete result.bindingOptions;
                    if (this._ngOptions.bindingOptions) {
                        $.each(this._ngOptions.bindingOptions, function(key, value) {
                            result[key] = scope.$eval(value.dataPath)
                        })
                    }
                    result._optionChangedCallbacks = this._optionChangedCallbacks;
                    result._disposingCallbacks = this._componentDisposing;
                    result.templateProvider = NgTemplateProvider;
                    result.templateCompiler = $.proxy(function($template) {
                        return this._compilerByTemplate($template)
                    }, this);
                    result.onActionCreated = function(component, action, config) {
                        if (config && $.inArray(config.category, SKIP_APPLY_ACTION_CATEGORIES) > -1) {
                            return action
                        }
                        var wrappedAction = function() {
                            var that = this,
                                args = arguments;
                            if (!scope || !scope.$root || scope.$root.$$phase) {
                                return action.apply(that, args)
                            }
                            return safeApply(function() {
                                return action.apply(that, args)
                            }, scope)
                        };
                        return wrappedAction
                    };
                    result.nestedComponentOptions = function(component) {
                        return {
                            templateCompiler: component.option("templateCompiler"),
                            modelByElement: component.option("modelByElement"),
                            onActionCreated: component.option("onActionCreated"),
                            nestedComponentOptions: component.option("nestedComponentOptions")
                        }
                    };
                    result.templatesRenderAsynchronously = true;
                    result.watchMethod = function(watchValue, callback, element) {
                        var disposeWatcher = scope.$watch(watchValue, function(oldValue, newValue) {
                            if (oldValue !== newValue) {
                                disposeWatcher();
                                callback()
                            }
                        }, true);
                        $(element).on(removeEvent, function() {
                            disposeWatcher()
                        })
                    };
                    result.modelByElement = function() {
                        return scope
                    };
                    return result
                }
            });
            ComponentBuilder = ComponentBuilder.inherit({
                ctor: function(options) {
                    this._componentName = options.componentName;
                    this._ngModel = options.ngModel;
                    this._ngModelController = options.ngModelController;
                    this.callBase.apply(this, arguments)
                },
                _isNgModelRequired: function() {
                    return this._componentClass.subclassOf(Editor) && this._ngModel
                },
                _initComponentBindings: function() {
                    this.callBase.apply(this, arguments);
                    this._initNgModelBinding()
                },
                _initNgModelBinding: function() {
                    if (!this._isNgModelRequired()) {
                        return
                    }
                    var that = this;
                    var clearNgModelWatcher = this._scope.$watch(this._ngModel, function(newValue, oldValue) {
                        if (that._ngLocker.locked(that._ngModelOption())) {
                            return
                        }
                        if (newValue === oldValue) {
                            return
                        }
                        that._component.option(that._ngModelOption(), newValue)
                    });
                    that._optionChangedCallbacks.add(function(args) {
                        that._ngLocker.obtain(that._ngModelOption());
                        try {
                            if (args.name !== that._ngModelOption()) {
                                return
                            }
                            that._ngModelController.$setViewValue(args.value)
                        } finally {
                            that._ngLocker.release(that._ngModelOption())
                        }
                    });
                    this._componentDisposing.add(clearNgModelWatcher)
                },
                _ngModelOption: function() {
                    if ($.inArray(this._componentName, ["dxFileUploader", "dxTagBox"]) > -1) {
                        return "values"
                    }
                    return "value"
                },
                _evalOptions: function() {
                    if (!this._isNgModelRequired()) {
                        return this.callBase.apply(this, arguments)
                    }
                    var result = this.callBase.apply(this, arguments);
                    result[this._ngModelOption()] = this._parse(this._ngModel)(this._scope);
                    return result
                }
            });
            var registeredComponents = {};
            var registerComponentDirective = function(name) {
                var priority = "dxValidator" !== name ? 1 : 10;
                ngModule.directive(name, ["$compile", "$parse", "dxDigestCallbacks", function($compile, $parse, dxDigestCallbacks) {
                    return {
                        restrict: "A",
                        require: "^?ngModel",
                        priority: priority,
                        compile: function($element) {
                            var componentClass = registeredComponents[name],
                                $content = componentClass.subclassOf(Widget) ? $element.contents().detach() : null;
                            return function(scope, $element, attrs, ngModelController, transcludeFn) {
                                $element.append($content);
                                safeApply(function() {
                                    new ComponentBuilder({
                                        componentClass: componentClass,
                                        componentName: name,
                                        compile: $compile,
                                        parse: $parse,
                                        $element: $element,
                                        scope: scope,
                                        ngOptionsString: attrs[name],
                                        ngOptions: attrs[name] ? scope.$eval(attrs[name]) : {},
                                        ngModel: attrs.ngModel,
                                        ngModelController: ngModelController,
                                        transcludeFn: transcludeFn,
                                        itemAlias: attrs[ITEM_ALIAS_ATTRIBUTE_NAME],
                                        dxDigestCallbacks: dxDigestCallbacks
                                    })
                                }, scope)
                            }
                        }
                    }
                }])
            };
            registerComponent.callbacks.add(function(name, componentClass) {
                if (!registeredComponents[name]) {
                    registerComponentDirective(name)
                }
                registeredComponents[name] = componentClass
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/integration/angular/components.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                MemorizedCallbacks = __webpack_require__( /*! ../../core/memorized_callbacks */ 140),
                ngModule = __webpack_require__( /*! ./module */ 151),
                iconUtils = __webpack_require__( /*! ../../core/utils/icon */ 77),
                inflector = __webpack_require__( /*! ../../core/utils/inflector */ 29),
                errors = __webpack_require__( /*! ../../core/errors */ 10);
            ngModule.directive("dxIcon", ["$compile", function($compile) {
                return {
                    restrict: "E",
                    link: function($scope, $element, $attrs) {
                        var html = iconUtils.getImageContainer($scope.dxTemplateModel.icon || $scope.dxTemplateModel.iconSrc);
                        if (html) {
                            var e = $compile(html.get(0))($scope);
                            $element.replaceWith(e)
                        }
                    }
                }
            }]);
            ngModule.directive("dxPolymorphWidget", ["$compile", function($compile) {
                return {
                    restrict: "E",
                    scope: {
                        name: "=",
                        options: "="
                    },
                    link: function($scope, $element, $attrs) {
                        var widgetName = $scope.name;
                        if (!widgetName) {
                            return
                        }
                        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                            var depricatedName = widgetName;
                            widgetName = inflector.camelize("dx-" + widgetName);
                            errors.log("W0001", "dxToolbar - 'widget' item field", depricatedName, "16.1", "Use: '" + widgetName + "' instead")
                        }
                        var markup = $("<div " + inflector.dasherize(widgetName) + '="options">').get(0);
                        $element.after(markup);
                        $compile(markup)($scope)
                    }
                }
            }]);
            ngModule.service("dxDigestCallbacks", ["$rootScope", function($rootScope) {
                var begin = new MemorizedCallbacks,
                    end = new MemorizedCallbacks;
                var digestPhase = false;
                $rootScope.$watch(function() {
                    if (digestPhase) {
                        return
                    }
                    digestPhase = true;
                    begin.fire();
                    $rootScope.$$postDigest(function() {
                        digestPhase = false;
                        end.fire()
                    })
                });
                return {
                    begin: begin,
                    end: end
                }
            }])
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/integration/angular/default_templates.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var TEMPLATE_GENERATORS = {};
            var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
            var baseElements = {
                container: function() {
                    return $("<div>").addClass(TEMPLATE_WRAPPER_CLASS)
                },
                html: function() {
                    return $("<div>").attr("ng-if", "dxTemplateModel.html").attr("ng-bind-html", "dxTemplateModel.html")
                },
                text: function(element) {
                    element = element || "<div>";
                    return $(element).attr("ng-if", "dxTemplateModel.text").attr("ng-if", "!dxTemplateModel.html").attr("ng-bind", "dxTemplateModel.text")
                },
                primitive: function() {
                    return $("<div>").attr("ng-if", "dxTemplateModelIsPrimitive").attr("ng-bind", "'' + dxTemplateModel")
                }
            };
            var emptyTemplate = function() {
                return $()
            };
            TEMPLATE_GENERATORS.CollectionWidget = {
                item: function() {
                    return baseElements.container().append(baseElements.html()).append(baseElements.text()).append(baseElements.primitive())
                },
                itemFrame: function() {
                    var $container = $("<div>").attr("ng-class", "{ 'dx-state-invisible': !dxTemplateModel.visible && dxTemplateModel.visible != undefined, 'dx-state-disabled': !!dxTemplateModel.disabled }"),
                        $placeholder = $("<div>").addClass("dx-item-content-placeholder");
                    $container.append($placeholder);
                    return $container
                }
            };
            var BUTTON_TEXT_CLASS = "dx-button-text";
            TEMPLATE_GENERATORS.dxButton = {
                content: function() {
                    var $titleBinding = $("<span>").attr("ng-bind", "dxTemplateModel.text").attr("ng-class", "{ '" + BUTTON_TEXT_CLASS + "' : !!dxTemplateModel.text }"),
                        icon = $("<dx-icon>");
                    return baseElements.container().append(icon).append($titleBinding).append(baseElements.primitive())
                }
            };
            var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
                LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
                BADGE_CLASS = "dx-badge",
                LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
                LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
            TEMPLATE_GENERATORS.dxList = {
                item: function() {
                    return TEMPLATE_GENERATORS.CollectionWidget.item().append($("<div>").attr("ng-if", "dxTemplateModel.key").attr("ng-bind", "dxTemplateModel.key"))
                },
                itemFrame: function() {
                    var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).attr("ng-if", "dxTemplateModel.badge"),
                        $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-bind", "dxTemplateModel.badge");
                    var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS).attr("ng-if", "dxTemplateModel.showChevron"),
                        $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                    return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badgeContainer.append($badge)).append($chevronContainer.append($chevron))
                },
                group: function() {
                    var $keyBinding = $("<div>").attr("ng-if", "dxTemplateModel.key").attr("ng-bind", "dxTemplateModel.key");
                    return baseElements.container().append($keyBinding).append(baseElements.primitive())
                }
            };
            TEMPLATE_GENERATORS.dxDropDownMenu = {
                item: TEMPLATE_GENERATORS.dxList.item,
                content: TEMPLATE_GENERATORS.dxButton.content
            };
            TEMPLATE_GENERATORS.dxDropDownList = {
                item: TEMPLATE_GENERATORS.dxList.item
            };
            TEMPLATE_GENERATORS.dxRadioGroup = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxScheduler = {
                item: function() {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item();
                    var $details = $("<div>").addClass("dx-scheduler-appointment-content-details");
                    $("<div>").attr("ng-if", "dxTemplateModel.allDay").addClass("dx-scheduler-appointment-content-allday").text(" All day: ").appendTo($details);
                    $("<div>").attr("ng-if", "dxTemplateModel.startDate").addClass("dx-scheduler-appointment-content-date").text("{{dxTemplateModel.startDate | date : 'shortTime' }}").appendTo($details);
                    $("<div>").attr("ng-if", "dxTemplateModel.endDate").addClass("dx-scheduler-appointment-content-date").text(" - ").appendTo($details);
                    $("<div>").attr("ng-if", "dxTemplateModel.endDate").addClass("dx-scheduler-appointment-content-date").text("{{dxTemplateModel.endDate | date : 'shortTime' }}").appendTo($details);
                    $details.appendTo($itemContent);
                    $("<span>").attr("ng-if", "dxTemplateModel.recurrenceRule").addClass("dx-scheduler-appointment-recurrence-icon dx-icon-repeat").appendTo($itemContent);
                    return $itemContent
                },
                appointmentTooltip: emptyTemplate,
                appointmentPopup: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxOverlay = {
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOutView = {
                menu: emptyTemplate,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOut = {
                menuItem: TEMPLATE_GENERATORS.dxList.item,
                menuGroup: TEMPLATE_GENERATORS.dxList.group,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxAccordion = {
                title: function() {
                    var $titleBinding = $("<span>").attr("ng-if", "dxTemplateModel.title").attr("ng-bind", "dxTemplateModel.title"),
                        icon = $("<dx-icon>");
                    return baseElements.container().append(icon).append($titleBinding).append(baseElements.primitive())
                },
                content: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxPivotTabs = {
                item: function() {
                    return baseElements.container().append($("<span>").attr("ng-if", "dxTemplateModel.title").attr("ng-bind", "dxTemplateModel.title")).append(baseElements.primitive())
                }
            };
            TEMPLATE_GENERATORS.dxPivot = {
                title: TEMPLATE_GENERATORS.dxPivotTabs.item,
                content: emptyTemplate
            };
            var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
            TEMPLATE_GENERATORS.dxPanorama = {
                itemFrame: function() {
                    return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().prepend($("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).attr("ng-if", "dxTemplateModel.title").attr("ng-bind", "dxTemplateModel.title"))
                }
            };
            TEMPLATE_GENERATORS.dxActionSheet = {
                item: function() {
                    return baseElements.container().append($("<div>").attr("dx-button", "{ bindingOptions: { text: 'dxTemplateModel.text', onClick: 'dxTemplateModel.onClick', type: 'dxTemplateModel.type', disabled: 'dxTemplateModel.disabled' } }"))
                }
            };
            TEMPLATE_GENERATORS.dxToolbarBase = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                    $('<dx-polymorph-widget name="dxTemplateModel.widget" options="dxTemplateModel.options">').appendTo(template);
                    return template
                },
                actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
            };
            TEMPLATE_GENERATORS.dxToolbarBase.menuItem = TEMPLATE_GENERATORS.dxToolbarBase.item;
            var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
            TEMPLATE_GENERATORS.dxGallery = {
                item: function() {
                    return baseElements.container().append(baseElements.html()).append(baseElements.text()).append($("<img>").addClass(GALLERY_IMAGE_CLASS).attr("ng-if", "!dxTemplateModel.imageSrc").attr("ng-src", "{{'' + dxTemplateModel}}")).append($("<img>").addClass(GALLERY_IMAGE_CLASS).attr("ng-if", "dxTemplateModel.imageSrc").attr("ng-src", "{{dxTemplateModel.imageSrc}}").attr("ng-attr-alt", "{{dxTemplateModel.imageAlt}}"))
                }
            };
            var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
            TEMPLATE_GENERATORS.dxTabs = {
                item: function() {
                    var container = baseElements.container();
                    var icon = $("<dx-icon>"),
                        text = baseElements.text("<span>").addClass(TABS_ITEM_TEXT_CLASS);
                    return container.append(baseElements.html()).append(icon).append(text).append(baseElements.primitive().addClass(TABS_ITEM_TEXT_CLASS))
                },
                itemFrame: function() {
                    var $badge = $("<div>").addClass("dx-tabs-item-badge dx-badge").attr("ng-bind", "dxTemplateModel.badge").attr("ng-if", "dxTemplateModel.badge");
                    return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badge)
                }
            };
            var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
            TEMPLATE_GENERATORS.dxNavBar = {
                itemFrame: function() {
                    var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-if", "dxTemplateModel.badge").attr("ng-bind", "dxTemplateModel.badge");
                    return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badge)
                }
            };
            TEMPLATE_GENERATORS.dxMenuBase = {
                item: function() {
                    var container = baseElements.container();
                    var text = $("<span>").attr("ng-if", "dxTemplateModel.text").addClass("dx-menu-item-text").attr("ng-bind", "dxTemplateModel.text"),
                        icon = $("<dx-icon>"),
                        popout = $("<span>").addClass("dx-menu-item-popout-container").attr("ng-if", "dxTemplateModel.items").append($("<div>").addClass("dx-menu-item-popout"));
                    container.append(baseElements.html()).append(icon).append(text).append(popout).append(baseElements.primitive()).appendTo(container);
                    return container
                }
            };
            TEMPLATE_GENERATORS.dxTreeView = {
                item: function() {
                    var content = baseElements.container(),
                        link = $("<span/>").attr("ng-bind", "dxTemplateModel.text"),
                        icon = $("<dx-icon>");
                    content.append(baseElements.html()).append(icon).append(link).append(baseElements.primitive());
                    return content
                }
            };
            TEMPLATE_GENERATORS.dxTabPanel = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item,
                title: function() {
                    var content = TEMPLATE_GENERATORS.dxTabs.item();
                    content.find(".dx-tab-text").eq(0).attr("ng-bind", "dxTemplateModel.title").attr("ng-if", "dxTemplateModel.title");
                    content.find("[ng-if='dxTemplateModel.html']").remove();
                    return content
                }
            };
            var popupTitleAndBottom = function() {
                return $("<div>").attr("dx-toolbar-base", "{ bindingOptions: { items: 'dxTemplateModel' } }")
            };
            TEMPLATE_GENERATORS.dxPopup = {
                title: popupTitleAndBottom,
                bottom: popupTitleAndBottom
            };
            TEMPLATE_GENERATORS.dxLookup = {
                title: TEMPLATE_GENERATORS.dxPopup.title,
                group: TEMPLATE_GENERATORS.dxList.group
            };
            var TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
                TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button";
            TEMPLATE_GENERATORS.dxTagBox = {
                tag: function() {
                    return $("<div>").addClass(TAGBOX_TAG_CONTENT_CLASS).append($("<span>").attr("ng-bind", "dxTemplateModel")).append($("<div>").addClass(TAGBOX_TAG_REMOVE_BUTTON_CLASS))
                }
            };
            module.exports = TEMPLATE_GENERATORS
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/integration/angular/event_registrator.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                eventRegistrator = __webpack_require__( /*! ../../events/core/event_registrator */ 43),
                ngModule = __webpack_require__( /*! ./module */ 151);
            eventRegistrator.callbacks.add(function(name, eventObject) {
                var ngEventName = name.slice(0, 2) + name.charAt(2).toUpperCase() + name.slice(3);
                ngModule.directive(ngEventName, ["$parse", function($parse) {
                    return function(scope, element, attr) {
                        var handler, attrValue = $.trim(attr[ngEventName]),
                            eventOptions = {};
                        if ("{" === attrValue.charAt(0)) {
                            eventOptions = scope.$eval(attrValue);
                            handler = $parse(eventOptions.execute)
                        } else {
                            handler = $parse(attr[ngEventName])
                        }
                        element.on(name, eventOptions, function(e) {
                            scope.$apply(function() {
                                handler(scope, {
                                    $event: e
                                })
                            })
                        })
                    }
                }])
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/integration/angular/template.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                TemplateBase = __webpack_require__( /*! ../../ui/widget/ui.template_base */ 47),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
            var NgTemplate = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this.setCompiler(this._getParentTemplateCompiler())
                },
                _getParentTemplateCompiler: function() {
                    var templateCompiler = null,
                        owner = this.owner();
                    while (!templateCompiler && owner) {
                        templateCompiler = $.isFunction(owner.option) ? owner.option("templateCompiler") : null;
                        owner = $.isFunction(owner.owner) ? owner.owner() : null
                    }
                    return templateCompiler
                },
                _renderCore: function(data, index, $container) {
                    var compiledTemplate = this._compiledTemplate,
                        result = $.isFunction(compiledTemplate) ? compiledTemplate(data, index, $container) : compiledTemplate;
                    return result
                },
                setCompiler: function(templateCompiler) {
                    if (!templateCompiler) {
                        return
                    }
                    this._compiledTemplate = templateCompiler(domUtils.normalizeTemplateElement(this._element))
                }
            });
            module.exports = NgTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/integration/angular/template_provider.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                templateProvider = __webpack_require__( /*! ../../ui/widget/jquery.template_provider */ 160),
                NgTemplate = __webpack_require__( /*! ./template */ 285),
                defaultTemplates = __webpack_require__( /*! ./default_templates */ 283);
            var NgTemplateProvider = templateProvider.constructor.inherit({
                createTemplate: function(element, owner) {
                    return new NgTemplate(element, owner)
                },
                getTemplates: function(widget) {
                    var templateCompiler = widget.option("templateCompiler"),
                        templates = this.callBase.apply(this, arguments);
                    $.each(templates, function(_, template) {
                        template.setCompiler && template.setCompiler(templateCompiler)
                    });
                    return templates
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName];
                    if (!templateGenerators) {
                        return this.callBase(widgetName)
                    }
                    var templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        var $markup = domUtils.createMarkupFromString(generator());
                        templates[name] = new NgTemplate($markup.wrap(), ngTemplateProvider)
                    });
                    return templates
                }
            });
            var ngTemplateProvider = new NgTemplateProvider;
            module.exports = ngTemplateProvider
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/integration/knockout/clean_node.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                cleanData = $.cleanData,
                compareVersion = __webpack_require__( /*! ../../core/utils/version */ 56).compare;
            if (compareVersion($.fn.jquery, [2, 0]) < 0) {
                return
            }
            $.cleanData = function(nodes) {
                var result = cleanData(nodes);
                for (var i = 0; i < nodes.length; i++) {
                    nodes[i].cleanedByJquery = true
                }
                for (i = 0; i < nodes.length; i++) {
                    if (!nodes[i].cleanedByKo) {
                        ko.cleanNode(nodes[i])
                    }
                    delete nodes[i].cleanedByKo
                }
                for (i = 0; i < nodes.length; i++) {
                    delete nodes[i].cleanedByJquery
                }
                return result
            };
            ko.utils.domNodeDisposal.cleanExternalData = function(node) {
                node.cleanedByKo = true;
                if (!node.cleanedByJquery) {
                    $.cleanData([node])
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/integration/knockout/clean_node_old.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                compareVersion = __webpack_require__( /*! ../../core/utils/version */ 56).compare;
            if (compareVersion($.fn.jquery, [2, 0]) >= 0) {
                return
            }
            var cleanKoData = function(element, andSelf) {
                var cleanNode = function() {
                    ko.cleanNode(this)
                };
                if (andSelf) {
                    element.each(cleanNode)
                } else {
                    element.find("*").each(cleanNode)
                }
            };
            var originalEmpty = $.fn.empty;
            $.fn.empty = function() {
                cleanKoData(this, false);
                return originalEmpty.apply(this, arguments)
            };
            var originalRemove = $.fn.remove;
            $.fn.remove = function(selector, keepData) {
                if (!keepData) {
                    var subject = this;
                    if (selector) {
                        subject = subject.filter(selector)
                    }
                    cleanKoData(subject, true)
                }
                return originalRemove.call(this, selector, keepData)
            };
            var originalHtml = $.fn.html;
            $.fn.html = function(value) {
                if ("string" === typeof value) {
                    cleanKoData(this, false)
                }
                return originalHtml.apply(this, arguments)
            };
            var originalReplaceWith = $.fn.replaceWith;
            $.fn.replaceWith = function(value) {
                var result = originalReplaceWith.apply(this, arguments);
                if (!this.parent().length) {
                    cleanKoData(this, true)
                }
                return result
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************************!*\
      !*** ./Scripts/integration/knockout/component_registrator.js ***!
      \***************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                Widget = __webpack_require__( /*! ../../ui/widget/ui.widget */ 19),
                KoTemplateProvider = __webpack_require__( /*! ./template_provider */ 216),
                Editor = __webpack_require__( /*! ../../ui/editor/editor */ 31),
                Locker = __webpack_require__( /*! ../../core/utils/locker */ 200);
            var LOCKS_DATA_KEY = "dxKoLocks",
                CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
            var editorsBindingHandlers = [];
            var registerComponentKoBinding = function(componentName, componentClass) {
                if (componentClass.subclassOf(Editor)) {
                    editorsBindingHandlers.push(componentName)
                }
                ko.bindingHandlers[componentName] = {
                    init: function(domNode, valueAccessor) {
                        var $element = $(domNode),
                            optionChangedCallbacks = $.Callbacks(),
                            ctorOptions = {
                                templateProvider: KoTemplateProvider,
                                modelByElement: function($element) {
                                    if ($element.length) {
                                        return ko.dataFor($element.get(0))
                                    }
                                },
                                nestedComponentOptions: function(component) {
                                    return {
                                        modelByElement: component.option("modelByElement"),
                                        nestedComponentOptions: component.option("nestedComponentOptions")
                                    }
                                },
                                watchMethod: function(watchValue, callback, element) {
                                    var values;
                                    ko.computed(function() {
                                        if (values) {
                                            callback()
                                        }
                                        values = watchValue()
                                    }, null, {
                                        disposeWhenNodeIsRemoved: element
                                    })
                                },
                                _optionChangedCallbacks: optionChangedCallbacks
                            },
                            optionNameToModelMap = {};
                        var applyModelValueToOption = function(optionName, modelValue) {
                            var component = $element.data(componentName),
                                locks = $element.data(LOCKS_DATA_KEY),
                                optionValue = ko.unwrap(modelValue);
                            if (ko.isWriteableObservable(modelValue)) {
                                optionNameToModelMap[optionName] = modelValue
                            }
                            if (component) {
                                if (locks.locked(optionName)) {
                                    return
                                }
                                locks.obtain(optionName);
                                try {
                                    if (ko.ignoreDependencies) {
                                        ko.ignoreDependencies(component.option, component, [optionName, optionValue])
                                    } else {
                                        component.option(optionName, optionValue)
                                    }
                                } finally {
                                    locks.release(optionName)
                                }
                            } else {
                                ctorOptions[optionName] = optionValue
                            }
                        };
                        var handleOptionChanged = function(args) {
                            var optionName = args.fullName,
                                optionValue = args.value;
                            if (!(optionName in optionNameToModelMap)) {
                                return
                            }
                            var $element = this._$element,
                                locks = $element.data(LOCKS_DATA_KEY);
                            if (locks.locked(optionName)) {
                                return
                            }
                            locks.obtain(optionName);
                            try {
                                optionNameToModelMap[optionName](optionValue)
                            } finally {
                                locks.release(optionName)
                            }
                        };
                        var createComponent = function() {
                            optionChangedCallbacks.add(handleOptionChanged);
                            $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new Locker)[componentName](ctorOptions);
                            ctorOptions = null
                        };
                        var unwrapModelValue = function(currentModel, propertyName, propertyPath) {
                            var unwrappedPropertyValue;
                            ko.computed(function() {
                                var propertyValue = currentModel[propertyName];
                                applyModelValueToOption(propertyPath, propertyValue);
                                unwrappedPropertyValue = ko.unwrap(propertyValue)
                            }, null, {
                                disposeWhenNodeIsRemoved: domNode
                            });
                            if ($.isPlainObject(unwrappedPropertyValue)) {
                                unwrapModel(unwrappedPropertyValue, propertyPath)
                            }
                        };
                        var unwrapModel = function(model, propertyPath) {
                            for (var propertyName in model) {
                                if (model.hasOwnProperty(propertyName)) {
                                    unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join(".") : propertyName)
                                }
                            }
                        };
                        ko.computed(function() {
                            var component = $element.data(componentName),
                                model = ko.unwrap(valueAccessor());
                            if (component) {
                                component.beginUpdate()
                            }
                            unwrapModel(model);
                            if (component) {
                                component.endUpdate()
                            } else {
                                createComponent()
                            }
                        }, null, {
                            disposeWhenNodeIsRemoved: domNode
                        });
                        return {
                            controlsDescendantBindings: componentClass.subclassOf(Widget)
                        }
                    }
                };
                if ("dxValidator" === componentName) {
                    ko.bindingHandlers.dxValidator.after = editorsBindingHandlers
                }
            };
            registerComponent.callbacks.add(function(name, componentClass) {
                registerComponentKoBinding(name, componentClass)
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/integration/knockout/components.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../../core/errors */ 10),
                Action = __webpack_require__( /*! ../../core/action */ 54),
                compileGetter = __webpack_require__( /*! ../../core/utils/data */ 16).compileGetter,
                ko = __webpack_require__( /*! knockout */ 40),
                iconUtils = __webpack_require__( /*! ../../core/utils/icon */ 77),
                inflector = __webpack_require__( /*! ../../core/utils/inflector */ 29),
                clickEvent = __webpack_require__( /*! ../../events/click */ 9),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                dateLocalization = __webpack_require__( /*! ../../localization/date */ 14);
            ko.bindingHandlers.dxAction = {
                update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                    var $element = $(element);
                    var unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                        actionSource = unwrappedValue,
                        actionOptions = {
                            context: element
                        };
                    if (unwrappedValue.execute) {
                        actionSource = unwrappedValue.execute;
                        $.extend(actionOptions, unwrappedValue)
                    }
                    var action = new Action(actionSource, actionOptions);
                    $element.off(".dxActionBinding").on(clickEvent.name + ".dxActionBinding", function(e) {
                        action.execute({
                            element: $element,
                            model: viewModel,
                            evaluate: function(expression) {
                                var context = viewModel;
                                if (expression.length > 0 && "$" === expression[0]) {
                                    context = ko.contextFor(element)
                                }
                                var getter = compileGetter(expression);
                                return getter(context)
                            },
                            jQueryEvent: e
                        });
                        if (!actionOptions.bubbling) {
                            e.stopPropagation()
                        }
                    })
                }
            };
            ko.bindingHandlers.dxControlsDescendantBindings = {
                init: function(_, valueAccessor) {
                    return {
                        controlsDescendantBindings: ko.unwrap(valueAccessor())
                    }
                }
            };
            ko.bindingHandlers.dxPolymorphWidget = {
                init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                    var widgetName = ko.utils.unwrapObservable(valueAccessor()).name;
                    if (!widgetName) {
                        return
                    }
                    ko.virtualElements.emptyNode(element);
                    if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                        var depricatedName = widgetName;
                        widgetName = inflector.camelize("dx-" + widgetName);
                        errors.log("W0001", "dxToolbar - 'widget' item field", depricatedName, "16.1", "Use: '" + widgetName + "' instead")
                    }
                    var markup = $('<div data-bind="' + widgetName + ': options">').get(0);
                    ko.virtualElements.prepend(element, markup);
                    var innerBindingContext = bindingContext.extend(valueAccessor);
                    ko.applyBindingsToDescendants(innerBindingContext, element);
                    return {
                        controlsDescendantBindings: true
                    }
                }
            };
            ko.virtualElements.allowedBindings.dxPolymorphWidget = true;
            ko.bindingHandlers.dxIcon = {
                init: function(element, valueAccessor) {
                    var options = ko.utils.unwrapObservable(valueAccessor()) || {},
                        iconElement = iconUtils.getImageContainer(options);
                    ko.virtualElements.emptyNode(element);
                    if (iconElement) {
                        ko.virtualElements.prepend(element, iconElement.get(0))
                    }
                },
                update: function(element, valueAccessor) {
                    var options = ko.utils.unwrapObservable(valueAccessor()) || {},
                        iconElement = iconUtils.getImageContainer(options);
                    ko.virtualElements.emptyNode(element);
                    if (iconElement) {
                        ko.virtualElements.prepend(element, iconElement.get(0))
                    }
                }
            };
            ko.virtualElements.allowedBindings.dxIcon = true;
            ko.bindingHandlers.dxShorttimeDate = {
                update: function(element, valueAccessor, allBindingsAccessor) {
                    return ko.bindingHandlers.text.update(element, function() {
                        var value = ko.utils.unwrapObservable(valueAccessor());
                        return dateUtils.serializeDate(dateUtils.makeDate(value), "shorttime", $.proxy(dateLocalization.format, dateLocalization))
                    }, allBindingsAccessor, null, null)
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************************!*\
      !*** ./Scripts/integration/knockout/default_templates.js ***!
      \***********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var TEMPLATE_GENERATORS = {};
            var createElementWithBindAttr = function(tagName, bindings, closeTag, additionalProperties) {
                closeTag = void 0 === closeTag ? true : closeTag;
                var bindAttr = $.map(bindings, function(value, key) {
                    return key + ":" + value
                }).join(",");
                additionalProperties = additionalProperties || "";
                return "<" + tagName + ' data-bind="' + bindAttr + '" ' + additionalProperties + ">" + (closeTag ? "</" + tagName + ">" : "")
            };
            var defaultKoTemplateBasicBindings = {
                css: "{ 'dx-state-disabled': $data.disabled, 'dx-state-invisible': !($data.visible === undefined || ko.unwrap($data.visible)) }"
            };
            var emptyTemplate = function() {
                return ""
            };
            TEMPLATE_GENERATORS.CollectionWidget = {
                itemFrame: function() {
                    var markup = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false), "<div class='dx-item-content-placeholder'></div>", "</div>"];
                    return markup.join("")
                },
                item: function() {
                    var htmlBinding = createElementWithBindAttr("div", {
                            html: "html"
                        }),
                        textBinding = createElementWithBindAttr("div", {
                            text: "text"
                        }),
                        primitiveBinding = createElementWithBindAttr("div", {
                            text: "String($data)"
                        });
                    var markup = ["<div>", "<!-- ko if: $data.html -->", htmlBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: jQuery.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                    return markup.join("")
                }
            };
            var BUTTON_TEXT_CLASS = "dx-button-text";
            TEMPLATE_GENERATORS.dxButton = {
                content: function() {
                    var textBinding = createElementWithBindAttr("span", {
                        text: "$data.text",
                        css: "{ '" + BUTTON_TEXT_CLASS + "' : !!$data.text }"
                    });
                    var markup = ["<div>", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", textBinding, "</div>"];
                    return markup.join("")
                }
            };
            var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
                LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
                BADGE_CLASS = "dx-badge",
                LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
                LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
            TEMPLATE_GENERATORS.dxList = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                        keyBinding = createElementWithBindAttr("div", {
                            text: "key"
                        });
                    template = [template.substring(0, template.length - 6), "<!-- ko if: $data.key -->" + keyBinding + "<!-- /ko -->", "</div>"];
                    return template.join("")
                },
                itemFrame: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                        badgeBinding = createElementWithBindAttr("div", {
                            text: "badge"
                        }, true, 'class="' + LIST_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                    var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", '<div class="' + LIST_ITEM_BADGE_CONTAINER_CLASS + '">', badgeBinding, "</div>", "<!-- /ko -->", "<!-- ko if: $data.showChevron -->", '<div class="' + LIST_ITEM_CHEVRON_CONTAINER_CLASS + '">', '<div class="' + LIST_ITEM_CHEVRON_CLASS + '"></div>', "</div>", "<!-- /ko -->", "</div>"];
                    return markup.join("")
                },
                group: function() {
                    var keyBinding = createElementWithBindAttr("div", {
                            text: "key"
                        }),
                        primitiveBinding = createElementWithBindAttr("div", {
                            text: "String($data)"
                        });
                    var markup = ["<div>", "<!-- ko if: $data.key -->", keyBinding, "<!-- /ko -->", "<!-- ko ifnot: jQuery.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                    return markup.join("")
                }
            };
            TEMPLATE_GENERATORS.dxDropDownMenu = {
                item: TEMPLATE_GENERATORS.dxList.item,
                content: TEMPLATE_GENERATORS.dxButton.content
            };
            TEMPLATE_GENERATORS.dxDropDownList = {
                item: TEMPLATE_GENERATORS.dxList.item
            };
            TEMPLATE_GENERATORS.dxRadioGroup = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxScheduler = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                        startDateBinding = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {
                            dxShorttimeDate: "$data.startDate"
                        }),
                        endDateBinding = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {
                            dxShorttimeDate: "$data.endDate"
                        }),
                        allDayBinding = createElementWithBindAttr("div class='dx-scheduler-appointment-content-allday'", {
                            text: "' All day: '"
                        }),
                        dash = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {
                            text: "' - '"
                        });
                    template = [template.substring(0, template.length - 6), "<div class='dx-scheduler-appointment-content-details'>", "<!-- ko if: $data.allDay -->" + allDayBinding + "<!-- /ko -->", "<!-- ko if: $data.startDate -->" + startDateBinding + "<!-- /ko -->", "<!-- ko if: $data.endDate -->" + dash + "<!-- /ko -->", "<!-- ko if: $data.endDate -->" + endDateBinding + "<!-- /ko -->", "</div>", "<!-- ko if: $data.recurrenceRule --><span class='dx-scheduler-appointment-recurrence-icon dx-icon-repeat'></span><!-- /ko -->", "</div>"];
                    return template.join("")
                },
                appointmentTooltip: emptyTemplate,
                appointmentPopup: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxOverlay = {
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOutView = {
                menu: emptyTemplate,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOut = {
                menuItem: TEMPLATE_GENERATORS.dxList.item,
                menuGroup: TEMPLATE_GENERATORS.dxList.group,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxAccordion = {
                title: function() {
                    var titleBinding = createElementWithBindAttr("span", {
                        text: "jQuery.isPlainObject($data) ? $data.title : String($data)"
                    });
                    var markup = ["<div>", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", titleBinding, "</div>"];
                    return markup.join("")
                },
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxResponsiveBox = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            }, TEMPLATE_GENERATORS.dxPivotTabs = {
                item: function() {
                    var titleBinding = createElementWithBindAttr("span", {
                            text: "title"
                        }),
                        primitiveBinding = createElementWithBindAttr("div", {
                            text: "String($data)"
                        });
                    var markup = ["<div>", "<!-- ko if: $data.title -->", titleBinding, "<!-- /ko -->", "<!-- ko ifnot: $data.title || jQuery.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                    return markup.join("")
                }
            };
            TEMPLATE_GENERATORS.dxPivot = {
                title: TEMPLATE_GENERATORS.dxPivotTabs.item,
                content: emptyTemplate
            };
            var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
            TEMPLATE_GENERATORS.dxPanorama = {
                itemFrame: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                        headerBinding = createElementWithBindAttr("div", {
                            text: "title"
                        }, true, 'class="' + PANORAMA_ITEM_TITLE_CLASS + '"');
                    var divInnerStart = template.indexOf(">") + 1;
                    template = [template.substring(0, divInnerStart), "<!-- ko if: $data.title -->", headerBinding, "<!-- /ko -->", template.substring(divInnerStart, template.length)];
                    return template.join("")
                }
            };
            TEMPLATE_GENERATORS.dxActionSheet = {
                item: function() {
                    return ["<div>", createElementWithBindAttr("div", {
                        dxButton: "{ text: $data.text, onClick: $data.clickAction || $data.onClick, type: $data.type, disabled: !!ko.unwrap($data.disabled) }"
                    }), "</div>"].join("")
                }
            };
            TEMPLATE_GENERATORS.dxToolbarBase = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                    template = [template.substring(0, template.length - 6), "<!-- ko if: $data.widget -->"];
                    template.push("<!-- ko dxPolymorphWidget: { name: $data.widget, options: $data.options } --><!-- /ko -->");
                    template.push("<!-- /ko -->");
                    return template.join("")
                },
                actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
            };
            TEMPLATE_GENERATORS.dxToolbarBase.menuItem = TEMPLATE_GENERATORS.dxToolbarBase.item;
            var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
            TEMPLATE_GENERATORS.dxGallery = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                        primitiveBinding = createElementWithBindAttr("div", {
                            text: "String($data)"
                        }),
                        imgBinding = createElementWithBindAttr("img", {
                            attr: "{ src: String($data) }"
                        }, false, 'class="' + GALLERY_IMAGE_CLASS + '"');
                    template = [template.substring(0, template.length - 6).replace(primitiveBinding, imgBinding), "<!-- ko if: $data.imageSrc -->", createElementWithBindAttr("img", {
                        attr: "{ src: $data.imageSrc, alt: $data.imageAlt }"
                    }, false, 'class="' + GALLERY_IMAGE_CLASS + '"'), "<!-- /ko -->"].join("");
                    return template
                }
            };
            TEMPLATE_GENERATORS.dxTabs = {
                item: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                        basePrimitiveBinding = createElementWithBindAttr("div", {
                            text: "String($data)"
                        }),
                        primitiveBinding = '<span class="dx-tab-text" data-bind="text: String($data)"></span>',
                        baseTextBinding = createElementWithBindAttr("div", {
                            text: "text"
                        }),
                        textBinding = '<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko --><span class="dx-tab-text" data-bind="text: $data.text"></span>';
                    template = template.replace("<!-- ko if: !$data.html && $data.text -->", "<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(basePrimitiveBinding, primitiveBinding).replace(baseTextBinding, textBinding);
                    return template
                },
                itemFrame: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                        badgeBinding = createElementWithBindAttr("div", {
                            attr: "{ 'class': 'dx-tabs-item-badge dx-badge' }",
                            text: "badge"
                        });
                    var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", badgeBinding, "<!-- /ko -->", "</div>"];
                    return markup.join("")
                }
            };
            TEMPLATE_GENERATORS.dxTabPanel = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item,
                title: function() {
                    var template = TEMPLATE_GENERATORS.dxTabs.item(),
                        htmlBinding = "<!-- ko if: $data.html -->" + createElementWithBindAttr("div", {
                            html: "html"
                        }) + "<!-- /ko -->";
                    return template.replace(/\$data\.text/g, "$data.title").replace(/\!\$data\.html\ \&\&\ /, "").replace(htmlBinding, "")
                }
            };
            var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
            TEMPLATE_GENERATORS.dxNavBar = {
                itemFrame: function() {
                    var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                        badgeBinding = createElementWithBindAttr("div", {
                            text: "badge"
                        }, true, 'class="' + NAVBAR_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                    var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", badgeBinding, "<!-- /ko -->", "</div>"];
                    return markup.join("")
                }
            };
            TEMPLATE_GENERATORS.dxMenuBase = {
                item: function() {
                    var template = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                        textBinding = createElementWithBindAttr("span", {
                            text: "text",
                            css: "{ 'dx-menu-item-text': true }"
                        }),
                        primitiveBinding = createElementWithBindAttr("span", {
                            text: "String($data)",
                            css: "{ 'dx-menu-item-text': true }"
                        }),
                        popout = "<span class='dx-menu-item-popout-container'><div class='dx-menu-item-popout'></div></span>";
                    template.push("<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", "<!-- ko if: $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: jQuery.isPlainObject($data) || $data.text -->", primitiveBinding, "<!-- /ko -->", "<!-- ko if: $data.items -->", popout, "<!-- /ko -->", "</div>");
                    return template.join("")
                }
            };
            TEMPLATE_GENERATORS.dxTreeView = {
                item: function() {
                    var node = [],
                        link = createElementWithBindAttr("span", {
                            text: "text"
                        }, true),
                        htmlBinding = createElementWithBindAttr("div", {
                            html: "html"
                        });
                    node.push("<div>", "<!-- ko if: $data.html && !$data.text -->", htmlBinding, "<!-- /ko -->", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->" + link + "<!-- /ko -->", "</div>");
                    return node.join("")
                }
            };
            var popupTitleAndBottom = function() {
                return ["<div>", createElementWithBindAttr("div", {
                    dxToolbarBase: "{ items: $data }"
                }), "</div>"].join("")
            };
            TEMPLATE_GENERATORS.dxPopup = {
                title: popupTitleAndBottom,
                bottom: popupTitleAndBottom
            };
            TEMPLATE_GENERATORS.dxLookup = {
                title: TEMPLATE_GENERATORS.dxPopup.title,
                group: TEMPLATE_GENERATORS.dxList.group
            };
            var TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
                TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button";
            TEMPLATE_GENERATORS.dxTagBox = {
                tag: function() {
                    return ["<div>", "<div class=" + TAGBOX_TAG_CONTENT_CLASS + ">", createElementWithBindAttr("span", {
                        text: "$data"
                    }), "<div class=" + TAGBOX_TAG_REMOVE_BUTTON_CLASS + "></div>", "</div>", "</div>"].join("")
                }
            };
            module.exports = TEMPLATE_GENERATORS
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************************!*\
      !*** ./Scripts/integration/knockout/event_registrator.js ***!
      \***********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                eventRegistrator = __webpack_require__( /*! ../../events/core/event_registrator */ 43),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4);
            eventRegistrator.callbacks.add(function(name, eventObject) {
                var koBindingEventName = eventUtils.addNamespace(name, name + "Binding");
                ko.bindingHandlers[name] = {
                    update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                        var $element = $(element),
                            unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                            eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
                        $element.off(koBindingEventName).on(koBindingEventName, $.isPlainObject(unwrappedValue) ? unwrappedValue : {}, function(e) {
                            eventSource.call(viewModel, viewModel, e)
                        })
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/integration/knockout/template.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                ko = __webpack_require__( /*! knockout */ 40),
                TemplateBase = __webpack_require__( /*! ../../ui/widget/ui.template_base */ 47),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11);
            var KoTemplate = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this._template = $("<div>").append(domUtils.normalizeTemplateElement(element));
                    this._registerKoTemplate()
                },
                _registerKoTemplate: function() {
                    var template = this._template.get(0);
                    new ko.templateSources.anonymousTemplate(template).nodes(template)
                },
                _prepareDataForContainer: function(data, container) {
                    var containerElement, containerContext, result = data;
                    if (container.length) {
                        containerElement = container.get(0);
                        data = void 0 !== data ? data : ko.dataFor(containerElement) || {};
                        containerContext = ko.contextFor(containerElement);
                        if (containerContext) {
                            result = data === containerContext.$data ? containerContext : containerContext.createChildContext(data)
                        } else {
                            result = data
                        }
                    }
                    return result
                },
                _renderCore: function(data, index, $container) {
                    var $placeholder = $("<div>").appendTo($container);
                    var $result;
                    ko.renderTemplate(this._template.get(0), data, {
                        afterRender: function(nodes) {
                            $result = $(nodes)
                        }
                    }, $placeholder.get(0), "replaceNode");
                    return $result
                },
                dispose: function() {
                    this.callBase();
                    this._template.remove()
                }
            });
            module.exports = KoTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/integration/knockout/validation.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                EventsMixin = __webpack_require__( /*! ../../core/events_mixin */ 32),
                ValidationEngine = __webpack_require__( /*! ../../ui/validation_engine */ 64),
                ko = __webpack_require__( /*! knockout */ 40);
            var koDxValidator = Class.inherit({
                ctor: function(target, option) {
                    var that = this;
                    that.target = target;
                    that.validationRules = option.validationRules;
                    that.name = option.name;
                    that.isValid = ko.observable(true);
                    that.validationError = ko.observable();
                    $.each(this.validationRules, function(_, rule) {
                        rule.validator = that
                    })
                },
                validate: function() {
                    var result = ValidationEngine.validate(this.target(), this.validationRules, this.name);
                    this._applyValidationResult(result);
                    return result
                },
                reset: function() {
                    this.target(null);
                    var result = {
                        isValid: true,
                        brokenRule: null
                    };
                    this._applyValidationResult(result);
                    return result
                },
                _applyValidationResult: function(result) {
                    result.validator = this;
                    this.target.dxValidator.isValid(result.isValid);
                    this.target.dxValidator.validationError(result.brokenRule);
                    this.fireEvent("validated", [result])
                }
            }).include(EventsMixin);
            ko.extenders.dxValidator = function(target, option) {
                target.dxValidator = new koDxValidator(target, option);
                target.subscribe($.proxy(target.dxValidator.validate, target.dxValidator));
                return target
            };
            ValidationEngine.registerModelForValidation = function(model) {
                $.each(model, function(name, member) {
                    if (ko.isObservable(member) && member.dxValidator) {
                        ValidationEngine.registerValidatorInGroup(model, member.dxValidator)
                    }
                })
            };
            ValidationEngine.unregisterModelForValidation = function(model) {
                $.each(model, function(name, member) {
                    if (ko.isObservable(member) && member.dxValidator) {
                        ValidationEngine.removeRegisteredValidator(model, member.dxValidator)
                    }
                })
            };
            ValidationEngine.validateModel = ValidationEngine.validateGroup
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************************!*\
      !*** ./Scripts/integration/knockout/variable_wrapper_utils.js ***!
      \****************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var ko = __webpack_require__( /*! knockout */ 40),
                variableWrapper = __webpack_require__( /*! ../../core/utils/variable_wrapper */ 73);
            variableWrapper.inject({
                isWrapped: ko.isObservable,
                isWritableWrapped: ko.isWritableObservable,
                wrap: ko.observable,
                unwrap: function(value) {
                    if (ko.isObservable(value)) {
                        return ko.utils.unwrapObservable(value)
                    }
                    return this.callBase(value)
                },
                assign: function(variable, value) {
                    if (ko.isObservable(variable)) {
                        variable(value)
                    } else {
                        this.callBase(variable, value)
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/localization/en/core.en.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = {
                en: {
                    Yes: "Yes",
                    No: "No",
                    Cancel: "Cancel",
                    Clear: "Clear",
                    Done: "Done",
                    Loading: "Loading...",
                    Select: "Select...",
                    Search: "Search",
                    Back: "Back",
                    OK: "OK",
                    "dxCollectionWidget-noDataText": "No data to display",
                    "validation-required": "Required",
                    "validation-required-formatted": "{0} is required",
                    "validation-numeric": "Value must be a number",
                    "validation-numeric-formatted": "{0} must be a number",
                    "validation-range": "Value is out of range",
                    "validation-range-formatted": "{0} is out of range",
                    "validation-stringLength": "The length of the value is not correct",
                    "validation-stringLength-formatted": "The length of {0} is not correct",
                    "validation-custom": "Value is invalid",
                    "validation-custom-formatted": "{0} is invalid",
                    "validation-compare": "Values do not match",
                    "validation-compare-formatted": "{0} does not match",
                    "validation-pattern": "Value does not match pattern",
                    "validation-pattern-formatted": "{0} does not match pattern",
                    "validation-email": "Email is invalid",
                    "validation-email-formatted": "{0} is invalid",
                    "validation-mask": "Value is invalid"
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/localization/en/widgets-base.en.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = {
                en: {
                    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
                    "dxList-pullingDownText": "Pull down to refresh...",
                    "dxList-pulledDownText": "Release to refresh...",
                    "dxList-refreshingText": "Refreshing...",
                    "dxList-pageLoadingText": "Loading...",
                    "dxList-nextButtonText": "More",
                    "dxList-selectAll": "Select All",
                    "dxListEditDecorator-delete": "Delete",
                    "dxListEditDecorator-more": "More",
                    "dxScrollView-pullingDownText": "Pull down to refresh...",
                    "dxScrollView-pulledDownText": "Release to refresh...",
                    "dxScrollView-refreshingText": "Refreshing...",
                    "dxScrollView-reachBottomText": "Loading...",
                    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
                    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
                    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
                    "dxDateBox-validation-datetime": "Value must be a date or time",
                    "dxFileUploader-selectFile": "Select file",
                    "dxFileUploader-dropFile": "or Drop file here",
                    "dxFileUploader-bytes": "bytes",
                    "dxFileUploader-kb": "kb",
                    "dxFileUploader-Mb": "Mb",
                    "dxFileUploader-Gb": "Gb",
                    "dxFileUploader-upload": "Upload",
                    "dxFileUploader-uploaded": "Uploaded",
                    "dxFileUploader-readyToUpload": "Ready to upload",
                    "dxFileUploader-uploadFailedMessage": "Upload failed",
                    "dxRangeSlider-ariaFrom": "From",
                    "dxRangeSlider-ariaTill": "Till",
                    "dxSwitch-onText": "ON",
                    "dxSwitch-offText": "OFF",
                    "dxForm-optionalMark": "optional",
                    "dxForm-requiredMessage": "{0} is required",
                    "dxNumberBox-invalidValueMessage": "Value must be a number"
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/localization/en/widgets-mobile.en.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {}.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/localization/en/widgets-web.en.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = {
                en: {
                    "dxDataGrid-columnChooserTitle": "Column Chooser",
                    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
                    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
                    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
                    "dxDataGrid-groupHeaderText": "Group by This Column",
                    "dxDataGrid-ungroupHeaderText": "Ungroup",
                    "dxDataGrid-ungroupAllText": "Ungroup All",
                    "dxDataGrid-editingEditRow": "Edit",
                    "dxDataGrid-editingSaveRowChanges": "Save",
                    "dxDataGrid-editingCancelRowChanges": "Cancel",
                    "dxDataGrid-editingDeleteRow": "Delete",
                    "dxDataGrid-editingUndeleteRow": "Undelete",
                    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
                    "dxDataGrid-validationCancelChanges": "Cancel changes",
                    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
                    "dxDataGrid-noDataText": "No data",
                    "dxDataGrid-searchPanelPlaceholder": "Search...",
                    "dxDataGrid-filterRowShowAllText": "(All)",
                    "dxDataGrid-filterRowResetOperationText": "Reset",
                    "dxDataGrid-filterRowOperationEquals": "Equals",
                    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
                    "dxDataGrid-filterRowOperationLess": "Less than",
                    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
                    "dxDataGrid-filterRowOperationGreater": "Greater than",
                    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
                    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
                    "dxDataGrid-filterRowOperationContains": "Contains",
                    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
                    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
                    "dxDataGrid-filterRowOperationBetween": "Between",
                    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
                    "dxDataGrid-filterRowOperationBetweenEndText": "End",
                    "dxDataGrid-applyFilterText": "Apply filter",
                    "dxDataGrid-trueText": "true",
                    "dxDataGrid-falseText": "false",
                    "dxDataGrid-sortingAscendingText": "Sort Ascending",
                    "dxDataGrid-sortingDescendingText": "Sort Descending",
                    "dxDataGrid-sortingClearText": "Clear Sorting",
                    "dxDataGrid-editingSaveAllChanges": "Save changes",
                    "dxDataGrid-editingCancelAllChanges": "Discard changes",
                    "dxDataGrid-editingAddRow": "Add a row",
                    "dxDataGrid-summaryMin": "Min: {0}",
                    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
                    "dxDataGrid-summaryMax": "Max: {0}",
                    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
                    "dxDataGrid-summaryAvg": "Avg: {0}",
                    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
                    "dxDataGrid-summarySum": "Sum: {0}",
                    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
                    "dxDataGrid-summaryCount": "Count: {0}",
                    "dxDataGrid-columnFixingFix": "Fix",
                    "dxDataGrid-columnFixingUnfix": "Unfix",
                    "dxDataGrid-columnFixingLeftPosition": "To the left",
                    "dxDataGrid-columnFixingRightPosition": "To the right",
                    "dxDataGrid-exportTo": "Export",
                    "dxDataGrid-exportToExcel": "Export to Excel file",
                    "dxDataGrid-excelFormat": "Excel file",
                    "dxDataGrid-selectedRows": "Selected rows",
                    "dxDataGrid-exportSelectedRows": "Export selected rows",
                    "dxDataGrid-exportAll": "Export all data",
                    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
                    "dxDataGrid-headerFilterOK": "OK",
                    "dxDataGrid-headerFilterCancel": "Cancel",
                    "dxDataGrid-ariaColumn": "Column",
                    "dxDataGrid-ariaValue": "Value",
                    "dxDataGrid-ariaFilterCell": "Filter cell",
                    "dxDataGrid-ariaCollapse": "Collapse",
                    "dxDataGrid-ariaExpand": "Expand",
                    "dxDataGrid-ariaDataGrid": "Data grid",
                    "dxDataGrid-ariaSearchInGrid": "Search in data grid",
                    "dxDataGrid-ariaSelectAll": "Select all",
                    "dxDataGrid-ariaSelectRow": "Select row",
                    "dxPager-infoText": "Page {0} of {1} ({2} items)",
                    "dxPager-pagesCountText": "of",
                    "dxPivotGrid-grandTotal": "Grand Total",
                    "dxPivotGrid-total": "{0} Total",
                    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
                    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
                    "dxPivotGrid-expandAll": "Expand All",
                    "dxPivotGrid-collapseAll": "Collapse All",
                    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
                    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
                    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
                    "dxPivotGrid-rowFields": "Row Fields",
                    "dxPivotGrid-columnFields": "Column Fields",
                    "dxPivotGrid-dataFields": "Data Fields",
                    "dxPivotGrid-filterFields": "Filter Fields",
                    "dxPivotGrid-allFields": "All Fields",
                    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
                    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
                    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
                    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
                    "dxScheduler-editorLabelTitle": "Subject",
                    "dxScheduler-editorLabelStartDate": "Start Date",
                    "dxScheduler-editorLabelEndDate": "End Date",
                    "dxScheduler-editorLabelDescription": "Description",
                    "dxScheduler-editorLabelRecurrence": "Repeat",
                    "dxScheduler-openAppointment": "Open appointment",
                    "dxScheduler-recurrenceNever": "Never",
                    "dxScheduler-recurrenceDaily": "Daily",
                    "dxScheduler-recurrenceWeekly": "Weekly",
                    "dxScheduler-recurrenceMonthly": "Monthly",
                    "dxScheduler-recurrenceYearly": "Yearly",
                    "dxScheduler-recurrenceEvery": "Every",
                    "dxScheduler-recurrenceEnd": "End repeat",
                    "dxScheduler-recurrenceAfter": "After",
                    "dxScheduler-recurrenceOn": "On",
                    "dxScheduler-recurrenceRepeatDaily": "day(s)",
                    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
                    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
                    "dxScheduler-recurrenceRepeatYearly": "year(s)",
                    "dxScheduler-switcherDay": "Day",
                    "dxScheduler-switcherWeek": "Week",
                    "dxScheduler-switcherWorkWeek": "Work week",
                    "dxScheduler-switcherMonth": "Month",
                    "dxScheduler-switcherAgenda": "Agenda",
                    "dxScheduler-switcherTimelineDay": "Timeline Day",
                    "dxScheduler-switcherTimelineWeek": "Timeline Week",
                    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
                    "dxScheduler-switcherTimelineMonth": "Timeline Month",
                    "dxScheduler-recurrenceRepeatOnDate": "on date",
                    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
                    "dxScheduler-allDay": "All day",
                    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
                    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
                    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
                    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
                    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
                    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
                    "dxScheduler-noTimezoneTitle": "No timezone",
                    "dxCalendar-todayButtonText": "Today",
                    "dxCalendar-ariaWidgetName": "Calendar",
                    "dxColorView-ariaRed": "Red",
                    "dxColorView-ariaGreen": "Green",
                    "dxColorView-ariaBlue": "Blue",
                    "dxColorView-ariaAlpha": "Transparency",
                    "dxColorView-ariaHex": "Color code",
                    "vizExport-printingButtonText": "Print",
                    "vizExport-titleMenuText": "Exporting/Printing",
                    "vizExport-exportButtonText": "{0} file"
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/localization/globalize/currency.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 86);
            __webpack_require__( /*! ./number */ 152);
            __webpack_require__( /*! ../currency */ 117);
            __webpack_require__( /*! globalize/currency */ 46);
            var enCurrencyUSD = {
                main: {
                    en: {
                        identity: {
                            version: {
                                _cldrVersion: "28",
                                _number: "$Revision: 11972 $"
                            },
                            language: "en"
                        },
                        numbers: {
                            currencies: {
                                USD: {
                                    displayName: "US Dollar",
                                    "displayName-count-one": "US dollar",
                                    "displayName-count-other": "US dollars",
                                    symbol: "$",
                                    "symbol-alt-narrow": "$"
                                }
                            }
                        }
                    }
                }
            };
            var currencyData = {
                supplemental: {
                    version: {
                        _cldrVersion: "28",
                        _unicodeVersion: "8.0.0",
                        _number: "$Revision: 11969 $"
                    },
                    currencyData: {
                        fractions: {
                            DEFAULT: {
                                _rounding: "0",
                                _digits: "2"
                            }
                        }
                    }
                }
            };
            var Globalize = __webpack_require__( /*! globalize */ 46),
                config = __webpack_require__( /*! ../../core/config */ 35),
                numberLocalization = __webpack_require__( /*! ../number */ 38);
            if (!Globalize || !Globalize.formatCurrency) {
                return
            }
            Globalize.load(enCurrencyUSD, currencyData);
            Globalize.locale("en");
            var formattersCache = {};
            var getFormatter = function(currency, format) {
                var formatter, formatCacheKey;
                if ("object" === typeof format) {
                    formatCacheKey = Globalize.locale().locale + ":" + currency + ":" + JSON.stringify(format)
                } else {
                    formatCacheKey = Globalize.locale().locale + ":" + currency + ":" + format
                }
                formatter = formattersCache[formatCacheKey];
                if (!formatter) {
                    formatter = formattersCache[formatCacheKey] = Globalize.currencyFormatter(currency, format)
                }
                return formatter
            };
            var globalizeCurrencyLocalization = {
                _formatNumberCore: function(value, format, formatConfig) {
                    if ("currency" === format) {
                        var currency = formatConfig && formatConfig.currency || config().defaultCurrency;
                        return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value)
                    }
                    return this.callBase.apply(this, arguments)
                },
                _normalizeFormatConfig: function(format, formatConfig, value) {
                    var config = this.callBase(format, formatConfig, value);
                    if ("currency" === format) {
                        config.style = "accounting"
                    }
                    return config
                },
                format: function(value, format) {
                    if ("number" !== typeof value) {
                        return value
                    }
                    format = this._normalizeFormat(format);
                    if (format) {
                        if ("default" === format.currency) {
                            format.currency = config().defaultCurrency
                        }
                        if ("currency" === format.type) {
                            return this._formatNumber(value, this._parseNumberFormatString("currency"), format)
                        } else {
                            if (format.currency) {
                                return getFormatter(format.currency, format)(value)
                            }
                        }
                    }
                    return this.callBase.apply(this, arguments)
                },
                getCurrencySymbol: function(currency) {
                    if (!currency) {
                        currency = config().defaultCurrency
                    }
                    return Globalize.cldr.main("numbers/currencies/" + currency)
                },
                getOpenXmlCurrencyFormat: function(currency) {
                    var i, result, symbol, encodeSymbols, currencySymbol = this.getCurrencySymbol(currency).symbol,
                        currencyFormat = Globalize.cldr.main("numbers/currencyFormats-numberSystem-latn");
                    if (currencyFormat.accounting) {
                        encodeSymbols = {
                            ".00": "{0}",
                            "'": "\\'",
                            "\\(": "\\(",
                            "\\)": "\\)",
                            " ": "\\ ",
                            '"': "&quot;",
                            "\\¤": currencySymbol
                        };
                        result = currencyFormat.accounting.split(";");
                        for (i = 0; i < result.length; i++) {
                            for (symbol in encodeSymbols) {
                                if (encodeSymbols.hasOwnProperty(symbol)) {
                                    result[i] = result[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol])
                                }
                            }
                        }
                        return 2 === result.length ? result[0] + "_);" + result[1] : result[0]
                    }
                }
            };
            numberLocalization.inject(globalizeCurrencyLocalization)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/localization/globalize/date.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 86);
            __webpack_require__( /*! ./number */ 152);
            __webpack_require__( /*! globalize/date */ 46);
            var timeData = {
                supplemental: {
                    version: {
                        _cldrVersion: "28",
                        _unicodeVersion: "8.0.0",
                        _number: "$Revision: 11969 $"
                    },
                    timeData: {
                        "001": {
                            _allowed: "H h",
                            _preferred: "H"
                        },
                        DE: {
                            _allowed: "H",
                            _preferred: "H"
                        },
                        JP: {
                            _allowed: "H K h",
                            _preferred: "H"
                        },
                        RU: {
                            _allowed: "H",
                            _preferred: "H"
                        },
                        US: {
                            _allowed: "H h",
                            _preferred: "h"
                        }
                    }
                }
            };
            var enCaGregorian = {
                main: {
                    en: {
                        identity: {
                            version: {
                                _cldrVersion: "28",
                                _number: "$Revision: 11972 $"
                            },
                            language: "en"
                        },
                        dates: {
                            calendars: {
                                gregorian: {
                                    months: {
                                        format: {
                                            abbreviated: {
                                                1: "Jan",
                                                2: "Feb",
                                                3: "Mar",
                                                4: "Apr",
                                                5: "May",
                                                6: "Jun",
                                                7: "Jul",
                                                8: "Aug",
                                                9: "Sep",
                                                10: "Oct",
                                                11: "Nov",
                                                12: "Dec"
                                            },
                                            narrow: {
                                                1: "J",
                                                2: "F",
                                                3: "M",
                                                4: "A",
                                                5: "M",
                                                6: "J",
                                                7: "J",
                                                8: "A",
                                                9: "S",
                                                10: "O",
                                                11: "N",
                                                12: "D"
                                            },
                                            wide: {
                                                1: "January",
                                                2: "February",
                                                3: "March",
                                                4: "April",
                                                5: "May",
                                                6: "June",
                                                7: "July",
                                                8: "August",
                                                9: "September",
                                                10: "October",
                                                11: "November",
                                                12: "December"
                                            }
                                        },
                                        "stand-alone": {
                                            abbreviated: {
                                                1: "Jan",
                                                2: "Feb",
                                                3: "Mar",
                                                4: "Apr",
                                                5: "May",
                                                6: "Jun",
                                                7: "Jul",
                                                8: "Aug",
                                                9: "Sep",
                                                10: "Oct",
                                                11: "Nov",
                                                12: "Dec"
                                            },
                                            narrow: {
                                                1: "J",
                                                2: "F",
                                                3: "M",
                                                4: "A",
                                                5: "M",
                                                6: "J",
                                                7: "J",
                                                8: "A",
                                                9: "S",
                                                10: "O",
                                                11: "N",
                                                12: "D"
                                            },
                                            wide: {
                                                1: "January",
                                                2: "February",
                                                3: "March",
                                                4: "April",
                                                5: "May",
                                                6: "June",
                                                7: "July",
                                                8: "August",
                                                9: "September",
                                                10: "October",
                                                11: "November",
                                                12: "December"
                                            }
                                        }
                                    },
                                    days: {
                                        format: {
                                            abbreviated: {
                                                sun: "Sun",
                                                mon: "Mon",
                                                tue: "Tue",
                                                wed: "Wed",
                                                thu: "Thu",
                                                fri: "Fri",
                                                sat: "Sat"
                                            },
                                            narrow: {
                                                sun: "S",
                                                mon: "M",
                                                tue: "T",
                                                wed: "W",
                                                thu: "T",
                                                fri: "F",
                                                sat: "S"
                                            },
                                            "short": {
                                                sun: "Su",
                                                mon: "Mo",
                                                tue: "Tu",
                                                wed: "We",
                                                thu: "Th",
                                                fri: "Fr",
                                                sat: "Sa"
                                            },
                                            wide: {
                                                sun: "Sunday",
                                                mon: "Monday",
                                                tue: "Tuesday",
                                                wed: "Wednesday",
                                                thu: "Thursday",
                                                fri: "Friday",
                                                sat: "Saturday"
                                            }
                                        },
                                        "stand-alone": {
                                            abbreviated: {
                                                sun: "Sun",
                                                mon: "Mon",
                                                tue: "Tue",
                                                wed: "Wed",
                                                thu: "Thu",
                                                fri: "Fri",
                                                sat: "Sat"
                                            },
                                            narrow: {
                                                sun: "S",
                                                mon: "M",
                                                tue: "T",
                                                wed: "W",
                                                thu: "T",
                                                fri: "F",
                                                sat: "S"
                                            },
                                            "short": {
                                                sun: "Su",
                                                mon: "Mo",
                                                tue: "Tu",
                                                wed: "We",
                                                thu: "Th",
                                                fri: "Fr",
                                                sat: "Sa"
                                            },
                                            wide: {
                                                sun: "Sunday",
                                                mon: "Monday",
                                                tue: "Tuesday",
                                                wed: "Wednesday",
                                                thu: "Thursday",
                                                fri: "Friday",
                                                sat: "Saturday"
                                            }
                                        }
                                    },
                                    quarters: {
                                        format: {
                                            abbreviated: {
                                                1: "Q1",
                                                2: "Q2",
                                                3: "Q3",
                                                4: "Q4"
                                            },
                                            narrow: {
                                                1: "1",
                                                2: "2",
                                                3: "3",
                                                4: "4"
                                            },
                                            wide: {
                                                1: "1st quarter",
                                                2: "2nd quarter",
                                                3: "3rd quarter",
                                                4: "4th quarter"
                                            }
                                        },
                                        "stand-alone": {
                                            abbreviated: {
                                                1: "Q1",
                                                2: "Q2",
                                                3: "Q3",
                                                4: "Q4"
                                            },
                                            narrow: {
                                                1: "1",
                                                2: "2",
                                                3: "3",
                                                4: "4"
                                            },
                                            wide: {
                                                1: "1st quarter",
                                                2: "2nd quarter",
                                                3: "3rd quarter",
                                                4: "4th quarter"
                                            }
                                        }
                                    },
                                    dayPeriods: {
                                        format: {
                                            abbreviated: {
                                                midnight: "midnight",
                                                am: "AM",
                                                "am-alt-variant": "am",
                                                noon: "noon",
                                                pm: "PM",
                                                "pm-alt-variant": "pm",
                                                morning1: "in the morning",
                                                afternoon1: "in the afternoon",
                                                evening1: "in the evening",
                                                night1: "at night"
                                            },
                                            narrow: {
                                                midnight: "mi",
                                                am: "a",
                                                "am-alt-variant": "am",
                                                noon: "n",
                                                pm: "p",
                                                "pm-alt-variant": "pm",
                                                morning1: "in the morning",
                                                afternoon1: "in the afternoon",
                                                evening1: "in the evening",
                                                night1: "at night"
                                            },
                                            wide: {
                                                midnight: "midnight",
                                                am: "AM",
                                                "am-alt-variant": "am",
                                                noon: "noon",
                                                pm: "PM",
                                                "pm-alt-variant": "pm",
                                                morning1: "in the morning",
                                                afternoon1: "in the afternoon",
                                                evening1: "in the evening",
                                                night1: "at night"
                                            }
                                        },
                                        "stand-alone": {
                                            abbreviated: {
                                                midnight: "midnight",
                                                am: "AM",
                                                "am-alt-variant": "am",
                                                noon: "noon",
                                                pm: "PM",
                                                "pm-alt-variant": "pm",
                                                morning1: "in the morning",
                                                afternoon1: "in the afternoon",
                                                evening1: "in the evening",
                                                night1: "at night"
                                            },
                                            narrow: {
                                                midnight: "midnight",
                                                am: "AM",
                                                "am-alt-variant": "am",
                                                noon: "noon",
                                                pm: "PM",
                                                "pm-alt-variant": "pm",
                                                morning1: "in the morning",
                                                afternoon1: "in the afternoon",
                                                evening1: "in the evening",
                                                night1: "at night"
                                            },
                                            wide: {
                                                midnight: "midnight",
                                                am: "AM",
                                                "am-alt-variant": "am",
                                                noon: "noon",
                                                pm: "PM",
                                                "pm-alt-variant": "pm",
                                                morning1: "morning",
                                                afternoon1: "afternoon",
                                                evening1: "evening",
                                                night1: "night"
                                            }
                                        }
                                    },
                                    eras: {
                                        eraNames: {
                                            0: "Before Christ",
                                            "0-alt-variant": "Before Common Era",
                                            1: "Anno Domini",
                                            "1-alt-variant": "Common Era"
                                        },
                                        eraAbbr: {
                                            0: "BC",
                                            "0-alt-variant": "BCE",
                                            1: "AD",
                                            "1-alt-variant": "CE"
                                        },
                                        eraNarrow: {
                                            0: "B",
                                            "0-alt-variant": "BCE",
                                            1: "A",
                                            "1-alt-variant": "CE"
                                        }
                                    },
                                    dateFormats: {
                                        full: "EEEE, MMMM d, y",
                                        "long": "MMMM d, y",
                                        medium: "MMM d, y",
                                        "short": "M/d/yy"
                                    },
                                    timeFormats: {
                                        full: "h:mm:ss a zzzz",
                                        "long": "h:mm:ss a z",
                                        medium: "h:mm:ss a",
                                        "short": "h:mm a"
                                    },
                                    dateTimeFormats: {
                                        full: "{1} 'at' {0}",
                                        "long": "{1} 'at' {0}",
                                        medium: "{1}, {0}",
                                        "short": "{1}, {0}",
                                        availableFormats: {
                                            d: "d",
                                            E: "ccc",
                                            Ed: "d E",
                                            Ehm: "E h:mm a",
                                            EHm: "E HH:mm",
                                            Ehms: "E h:mm:ss a",
                                            EHms: "E HH:mm:ss",
                                            Gy: "y G",
                                            GyMMM: "MMM y G",
                                            GyMMMd: "MMM d, y G",
                                            GyMMMEd: "E, MMM d, y G",
                                            h: "h a",
                                            H: "HH",
                                            hm: "h:mm a",
                                            Hm: "HH:mm",
                                            hms: "h:mm:ss a",
                                            Hms: "HH:mm:ss",
                                            hmsv: "h:mm:ss a v",
                                            Hmsv: "HH:mm:ss v",
                                            hmv: "h:mm a v",
                                            Hmv: "HH:mm v",
                                            M: "L",
                                            Md: "M/d",
                                            MEd: "E, M/d",
                                            MMM: "LLL",
                                            MMMd: "MMM d",
                                            MMMEd: "E, MMM d",
                                            MMMMd: "MMMM d",
                                            ms: "mm:ss",
                                            y: "y",
                                            yM: "M/y",
                                            yMd: "M/d/y",
                                            yMEd: "E, M/d/y",
                                            yMMM: "MMM y",
                                            yMMMd: "MMM d, y",
                                            yMMMEd: "E, MMM d, y",
                                            yMMMM: "MMMM y",
                                            yQQQ: "QQQ y",
                                            yQQQQ: "QQQQ y"
                                        },
                                        appendItems: {
                                            Day: "{0} ({2}: {1})",
                                            "Day-Of-Week": "{0} {1}",
                                            Era: "{0} {1}",
                                            Hour: "{0} ({2}: {1})",
                                            Minute: "{0} ({2}: {1})",
                                            Month: "{0} ({2}: {1})",
                                            Quarter: "{0} ({2}: {1})",
                                            Second: "{0} ({2}: {1})",
                                            Timezone: "{0} {1}",
                                            Week: "{0} ({2}: {1})",
                                            Year: "{0} {1}"
                                        },
                                        intervalFormats: {
                                            intervalFormatFallback: "{0} – {1}",
                                            d: {
                                                d: "d – d"
                                            },
                                            h: {
                                                a: "h a – h a",
                                                h: "h – h a"
                                            },
                                            H: {
                                                H: "HH – HH"
                                            },
                                            hm: {
                                                a: "h:mm a – h:mm a",
                                                h: "h:mm – h:mm a",
                                                m: "h:mm – h:mm a"
                                            },
                                            Hm: {
                                                H: "HH:mm – HH:mm",
                                                m: "HH:mm – HH:mm"
                                            },
                                            hmv: {
                                                a: "h:mm a – h:mm a v",
                                                h: "h:mm – h:mm a v",
                                                m: "h:mm – h:mm a v"
                                            },
                                            Hmv: {
                                                H: "HH:mm – HH:mm v",
                                                m: "HH:mm – HH:mm v"
                                            },
                                            hv: {
                                                a: "h a – h a v",
                                                h: "h – h a v"
                                            },
                                            Hv: {
                                                H: "HH – HH v"
                                            },
                                            M: {
                                                M: "M – M"
                                            },
                                            Md: {
                                                d: "M/d – M/d",
                                                M: "M/d – M/d"
                                            },
                                            MEd: {
                                                d: "E, M/d – E, M/d",
                                                M: "E, M/d – E, M/d"
                                            },
                                            MMM: {
                                                M: "MMM – MMM"
                                            },
                                            MMMd: {
                                                d: "MMM d – d",
                                                M: "MMM d – MMM d"
                                            },
                                            MMMEd: {
                                                d: "E, MMM d – E, MMM d",
                                                M: "E, MMM d – E, MMM d"
                                            },
                                            y: {
                                                y: "y – y"
                                            },
                                            yM: {
                                                M: "M/y – M/y",
                                                y: "M/y – M/y"
                                            },
                                            yMd: {
                                                d: "M/d/y – M/d/y",
                                                M: "M/d/y – M/d/y",
                                                y: "M/d/y – M/d/y"
                                            },
                                            yMEd: {
                                                d: "E, M/d/y – E, M/d/y",
                                                M: "E, M/d/y – E, M/d/y",
                                                y: "E, M/d/y – E, M/d/y"
                                            },
                                            yMMM: {
                                                M: "MMM – MMM y",
                                                y: "MMM y – MMM y"
                                            },
                                            yMMMd: {
                                                d: "MMM d – d, y",
                                                M: "MMM d – MMM d, y",
                                                y: "MMM d, y – MMM d, y"
                                            },
                                            yMMMEd: {
                                                d: "E, MMM d – E, MMM d, y",
                                                M: "E, MMM d – E, MMM d, y",
                                                y: "E, MMM d, y – E, MMM d, y"
                                            },
                                            yMMMM: {
                                                M: "MMMM – MMMM y",
                                                y: "MMMM y – MMMM y"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            var weekData = {
                supplemental: {
                    version: {
                        _cldrVersion: "28",
                        _unicodeVersion: "8.0.0",
                        _number: "$Revision: 11969 $"
                    },
                    weekData: {
                        minDays: {
                            "001": "1",
                            US: "1",
                            DE: "4"
                        },
                        firstDay: {
                            "001": "mon",
                            DE: "mon",
                            RU: "mon",
                            JP: "sun",
                            US: "sun"
                        },
                        weekendStart: {
                            "001": "sat"
                        },
                        weekendEnd: {
                            "001": "sun"
                        }
                    }
                }
            };
            var $ = __webpack_require__( /*! jquery */ 1),
                Globalize = __webpack_require__( /*! globalize */ 46),
                dateLocalization = __webpack_require__( /*! ../date */ 14),
                errors = __webpack_require__( /*! ../../core/errors */ 10);
            if (!Globalize || !Globalize.formatDate) {
                return
            }
            Globalize.load(weekData, timeData, enCaGregorian);
            Globalize.locale("en");
            var formattersCache = {};
            var FORMATS_TO_GLOBALIZE_MAP = {
                shortdate: {
                    path: "dateTimeFormats/availableFormats/yMd"
                },
                shorttime: {
                    path: "timeFormats/short"
                },
                longdate: {
                    path: "dateFormats/full"
                },
                longtime: {
                    path: "timeFormats/medium"
                },
                monthandday: {
                    path: "dateTimeFormats/availableFormats/MMMMd"
                },
                monthandyear: {
                    path: "dateTimeFormats/availableFormats/yMMMM"
                },
                quarterandyear: {
                    path: "dateTimeFormats/availableFormats/yQQQ"
                },
                day: {
                    path: "dateTimeFormats/availableFormats/d"
                },
                year: {
                    path: "dateTimeFormats/availableFormats/y"
                },
                shortdateshorttime: {
                    path: "dateTimeFormats/short",
                    parts: ["shorttime", "shortdate"]
                },
                mediumdatemediumtime: {
                    path: "dateTimeFormats/medium",
                    parts: ["shorttime", "monthandday"]
                },
                longdatelongtime: {
                    path: "dateTimeFormats/medium",
                    parts: ["longtime", "longdate"]
                },
                month: {
                    pattern: "LLLL"
                },
                shortyear: {
                    pattern: "yy"
                },
                dayofweek: {
                    pattern: "EEEE"
                },
                quarter: {
                    pattern: "QQQ"
                },
                millisecond: {
                    pattern: "SSS"
                },
                hour: {
                    pattern: "HH"
                },
                minute: {
                    pattern: "mm"
                }
            };
            var globalizeDateLocalization = {
                getPatternByFormat: function(format) {
                    var that = this,
                        lowerFormat = format.toLowerCase(),
                        globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];
                    if ("datetime-local" === lowerFormat) {
                        return "yyyy-MM-ddTHH':'mm':'ss"
                    }
                    if (!globalizeFormat) {
                        return
                    }
                    var result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;
                    if (globalizeFormat.parts) {
                        $.each(globalizeFormat.parts, function(index, part) {
                            result = result.replace("{" + index + "}", that.getPatternByFormat(part))
                        })
                    }
                    return result
                },
                _getFormatStringByPath: function(path) {
                    return Globalize.locale().main("dates/calendars/gregorian/" + path)
                },
                getMonthNames: function(format) {
                    var months = Globalize.locale().main("dates/calendars/gregorian/months/stand-alone/" + (format || "wide"));
                    return $.map(months, function(month) {
                        return month
                    })
                },
                getDayNames: function(format) {
                    var days = Globalize.locale().main("dates/calendars/gregorian/days/stand-alone/" + (format || "wide"));
                    return $.map(days, function(day) {
                        return day
                    })
                },
                getTimeSeparator: function() {
                    return Globalize.locale().main("numbers/symbols-numberSystem-latn/timeSeparator")
                },
                format: function(date, format) {
                    if (!date) {
                        return
                    }
                    if (!format) {
                        return date
                    }
                    var formatter, formatCacheKey;
                    if ("function" === typeof format) {
                        return format(date)
                    }
                    if (format.formatter) {
                        return format.formatter(date)
                    }
                    format = format.type || format;
                    if ("string" === typeof format) {
                        formatCacheKey = Globalize.locale().locale + ":" + format;
                        formatter = formattersCache[formatCacheKey];
                        if (!formatter) {
                            format = {
                                raw: this.getPatternByFormat(format) || format
                            };
                            formatter = formattersCache[formatCacheKey] = Globalize.dateFormatter(format)
                        }
                    } else {
                        formatter = Globalize.dateFormatter(format)
                    }
                    return formatter(date)
                },
                parse: function(text, format) {
                    if (!text) {
                        return
                    }
                    if (!format || "function" === typeof format || format.formatter && !format.parser) {
                        if (format) {
                            errors.log("W0012")
                        }
                        return Globalize.parseDate(text)
                    }
                    if (format.parser) {
                        return format.parser(text)
                    }
                    if ("string" === typeof format) {
                        format = {
                            raw: this.getPatternByFormat(format) || format
                        }
                    }
                    return Globalize.parseDate(text, format)
                },
                firstDayOfWeekIndex: function() {
                    var firstDay = Globalize.locale().supplemental.weekData.firstDay();
                    return $.inArray(firstDay, this._getDayKeys())
                },
                _getDayKeys: function() {
                    var days = Globalize.locale().main("dates/calendars/gregorian/days/format/short");
                    return $.map(days, function(day, key) {
                        return key
                    })
                }
            };
            dateLocalization.inject(globalizeDateLocalization)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/localization/globalize/message.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 86);
            var Globalize = __webpack_require__( /*! globalize */ 46),
                messageLocalization = __webpack_require__( /*! ../message */ 8);
            __webpack_require__( /*! globalize/message */ 46);
            if (!Globalize || !Globalize.formatMessage) {
                return
            }
            var DEFAULT_LOCALE = "en";
            var originalLoadMessages = Globalize.loadMessages;
            Globalize.loadMessages = function(messages) {
                messageLocalization.load(messages)
            };
            var globalizeMessageLocalization = {
                ctor: function() {
                    this.load(this._dictionary)
                },
                load: function(messages) {
                    this.callBase(messages);
                    originalLoadMessages(messages)
                },
                locale: function(locale) {
                    if (!locale) {
                        return Globalize.locale().locale
                    }
                    Globalize.locale(locale)
                },
                getMessagesByLocales: function() {
                    return Globalize.cldr.get("globalize-messages")
                },
                getFormatter: function(key, locale) {
                    var currentLocale = locale || this.locale(),
                        formatter = this.callBase(key, locale);
                    if (!formatter) {
                        formatter = this._formatterByGlobalize(key, locale)
                    }
                    if (!formatter && currentLocale !== DEFAULT_LOCALE) {
                        formatter = this.getFormatter(key, DEFAULT_LOCALE)
                    }
                    return formatter
                },
                _formatterByGlobalize: function(key, locale) {
                    var result, currentGlobalize = !locale || locale === this.locale() ? Globalize : new Globalize(locale);
                    if (this._messageLoaded(key, locale)) {
                        result = currentGlobalize.messageFormatter(key)
                    }
                    return result
                },
                _messageLoaded: function(key, locale) {
                    var currentCldr = locale ? new Globalize(locale).cldr : Globalize.locale(),
                        value = currentCldr.get(["globalize-messages/{bundle}", key]);
                    return void 0 !== value
                },
                _loadSingle: function(key, value, locale) {
                    var data = {};
                    data[locale] = {};
                    data[locale][key] = value;
                    this.load(data)
                }
            };
            messageLocalization.inject(globalizeMessageLocalization)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************************!*\
      !*** ./Scripts/ui/collection/ui.collection_widget.base.js ***!
      \************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Action = __webpack_require__( /*! ../../core/action */ 54),
                Guid = __webpack_require__( /*! ../../core/guid */ 33),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                domUtils = __webpack_require__( /*! ../../core/utils/dom */ 11),
                Widget = __webpack_require__( /*! ../widget/ui.widget */ 19),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4),
                pointerEvents = __webpack_require__( /*! ../../events/pointer */ 13),
                DataHelperMixin = __webpack_require__( /*! ./ui.data_helper */ 118),
                selectors = __webpack_require__( /*! ../widget/jquery.selectors */ 98),
                messageLocalization = __webpack_require__( /*! ../../localization/message */ 8),
                holdEvent = __webpack_require__( /*! ../../events/hold */ 63),
                clickEvent = __webpack_require__( /*! ../../events/click */ 9),
                contextmenuEvent = __webpack_require__( /*! ../../events/contextmenu */ 173);
            var COLLECTION_CLASS = "dx-collection",
                ITEM_CLASS = "dx-item",
                CONTENT_CLASS_POSTFIX = "-content",
                ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder",
                ITEM_DATA_KEY = "dxItemData",
                ITEM_INDEX_KEY = "dxItemIndex",
                ITEM_TEMPLATE_ID_PREFIX = "tmpl-",
                ITEMS_SELECTOR = "[data-options*='dxItem']",
                SELECTED_ITEM_CLASS = "dx-item-selected",
                ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait",
                EMPTY_COLLECTION = "dx-empty-collection",
                TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
                DISABLED_STATE_CLASS = "dx-state-disabled",
                INVISIBLE_STATE_CLASS = "dx-state-invisible",
                ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+(\w+)$/;
            var FOCUS_UP = "up",
                FOCUS_DOWN = "down",
                FOCUS_LEFT = "left",
                FOCUS_RIGHT = "right",
                FOCUS_PAGE_UP = "pageup",
                FOCUS_PAGE_DOWN = "pagedown",
                FOCUS_LAST = "last",
                FOCUS_FIRST = "first";
            var CollectionWidget = Widget.inherit({
                _activeStateUnit: "." + ITEM_CLASS,
                _supportedKeys: function() {
                    var click = function(e) {
                            var $itemElement = this.option("focusedElement");
                            if (!$itemElement) {
                                return
                            }
                            e.target = $itemElement;
                            e.currentTarget = $itemElement;
                            this._itemClickHandler(e)
                        },
                        move = function(location, e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._moveFocus(location, e)
                        };
                    return $.extend(this.callBase(), {
                        space: click,
                        enter: click,
                        leftArrow: $.proxy(move, this, FOCUS_LEFT),
                        rightArrow: $.proxy(move, this, FOCUS_RIGHT),
                        upArrow: $.proxy(move, this, FOCUS_UP),
                        downArrow: $.proxy(move, this, FOCUS_DOWN),
                        pageUp: $.proxy(move, this, FOCUS_UP),
                        pageDown: $.proxy(move, this, FOCUS_DOWN),
                        home: $.proxy(move, this, FOCUS_FIRST),
                        end: $.proxy(move, this, FOCUS_LAST)
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                        selectOnFocus: false,
                        loopItemFocus: true,
                        items: [],
                        itemTemplate: "item",
                        onItemRendered: null,
                        onItemClick: null,
                        onItemHold: null,
                        itemHoldTimeout: 750,
                        onItemContextMenu: null,
                        onFocusedItemChanged: null,
                        noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
                        dataSource: null,
                        _itemAttributes: {},
                        itemTemplateProperty: "template",
                        focusOnSelectedItem: true,
                        focusedElement: null
                    })
                },
                _getAnonymousTemplateName: function() {
                    return "item"
                },
                _init: function() {
                    this.callBase();
                    this._cleanRenderedItems();
                    this._refreshDataSource()
                },
                _initTemplates: function() {
                    this._initItemsFromMarkup();
                    this.callBase()
                },
                _initItemsFromMarkup: function() {
                    var $items = this.element().contents().filter(ITEMS_SELECTOR);
                    if (!$items.length || this.option("items").length) {
                        return
                    }
                    var items = $.map($items, $.proxy(function(item) {
                        var $item = $(item);
                        var result = domUtils.getElementOptions(item).dxItem;
                        var isTemplateRequired = $.trim($item.html()) && !result.template;
                        if (isTemplateRequired) {
                            result.template = this._prepareItemTemplate($item)
                        } else {
                            $item.remove()
                        }
                        return result
                    }, this));
                    this.option("items", items)
                },
                _prepareItemTemplate: function($item) {
                    var templateId = ITEM_TEMPLATE_ID_PREFIX + new Guid;
                    var templateOptions = 'dxTemplate: { name: "' + templateId + '" }';
                    $item.detach().clone().attr("data-options", templateOptions).data("options", templateOptions).appendTo(this.element());
                    return templateId
                },
                _dataSourceOptions: function() {
                    return {
                        paginate: false
                    }
                },
                _cleanRenderedItems: function() {
                    this._renderedItemsCount = 0
                },
                _focusTarget: function() {
                    return this.element()
                },
                _focusInHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    if (-1 === $.inArray(e.target, this._focusTarget())) {
                        return
                    }
                    var $focusedElement = this.option("focusedElement");
                    if ($focusedElement && $focusedElement.length) {
                        this._setFocusedItem($focusedElement)
                    } else {
                        var $activeItem = this._getActiveItem();
                        if ($activeItem.length) {
                            this.option("focusedElement", $activeItem)
                        }
                    }
                },
                _focusOutHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    var $target = this.option("focusedElement");
                    if ($target) {
                        this._toggleFocusClass(false, $target)
                    }
                },
                _getActiveItem: function(last) {
                    var $focusedElement = this.option("focusedElement");
                    if ($focusedElement && $focusedElement.length) {
                        return $focusedElement
                    }
                    var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0,
                        activeElements = this._getActiveElement(),
                        lastIndex = activeElements.length - 1;
                    if (index < 0) {
                        index = last ? lastIndex : 0
                    }
                    return activeElements.eq(index)
                },
                _renderFocusTarget: function() {
                    this.callBase.apply(this, arguments);
                    this._refreshActiveDescendant()
                },
                _moveFocus: function(location) {
                    var $newTarget, $items = this._itemElements().filter(":visible").not(".dx-state-disabled");
                    switch (location) {
                        case FOCUS_PAGE_UP:
                        case FOCUS_UP:
                            $newTarget = this._prevItem($items);
                            break;
                        case FOCUS_PAGE_DOWN:
                        case FOCUS_DOWN:
                            $newTarget = this._nextItem($items);
                            break;
                        case FOCUS_RIGHT:
                            $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                            break;
                        case FOCUS_LEFT:
                            $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                            break;
                        case FOCUS_FIRST:
                            $newTarget = $items.first();
                            break;
                        case FOCUS_LAST:
                            $newTarget = $items.last();
                            break;
                        default:
                            return false
                    }
                    if (0 !== $newTarget.length) {
                        this.option("focusedElement", $newTarget)
                    }
                },
                _prevItem: function($items) {
                    var $target = this._getActiveItem(),
                        targetIndex = $items.index($target),
                        $last = $items.last(),
                        $item = $($items[targetIndex - 1]),
                        loop = this.option("loopItemFocus");
                    if (0 === $item.length && loop) {
                        $item = $last
                    }
                    return $item
                },
                _nextItem: function($items) {
                    var $target = this._getActiveItem(true),
                        targetIndex = $items.index($target),
                        $first = $items.first(),
                        $item = $($items[targetIndex + 1]),
                        loop = this.option("loopItemFocus");
                    if (0 === $item.length && loop) {
                        $item = $first
                    }
                    return $item
                },
                _selectFocusedItem: function($target) {
                    this.selectItem($target)
                },
                _removeFocusedItem: function($target) {
                    if ($target && $target.length) {
                        this._toggleFocusClass(false, $target);
                        $target.removeAttr("id")
                    }
                },
                _refreshActiveDescendant: function() {
                    this.setAria("activedescendant", "");
                    this.setAria("activedescendant", this.getFocusedItemId())
                },
                _setFocusedItem: function($target) {
                    if (!$target || !$target.length) {
                        return
                    }
                    $target.attr("id", this.getFocusedItemId());
                    this._toggleFocusClass(true, $target);
                    this.onFocusedItemChanged(this.getFocusedItemId());
                    this._refreshActiveDescendant();
                    if (this.option("selectOnFocus")) {
                        this._selectFocusedItem($target)
                    }
                },
                _findItemElementByItem: function(item) {
                    var result = $(),
                        that = this;
                    this.itemElements().each(function() {
                        var $item = $(this);
                        if ($item.data(that._itemDataKey()) === item) {
                            result = $item;
                            return false
                        }
                    });
                    return result
                },
                _getIndexByItem: function(item) {
                    return this.option("items").indexOf(item)
                },
                _itemOptionChanged: function(item, property, value) {
                    var $item = this._findItemElementByItem(item);
                    switch (property) {
                        case "visible":
                            this._renderItemVisibleState($item, value);
                            break;
                        case "disabled":
                            this._renderItemDisableState($item, value);
                            break;
                        default:
                            var index = this._getIndexByItem(item);
                            this._renderItem(index, item, null, $item)
                    }
                },
                _renderItemVisibleState: function($item, value) {
                    $item.toggleClass(INVISIBLE_STATE_CLASS, !value)
                },
                _renderItemDisableState: function($item, value) {
                    $item.toggleClass(DISABLED_STATE_CLASS, !!value)
                },
                _optionChanged: function(args) {
                    if ("items" === args.name) {
                        var matches = args.fullName.match(ITEM_PATH_REGEX);
                        if (matches && matches.length) {
                            var property = matches[matches.length - 1],
                                itemPath = args.fullName.replace("." + property, ""),
                                item = this.option(itemPath);
                            this._itemOptionChanged(item, property, args.value);
                            return
                        }
                    }
                    switch (args.name) {
                        case "items":
                        case "_itemAttributes":
                        case "itemTemplateProperty":
                            this._cleanRenderedItems();
                            this._invalidate();
                            break;
                        case "dataSource":
                            this.option("items", []);
                            this._refreshDataSource();
                            this._renderEmptyMessage();
                            break;
                        case "noDataText":
                            this._renderEmptyMessage();
                            break;
                        case "itemTemplate":
                            this._invalidate();
                            break;
                        case "onItemRendered":
                            this._createItemRenderAction();
                            break;
                        case "onItemClick":
                            break;
                        case "onItemHold":
                        case "itemHoldTimeout":
                            this._attachHoldEvent();
                            break;
                        case "onItemContextMenu":
                            this._attachContextMenuEvent();
                            break;
                        case "onFocusedItemChanged":
                            this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                            break;
                        case "selectOnFocus":
                        case "loopItemFocus":
                        case "focusOnSelectedItem":
                            break;
                        case "focusedElement":
                            this._removeFocusedItem(args.previousValue);
                            this._setFocusedItem(args.value);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _loadNextPage: function() {
                    var dataSource = this._dataSource;
                    this._expectNextPageLoading();
                    dataSource.pageIndex(1 + dataSource.pageIndex());
                    return dataSource.load()
                },
                _expectNextPageLoading: function() {
                    this._startIndexForAppendedItems = 0
                },
                _expectLastItemLoading: function() {
                    this._startIndexForAppendedItems = -1
                },
                _forgetNextPageLoading: function() {
                    this._startIndexForAppendedItems = null
                },
                _dataSourceChangedHandler: function(newItems) {
                    var items = this.option("items");
                    if (this._initialized && items && this._shouldAppendItems()) {
                        this._renderedItemsCount = items.length;
                        if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
                            this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems))
                        }
                        this._forgetNextPageLoading();
                        this._renderContent();
                        this._renderFocusTarget()
                    } else {
                        this.option("items", newItems)
                    }
                },
                _dataSourceLoadErrorHandler: function() {
                    this._forgetNextPageLoading();
                    this.option("items", this.option("items"))
                },
                _shouldAppendItems: function() {
                    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend()
                },
                _allowDynamicItemsAppend: function() {
                    return false
                },
                _clean: function() {
                    this._cleanFocusState();
                    this._cleanItemContainer()
                },
                _cleanItemContainer: function() {
                    this._itemContainer().empty()
                },
                _refresh: function() {
                    this._cleanRenderedItems();
                    this.callBase.apply(this, arguments)
                },
                _itemContainer: function() {
                    return this.element()
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _itemContentClass: function() {
                    return this._itemClass() + CONTENT_CLASS_POSTFIX
                },
                _selectedItemClass: function() {
                    return SELECTED_ITEM_CLASS
                },
                _itemResponseWaitClass: function() {
                    return ITEM_RESPONSE_WAIT_CLASS
                },
                _itemSelector: function() {
                    return "." + this._itemClass()
                },
                _itemDataKey: function() {
                    return ITEM_DATA_KEY
                },
                _itemIndexKey: function() {
                    return ITEM_INDEX_KEY
                },
                _itemElements: function() {
                    return this._itemContainer().find(this._itemSelector())
                },
                _render: function() {
                    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                    this.callBase();
                    this.element().addClass(COLLECTION_CLASS);
                    this._attachClickEvent();
                    this._attachHoldEvent();
                    this._attachContextMenuEvent()
                },
                _attachClickEvent: function() {
                    var itemSelector = this._itemSelector(),
                        clickEventNamespace = eventUtils.addNamespace(clickEvent.name, this.NAME),
                        pointerDownEventNamespace = eventUtils.addNamespace(pointerEvents.down, this.NAME),
                        that = this;
                    var pointerDownAction = new Action(function(args) {
                        var event = args.event;
                        that._itemPointerDownHandler(event)
                    });
                    this._itemContainer().off(clickEventNamespace, itemSelector).off(pointerDownEventNamespace, itemSelector).on(clickEventNamespace, itemSelector, $.proxy(function(e) {
                        this._itemClickHandler(e)
                    }, this)).on(pointerDownEventNamespace, itemSelector, function(e) {
                        pointerDownAction.execute({
                            element: $(e.target),
                            event: e
                        })
                    })
                },
                _itemClickHandler: function(e, args, config) {
                    this._itemJQueryEventHandler(e, "onItemClick", args, config)
                },
                _itemPointerDownHandler: function(e) {
                    if (!this.option("focusStateEnabled")) {
                        return
                    }
                    var $target = $(e.target),
                        $closestItem = $target.closest(this._itemElements()),
                        $closestFocusable = $target.closest(selectors.focusable);
                    if ($closestItem.length && -1 !== $.inArray($closestFocusable.get(0), this._focusTarget())) {
                        this.option("focusedElement", $closestItem)
                    }
                },
                _attachHoldEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = eventUtils.addNamespace(holdEvent.name, this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachHoldEvent()) {
                        $itemContainer.on(eventName, itemSelector, {
                            timeout: this._getHoldTimeout()
                        }, $.proxy(this._itemHoldHandler, this))
                    }
                },
                _getHoldTimeout: function() {
                    return this.option("itemHoldTimeout")
                },
                _shouldAttachHoldEvent: function() {
                    return this.option("onItemHold")
                },
                _itemHoldHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemHold")
                },
                _attachContextMenuEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = eventUtils.addNamespace(contextmenuEvent.name, this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachContextMenuEvent()) {
                        $itemContainer.on(eventName, itemSelector, $.proxy(this._itemContextMenuHandler, this))
                    }
                },
                _shouldAttachContextMenuEvent: function() {
                    return this.option("onItemContextMenu")
                },
                _itemContextMenuHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemContextMenu")
                },
                _renderContentImpl: function() {
                    var items = this.option("items") || [];
                    if (this._renderedItemsCount) {
                        this._renderItems(items.slice(this._renderedItemsCount))
                    } else {
                        this._renderItems(items)
                    }
                },
                _renderItems: function(items) {
                    if (items.length) {
                        $.each(items, $.proxy(this._renderItem, this))
                    }
                    this._renderEmptyMessage()
                },
                _renderItem: function(index, itemData, $container, $itemToReplace) {
                    $container = $container || this._itemContainer();
                    var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);
                    this._setElementData($itemFrame, itemData, index);
                    $itemFrame.attr(this.option("_itemAttributes"));
                    this._attachItemClickEvent(itemData, $itemFrame);
                    var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
                    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                    var renderContentPromise = this._renderItemContent({
                        index: index,
                        itemData: itemData,
                        container: $itemContent,
                        contentClass: this._itemContentClass(),
                        defaultTemplateName: this.option("itemTemplate")
                    });
                    var that = this;
                    $.when(renderContentPromise).done(function($itemContent) {
                        that._postprocessRenderItem({
                            itemElement: $itemFrame,
                            itemContent: $itemContent,
                            itemData: itemData,
                            itemIndex: index
                        });
                        that._executeItemRenderAction(index, itemData, $itemFrame)
                    });
                    return $itemFrame
                },
                _attachItemClickEvent: function(itemData, $itemElement) {
                    if (!itemData || !itemData.onClick) {
                        return
                    }
                    $itemElement.on(clickEvent.name, $.proxy(function(e) {
                        this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
                            jQueryEvent: e
                        })
                    }, this))
                },
                _renderItemContent: function(args) {
                    var itemTemplateName = this._getItemTemplateName(args);
                    var itemTemplate = this._getTemplate(itemTemplateName);
                    this._addItemContentClasses(args);
                    var $templateResult = this._createItemByTemplate(itemTemplate, args);
                    if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                        return args.container
                    }
                    return this._renderItemContentByNode(args, $templateResult)
                },
                _renderItemContentByNode: function(args, $node) {
                    args.container.replaceWith($node);
                    args.container = $node;
                    this._addItemContentClasses(args);
                    return $node
                },
                _addItemContentClasses: function(args) {
                    var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
                    args.container.addClass(classes.join(" "))
                },
                _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
                    var itemFrameTemplate = this.option("templateProvider").getTemplates(this).itemFrame,
                        $itemFrame = itemFrameTemplate.render(commonUtils.isDefined(itemData) ? itemData : {}, $container, index);
                    if ($itemToReplace && $itemToReplace.length) {
                        $itemToReplace.replaceWith($itemFrame)
                    } else {
                        $itemFrame.appendTo($container)
                    }
                    return $itemFrame
                },
                _postprocessRenderItem: $.noop,
                _executeItemRenderAction: function(index, itemData, itemElement) {
                    this._getItemRenderAction()({
                        itemElement: itemElement,
                        itemIndex: index,
                        itemData: itemData
                    })
                },
                _setElementData: function(element, data, index) {
                    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
                },
                _createItemRenderAction: function() {
                    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
                        element: this.element(),
                        excludeValidators: ["designMode", "disabled", "readOnly"],
                        category: "rendering"
                    })
                },
                _getItemRenderAction: function() {
                    return this._itemRenderAction || this._createItemRenderAction()
                },
                _getItemTemplateName: function(args) {
                    var data = args.itemData,
                        templateProperty = args.templateProperty || this.option("itemTemplateProperty"),
                        template = data && data[templateProperty];
                    return template || args.defaultTemplateName
                },
                _createItemByTemplate: function(itemTemplate, renderArgs) {
                    return itemTemplate.render(renderArgs.itemData, renderArgs.container, renderArgs.index, "ignoreTarget")
                },
                _emptyMessageContainer: function() {
                    return this._itemContainer()
                },
                _renderEmptyMessage: function() {
                    var noDataText = this.option("noDataText"),
                        items = this.option("items"),
                        hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
                    if (hideNoData && this._$nodata) {
                        this._$nodata.remove();
                        this._$nodata = null;
                        this.setAria("label", void 0)
                    }
                    if (!hideNoData) {
                        this._$nodata = this._$nodata || $("<div>").addClass("dx-empty-message");
                        this._$nodata.appendTo(this._emptyMessageContainer()).html(noDataText);
                        this.setAria("label", noDataText)
                    }
                    this.element().toggleClass(EMPTY_COLLECTION, !hideNoData)
                },
                _itemJQueryEventHandler: function(jQueryEvent, handlerOptionName, actionArgs, actionConfig) {
                    this._itemEventHandler(jQueryEvent.target, handlerOptionName, $.extend(actionArgs, {
                        jQueryEvent: jQueryEvent
                    }), actionConfig)
                },
                _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
                    var action = this._createActionByOption(handlerOptionName, $.extend({
                        validatingTargetName: "itemElement"
                    }, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
                    var action = this._createAction(handler, $.extend({
                        validatingTargetName: "itemElement"
                    }, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                    var $itemElement = this._closestItemElement($(initiator));
                    return action($.extend(this._extendActionArgs($itemElement), actionArgs))
                },
                _extendActionArgs: function($itemElement) {
                    return {
                        itemElement: $itemElement,
                        itemIndex: this._itemElements().index($itemElement),
                        itemData: this._getItemData($itemElement)
                    }
                },
                _closestItemElement: function($element) {
                    return $($element).closest(this._itemSelector())
                },
                _getItemData: function(itemElement) {
                    return $(itemElement).data(this._itemDataKey())
                },
                getFocusedItemId: function() {
                    if (!this._focusedItemId) {
                        this._focusedItemId = new Guid
                    }
                    return this._focusedItemId
                },
                itemElements: function() {
                    return this._itemElements()
                },
                itemsContainer: function() {
                    return this._itemContainer()
                }
            }).include(DataHelperMixin);
            CollectionWidget.publicName("CollectionWidget");
            module.exports = CollectionWidget
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************************************!*\
      !*** ./Scripts/ui/collection/ui.collection_widget.edit.strategy.js ***!
      \*********************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5),
                abstract = Class.abstract;
            var EditStrategy = Class.inherit({
                ctor: function(collectionWidget) {
                    this._collectionWidget = collectionWidget
                },
                getIndexByItemData: abstract,
                getItemDataByIndex: abstract,
                getNormalizedIndex: function(value) {
                    if (this._isNormalizedItemIndex(value)) {
                        return value
                    }
                    if (this._isItemIndex(value)) {
                        return this._normalizeItemIndex(value)
                    }
                    if (this._isDOMNode(value)) {
                        return this._getNormalizedItemIndex(value)
                    }
                    return this._normalizeItemIndex(this.getIndexByItemData(value))
                },
                getIndex: function(value) {
                    if (this._isNormalizedItemIndex(value)) {
                        return this._denormalizeItemIndex(value)
                    }
                    if (this._isItemIndex(value)) {
                        return value
                    }
                    if (this._isDOMNode(value)) {
                        return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
                    }
                    return this.getIndexByItemData(value)
                },
                getItemElement: function(value) {
                    if (this._isNormalizedItemIndex(value)) {
                        return this._getItemByNormalizedIndex(value)
                    }
                    if (this._isItemIndex(value)) {
                        return this._getItemByNormalizedIndex(this._normalizeItemIndex(value))
                    }
                    if (this._isDOMNode(value)) {
                        return $(value)
                    }
                    return this._getItemByNormalizedIndex(this.getIndexByItemData(value))
                },
                deleteItemAtIndex: abstract,
                updateSelectionAfterDelete: abstract,
                fetchSelectedItems: abstract,
                fetchSelectionDifference: function(addedSelection, removedSelection) {
                    return {
                        addedItems: this.fetchSelectedItems(addedSelection),
                        removedItems: this.fetchSelectedItems(removedSelection)
                    }
                },
                selectedItemIndices: abstract,
                itemPlacementFunc: function(movingIndex, destinationIndex) {
                    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
                },
                moveItemAtIndexToIndex: abstract,
                getSelectedItemsAfterReorderItem: function() {
                    return this._collectionWidget.option("selectedItems")
                },
                _isNormalizedItemIndex: function(index) {
                    return "number" === typeof index && Math.round(index) === index
                },
                _isDOMNode: function(value) {
                    var $value;
                    try {
                        $value = $(value)
                    } catch (error) {
                        return false
                    }
                    return $value && $value.length && $value.get(0).nodeType
                },
                _isItemIndex: abstract,
                _getNormalizedItemIndex: abstract,
                _normalizeItemIndex: abstract,
                _denormalizeItemIndex: abstract,
                _getItemByNormalizedIndex: abstract,
                _itemsFromSameParent: abstract
            });
            module.exports = EditStrategy
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , , , , , , , , , , , ,
    /*!*******************************************************!*\
      !*** ./Scripts/ui/widget/jquery.default_templates.js ***!
      \*******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                inflector = __webpack_require__( /*! ../../core/utils/inflector */ 29),
                iconUtils = __webpack_require__( /*! ../../core/utils/icon */ 77),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                errors = __webpack_require__( /*! ../../core/errors */ 10),
                dateLocalization = __webpack_require__( /*! ../../localization/date */ 14);
            var TEMPLATE_GENERATORS = {};
            var emptyTemplate = function() {
                return $()
            };
            var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
            TEMPLATE_GENERATORS.CollectionWidget = {
                item: function(itemData) {
                    var $itemContent = $("<div>");
                    if ($.isPlainObject(itemData)) {
                        if (itemData.text) {
                            $itemContent.text(itemData.text)
                        }
                        if (itemData.html) {
                            $itemContent.html(itemData.html)
                        }
                    } else {
                        $itemContent.text(String(itemData))
                    }
                    return $itemContent
                },
                itemFrame: function(itemData) {
                    var $itemFrame = $("<div>");
                    $itemFrame.toggleClass("dx-state-invisible", void 0 !== itemData.visible && !itemData.visible);
                    $itemFrame.toggleClass("dx-state-disabled", !!itemData.disabled);
                    var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                    $itemFrame.append($placeholder);
                    return $itemFrame
                }
            };
            var BUTTON_TEXT_CLASS = "dx-button-text";
            TEMPLATE_GENERATORS.dxButton = {
                content: function(itemData) {
                    var $itemContent = $("<div>"),
                        $iconElement = iconUtils.getImageContainer(itemData.icon),
                        $textContainer = itemData.text ? $("<span>").text(itemData.text).addClass(BUTTON_TEXT_CLASS) : void 0;
                    $itemContent.append($iconElement).append($textContainer);
                    return $itemContent
                }
            };
            var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
                LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
                BADGE_CLASS = "dx-badge",
                LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
                LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
            TEMPLATE_GENERATORS.dxList = {
                item: function(itemData) {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                    if (itemData.key) {
                        var $key = $("<div>").text(itemData.key);
                        $key.appendTo($itemContent)
                    }
                    return $itemContent
                },
                itemFrame: function(itemData) {
                    var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                    if (itemData.badge) {
                        var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS),
                            $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                        $badge.text(itemData.badge);
                        $badgeContainer.append($badge).appendTo($itemFrame)
                    }
                    if (itemData.showChevron) {
                        var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS),
                            $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                        $chevronContainer.append($chevron).appendTo($itemFrame)
                    }
                    return $itemFrame
                },
                group: function(groupData) {
                    var $groupContent = $("<div>");
                    if ($.isPlainObject(groupData)) {
                        if (groupData.key) {
                            $groupContent.text(groupData.key)
                        }
                    } else {
                        $groupContent.html(String(groupData))
                    }
                    return $groupContent
                }
            };
            TEMPLATE_GENERATORS.dxDropDownMenu = {
                item: TEMPLATE_GENERATORS.dxList.item,
                content: TEMPLATE_GENERATORS.dxButton.content
            };
            TEMPLATE_GENERATORS.dxDropDownList = {
                item: TEMPLATE_GENERATORS.dxList.item
            };
            TEMPLATE_GENERATORS.dxRadioGroup = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxScheduler = {
                item: function(itemData) {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                    var $details = $("<div>").addClass("dx-scheduler-appointment-content-details");
                    if (itemData.allDay) {
                        $("<div>").text(" All day: ").addClass("dx-scheduler-appointment-content-allday").appendTo($details)
                    }
                    if (itemData.startDate) {
                        $("<div>").text(dateLocalization.format(dateUtils.makeDate(itemData.startDate), "shorttime")).addClass("dx-scheduler-appointment-content-date").appendTo($details)
                    }
                    if (itemData.endDate) {
                        $("<div>").text(" - ").addClass("dx-scheduler-appointment-content-date").appendTo($details);
                        $("<div>").text(dateLocalization.format(dateUtils.makeDate(itemData.endDate), "shorttime")).addClass("dx-scheduler-appointment-content-date").appendTo($details)
                    }
                    $details.appendTo($itemContent);
                    if (itemData.recurrenceRule) {
                        $("<span>").addClass("dx-scheduler-appointment-recurrence-icon dx-icon-repeat").appendTo($itemContent)
                    }
                    return $itemContent
                },
                appointmentTooltip: emptyTemplate,
                appointmentPopup: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxOverlay = {
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOutView = {
                menu: emptyTemplate,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxSlideOut = {
                menuItem: TEMPLATE_GENERATORS.dxList.item,
                menuGroup: TEMPLATE_GENERATORS.dxList.group,
                content: emptyTemplate
            };
            TEMPLATE_GENERATORS.dxAccordion = {
                title: function(titleData) {
                    var $titleContent = $("<div>"),
                        icon = titleData.icon,
                        iconSrc = titleData.iconSrc,
                        $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                    if ($.isPlainObject(titleData)) {
                        if (titleData.title) {
                            $titleContent.text(titleData.title)
                        }
                    } else {
                        $titleContent.html(String(titleData))
                    }
                    $iconElement && $iconElement.prependTo($titleContent);
                    return $titleContent
                },
                item: TEMPLATE_GENERATORS.CollectionWidget.item
            };
            TEMPLATE_GENERATORS.dxActionSheet = {
                item: function(itemData) {
                    return $("<div>").append($("<div>").dxButton($.extend({
                        onClick: itemData.click
                    }, itemData)))
                }
            };
            var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
            TEMPLATE_GENERATORS.dxGallery = {
                item: function(itemData) {
                    var $itemContent = $("<div>"),
                        $img = $("<img>").addClass(GALLERY_IMAGE_CLASS);
                    if ($.isPlainObject(itemData)) {
                        $img.attr({
                            src: itemData.imageSrc,
                            alt: itemData.imageAlt
                        }).appendTo($itemContent)
                    } else {
                        $img.attr("src", String(itemData)).appendTo($itemContent)
                    }
                    return $itemContent
                }
            };
            var DX_MENU_ITEM_CAPTION_CLASS = "dx-menu-item-text",
                DX_MENU_ITEM_POPOUT_CLASS = "dx-menu-item-popout",
                DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = "dx-menu-item-popout-container";
            TEMPLATE_GENERATORS.dxMenuBase = {
                item: function(itemData) {
                    var $itemContent = $("<div>"),
                        icon = itemData.icon,
                        iconSrc = itemData.iconSrc,
                        $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                    $iconElement && $iconElement.appendTo($itemContent);
                    var $itemCaption;
                    if (!commonUtils.isPrimitive(itemData) && itemData.text) {
                        $itemCaption = $("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS).text(itemData.text)
                    } else {
                        if (!$.isPlainObject(itemData)) {
                            $itemCaption = $("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS).html(String(itemData))
                        }
                    }
                    $itemContent.append($itemCaption);
                    var $popOutImage, $popOutContainer;
                    if (itemData.items && itemData.items.length > 0) {
                        $popOutContainer = $("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).appendTo($itemContent);
                        $popOutImage = $("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS).appendTo($popOutContainer)
                    }
                    return $itemContent
                }
            };
            var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
            TEMPLATE_GENERATORS.dxPanorama = {
                itemFrame: function(itemData) {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                    if (itemData.title) {
                        var $itemHeader = $("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).text(itemData.title);
                        $itemContent.prepend($itemHeader)
                    }
                    return $itemContent
                }
            };
            TEMPLATE_GENERATORS.dxPivotTabs = {
                item: function(itemData) {
                    var $itemContent = $("<div>");
                    var $itemText;
                    if (itemData && itemData.title) {
                        $itemText = $("<span>").text(itemData.title)
                    } else {
                        $itemText = $("<span>").text(String(itemData))
                    }
                    $itemContent.html($itemText);
                    return $itemContent
                }
            };
            TEMPLATE_GENERATORS.dxPivot = {
                title: TEMPLATE_GENERATORS.dxPivotTabs.item,
                content: emptyTemplate
            };
            var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
            TEMPLATE_GENERATORS.dxTabs = {
                item: function(itemData) {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                    if (itemData.html) {
                        return $itemContent
                    }
                    var icon = itemData.icon,
                        iconSrc = itemData.iconSrc,
                        $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                    if (!itemData.html) {
                        $itemContent.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS))
                    }
                    $iconElement && $iconElement.prependTo($itemContent);
                    return $itemContent
                },
                itemFrame: function(itemData) {
                    var $badge = $(),
                        $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                    if (itemData.badge) {
                        $badge = $("<div>", {
                            "class": "dx-tabs-item-badge dx-badge"
                        }).text(itemData.badge)
                    }
                    $itemFrame.append($badge);
                    return $itemFrame
                }
            };
            TEMPLATE_GENERATORS.dxTabPanel = {
                item: TEMPLATE_GENERATORS.CollectionWidget.item,
                title: function(itemData) {
                    var itemTitleData = itemData;
                    if ($.isPlainObject(itemData)) {
                        itemTitleData = $.extend({}, itemData, {
                            text: itemData.title,
                            html: null
                        })
                    }
                    var $title = TEMPLATE_GENERATORS.dxTabs.item(itemTitleData);
                    return $title
                }
            };
            var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
            TEMPLATE_GENERATORS.dxNavBar = {
                itemFrame: function(itemData) {
                    var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                    if (itemData.badge) {
                        var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                        $badge.text(itemData.badge);
                        $badge.appendTo($itemFrame)
                    }
                    return $itemFrame
                }
            };
            TEMPLATE_GENERATORS.dxToolbarBase = {
                item: function(itemData) {
                    var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                    var widgetName = itemData.widget;
                    if (widgetName) {
                        var widgetElement = $("<div>").appendTo($itemContent),
                            options = itemData.options || {};
                        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                            var depricatedName = widgetName;
                            widgetName = inflector.camelize("dx-" + widgetName);
                            errors.log("W0001", "dxToolbar - 'widget' item field", depricatedName, "16.1", "Use: '" + widgetName + "' instead")
                        }
                        widgetElement[widgetName](options)
                    } else {
                        if (itemData.text) {
                            $itemContent.wrapInner("<div>")
                        }
                    }
                    return $itemContent
                },
                actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
            };
            TEMPLATE_GENERATORS.dxToolbarBase.menuItem = TEMPLATE_GENERATORS.dxToolbarBase.item;
            TEMPLATE_GENERATORS.dxTreeView = {
                item: function(itemData) {
                    var $itemContent = $("<div>"),
                        icon = itemData.icon,
                        iconSrc = itemData.iconSrc,
                        $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                    if (itemData.html) {
                        $itemContent.html(itemData.html)
                    } else {
                        $iconElement && $iconElement.appendTo($itemContent);
                        $("<span>").text(itemData.text).appendTo($itemContent)
                    }
                    return $itemContent
                }
            };
            var popupTitleAndBottom = function(itemData) {
                return $("<div>").append($("<div>").dxToolbarBase({
                    items: itemData
                }))
            };
            TEMPLATE_GENERATORS.dxPopup = {
                title: popupTitleAndBottom,
                bottom: popupTitleAndBottom
            };
            TEMPLATE_GENERATORS.dxLookup = {
                title: TEMPLATE_GENERATORS.dxPopup.title,
                group: TEMPLATE_GENERATORS.dxList.group
            };
            var TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
                TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button";
            TEMPLATE_GENERATORS.dxTagBox = {
                tag: function(itemData, index, $tag) {
                    var $tagContent = $("<div>").addClass(TAGBOX_TAG_CONTENT_CLASS);
                    $("<span>").text(itemData).appendTo($tagContent);
                    $("<div>").addClass(TAGBOX_TAG_REMOVE_BUTTON_CLASS).appendTo($tagContent);
                    return $("<div>").append($tagContent)
                }
            };
            TEMPLATE_GENERATORS.dxCalendar = {
                cell: function(itemData) {
                    return $("<div>").append($("<span>").text(itemData.text || String(itemData)))
                }
            };
            module.exports = TEMPLATE_GENERATORS
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/ui/widget/ui.template.empty.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                TemplateBase = __webpack_require__( /*! ./ui.template_base */ 47);
            var EmptyTemplate = TemplateBase.inherit({
                ctor: function(owner) {
                    this.callBase($(), owner)
                },
                _renderCore: function() {
                    return $()
                }
            });
            module.exports = EmptyTemplate
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/ui/widget/ui.template_provider_base.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                Class = __webpack_require__( /*! ../../core/class */ 5);
            var abstract = Class.abstract;
            var TemplateProviderBase = Class.inherit({
                ctor: function() {
                    this.widgetTemplatesCache = {}
                },
                createTemplate: abstract,
                getTemplates: function(widget) {
                    return this._getWidgetTemplates(widget.constructor)
                },
                _getWidgetTemplates: function(widgetConstructor) {
                    if (!widgetConstructor.publicName) {
                        return {}
                    }
                    return this._getCachedWidgetTemplates(widgetConstructor)
                },
                _getCachedWidgetTemplates: function(widgetConstructor) {
                    var widgetName = widgetConstructor.publicName(),
                        templatesCache = this.widgetTemplatesCache;
                    if (!templatesCache[widgetName]) {
                        templatesCache[widgetName] = $.extend({}, this._getWidgetTemplates(widgetConstructor.parent), this._templatesForWidget(widgetName))
                    }
                    return templatesCache[widgetName]
                },
                _templatesForWidget: abstract
            });
            module.exports = TemplateProviderBase
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/axes/base_tick_manager.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var TickManager, $ = __webpack_require__( /*! jquery */ 1),
                coreTickManager = __webpack_require__( /*! ./numeric_tick_manager */ 189),
                dateTimeManager = __webpack_require__( /*! ./datetime_tick_manager */ 499),
                overlappingMethods = __webpack_require__( /*! ./tick_overlapping_manager */ 502),
                logarithmicMethods = __webpack_require__( /*! ./logarithmic_tick_manager */ 500),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                formatHelper = __webpack_require__( /*! ../../format_helper */ 68),
                _isDefined = commonUtils.isDefined,
                _isNumber = commonUtils.isNumber,
                _addInterval = dateUtils.addInterval,
                utils = __webpack_require__( /*! ../core/utils */ 6),
                _adjustValue = utils.adjustValue,
                _map = utils.map,
                _each = $.each,
                _inArray = $.inArray,
                _noop = $.noop,
                DEFAULT_GRID_SPACING_FACTOR = 30,
                DEFAULT_MINOR_GRID_SPACING_FACTOR = 15,
                DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 3, 5],
                TICKS_COUNT_LIMIT = 2e3,
                MIN_ARRANGEMENT_TICKS_COUNT = 2;

            function getUniqueValues(array) {
                var currentValue, lastValue = array[0],
                    result = [lastValue.obj],
                    length = array.length,
                    i = 1;
                for (i; i < length; i++) {
                    currentValue = array[i];
                    if (lastValue.value !== currentValue.value) {
                        result.push(currentValue.obj);
                        lastValue = currentValue
                    }
                }
                return result
            }

            function concatAndSort(array1, array2) {
                if (!array1.length && !array2.length) {
                    return []
                }
                var array = array1.concat(array2),
                    values = [],
                    length = array.length,
                    hasNull = false,
                    i = 0;
                for (i; i < length; i++) {
                    if (null !== array[i]) {
                        values.push({
                            obj: array[i],
                            value: array[i].valueOf()
                        })
                    } else {
                        hasNull = true
                    }
                }
                values.sort(function(x, y) {
                    return x.value - y.value
                });
                values = getUniqueValues(values);
                hasNull && values.push(null);
                return values
            }
            exports.discrete = $.extend({}, coreTickManager.continuous, {
                _calculateMinorTicks: _noop,
                _findTickInterval: _noop,
                _createTicks: function() {
                    return []
                },
                _getMarginValue: _noop,
                _generateBounds: _noop,
                _correctMin: _noop,
                _correctMax: _noop,
                _findBusinessDelta: _noop,
                _addBoundedTicks: _noop,
                getFullTicks: function() {
                    return this._customTicks
                },
                getMinorTicks: function() {
                    return this._decimatedTicks || []
                },
                _findTickIntervalForCustomTicks: function() {
                    return 1
                }
            });
            TickManager = exports.TickManager = function(types, data, options) {
                options = options || {};
                this.update(types || {}, data || {}, options);
                this._initOverlappingMethods(options.overlappingBehaviorType)
            };
            TickManager.prototype = {
                constructor: TickManager,
                dispose: function() {
                    this._ticks = null;
                    this._minorTicks = null;
                    this._decimatedTicks = null;
                    this._boundaryTicks = null;
                    this._options = null
                },
                update: function(types, data, options) {
                    this._updateOptions(options || {});
                    this._min = data.min;
                    this._updateTypes(types || {});
                    this._updateData(data || {})
                },
                _updateMinMax: function(data) {
                    var min = data.min || 0,
                        max = data.max || 0,
                        newMinMax = this._applyMinMaxMargins(min, max);
                    this._min = this._originalMin = newMinMax.min;
                    this._max = this._originalMax = newMinMax.max;
                    this._updateBusinessDelta()
                },
                _updateBusinessDelta: function() {
                    this._businessDelta = this._findBusinessDelta && this._findBusinessDelta(this._min, this._max)
                },
                _updateTypes: function(types) {
                    var that = this,
                        axisType = that._validateAxisType(types.axisType),
                        dataType = that._validateDataType(types.dataType);
                    that._resetMethods();
                    this._axisType = axisType;
                    this._dataType = dataType;
                    this._initMethods()
                },
                _updateData: function(data) {
                    data = $.extend({}, data);
                    data.min = _isDefined(data.min) ? data.min : this._originalMin;
                    data.max = _isDefined(data.max) ? data.max : this._originalMax;
                    this._updateMinMax(data);
                    this._customTicks = data.customTicks && data.customTicks.slice();
                    this._customMinorTicks = data.customMinorTicks;
                    this._customBoundTicks = data.customBoundTicks;
                    this._screenDelta = data.screenDelta || 0
                },
                _updateOptions: function(options) {
                    var opt;
                    this._options = opt = options;
                    this._useAutoArrangement = !!this._options.useTicksAutoArrangement;
                    opt.gridSpacingFactor = opt.gridSpacingFactor || DEFAULT_GRID_SPACING_FACTOR;
                    opt.minorGridSpacingFactor = opt.minorGridSpacingFactor || DEFAULT_MINOR_GRID_SPACING_FACTOR;
                    opt.numberMultipliers = opt.numberMultipliers || DEFAULT_NUMBER_MULTIPLIERS
                },
                getTickBounds: function() {
                    return {
                        minVisible: this._minBound,
                        maxVisible: this._maxBound
                    }
                },
                getTicks: function(withoutOverlappingBehavior) {
                    var that = this,
                        options = that._options;
                    that._ticks = that._calculateMajorTicks();
                    that._checkLabelFormat();
                    that._decimatedTicks = [];
                    that._applyAutoArrangement();
                    !withoutOverlappingBehavior && that._applyOverlappingBehavior();
                    that._generateBounds();
                    if (options.showMinorTicks) {
                        that._minorTicks = that._calculateMinorTicks()
                    }
                    that._addBoundedTicks();
                    return that._ticks
                },
                getMinorTicks: function() {
                    var that = this,
                        decimatedTicks = that.getDecimatedTicks(),
                        options = that._options || {},
                        hasDecimatedTicks = decimatedTicks.length,
                        hasMinorTickOptions = _isDefined(options.minorTickInterval) || _isDefined(options.minorTickCount),
                        hasCustomMinorTicks = that._customMinorTicks && that._customMinorTicks.length,
                        hasMinorTicks = options.showMinorTicks && (hasMinorTickOptions || hasCustomMinorTicks),
                        ticks = hasDecimatedTicks && !hasMinorTicks ? decimatedTicks : that._minorTicks || [];
                    return concatAndSort(ticks, [])
                },
                getDecimatedTicks: function() {
                    return this._decimatedTicks || []
                },
                getFullTicks: function() {
                    var that = this,
                        needCalculateMinorTicks = that._ticks && !that._minorTicks,
                        minorTicks = needCalculateMinorTicks ? that._calculateMinorTicks() : that._minorTicks || [];
                    return concatAndSort(that._ticks || [], minorTicks.concat(that.getBoundaryTicks()))
                },
                getBoundaryTicks: function() {
                    return this._boundaryTicks || []
                },
                getTickInterval: function() {
                    return this._tickInterval
                },
                getMinorTickInterval: function() {
                    return this._minorTickInterval
                },
                getOverlappingBehavior: function() {
                    return this._options.overlappingBehavior
                },
                getOptions: function() {
                    return this._options
                },
                _calculateMajorTicks: function() {
                    var ticks, that = this;
                    if (that._options.showCalculatedTicks || !that._customTicks) {
                        ticks = that._createTicks(that._options.showCalculatedTicks ? that._customTicks || [] : [], that._findTickInterval(), that._min, that._max)
                    } else {
                        ticks = that._customTicks.slice();
                        that._tickInterval = ticks.length > 1 ? that._findTickIntervalForCustomTicks() : 0
                    }
                    return ticks
                },
                _applyMargin: function(margin, min, max, isNegative) {
                    var coef, value = min;
                    if (isFinite(margin)) {
                        coef = this._getMarginValue(min, max, margin);
                        if (coef) {
                            value = this._getNextTickValue(min, coef, isNegative, false)
                        }
                    }
                    return value
                },
                _applyMinMaxMargins: function(min, max) {
                    var options = this._options,
                        newMin = min > max ? max : min,
                        newMax = max > min ? max : min;
                    this._minCorrectionEnabled = this._getCorrectionEnabled(min, "min");
                    this._maxCorrectionEnabled = this._getCorrectionEnabled(max, "max");
                    if (options && !options.stick) {
                        newMin = this._applyMargin(options.minValueMargin, min, max, true);
                        newMax = this._applyMargin(options.maxValueMargin, max, min, false)
                    }
                    return {
                        min: newMin,
                        max: newMax
                    }
                },
                _checkBoundedTickInArray: function(value, array) {
                    var arrayValues = _map(array || [], function(item) {
                            return item.valueOf()
                        }),
                        minorTicksIndex = _inArray(value.valueOf(), arrayValues);
                    if (-1 !== minorTicksIndex) {
                        array.splice(minorTicksIndex, 1)
                    }
                },
                _checkLabelFormat: function() {
                    var options = this._options;
                    if ("datetime" === this._dataType && !options.hasLabelFormat && this._ticks.length) {
                        options.labelOptions.format = options.isMarkersVisible ? dateUtils.getDateFormatByTickInterval(this._tickInterval) : formatHelper.getDateFormatByTicks(this._ticks)
                    }
                },
                _generateBounds: function() {
                    var that = this,
                        interval = that._getBoundInterval(),
                        stick = that._options.stick,
                        minStickValue = that._options.minStickValue,
                        maxStickValue = that._options.maxStickValue,
                        minBound = that._minCorrectionEnabled && !stick ? that._getNextTickValue(that._min, interval, true) : that._originalMin,
                        maxBound = that._maxCorrectionEnabled && !stick ? that._getNextTickValue(that._max, interval) : that._originalMax;
                    that._minBound = minBound < minStickValue ? minStickValue : minBound;
                    that._maxBound = maxBound > maxStickValue ? maxStickValue : maxBound
                },
                _initOverlappingMethods: function(type) {
                    this._initMethods(overlappingMethods[type || "linear"])
                },
                _addBoundedTicks: function() {
                    var that = this,
                        tickValues = _map(that._ticks, function(tick) {
                            return tick.valueOf()
                        }),
                        customBounds = that._customBoundTicks,
                        min = that._originalMin,
                        max = that._originalMax,
                        addMinMax = that._options.addMinMax || {};

                    function processTick(tick) {
                        that._boundaryTicks.push(tick);
                        that._checkBoundedTickInArray(tick, that._minorTicks);
                        that._checkBoundedTickInArray(tick, that._decimatedTicks)
                    }
                    that._boundaryTicks = [];
                    if (customBounds) {
                        if (addMinMax.min && _isDefined(customBounds[0])) {
                            processTick(customBounds[0])
                        }
                        if (addMinMax.max && _isDefined(customBounds[1])) {
                            processTick(customBounds[1])
                        }
                    } else {
                        if (addMinMax.min && -1 === _inArray(min.valueOf(), tickValues)) {
                            processTick(min)
                        }
                        if (addMinMax.max && -1 === _inArray(max.valueOf(), tickValues)) {
                            processTick(max)
                        }
                    }
                },
                _getCorrectionEnabled: function(value, marginSelector) {
                    var options = this._options || {},
                        hasPercentStick = options.percentStick && 1 === Math.abs(value),
                        hasValueMargin = options[marginSelector + "ValueMargin"];
                    return !hasPercentStick && !hasValueMargin
                },
                _validateAxisType: function(type) {
                    var defaultType = "continuous",
                        allowedTypes = {
                            continuous: true,
                            discrete: true,
                            logarithmic: true
                        };
                    return allowedTypes[type] ? type : defaultType
                },
                _validateDataType: function(type) {
                    var allowedTypes = {
                        numeric: true,
                        datetime: true,
                        string: true
                    };
                    if (!allowedTypes[type]) {
                        type = _isDefined(this._min) ? this._getDataType(this._min) : "numeric"
                    }
                    return type
                },
                _getDataType: function(value) {
                    return commonUtils.isDate(value) ? "datetime" : "numeric"
                },
                _getMethods: function() {
                    var methods;
                    if ("continuous" === this._axisType) {
                        methods = "datetime" === this._dataType ? dateTimeManager.datetime : coreTickManager.continuous
                    } else {
                        switch (this._axisType) {
                            case "discrete":
                                methods = exports.discrete;
                                break;
                            case "logarithmic":
                                methods = logarithmicMethods.logarithmic;
                                break;
                            default:
                                methods = coreTickManager.continuous
                        }
                    }
                    return methods
                },
                _resetMethods: function() {
                    var that = this,
                        methods = that._getMethods();
                    _each(methods, function(name) {
                        if (that[name]) {
                            delete that[name]
                        }
                    })
                },
                _initMethods: function(methods) {
                    var that = this;
                    methods = methods || that._getMethods();
                    _each(methods, function(name, func) {
                        that[name] = func
                    })
                },
                _getDeltaCoef: function(screenDelta, businessDelta, gridSpacingFactor) {
                    var count;
                    gridSpacingFactor = gridSpacingFactor || this._options.gridSpacingFactor;
                    screenDelta = screenDelta || this._screenDelta;
                    businessDelta = businessDelta || this._businessDelta;
                    count = screenDelta / gridSpacingFactor;
                    count = count <= 1 ? MIN_ARRANGEMENT_TICKS_COUNT : count;
                    return businessDelta / count
                },
                _adjustNumericTickValue: function(value, interval, min) {
                    return commonUtils.isExponential(value) ? _adjustValue(value) : utils.applyPrecisionByMinDelta(min, interval, value)
                },
                _isTickIntervalCorrect: function(tickInterval, tickCountLimit, businessDelta) {
                    var date;
                    businessDelta = businessDelta || this._businessDelta;
                    if (!_isNumber(tickInterval)) {
                        date = new Date;
                        tickInterval = _addInterval(date, tickInterval) - date;
                        if (!tickInterval) {
                            return false
                        }
                    }
                    if (_isNumber(tickInterval)) {
                        if (tickInterval > 0 && businessDelta / tickInterval > tickCountLimit) {
                            if (this._options.incidentOccurred) {
                                this._options.incidentOccurred("W2003")
                            }
                        } else {
                            return true
                        }
                    }
                    return false
                },
                _correctValue: function(valueTypeSelector, tickInterval, correctionMethod) {
                    var that = this,
                        correctionEnabledSelector = "_" + valueTypeSelector + "CorrectionEnabled",
                        spaceCorrectionSelector = valueTypeSelector + "SpaceCorrection",
                        valueSelector = "_" + valueTypeSelector,
                        minStickValue = that._options.minStickValue,
                        maxStickValue = that._options.maxStickValue;
                    if (that[correctionEnabledSelector]) {
                        if (that._options[spaceCorrectionSelector]) {
                            that[valueSelector] = that._getNextTickValue(that[valueSelector], tickInterval, "min" === valueTypeSelector)
                        }
                        correctionMethod.call(this, tickInterval)
                    }
                    if ("min" === valueTypeSelector) {
                        that[valueSelector] = that[valueSelector] < minStickValue ? minStickValue : that[valueSelector]
                    }
                    if ("max" === valueTypeSelector) {
                        that[valueSelector] = that[valueSelector] > maxStickValue ? maxStickValue : that[valueSelector]
                    }
                },
                _findTickInterval: function() {
                    var tickInterval, that = this,
                        options = that._options,
                        calculatedTickInterval = that._getInterval(),
                        userTickInterval = that._isTickIntervalValid(options.tickInterval) && that._isTickIntervalCorrect(options.tickInterval, TICKS_COUNT_LIMIT) && options.tickInterval;
                    tickInterval = that.checkUserTickInterval(userTickInterval, calculatedTickInterval);
                    if (that._isTickIntervalValid(tickInterval)) {
                        that._correctValue("min", tickInterval, that._correctMin);
                        that._correctValue("max", tickInterval, that._correctMax);
                        that._updateBusinessDelta()
                    }
                    that._tickInterval = tickInterval;
                    return tickInterval
                },
                _findMinorTickInterval: function(firstTick, secondTick) {
                    var that = this,
                        ticks = that._ticks,
                        intervals = that._options.stick ? ticks.length - 1 : ticks.length;
                    if (intervals < 1) {
                        intervals = 1
                    }
                    that._getMinorInterval(that._screenDelta / intervals, that._findBusinessDelta(firstTick, secondTick, false));
                    return that._minorTickInterval
                },
                _createMinorTicks: function(ticks, firstTick, secondTick) {
                    var that = this,
                        tickInterval = that._findMinorTickInterval(firstTick, secondTick),
                        isTickIntervalNegative = false,
                        isTickIntervalWithPow = false,
                        needCorrectTick = false,
                        startTick = that._getNextTickValue(firstTick, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                    if (that._isTickIntervalValid(tickInterval)) {
                        ticks = that._createCountedTicks(ticks, tickInterval, startTick, secondTick, that._minorTickCount, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick)
                    }
                    return ticks
                },
                _calculateMinorTicks: function() {
                    var that = this,
                        options = that._options,
                        minorTicks = [],
                        ticks = that._ticks,
                        ticksLength = ticks.length,
                        hasUnitBeginningTick = that._hasUnitBeginningTickCorrection(),
                        i = hasUnitBeginningTick ? 1 : 0;
                    if (options.showMinorCalculatedTicks || !that._customMinorTicks) {
                        if (ticks.length) {
                            minorTicks = that._getBoundedMinorTicks(minorTicks, that._minBound, ticks[0], true);
                            if (hasUnitBeginningTick) {
                                minorTicks = that._getUnitBeginningMinorTicks(minorTicks)
                            }
                            for (i; i < ticksLength - 1; i++) {
                                minorTicks = that._createMinorTicks(minorTicks, ticks[i], ticks[i + 1])
                            }
                            minorTicks = that._getBoundedMinorTicks(minorTicks, that._maxBound, ticks[ticksLength - 1])
                        } else {
                            minorTicks = that._createMinorTicks(minorTicks, that._minBound, that._maxBound)
                        }
                        options.showMinorCalculatedTicks && (minorTicks = minorTicks.concat(that._customMinorTicks || []))
                    } else {
                        minorTicks = that._customMinorTicks
                    }
                    return minorTicks
                },
                _createCountedTicks: function(ticks, tickInterval, min, max, count, isTickIntervalWithPow, needMax) {
                    var i, value = min;
                    for (i = 0; i < count; i++) {
                        if (!(false === needMax && value.valueOf() === max.valueOf())) {
                            ticks.push(value)
                        }
                        value = this._getNextTickValue(value, tickInterval, false, isTickIntervalWithPow, false)
                    }
                    return ticks
                },
                _createTicks: function(ticks, tickInterval, min, max, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
                    var leftBound, rightBound, boundedRule, that = this,
                        value = min,
                        newValue = min;
                    if (that._isTickIntervalValid(tickInterval)) {
                        boundedRule = min - max < 0;
                        do {
                            value = newValue;
                            if (that._options.stick) {
                                if (value >= that._originalMin && value <= that._originalMax) {
                                    ticks.push(value)
                                }
                            } else {
                                ticks.push(value)
                            }
                            newValue = that._getNextTickValue(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection);
                            if (value.valueOf() === newValue.valueOf()) {
                                break
                            }
                            leftBound = newValue - min >= 0;
                            rightBound = max - newValue >= 0
                        } while (boundedRule === leftBound && boundedRule === rightBound)
                    } else {
                        ticks.push(value)
                    }
                    return ticks
                },
                _getBoundedMinorTicks: function(minorTicks, boundedTick, tick, isNegative) {
                    var startTick, endTick, that = this,
                        needCorrectTick = false,
                        nextTick = that._tickInterval ? this._getNextTickValue(tick, that._tickInterval, isNegative, true, needCorrectTick) : boundedTick,
                        tickInterval = that._findMinorTickInterval(tick, nextTick),
                        isTickIntervalCorrect = that._isTickIntervalCorrect(tickInterval, TICKS_COUNT_LIMIT, that._findBusinessDelta(tick, boundedTick, false)),
                        boundedTickValue = boundedTick.valueOf();
                    if (isTickIntervalCorrect && that._isTickIntervalValid(tickInterval) && that._minorTickCount > 0) {
                        if (isNegative) {
                            if (tick.valueOf() <= boundedTickValue) {
                                return minorTicks
                            }
                            while (nextTick.valueOf() < boundedTickValue) {
                                nextTick = this._getNextTickValue(nextTick, tickInterval, false, false, needCorrectTick)
                            }
                            startTick = nextTick;
                            endTick = that._getNextTickValue(tick, tickInterval, true, false, false)
                        } else {
                            startTick = that._getNextTickValue(tick, tickInterval, false, false, false);
                            endTick = boundedTick
                        }
                        minorTicks = that._createTicks(minorTicks, tickInterval, startTick, endTick, false, false, needCorrectTick)
                    }
                    return minorTicks
                },
                getTypes: function() {
                    return {
                        axisType: this._axisType,
                        dataType: this._dataType
                    }
                },
                getData: function() {
                    return {
                        min: this._min,
                        max: this._max,
                        customTicks: this._customTicks,
                        customMinorTicks: this._customMinorTicks,
                        screenDelta: this._screenDelta
                    }
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/axes/xy_axes.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                formatHelper = __webpack_require__( /*! ../../format_helper */ 68),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _isDefined = commonUtils.isDefined,
                constants = __webpack_require__( /*! ./axes_constants */ 230),
                _extend = $.extend,
                CANVAS_POSITION_PREFIX = constants.canvasPositionPrefix,
                TOP = constants.top,
                BOTTOM = constants.bottom,
                LEFT = constants.left,
                RIGHT = constants.right,
                CENTER = constants.center;
            var dateSetters = {
                millisecond: function(date) {
                    date.setMilliseconds(0)
                },
                second: function(date) {
                    date.setSeconds(0, 0)
                },
                minute: function(date) {
                    date.setMinutes(0, 0, 0)
                },
                hour: function(date) {
                    date.setHours(0, 0, 0, 0)
                },
                month: function(date) {
                    date.setMonth(0);
                    dateSetters.day(date)
                },
                quarter: function(date) {
                    date.setMonth(dateUtils.getFirstQuarterMonth(date.getMonth()));
                    dateSetters.day(date)
                }
            };
            dateSetters.week = dateSetters.day = function(date) {
                date.setDate(1);
                dateSetters.hour(date)
            };

            function getMarkerDate(date, tickInterval) {
                var markerDate = new Date(date.getTime()),
                    setter = dateSetters[tickInterval];
                setter && setter(markerDate);
                return markerDate
            }
            module.exports = {
                linear: {
                    measureLabels: function() {
                        return this._tickManager.getMaxLabelParams()
                    },
                    getMarkerTrackers: function() {
                        return this._markerTrackers
                    },
                    _prepareDatesDifferences: function(datesDifferences, tickInterval) {
                        var dateUnitInterval, i;
                        if ("week" === tickInterval) {
                            tickInterval = "day"
                        }
                        if ("quarter" === tickInterval) {
                            tickInterval = "month"
                        }
                        if (datesDifferences[tickInterval]) {
                            for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {
                                dateUnitInterval = dateUtils.dateUnitIntervals[i];
                                if (datesDifferences[dateUnitInterval]) {
                                    datesDifferences[dateUnitInterval] = false;
                                    datesDifferences.count--
                                }
                                if (dateUnitInterval === tickInterval) {
                                    break
                                }
                            }
                        }
                    },
                    _getSharpParam: function(opposite) {
                        return this._isHorizontal ^ opposite ? "h" : "v"
                    },
                    _createAxisElement: function() {
                        var axisCoord = this._axisPosition,
                            canvas = this._getCanvasStartEnd(),
                            points = this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end];
                        return this._renderer.path(points, "line")
                    },
                    _getTranslatedCoord: function(value, offset) {
                        return this._translator.translate(value, offset)
                    },
                    _getCanvasStartEnd: function() {
                        return {
                            start: this._translator.translateSpecialCase(constants.canvasPositionStart),
                            end: this._translator.translateSpecialCase(constants.canvasPositionEnd)
                        }
                    },
                    _getScreenDelta: function() {
                        return Math.abs(this._translator.translateSpecialCase(constants.canvasPositionStart) - this._translator.translateSpecialCase(constants.canvasPositionEnd))
                    },
                    _initAxisPositions: function() {
                        var that = this,
                            position = that._options.position,
                            delta = 0;
                        if (that.delta) {
                            delta = that.delta[position] || 0
                        }
                        that._axisPosition = that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + position) + delta
                    },
                    _getTickCoord: function(tick) {
                        var coords, corrections = {
                                top: -1,
                                middle: -.5,
                                bottom: 0,
                                left: -1,
                                center: -.5,
                                right: 0
                            },
                            tickCorrection = corrections[this._options.tickOrientation || "center"];
                        if (_isDefined(tick.posX) && _isDefined(tick.posY)) {
                            coords = {
                                x1: tick.posX,
                                y1: tick.posY + tickCorrection * tick.length,
                                x2: tick.posX,
                                y2: tick.posY + tickCorrection * tick.length + tick.length
                            }
                        } else {
                            coords = null
                        }
                        return coords
                    },
                    _drawTitle: function() {
                        var that = this,
                            options = that._options,
                            titleOptions = options.title,
                            attr = {
                                opacity: titleOptions.opacity,
                                align: CENTER
                            };
                        if (!titleOptions.text || !that._axisTitleGroup) {
                            return
                        }
                        that._title = that._renderer.text(titleOptions.text, 0, 0).css(vizUtils.patchFontOptions(titleOptions.font)).attr(attr).append(that._axisTitleGroup)
                    },
                    _drawDateMarker: function(dateMarker, options) {
                        var labelPosX, labelPosY, textElement, textSize, textIndent, pathElement, that = this,
                            markerOptions = that._options.marker;
                        if (null === options.x) {
                            return
                        }
                        if (!options.withoutStick) {
                            pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], "line").attr({
                                "stroke-width": markerOptions.width,
                                stroke: markerOptions.color,
                                "stroke-opacity": markerOptions.opacity,
                                sharp: "h"
                            }).append(that._axisElementsGroup)
                        }
                        textElement = that._renderer.text(String(constants.formatLabel(dateMarker, options.labelFormat)), 0, 0).attr({
                            align: "left"
                        }).css(vizUtils.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup);
                        textSize = textElement.getBBox();
                        textIndent = markerOptions.width + markerOptions.textLeftIndent;
                        labelPosX = this._translator.getBusinessRange().invert ? options.x - textIndent - textSize.width : options.x + textIndent;
                        labelPosY = options.y + markerOptions.textTopIndent + textSize.height / 2;
                        textElement.move(labelPosX, labelPosY);
                        return {
                            labelStartPosX: labelPosX,
                            labelEndPosX: labelPosX + textSize.width,
                            path: pathElement,
                            text: textElement,
                            date: dateMarker,
                            dateMarkerStartPosX: options.x
                        }
                    },
                    _disposeDateMarker: function(marker) {
                        marker.path && marker.path.dispose();
                        marker.path = null;
                        marker.text.dispose();
                        marker.text = null
                    },
                    _getDiff: function(currentValue, previousValue) {
                        var datesDifferences = dateUtils.getDatesDifferences(previousValue, currentValue);
                        this._prepareDatesDifferences(datesDifferences, this._dateUnitInterval);
                        return datesDifferences
                    },
                    _drawDateMarkers: function() {
                        var prevDateMarker, markersAreaTop, dateMarker, markerDate, diff, that = this,
                            options = that._options,
                            ticks = that._majorTicks,
                            boundaryTicks = that._boundaryTicks,
                            lastIndexOfBoundaryTicks = boundaryTicks.length - 1,
                            length = ticks.length,
                            dateMarkers = [],
                            i = 1;
                        boundaryTicks[0] && ticks[0].value > boundaryTicks[0].value && ticks.unshift(boundaryTicks[0]);
                        boundaryTicks[lastIndexOfBoundaryTicks] && ticks[length - 1].value < boundaryTicks[lastIndexOfBoundaryTicks].value && ticks.push(boundaryTicks[lastIndexOfBoundaryTicks]);
                        length = ticks.length;
                        if ("datetime" !== options.argumentType || "discrete" === options.type || length <= 1) {
                            return
                        }
                        markersAreaTop = that._axisPosition + this._axisElementsGroup.getBBox().height + options.label.indentFromAxis + options.marker.topIndent;
                        that._dateUnitInterval = dateUtils.getDateUnitInterval(this._tickManager.getTickInterval());
                        for (i; i < length; i++) {
                            diff = that._getDiff(ticks[i].value, ticks[i - 1].value);
                            if (diff.count > 0) {
                                markerDate = getMarkerDate(ticks[i].value, that._dateUnitInterval);
                                dateMarker = that._drawDateMarker(markerDate, {
                                    x: that._translator.translate(markerDate),
                                    y: markersAreaTop,
                                    labelFormat: that._getLabelFormatOptions(formatHelper.getDateFormatByDifferences(diff))
                                });
                                if (dateMarker) {
                                    if (that._checkMarkersPosition(dateMarker, prevDateMarker)) {
                                        dateMarkers.push(dateMarker);
                                        prevDateMarker = dateMarker
                                    } else {
                                        that._disposeDateMarker(dateMarker)
                                    }
                                }
                            }
                        }
                        if (dateMarkers.length) {
                            dateMarker = that._drawDateMarker(ticks[0].value, {
                                x: that._translator.translate(ticks[0].value),
                                y: markersAreaTop,
                                labelFormat: that._getLabelFormatOptions(formatHelper.getDateFormatByDifferences(that._getDiff(ticks[0].value, dateMarkers[0].date))),
                                withoutStick: true
                            });
                            if (dateMarker) {
                                !that._checkMarkersPosition(dateMarker, dateMarkers[0]) && that._disposeDateMarker(dateMarker);
                                dateMarkers.unshift(dateMarker)
                            }
                        }
                        that._initializeMarkersTrackers(dateMarkers, that._axisElementsGroup, that._axisGroup.getBBox().width, markersAreaTop)
                    },
                    _initializeMarkersTrackers: function(dateMarkers, group, axisWidth, markersAreaTop) {
                        var markerTracker, nextMarker, i, x, currentMarker, that = this,
                            separatorHeight = that._options.marker.separatorHeight,
                            renderer = that._renderer,
                            length = dateMarkers.length,
                            businessRange = this._translator.getBusinessRange();
                        that._markerTrackers = [];
                        for (i = 0; i < length; i++) {
                            currentMarker = dateMarkers[i];
                            nextMarker = dateMarkers[i + 1] || {
                                dateMarkerStartPosX: businessRange.invert ? this._translator.translateSpecialCase("canvas_position_end") : axisWidth,
                                date: businessRange.max
                            };
                            x = currentMarker.dateMarkerStartPosX;
                            markerTracker = renderer.path([x, markersAreaTop, x, markersAreaTop + separatorHeight, nextMarker.dateMarkerStartPosX, markersAreaTop + separatorHeight, nextMarker.dateMarkerStartPosX, markersAreaTop, x, markersAreaTop]).attr({
                                "stroke-width": 1,
                                stroke: "grey",
                                fill: "grey",
                                "fill-opacity": 1e-4,
                                "stroke-opacity": 1e-4
                            }).append(group);
                            markerTracker.data("range", {
                                startValue: currentMarker.date,
                                endValue: nextMarker.date
                            });
                            that._markerTrackers.push(markerTracker)
                        }
                    },
                    _checkMarkersPosition: function(dateMarker, prevDateMarker) {
                        return void 0 === prevDateMarker || dateMarker.labelStartPosX > prevDateMarker.labelEndPosX || dateMarker.labelEndPosX < prevDateMarker.labelStartPosX
                    },
                    _getLabelFormatOptions: function(formatString) {
                        var that = this,
                            markerLabelOptions = that._markerLabelOptions;
                        if (!markerLabelOptions) {
                            that._markerLabelOptions = markerLabelOptions = _extend(true, {}, that._options.marker.label)
                        }
                        if (!_isDefined(that._options.marker.label.format)) {
                            markerLabelOptions.format = formatString
                        }
                        return markerLabelOptions
                    },
                    _adjustConstantLineLabels: function() {
                        var label, line, lineBox, linesOptions, labelOptions, box, x, y, i, paddingTopBottom, paddingLeftRight, labelVerticalAlignment, labelHorizontalAlignment, labelIsInside, labelHeight, labelWidth, that = this,
                            options = that._options,
                            isHorizontal = that._isHorizontal,
                            lines = that._constantLines,
                            labels = that._constantLineLabels,
                            padding = isHorizontal ? {
                                top: 0,
                                bottom: 0
                            } : {
                                left: 0,
                                right: 0
                            },
                            delta = 0;
                        if (void 0 === labels && void 0 === lines) {
                            return
                        }
                        for (i = 0; i < labels.length; i++) {
                            x = y = 0;
                            linesOptions = options.constantLines[i];
                            paddingTopBottom = linesOptions.paddingTopBottom;
                            paddingLeftRight = linesOptions.paddingLeftRight;
                            labelOptions = linesOptions.label;
                            labelVerticalAlignment = labelOptions.verticalAlignment;
                            labelHorizontalAlignment = labelOptions.horizontalAlignment;
                            labelIsInside = "inside" === labelOptions.position;
                            label = labels[i];
                            if (null !== label) {
                                line = lines[i];
                                box = label.getBBox();
                                lineBox = line.getBBox();
                                labelHeight = box.height;
                                labelWidth = box.width;
                                if (isHorizontal) {
                                    if (labelIsInside) {
                                        if (labelHorizontalAlignment === LEFT) {
                                            x -= paddingLeftRight
                                        } else {
                                            x += paddingLeftRight
                                        }
                                        switch (labelVerticalAlignment) {
                                            case CENTER:
                                                y += lineBox.y + lineBox.height / 2 - box.y - labelHeight / 2;
                                                break;
                                            case BOTTOM:
                                                y += lineBox.y + lineBox.height - box.y - labelHeight - paddingTopBottom;
                                                break;
                                            default:
                                                y += lineBox.y - box.y + paddingTopBottom
                                        }
                                    } else {
                                        if (labelVerticalAlignment === BOTTOM) {
                                            delta = that.delta && that.delta[BOTTOM] || 0;
                                            y += paddingTopBottom - box.y + that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + BOTTOM) + delta;
                                            if (padding[BOTTOM] < labelHeight + paddingTopBottom) {
                                                padding[BOTTOM] = labelHeight + paddingTopBottom
                                            }
                                        } else {
                                            delta = that.delta && that.delta[TOP] || 0;
                                            y -= paddingTopBottom + box.y + labelHeight - that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + TOP) - delta;
                                            if (padding[TOP] < paddingTopBottom + labelHeight) {
                                                padding[TOP] = paddingTopBottom + labelHeight
                                            }
                                        }
                                    }
                                } else {
                                    if (labelIsInside) {
                                        switch (labelHorizontalAlignment) {
                                            case CENTER:
                                                x += lineBox.x + lineBox.width / 2 - box.x - labelWidth / 2;
                                                break;
                                            case RIGHT:
                                                x -= paddingLeftRight;
                                                break;
                                            default:
                                                x += paddingLeftRight
                                        }
                                        if (labelVerticalAlignment === BOTTOM) {
                                            y += lineBox.y - box.y + paddingTopBottom
                                        } else {
                                            y += lineBox.y - box.y - labelHeight - paddingTopBottom
                                        }
                                    } else {
                                        y += lineBox.y + lineBox.height / 2 - box.y - labelHeight / 2;
                                        if (labelHorizontalAlignment === RIGHT) {
                                            x += paddingLeftRight;
                                            if (padding[RIGHT] < paddingLeftRight + labelWidth) {
                                                padding[RIGHT] = paddingLeftRight + labelWidth
                                            }
                                        } else {
                                            x -= paddingLeftRight;
                                            if (padding[LEFT] < paddingLeftRight + labelWidth) {
                                                padding[LEFT] = paddingLeftRight + labelWidth
                                            }
                                        }
                                    }
                                }
                                label.move(x, y)
                            }
                        }
                        that.padding = padding
                    },
                    _checkAlignmentConstantLineLabels: function(labelOptions) {
                        var position = labelOptions.position,
                            verticalAlignment = (labelOptions.verticalAlignment || "").toLowerCase(),
                            horizontalAlignment = (labelOptions.horizontalAlignment || "").toLowerCase();
                        if (this._isHorizontal) {
                            if ("outside" === position) {
                                verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                                horizontalAlignment = CENTER
                            } else {
                                verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
                                horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                            }
                        } else {
                            if ("outside" === position) {
                                verticalAlignment = CENTER;
                                horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                            } else {
                                verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                                horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT
                            }
                        }
                        labelOptions.verticalAlignment = verticalAlignment;
                        labelOptions.horizontalAlignment = horizontalAlignment
                    },
                    _getConstantLineLabelsCoords: function(value, lineLabelOptions) {
                        var that = this,
                            additionalTranslator = that._additionalTranslator,
                            align = CENTER,
                            x = value,
                            y = value;
                        if (that._isHorizontal) {
                            y = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.verticalAlignment)
                        } else {
                            x = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.horizontalAlignment)
                        }
                        switch (lineLabelOptions.horizontalAlignment) {
                            case LEFT:
                                align = !that._isHorizontal && "inside" === lineLabelOptions.position ? LEFT : RIGHT;
                                break;
                            case CENTER:
                                align = CENTER;
                                break;
                            case RIGHT:
                                align = !that._isHorizontal && "inside" === lineLabelOptions.position ? RIGHT : LEFT
                        }
                        return {
                            x: x,
                            y: y,
                            align: align
                        }
                    },
                    _getAdjustedStripLabelCoords: function(stripOptions, label, rect) {
                        var x = 0,
                            y = 0,
                            horizontalAlignment = stripOptions.label.horizontalAlignment,
                            verticalAlignment = stripOptions.label.verticalAlignment,
                            box = label.getBBox(),
                            rectBox = rect.getBBox();
                        if (horizontalAlignment === LEFT) {
                            x += stripOptions.paddingLeftRight
                        } else {
                            if (horizontalAlignment === RIGHT) {
                                x -= stripOptions.paddingLeftRight
                            }
                        }
                        if (verticalAlignment === TOP) {
                            y += rectBox.y - box.y + stripOptions.paddingTopBottom
                        } else {
                            if (verticalAlignment === CENTER) {
                                y += rectBox.y + rectBox.height / 2 - box.y - box.height / 2
                            } else {
                                if (verticalAlignment === BOTTOM) {
                                    y -= stripOptions.paddingTopBottom
                                }
                            }
                        }
                        return {
                            x: x,
                            y: y
                        }
                    },
                    _adjustTitle: function() {
                        var boxGroup, boxTitle, params, heightTitle, noLabels, that = this,
                            options = that._options,
                            position = options.position,
                            title = that._title,
                            margin = options.title.margin,
                            centerPosition = that._translator.translateSpecialCase(CANVAS_POSITION_PREFIX + CENTER),
                            axisElementsGroup = that._axisElementsGroup,
                            axisPosition = that._axisPosition;
                        if (!title || !axisElementsGroup) {
                            return
                        }
                        boxTitle = title.getBBox();
                        boxGroup = axisElementsGroup.getBBox();
                        noLabels = boxGroup.isEmpty;
                        heightTitle = boxTitle.height;
                        if (that._isHorizontal) {
                            if (position === BOTTOM) {
                                params = {
                                    y: (noLabels ? axisPosition : boxGroup.y + boxGroup.height) - boxTitle.y + margin,
                                    x: centerPosition
                                }
                            } else {
                                params = {
                                    y: (noLabels ? axisPosition : boxGroup.y) - heightTitle - boxTitle.y - margin,
                                    x: centerPosition
                                }
                            }
                        } else {
                            if (position === LEFT) {
                                params = {
                                    x: (noLabels ? axisPosition : boxGroup.x) - heightTitle - boxTitle.y - margin,
                                    y: centerPosition
                                }
                            } else {
                                params = {
                                    x: (noLabels ? axisPosition : boxGroup.x + boxGroup.width) + heightTitle + boxTitle.y + margin,
                                    y: centerPosition
                                }
                            }
                            params.rotate = options.position === LEFT ? 270 : 90
                        }
                        title.attr(params)
                    },
                    coordsIn: function(x, y) {
                        var rect = this.getBoundingRect();
                        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height
                    },
                    _boundaryTicksVisibility: {
                        min: true,
                        max: true
                    },
                    _getOverlappingBehaviorOptions: function() {
                        var that = this,
                            options = that._options,
                            getText = function() {
                                return ""
                            },
                            overlappingBehavior = options.label.overlappingBehavior ? _extend({}, options.label.overlappingBehavior) : null;
                        if (overlappingBehavior) {
                            if (!that._isHorizontal) {
                                overlappingBehavior.mode = constants.validateOverlappingMode(overlappingBehavior.mode)
                            }
                            if ("rotate" !== overlappingBehavior.mode) {
                                overlappingBehavior.rotationAngle = 0
                            }
                        }
                        if (!that._translator.getBusinessRange().stubData) {
                            getText = function(value, labelOptions) {
                                return constants.formatLabel(value, labelOptions, {
                                    min: options.min,
                                    max: options.max
                                })
                            }
                        }
                        return {
                            hasLabelFormat: that._hasLabelFormat,
                            labelOptions: options.label,
                            isMarkersVisible: "discrete" === options.type ? false : options.marker.visible,
                            overlappingBehavior: overlappingBehavior,
                            isHorizontal: that._isHorizontal,
                            textOptions: that._textOptions,
                            textFontStyles: that._textFontStyles,
                            textSpacing: options.label.minSpacing,
                            getText: getText,
                            renderText: function(text, x, y, options) {
                                return that._renderer.text(text, x, y, options).append(that._renderer.root)
                            },
                            translate: function(value, useAdditionalTranslator) {
                                return useAdditionalTranslator ? that._additionalTranslator.translate(value) : that._translator.translate(value)
                            },
                            addMinMax: options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : void 0
                        }
                    },
                    _getMinMax: function() {
                        return {
                            min: this._options.min,
                            max: this._options.max
                        }
                    },
                    _getStick: function() {
                        return !this._options.valueMarginsEnabled
                    },
                    _getStripLabelCoords: function(stripLabelOptions, stripFrom, stripTo) {
                        var x, y, that = this,
                            additionalTranslator = that._additionalTranslator,
                            isHorizontal = that._isHorizontal,
                            align = isHorizontal ? CENTER : LEFT;
                        if (isHorizontal) {
                            if (stripLabelOptions.horizontalAlignment === CENTER) {
                                x = stripFrom + (stripTo - stripFrom) / 2;
                                align = CENTER
                            } else {
                                if (stripLabelOptions.horizontalAlignment === LEFT) {
                                    x = stripFrom;
                                    align = LEFT
                                } else {
                                    if (stripLabelOptions.horizontalAlignment === RIGHT) {
                                        x = stripTo;
                                        align = RIGHT
                                    }
                                }
                            }
                            y = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.verticalAlignment)
                        } else {
                            x = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.horizontalAlignment);
                            align = stripLabelOptions.horizontalAlignment;
                            if (stripLabelOptions.verticalAlignment === TOP) {
                                y = stripFrom
                            } else {
                                if (stripLabelOptions.verticalAlignment === CENTER) {
                                    y = stripTo + (stripFrom - stripTo) / 2
                                } else {
                                    if (stripLabelOptions.verticalAlignment === BOTTOM) {
                                        y = stripTo
                                    }
                                }
                            }
                        }
                        return {
                            x: x,
                            y: y,
                            align: align
                        }
                    },
                    _getTranslatedValue: function(value, y, offset) {
                        return {
                            x: this._translator.translate(value, offset, "semidiscrete" === this._options.type && this._options.tickInterval),
                            y: y
                        }
                    },
                    _getSkippedCategory: function() {
                        var skippedCategory, categories = this._translator.getVisibleCategories() || this._translator.getBusinessRange().categories;
                        if (categories && categories.length && !!this._tickOffset) {
                            skippedCategory = categories[categories.length - 1]
                        }
                        return skippedCategory
                    },
                    _getSpiderCategoryOption: $.noop
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/chart_components/advanced_chart.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                rangeModule = __webpack_require__( /*! ../translators/range */ 89),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                DEFAULT_AXIS_NAME = "defaultAxisName",
                axisModule = __webpack_require__( /*! ../axes/base_axis */ 231),
                seriesFamilyModule = __webpack_require__( /*! ../core/series_family */ 331),
                BaseChart = __webpack_require__( /*! ./base_chart */ 232).BaseChart,
                _isArray = commonUtils.isArray,
                _isDefined = commonUtils.isDefined,
                _each = $.each,
                _noop = $.noop,
                _extend = $.extend,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _map = vizUtils.map,
                MIN = "min",
                MAX = "max";

            function prepareAxis(axisOptions) {
                return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions]
            }

            function prepareVisibleArea(visibleArea, aggregationRange, axisRange, argRange) {
                visibleArea.minVal = axisRange.min;
                visibleArea.maxVal = axisRange.max;
                visibleArea.minArg = !_isDefined(visibleArea.minArg) ? _isDefined(argRange.minVisible) ? argRange.minVisible : aggregationRange.arg.min : visibleArea.minArg;
                visibleArea.maxArg = !_isDefined(visibleArea.maxArg) ? _isDefined(argRange.maxVisible) ? argRange.maxVisible : aggregationRange.arg.max : visibleArea.maxArg
            }
            var AdvancedChart = BaseChart.inherit({
                _dispose: function() {
                    var that = this,
                        disposeObjectsInArray = this._disposeObjectsInArray;
                    that.callBase();
                    that.panes = null;
                    if (that._legend) {
                        that._legend.dispose();
                        that._legend = null
                    }
                    disposeObjectsInArray.call(that, "panesBackground");
                    disposeObjectsInArray.call(that, "seriesFamilies");
                    that._disposeAxes()
                },
                _reinitAxes: function() {
                    this.translators = {};
                    this.panes = this._createPanes();
                    this._populateAxes()
                },
                _populateAxes: function() {
                    var argumentAxes, paneWithNonVirtualAxis, that = this,
                        valueAxes = [],
                        panes = that.panes,
                        rotated = that._isRotated(),
                        valueAxisOptions = that.option("valueAxis") || {},
                        argumentOption = that.option("argumentAxis") || {},
                        argumentAxesOptions = prepareAxis(argumentOption)[0],
                        valueAxesOptions = prepareAxis(valueAxisOptions),
                        axisNames = [],
                        valueAxesCounter = 0,
                        crosshairOptions = that._getCrosshairOptions() || {},
                        crosshairEnabled = crosshairOptions.enabled,
                        horCrosshairEnabled = crosshairEnabled && crosshairOptions.horizontalLine.visible,
                        verCrosshairEnabled = crosshairEnabled && crosshairOptions.verticalLine.visible;

                    function getNextAxisName() {
                        return DEFAULT_AXIS_NAME + valueAxesCounter++
                    }
                    that._disposeAxes();
                    if (rotated) {
                        paneWithNonVirtualAxis = "right" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name
                    } else {
                        paneWithNonVirtualAxis = "top" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name
                    }
                    argumentAxes = _map(panes, function(pane, index) {
                        return that._createAxis("argumentAxis", argumentAxesOptions, {
                            pane: pane.name,
                            crosshairEnabled: rotated ? horCrosshairEnabled : verCrosshairEnabled
                        }, rotated, pane.name !== paneWithNonVirtualAxis, index)
                    });
                    _each(valueAxesOptions, function(priority, axisOptions) {
                        var axisPanes = [],
                            name = axisOptions.name;
                        if (name && -1 !== $.inArray(name, axisNames)) {
                            that._incidentOccurred("E2102");
                            return
                        }
                        name && axisNames.push(name);
                        if (axisOptions.pane) {
                            axisPanes.push(axisOptions.pane)
                        }
                        if (axisOptions.panes && axisOptions.panes.length) {
                            axisPanes = axisPanes.concat(axisOptions.panes.slice(0))
                        }
                        axisPanes = vizUtils.unique(axisPanes);
                        if (!axisPanes.length) {
                            axisPanes.push(void 0)
                        }
                        _each(axisPanes, function(_, pane) {
                            valueAxes.push(that._createAxis("valueAxis", axisOptions, {
                                name: name || getNextAxisName(),
                                pane: pane,
                                priority: priority,
                                crosshairEnabled: rotated ? verCrosshairEnabled : horCrosshairEnabled
                            }, rotated))
                        })
                    });
                    that._valueAxes = valueAxes;
                    that._argumentAxes = argumentAxes
                },
                _prepareStackPoints: function(singleSeries, stackPoints) {
                    var points = singleSeries.getPoints(),
                        stackName = singleSeries.getStackName();
                    _each(points, function(_, point) {
                        var argument = point.argument;
                        if (!stackPoints[argument]) {
                            stackPoints[argument] = {};
                            stackPoints[argument][null] = []
                        }
                        if (stackName && !_isArray(stackPoints[argument][stackName])) {
                            stackPoints[argument][stackName] = [];
                            _each(stackPoints[argument][null], function(_, point) {
                                if (!point.stackName) {
                                    stackPoints[argument][stackName].push(point)
                                }
                            })
                        }
                        if (stackName) {
                            stackPoints[argument][stackName].push(point);
                            stackPoints[argument][null].push(point)
                        } else {
                            _each(stackPoints[argument], function(_, stack) {
                                stack.push(point)
                            })
                        }
                        point.stackPoints = stackPoints[argument][stackName];
                        point.stackName = stackName
                    })
                },
                _resetStackPoints: function(singleSeries) {
                    _each(singleSeries.getPoints(), function(_, point) {
                        point.stackPoints = null;
                        point.stackName = null
                    })
                },
                _disposeAxes: function() {
                    var that = this,
                        disposeObjectsInArray = that._disposeObjectsInArray;
                    disposeObjectsInArray.call(that, "_argumentAxes");
                    disposeObjectsInArray.call(that, "_valueAxes")
                },
                _drawAxes: function(panesBorderOptions, drawOptions, adjustUnits) {
                    var that = this,
                        drawAxes = function(axes) {
                            _each(axes, function(_, axis) {
                                axis.draw(adjustUnits)
                            })
                        },
                        drawStaticAxisElements = function(axes) {
                            _each(axes, function(_i, axis) {
                                axis.drawGrids(panesBorderOptions[axis.pane])
                            })
                        };
                    that._restoreOriginalBusinessRange();
                    that._reinitTranslators();
                    that._prepareAxesAndDraw(drawAxes, drawStaticAxisElements, drawOptions)
                },
                _restoreOriginalBusinessRange: _noop,
                _appendAdditionalSeriesGroups: function() {
                    this._crosshairCursorGroup.linkAppend();
                    this._scrollBar && this._scrollBarGroup.linkAppend()
                },
                _getLegendTargets: function() {
                    var that = this;
                    return _map(that.series, function(item) {
                        if (item.getOptions().showInLegend) {
                            return that._getLegendOptions(item)
                        }
                        return null
                    })
                },
                _legendItemTextField: "name",
                _seriesPopulatedHandlerCore: function() {
                    this._processSeriesFamilies();
                    this._processValueAxisFormat()
                },
                _renderTrackers: function() {
                    var i, that = this;
                    for (i = 0; i < that.series.length; ++i) {
                        that.series[i].drawTrackers()
                    }
                },
                _specialProcessSeries: function() {
                    this._processSeriesFamilies()
                },
                _processSeriesFamilies: function() {
                    var paneSeries, that = this,
                        types = [],
                        families = [],
                        themeManager = that._themeManager,
                        negativesAsZeroes = themeManager.getOptions("negativesAsZeroes"),
                        negativesAsZeros = themeManager.getOptions("negativesAsZeros"),
                        familyOptions = {
                            equalBarWidth: themeManager.getOptions("equalBarWidth"),
                            minBubbleSize: themeManager.getOptions("minBubbleSize"),
                            maxBubbleSize: themeManager.getOptions("maxBubbleSize"),
                            barWidth: themeManager.getOptions("barWidth"),
                            negativesAsZeroes: _isDefined(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
                        };
                    if (that.seriesFamilies && that.seriesFamilies.length) {
                        _each(that.seriesFamilies, function(_, family) {
                            family.updateOptions(familyOptions);
                            family.adjustSeriesValues()
                        });
                        return
                    }
                    _each(that.series, function(_, item) {
                        if (-1 === $.inArray(item.type, types)) {
                            types.push(item.type)
                        }
                    });
                    _each(that._getLayoutTargets(), function(_, pane) {
                        paneSeries = that._getSeriesForPane(pane.name);
                        _each(types, function(_, type) {
                            var family = new seriesFamilyModule.SeriesFamily({
                                type: type,
                                pane: pane.name,
                                equalBarWidth: familyOptions.equalBarWidth,
                                minBubbleSize: familyOptions.minBubbleSize,
                                maxBubbleSize: familyOptions.maxBubbleSize,
                                barWidth: familyOptions.barWidth,
                                negativesAsZeroes: familyOptions.negativesAsZeroes,
                                rotated: that._isRotated()
                            });
                            family.add(paneSeries);
                            family.adjustSeriesValues();
                            families.push(family)
                        })
                    });
                    that.seriesFamilies = families
                },
                _updateSeriesDimensions: function() {
                    var i, that = this,
                        seriesFamilies = that.seriesFamilies || [];
                    for (i = 0; i < seriesFamilies.length; i++) {
                        var family = seriesFamilies[i],
                            translators = that._getTranslator(family.pane) || {};
                        family.updateSeriesValues(translators);
                        family.adjustSeriesDimensions(translators)
                    }
                },
                _getLegendCallBack: function(series) {
                    return this._legend && this._legend.getActionCallback(series)
                },
                _appendAxesGroups: function() {
                    var that = this;
                    that._stripsGroup.linkAppend();
                    that._gridGroup.linkAppend();
                    that._axesGroup.linkAppend();
                    that._constantLinesGroup.linkAppend();
                    that._labelAxesGroup.linkAppend()
                },
                _populateBusinessRange: function(visibleArea) {
                    var argBusinessRange, that = this,
                        businessRanges = [],
                        rotated = that._isRotated(),
                        argAxes = that._argumentAxes,
                        lastArgAxis = argAxes[argAxes.length - 1],
                        calcInterval = lastArgAxis.calcInterval,
                        argRange = new rangeModule.Range({
                            rotated: !!rotated
                        }),
                        groupsData = that._groupsData;
                    that.businessRanges = null;
                    _each(argAxes, function(_, axis) {
                        argRange.addRange(axis.getRangeData())
                    });
                    _each(groupsData.groups, function(_, group) {
                        var groupRange = new rangeModule.Range({
                                rotated: !!rotated,
                                pane: group.valueAxis.pane,
                                axis: group.valueAxis.name
                            }),
                            groupAxisRange = group.valueAxis.getRangeData();
                        groupRange.addRange(groupAxisRange);
                        _each(group.series, function(_, series) {
                            visibleArea && prepareVisibleArea(visibleArea, series.getRangeData(), groupAxisRange, argRange);
                            var seriesRange = series.getRangeData(visibleArea, calcInterval);
                            groupRange.addRange(seriesRange.val);
                            argRange.addRange(seriesRange.arg)
                        });
                        if (!groupRange.isDefined()) {
                            groupRange.setStubData(group.valueAxis.getOptions().valueType)
                        }
                        if (group.valueAxis.getOptions().showZero) {
                            groupRange.correctValueZeroLevel()
                        }
                        groupRange.checkZeroStick();
                        businessRanges.push({
                            val: groupRange,
                            arg: argRange
                        })
                    });
                    argRange.addRange({
                        categories: groupsData.categories
                    });
                    if (!argRange.isDefined()) {
                        argRange.setStubData(argAxes[0].getOptions().argumentType)
                    }
                    if (visibleArea && visibleArea.notApplyMargins && "discrete" !== argRange.axisType) {
                        argBusinessRange = argAxes[0].getTranslator().getBusinessRange();
                        argRange.addRange({
                            min: argBusinessRange.min,
                            max: argBusinessRange.max,
                            stick: true
                        })
                    }
                    that._correctBusinessRange(argRange, lastArgAxis);
                    that.businessRanges = businessRanges
                },
                _correctBusinessRange: function(range, lastArgAxis) {
                    var setTicksAtUnitBeginning = lastArgAxis.getOptions().setTicksAtUnitBeginning,
                        tickIntervalRange = {},
                        tickInterval = lastArgAxis.getOptions().tickInterval,
                        originInterval = tickInterval;
                    tickInterval = $.isNumeric(tickInterval) ? tickInterval : dateUtils.dateToMilliseconds(tickInterval);
                    if (tickInterval && _isDefined(range[MIN]) && _isDefined(range[MAX]) && tickInterval >= Math.abs(range[MAX] - range[MIN])) {
                        if (commonUtils.isDate(range[MIN])) {
                            if (!$.isNumeric(originInterval)) {
                                tickIntervalRange[MIN] = dateUtils.addInterval(range[MIN], originInterval, true);
                                tickIntervalRange[MAX] = dateUtils.addInterval(range[MAX], originInterval, false)
                            } else {
                                tickIntervalRange[MIN] = new Date(range[MIN].valueOf() - tickInterval);
                                tickIntervalRange[MAX] = new Date(range[MAX].valueOf() + tickInterval)
                            }
                            if (setTicksAtUnitBeginning) {
                                dateUtils.correctDateWithUnitBeginning(tickIntervalRange[MAX], originInterval);
                                dateUtils.correctDateWithUnitBeginning(tickIntervalRange[MIN], originInterval)
                            }
                        } else {
                            tickIntervalRange[MIN] = range[MIN] - tickInterval;
                            tickIntervalRange[MAX] = range[MAX] + tickInterval
                        }
                        range.addRange(tickIntervalRange)
                    }
                },
                _getArgumentAxes: function() {
                    return this._argumentAxes
                },
                _getValueAxes: function() {
                    return this._valueAxes
                },
                _processValueAxisFormat: function() {
                    var that = this,
                        valueAxes = that._valueAxes,
                        axesWithFullStackedFormat = [];
                    _each(that.series, function() {
                        if (this.isFullStackedSeries() && -1 === $.inArray(this.axis, axesWithFullStackedFormat)) {
                            axesWithFullStackedFormat.push(this.axis)
                        }
                    });
                    _each(valueAxes, function() {
                        if (-1 !== $.inArray(this.name, axesWithFullStackedFormat)) {
                            this.setPercentLabelFormat()
                        } else {
                            this.resetAutoLabelFormat()
                        }
                    })
                },
                _createAxis: function(typeSelector, userOptions, axisOptions, rotated, virtual, index) {
                    var axis, that = this,
                        renderingSettings = _extend({
                            renderer: that._renderer,
                            incidentOccurred: that._incidentOccurred,
                            axisClass: "argumentAxis" === typeSelector ? "arg" : "val",
                            widgetClass: "dxc",
                            stripsGroup: that._stripsGroup,
                            labelAxesGroup: that._labelAxesGroup,
                            constantLinesGroup: that._constantLinesGroup,
                            axesContainerGroup: that._axesGroup,
                            gridGroup: that._gridGroup
                        }, that._getAxisRenderingOptions(typeSelector)),
                        preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated),
                        options = _extend(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));
                    if (virtual) {
                        options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;
                        options.title = {}
                    }
                    axis = new axisModule.Axis(renderingSettings);
                    axis.updateOptions(options);
                    if (!virtual && _isDefined(index)) {
                        that._displayedArgumentAxisIndex = index
                    }
                    return axis
                },
                _getTrackerSettings: function() {
                    return _extend(this.callBase(), {
                        argumentAxis: this._argumentAxes[this._displayedArgumentAxisIndex]
                    })
                },
                _prepareStripsAndConstantLines: function(typeSelector, userOptions, rotated) {
                    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);
                    if (userOptions.strips) {
                        _each(userOptions.strips, function(i) {
                            userOptions.strips[i] = _extend(true, {}, userOptions.stripStyle, userOptions.strips[i])
                        })
                    }
                    if (userOptions.constantLines) {
                        _each(userOptions.constantLines, function(i, line) {
                            userOptions.constantLines[i] = _extend(true, {}, userOptions.constantLineStyle, line)
                        })
                    }
                    return userOptions
                },
                _legendDataField: "series",
                _getStoredSeries: function() {
                    return this.series
                },
                _adjustSeries: _noop,
                _collectPointsByArg: _noop
            });
            exports.AdvancedChart = AdvancedChart
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/chart_components/layout_manager.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                layoutElementModule = __webpack_require__( /*! ../core/layout_element */ 190),
                _isNumber = commonUtils.isNumber,
                _min = Math.min,
                _max = Math.max,
                _floor = Math.floor,
                _sqrt = Math.sqrt,
                _each = $.each,
                _extend = $.extend,
                consts = __webpack_require__( /*! ../components/consts */ 126),
                pieLabelIndent = consts.pieLabelIndent,
                pieLabelSpacing = consts.pieLabelSpacing;

            function updateAxis(axes, side, needRemoveSpace) {
                if (axes && needRemoveSpace[side] > 0) {
                    _each(axes, function(i, axis) {
                        var bbox = axis.getBoundingRect();
                        axis.updateSize();
                        needRemoveSpace[side] -= bbox[side] - axis.getBoundingRect()[side]
                    });
                    if (needRemoveSpace[side] > 0) {
                        _each(axes, function(_, axis) {
                            axis.updateSize(true)
                        })
                    }
                }
            }

            function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
                var nearestCoord;
                if (pointCenterCoord < firstCoord) {
                    nearestCoord = firstCoord
                } else {
                    if (secondCoord < pointCenterCoord) {
                        nearestCoord = secondCoord
                    } else {
                        nearestCoord = pointCenterCoord
                    }
                }
                return nearestCoord
            }

            function getLabelLayout(point) {
                if (point._label.isVisible() && "inside" !== point._label.getLayoutOptions().position) {
                    return point._label.getBoundingRect()
                }
            }

            function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
                var radiusIsFound = false;
                _each(series, function(_, singleSeries) {
                    if (radiusIsFound) {
                        return false
                    }
                    _each(singleSeries.getVisiblePoints(), function(_, point) {
                        var labelBBox = getLabelLayout(point);
                        if (labelBBox) {
                            var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX),
                                yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
                            accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - pieLabelIndent, minR), accessibleRadius);
                            radiusIsFound = true
                        }
                    })
                });
                return accessibleRadius
            }

            function getSizeLabels(series) {
                var sizes = [],
                    commonWidth = 0;
                _each(series, function(_, singleSeries) {
                    var maxWidth = 0;
                    _each(singleSeries.getVisiblePoints(), function(_, point) {
                        var labelBBox = getLabelLayout(point);
                        if (labelBBox) {
                            maxWidth = _max(labelBBox.width + pieLabelSpacing, maxWidth)
                        }
                    });
                    sizes.push(maxWidth);
                    commonWidth += maxWidth
                });
                return {
                    sizes: sizes,
                    common: commonWidth
                }
            }

            function correctLabelRadius(sizes, radius, series, canvas, averageWidthLabels) {
                var curRadius, i, centerX = (canvas.width - canvas.left - canvas.right) / 2;
                for (i = 0; i < series.length; i++) {
                    if (0 === sizes[i]) {
                        curRadius && (curRadius += sizes[i - 1]);
                        continue
                    }
                    curRadius = _floor(curRadius ? curRadius + sizes[i - 1] : radius);
                    series[i].correctLabelRadius(curRadius);
                    if (averageWidthLabels && i !== series.length - 1) {
                        sizes[i] = averageWidthLabels;
                        series[i].setVisibleArea({
                            left: centerX - radius - averageWidthLabels * (i + 1),
                            right: canvas.width - (centerX + radius + averageWidthLabels * (i + 1)),
                            top: canvas.top,
                            bottom: canvas.bottom,
                            width: canvas.width,
                            height: canvas.height
                        })
                    }
                }
            }

            function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
                return _sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY))
            }

            function getInnerRadius(series) {
                var innerRadius;
                if ("pie" === series.type) {
                    innerRadius = 0
                } else {
                    innerRadius = _isNumber(series.innerRadius) ? Number(series.innerRadius) : .5;
                    innerRadius = innerRadius < .2 ? .2 : innerRadius;
                    innerRadius = innerRadius > .8 ? .8 : innerRadius
                }
                return innerRadius
            }

            function isValidBox(box) {
                return !!(box.x || box.y || box.width || box.height)
            }

            function correctDeltaMarginValue(panes, marginSides) {
                var canvas, deltaSide, requireAxesRedraw = false;
                _each(panes, function(_, pane) {
                    canvas = pane.canvas;
                    _each(marginSides, function(_, side) {
                        deltaSide = "delta" + side;
                        canvas[deltaSide] = _max(canvas[deltaSide] - (canvas[side.toLowerCase()] - canvas["original" + side]), 0);
                        if (canvas[deltaSide] > 0) {
                            requireAxesRedraw = true
                        }
                    })
                });
                return requireAxesRedraw
            }

            function getPane(name, panes) {
                var findPane = panes[0];
                _each(panes, function(_, pane) {
                    if (name === pane.name) {
                        findPane = pane
                    }
                });
                return findPane
            }

            function applyFoundExceedings(panes, rotated) {
                var stopDrawAxes = false,
                    maxLeft = 0,
                    maxRight = 0,
                    maxTop = 0,
                    maxBottom = 0;
                _each(panes, function(_, pane) {
                    maxLeft = _max(maxLeft, pane.canvas.deltaLeft);
                    maxRight = _max(maxRight, pane.canvas.deltaRight);
                    maxTop = _max(maxTop, pane.canvas.deltaTop);
                    maxBottom = _max(maxBottom, pane.canvas.deltaBottom)
                });
                if (rotated) {
                    _each(panes, function(_, pane) {
                        pane.canvas.top += maxTop;
                        pane.canvas.bottom += maxBottom;
                        pane.canvas.right += pane.canvas.deltaRight;
                        pane.canvas.left += pane.canvas.deltaLeft
                    })
                } else {
                    _each(panes, function(_, pane) {
                        pane.canvas.top += pane.canvas.deltaTop;
                        pane.canvas.bottom += pane.canvas.deltaBottom;
                        pane.canvas.right += maxRight;
                        pane.canvas.left += maxLeft
                    })
                }
                _each(panes, function(_, pane) {
                    if (pane.canvas.top + pane.canvas.bottom > pane.canvas.height) {
                        stopDrawAxes = true
                    }
                    if (pane.canvas.left + pane.canvas.right > pane.canvas.width) {
                        stopDrawAxes = true
                    }
                });
                return stopDrawAxes
            }
            var inverseAlign = {
                left: "right",
                right: "left",
                top: "bottom",
                bottom: "top",
                center: "center"
            };

            function downSize(canvas, layoutOptions) {
                canvas[layoutOptions.cutLayoutSide] += "horizontal" === layoutOptions.cutSide ? layoutOptions.width : layoutOptions.height
            }

            function getOffset(layoutOptions, offsets) {
                var side = layoutOptions.cutLayoutSide,
                    offset = {
                        horizontal: 0,
                        vertical: 0
                    };
                switch (side) {
                    case "top":
                    case "left":
                        offset[layoutOptions.cutSide] = -offsets[side];
                        break;
                    case "bottom":
                    case "right":
                        offset[layoutOptions.cutSide] = offsets[side]
                }
                return offset
            }

            function LayoutManager() {}

            function toLayoutElementCoords(canvas) {
                return new layoutElementModule.WrapperLayoutElement(null, {
                    x: canvas.left,
                    y: canvas.top,
                    width: canvas.width - canvas.left - canvas.right,
                    height: canvas.height - canvas.top - canvas.bottom
                })
            }
            LayoutManager.prototype = {
                constructor: LayoutManager,
                setOptions: function(options) {
                    this._options = options
                },
                applyVerticalAxesLayout: function(axes, panes, rotated) {
                    this._applyAxesLayout(axes, panes, rotated)
                },
                applyHorizontalAxesLayout: function(axes, panes, rotated) {
                    axes.reverse();
                    this._applyAxesLayout(axes, panes, rotated);
                    axes.reverse()
                },
                _applyAxesLayout: function(axes, panes, rotated) {
                    var canvas, axisPosition, box, delta, axis, axisLength, direction, directionMultiplier, pane, i, that = this,
                        someDirection = [];
                    _each(panes, function(_, pane) {
                        _extend(pane.canvas, {
                            deltaLeft: 0,
                            deltaRight: 0,
                            deltaTop: 0,
                            deltaBottom: 0
                        })
                    });
                    for (i = 0; i < axes.length; i++) {
                        axis = axes[i];
                        axisPosition = axis.getOptions().position || "left";
                        axis.delta = {};
                        box = axis.getBoundingRect();
                        pane = getPane(axis.pane, panes);
                        canvas = pane.canvas;
                        if (!isValidBox(box)) {
                            continue
                        }
                        direction = "delta" + axisPosition.slice(0, 1).toUpperCase() + axisPosition.slice(1);
                        switch (axisPosition) {
                            case "right":
                                directionMultiplier = 1;
                                canvas.deltaLeft += axis.padding ? axis.padding.left : 0;
                                break;
                            case "left":
                                directionMultiplier = -1;
                                canvas.deltaRight += axis.padding ? axis.padding.right : 0;
                                break;
                            case "top":
                                directionMultiplier = -1;
                                canvas.deltaBottom += axis.padding ? axis.padding.bottom : 0;
                                break;
                            case "bottom":
                                directionMultiplier = 1;
                                canvas.deltaTop += axis.padding ? axis.padding.top : 0
                        }
                        switch (axisPosition) {
                            case "right":
                            case "left":
                                if (!box.isEmpty) {
                                    delta = box.y + box.height - (canvas.height - canvas.originalBottom);
                                    if (delta > 0) {
                                        that.requireAxesRedraw = true;
                                        canvas.deltaBottom += delta
                                    }
                                    delta = canvas.originalTop - box.y;
                                    if (delta > 0) {
                                        that.requireAxesRedraw = true;
                                        canvas.deltaTop += delta
                                    }
                                }
                                axisLength = box.width;
                                someDirection = ["Left", "Right"];
                                break;
                            case "top":
                            case "bottom":
                                if (!box.isEmpty) {
                                    delta = box.x + box.width - (canvas.width - canvas.originalRight);
                                    if (delta > 0) {
                                        that.requireAxesRedraw = true;
                                        canvas.deltaRight += delta
                                    }
                                    delta = canvas.originalLeft - box.x;
                                    if (delta > 0) {
                                        that.requireAxesRedraw = true;
                                        canvas.deltaLeft += delta
                                    }
                                }
                                someDirection = ["Bottom", "Top"];
                                axisLength = box.height
                        }
                        if (!axis.delta[axisPosition] && canvas[direction] > 0) {
                            canvas[direction] += axis.getMultipleAxesSpacing()
                        }
                        axis.delta[axisPosition] = axis.delta[axisPosition] || 0;
                        axis.delta[axisPosition] += canvas[direction] * directionMultiplier;
                        canvas[direction] += axisLength
                    }
                    that.requireAxesRedraw = correctDeltaMarginValue(panes, someDirection) || that.requireAxesRedraw;
                    that.stopDrawAxes = applyFoundExceedings(panes, rotated)
                },
                applyPieChartSeriesLayout: function(canvas, series, hideLayoutLabels) {
                    var sizeLabels, averageWidthLabels, fullRadiusWithLabels, paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
                        paneSpaceWidth = canvas.width - canvas.left - canvas.right,
                        paneCenterX = paneSpaceWidth / 2 + canvas.left,
                        paneCenterY = paneSpaceHeight / 2 + canvas.top,
                        piePercentage = this._options.piePercentage,
                        accessibleRadius = _isNumber(piePercentage) ? piePercentage * _min(canvas.height, canvas.width) / 2 : _min(paneSpaceWidth, paneSpaceHeight) / 2,
                        minR = .7 * accessibleRadius,
                        countSeriesWithOuterLabels = 0,
                        innerRadius = getInnerRadius(series[0]);
                    if (!hideLayoutLabels && !_isNumber(piePercentage)) {
                        sizeLabels = getSizeLabels(series);
                        fullRadiusWithLabels = paneCenterX - sizeLabels.common + canvas.left;
                        if (fullRadiusWithLabels < minR) {
                            accessibleRadius = minR;
                            _each(sizeLabels.sizes, function(_, size) {
                                0 !== size && countSeriesWithOuterLabels++
                            });
                            averageWidthLabels = (paneCenterX - accessibleRadius - canvas.left) / countSeriesWithOuterLabels
                        } else {
                            accessibleRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR), fullRadiusWithLabels)
                        }
                        correctLabelRadius(sizeLabels.sizes, accessibleRadius, series, canvas, averageWidthLabels)
                    }
                    return {
                        centerX: _floor(paneCenterX),
                        centerY: _floor(paneCenterY),
                        radiusInner: _floor(accessibleRadius * innerRadius),
                        radiusOuter: _floor(accessibleRadius),
                        canvas: canvas
                    }
                },
                needMoreSpaceForPanesCanvas: function(panes, rotated) {
                    var options = this._options,
                        width = options.width,
                        height = options.height,
                        piePercentage = options.piePercentage,
                        percentageIsValid = _isNumber(piePercentage),
                        needHorizontalSpace = 0,
                        needVerticalSpace = 0;
                    _each(panes, function(_, pane) {
                        var paneCanvas = pane.canvas,
                            minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : void 0,
                            needPaneHorizontalSpace = (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right),
                            needPaneVerticalSpace = (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom);
                        if (rotated) {
                            needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
                            needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace)
                        } else {
                            needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
                            needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0
                        }
                    });
                    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
                        width: needHorizontalSpace,
                        height: needVerticalSpace
                    } : false
                },
                layoutElements: function(elements, canvas, funcAxisDrawer, panes, rotated, axes) {
                    this._elements = elements;
                    this._probeDrawing(canvas);
                    this._drawElements(canvas);
                    funcAxisDrawer && funcAxisDrawer();
                    this._processAdaptiveLayout(panes, rotated, canvas, axes, funcAxisDrawer);
                    this._positionElements(canvas)
                },
                _processAdaptiveLayout: function(panes, rotated, canvas, axes, funcAxisDrawer) {
                    var that = this,
                        size = that.needMoreSpaceForPanesCanvas(panes, rotated),
                        items = this._elements;
                    if (!size) {
                        return
                    }

                    function processCanvases(item, layoutOptions, side) {
                        if (!item.getLayoutOptions()[side]) {
                            canvas[layoutOptions.cutLayoutSide] -= layoutOptions[side];
                            size[side] = Math.max(size[side] - layoutOptions[side], 0)
                        }
                    }
                    $.each(items.slice().reverse(), function(_, item) {
                        var sizeObject, layoutOptions = _extend({}, item.getLayoutOptions());
                        if (!layoutOptions) {
                            return
                        }
                        sizeObject = $.extend({}, layoutOptions);
                        if ("vertical" === layoutOptions.cutSide && size.height) {
                            item.draw(sizeObject.width, sizeObject.height - size.height);
                            processCanvases(item, layoutOptions, "height")
                        }
                        if ("horizontal" === layoutOptions.cutSide && size.width) {
                            item.draw(sizeObject.width - size.width, sizeObject.height);
                            processCanvases(item, layoutOptions, "width")
                        }
                    });
                    updateAxis(axes.verticalAxes, "width", size);
                    updateAxis(axes.horizontalAxes, "height", size);
                    funcAxisDrawer && funcAxisDrawer(true)
                },
                _probeDrawing: function(canvas) {
                    var that = this;
                    $.each(this._elements, function(_, item) {
                        var sizeObject, layoutOptions = item.getLayoutOptions();
                        if (!layoutOptions) {
                            return
                        }
                        sizeObject = {
                            width: canvas.width - canvas.left - canvas.right,
                            height: canvas.height - canvas.top - canvas.bottom
                        };
                        if ("vertical" === layoutOptions.cutSide) {
                            sizeObject.height -= that._options.height
                        } else {
                            sizeObject.width -= that._options.width
                        }
                        item.probeDraw(sizeObject.width, sizeObject.height);
                        downSize(canvas, item.getLayoutOptions())
                    })
                },
                _drawElements: function(canvas) {
                    $.each(this._elements.slice().reverse(), function(_, item) {
                        var sizeObject, cutSide, length, layoutOptions = item.getLayoutOptions();
                        if (!layoutOptions) {
                            return
                        }
                        sizeObject = {
                            width: canvas.width - canvas.left - canvas.right,
                            height: canvas.height - canvas.top - canvas.bottom
                        };
                        cutSide = layoutOptions.cutSide;
                        length = "horizontal" === cutSide ? "width" : "height";
                        sizeObject[length] = layoutOptions[length];
                        item.draw(sizeObject.width, sizeObject.height)
                    })
                },
                _positionElements: function(canvas) {
                    var offsets = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    };
                    $.each(this._elements.slice().reverse(), function(_, item) {
                        var position, cutSide, my, layoutOptions = item.getLayoutOptions();
                        if (!layoutOptions) {
                            return
                        }
                        position = layoutOptions.position;
                        cutSide = layoutOptions.cutSide;
                        my = {
                            horizontal: position.horizontal,
                            vertical: position.vertical
                        };
                        my[cutSide] = inverseAlign[my[cutSide]];
                        item.position({
                            of: toLayoutElementCoords(canvas),
                            my: my,
                            at: position,
                            offset: getOffset(layoutOptions, offsets)
                        });
                        offsets[layoutOptions.cutLayoutSide] += layoutOptions["horizontal" === layoutOptions.cutSide ? "width" : "height"]
                    })
                }
            };
            exports.LayoutManager = LayoutManager
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************************!*\
      !*** ./Scripts/viz/components/chart_theme_manager.js ***!
      \*******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                rendererModule = __webpack_require__( /*! ../core/renderers/renderer */ 176),
                isIE8 = !rendererModule.isSvg(),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager,
                _isString = commonUtils.isString,
                _isDefined = commonUtils.isDefined,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                FONT = "font",
                COMMON_AXIS_SETTINGS = "commonAxisSettings",
                PIE_FONT_FIELDS = ["legend." + FONT, "title." + FONT, "title.subtitle." + FONT, "tooltip." + FONT, "loadingIndicator." + FONT, "export." + FONT, "commonSeriesSettings.label." + FONT],
                POLAR_FONT_FIELDS = PIE_FONT_FIELDS.concat([COMMON_AXIS_SETTINGS + ".label." + FONT, COMMON_AXIS_SETTINGS + ".title." + FONT]),
                CHART_FONT_FIELDS = POLAR_FONT_FIELDS.concat(["crosshair.label." + FONT]),
                chartToFontFieldsMap = {
                    pie: PIE_FONT_FIELDS,
                    chart: CHART_FONT_FIELDS,
                    polar: POLAR_FONT_FIELDS
                };
            var ThemeManager = BaseThemeManager.inherit(function() {
                var ctor = function(options, themeGroupName) {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    options = options || {};
                    that._userOptions = options;
                    that._mergeAxisTitleOptions = [];
                    that._multiPieColors = {};
                    that._themeSection = themeGroupName;
                    that._fontFields = chartToFontFieldsMap[themeGroupName];
                    that._IE8 = isIE8;
                    that._callback = $.noop
                };
                var dispose = function() {
                    var that = this;
                    that.palette && that.palette.dispose();
                    that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
                    return that.callBase.apply(that, arguments)
                };
                var resetPalette = function() {
                    this.palette.reset();
                    this._multiPieColors = {}
                };
                var updatePalette = function(palette) {
                    this.palette = this.createPalette(palette, {
                        useHighlight: true
                    })
                };
                var processTitleOptions = function(options) {
                    return _isString(options) ? {
                        text: options
                    } : options
                };
                var processAxisOptions = function(axisOptions) {
                    if (!axisOptions) {
                        return
                    }
                    axisOptions = $.extend(true, {}, axisOptions);
                    axisOptions.title = processTitleOptions(axisOptions.title);
                    if ("logarithmic" === axisOptions.type && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !$.isNumeric(axisOptions.logarithmBase)) {
                        axisOptions.logarithmBase = void 0;
                        axisOptions.logarithmBaseError = true
                    }
                    if (axisOptions.label) {
                        if (axisOptions.label.alignment) {
                            axisOptions.label.userAlignment = true
                        }
                        if (_isString(axisOptions.label.overlappingBehavior)) {
                            axisOptions.label.overlappingBehavior = {
                                mode: axisOptions.label.overlappingBehavior
                            }
                        }
                        if (!axisOptions.label.overlappingBehavior || !axisOptions.label.overlappingBehavior.mode) {
                            axisOptions.label.overlappingBehavior = axisOptions.label.overlappingBehavior || {}
                        }
                    }
                    return axisOptions
                };
                var applyParticularAxisOptions = function(name, userOptions, rotated) {
                    var theme = this._theme,
                        position = !(rotated ^ "valueAxis" === name) ? "horizontalAxis" : "verticalAxis",
                        commonAxisSettings = processAxisOptions(this._userOptions.commonAxisSettings, name);
                    return $.extend(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processAxisOptions(userOptions, name))
                };
                var mergeOptions = function(name, userOptions) {
                    userOptions = userOptions || this._userOptions[name];
                    var theme = this._theme[name],
                        result = this._mergedSettings[name];
                    if (result) {
                        return result
                    }
                    if ($.isPlainObject(theme) && $.isPlainObject(userOptions)) {
                        result = $.extend(true, {}, theme, userOptions)
                    } else {
                        result = _isDefined(userOptions) ? userOptions : theme
                    }
                    this._mergedSettings[name] = result;
                    return result
                };
                var applyParticularTheme = {
                    base: mergeOptions,
                    argumentAxis: applyParticularAxisOptions,
                    valueAxisRangeSelector: function() {
                        return mergeOptions.call(this, "valueAxis")
                    },
                    valueAxis: applyParticularAxisOptions,
                    series: function(name, userOptions) {
                        var settings, mainSeriesColor, seriesVisibility, that = this,
                            theme = that._theme,
                            userCommonSettings = that._userOptions.commonSeriesSettings || {},
                            themeCommonSettings = theme.commonSeriesSettings,
                            widgetType = that._themeSection.split(".").slice(-1)[0],
                            type = _normalizeEnum(userOptions.type || userCommonSettings.type || themeCommonSettings.type || "pie" === widgetType && theme.type),
                            palette = that.palette,
                            isBar = ~type.indexOf("bar"),
                            isLine = ~type.indexOf("line"),
                            isArea = ~type.indexOf("area"),
                            isBubble = "bubble" === type,
                            resolveLabelsOverlapping = that.getOptions("resolveLabelsOverlapping"),
                            resolveLabelOverlapping = that.getOptions("resolveLabelOverlapping"),
                            containerBackgroundColor = that.getOptions("containerBackgroundColor");
                        if (isBar || isBubble) {
                            userOptions = $.extend(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
                            seriesVisibility = userOptions.visible;
                            userCommonSettings = {
                                type: {}
                            };
                            $.extend(true, userOptions, userOptions.point);
                            userOptions.visible = seriesVisibility
                        }
                        settings = $.extend(true, {}, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
                        settings.type = type;
                        settings.widgetType = widgetType;
                        settings.containerBackgroundColor = containerBackgroundColor;
                        if ("pie" !== widgetType) {
                            mainSeriesColor = settings.color || palette.getNextColor()
                        } else {
                            mainSeriesColor = function(argument, index) {
                                var cat = argument + index;
                                if (!that._multiPieColors[cat]) {
                                    that._multiPieColors[cat] = palette.getNextColor()
                                }
                                return that._multiPieColors[cat]
                            }
                        }
                        settings.mainSeriesColor = mainSeriesColor;
                        settings._IE8 = isIE8;
                        settings.resolveLabelOverlapping = resolveLabelOverlapping;
                        settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
                        if (settings.label && (isLine || isArea && "rangearea" !== type || "scatter" === type)) {
                            settings.label.position = "outside"
                        }
                        return settings
                    },
                    animation: function(name) {
                        var userOptions = this._userOptions[name];
                        userOptions = $.isPlainObject(userOptions) ? userOptions : _isDefined(userOptions) ? {
                            enabled: !!userOptions
                        } : {};
                        return mergeOptions.call(this, name, userOptions)
                    }
                };
                return {
                    _themeSection: "chart",
                    ctor: ctor,
                    dispose: dispose,
                    resetPalette: resetPalette,
                    getOptions: function(name) {
                        return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments)
                    },
                    refresh: function() {
                        this._mergedSettings = {};
                        return this.callBase.apply(this, arguments)
                    },
                    _initializeTheme: function() {
                        var that = this;
                        that.callBase.apply(that, arguments);
                        that.updatePalette(that.getOptions("palette"))
                    },
                    resetOptions: function(name) {
                        this._mergedSettings[name] = null
                    },
                    update: function(options) {
                        this._userOptions = options
                    },
                    updatePalette: updatePalette
                }
            }());
            exports.ThemeManager = ThemeManager;
            exports._setIE8Mode = function(isIE8Mode) {
                var initIEMode = isIE8;
                isIE8 = isIE8Mode;
                return initIEMode
            };
            exports._resetIE8Mode = function(initIEMode) {
                isIE8 = initIEMode
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/components/legend.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                layoutElementModule = __webpack_require__( /*! ../core/layout_element */ 190),
                _Number = Number,
                _math = Math,
                _round = _math.round,
                _max = _math.max,
                _min = _math.min,
                _ceil = _math.ceil,
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _isFunction = commonUtils.isFunction,
                _enumParser = vizUtils.enumParser,
                _normalizeEnum = vizUtils.normalizeEnum,
                _extend = $.extend,
                _each = $.each,
                DEFAULT_MARGIN = 10,
                DEFAULT_MARKER_HATCHING_WIDTH = 2,
                DEFAULT_MARKER_HATCHING_STEP = 5,
                CENTER = "center",
                RIGHT = "right",
                LEFT = "left",
                TOP = "top",
                BOTTOM = "bottom",
                HORIZONTAL = "horizontal",
                VERTICAL = "vertical",
                INSIDE = "inside",
                OUTSIDE = "outside",
                NONE = "none",
                HEIGHT = "height",
                WIDTH = "width",
                parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]),
                parseVerticalAlignment = _enumParser([TOP, BOTTOM]),
                parseOrientation = _enumParser([VERTICAL, HORIZONTAL]),
                parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]),
                parsePosition = _enumParser([OUTSIDE, INSIDE]),
                parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);

            function getPattern(renderer, states, action, color) {
                if (!states || !states[action]) {
                    return
                }
                var hatching, direction = states[action].hatching.direction,
                    colorFromAction = states[action].fill;
                color = colorFromAction === NONE ? color : colorFromAction;
                direction = !direction || direction === NONE ? RIGHT : direction;
                hatching = _extend({}, states[action].hatching, {
                    direction: direction,
                    step: DEFAULT_MARKER_HATCHING_STEP,
                    width: DEFAULT_MARKER_HATCHING_WIDTH
                });
                return renderer.pattern(color, hatching)
            }

            function parseMargins(options) {
                var margin = options.margin;
                if (margin >= 0) {
                    margin = _Number(options.margin);
                    margin = {
                        top: margin,
                        bottom: margin,
                        left: margin,
                        right: margin
                    }
                } else {
                    margin = {
                        top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
                        bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
                        left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
                        right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
                    }
                }
                options.margin = margin
            }

            function getSizeItem(options, markerSize, labelBBox) {
                var width, height, defaultXMargin = 7,
                    defaultTopMargin = 4;
                switch (options.itemTextPosition) {
                    case LEFT:
                    case RIGHT:
                        width = markerSize + defaultXMargin + labelBBox.width;
                        height = _max(markerSize, labelBBox.height);
                        break;
                    case TOP:
                    case BOTTOM:
                        width = _max(markerSize, labelBBox.width);
                        height = markerSize + defaultTopMargin + labelBBox.height
                }
                return {
                    width: width,
                    height: height
                }
            }

            function calculateBboxLabelAndMarker(markerBBox, labelBBox) {
                var bbox = {};
                bbox.left = _min(markerBBox.x, labelBBox.x);
                bbox.top = _min(markerBBox.y, labelBBox.y);
                bbox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
                bbox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
                return bbox
            }

            function applyMarkerState(id, idToIndexMap, items, stateName) {
                var item = idToIndexMap && items[idToIndexMap[id]];
                if (item) {
                    item.marker.attr(item.states[stateName])
                }
            }

            function parseOptions(options, textField) {
                if (!options) {
                    return null
                }
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assertParam(options.visible, "Visibility was not passed");
                debug.assertParam(options.markerSize, "markerSize was not passed");
                debug.assertParam(options.font.color, "fontColor was not passed");
                debug.assertParam(options.font.family, "fontFamily was not passed");
                debug.assertParam(options.font.size, "fontSize was not passed");
                debug.assertParam(options.paddingLeftRight, "paddingLeftRight was not passed");
                debug.assertParam(options.paddingTopBottom, "paddingTopBottom was not passed");
                debug.assertParam(options.columnItemSpacing, "columnItemSpacing was not passed");
                debug.assertParam(options.rowItemSpacing, "rowItemSpacing was not passed");
                parseMargins(options);
                options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
                options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
                options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
                options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
                options.position = parsePosition(options.position, OUTSIDE);
                options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
                options.hoverMode = _normalizeEnum(options.hoverMode);
                options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function() {
                    return this[textField]
                };
                options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : $.noop;
                options._incidentOccurred = options._incidentOccurred || $.noop;
                return options
            }

            function createSquareMarker(renderer, size) {
                return renderer.rect(0, 0, size, size)
            }

            function createCircleMarker(renderer, size) {
                return renderer.circle(size / 2, size / 2, size / 2)
            }

            function isCircle(type) {
                return "circle" === _normalizeEnum(type)
            }

            function getMarkerCreator(type) {
                return isCircle(type) ? createCircleMarker : createSquareMarker
            }

            function inRect(rect, x, y) {
                return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom
            }

            function checkLinesSize(lines, layoutOptions, countItems) {
                var position = {
                        x: 0,
                        y: 0
                    },
                    maxMeasureLength = 0,
                    maxOrtMeasureLength = 0;
                _each(lines, function(i, line) {
                    var firstItem = line[0];
                    _each(line, function(_, item) {
                        var offset = item.offset || layoutOptions.spacing;
                        position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
                        maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction])
                    });
                    position[layoutOptions.direction] = 0;
                    position[layoutOptions.ortDirection] += firstItem[layoutOptions.ortMeasure] + firstItem.ortOffset || layoutOptions.ortSpacing;
                    maxOrtMeasureLength = _max(maxOrtMeasureLength, position[layoutOptions.ortDirection])
                });
                if (maxMeasureLength > layoutOptions.length) {
                    layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
                    return true
                }
            }

            function decreaseItemCount(layoutOptions, countItems) {
                layoutOptions.ortCountItem++;
                return _ceil(countItems / layoutOptions.ortCountItem)
            }

            function getLineLength(line, layoutOptions) {
                var lineLength = 0;
                _each(line, function(_, item) {
                    var offset = item.offset || layoutOptions.spacing;
                    lineLength += item[layoutOptions.measure] + offset
                });
                return lineLength
            }

            function getMaxLineLength(lines, layoutOptions) {
                var maxLineLength = 0;
                _each(lines, function(_, line) {
                    maxLineLength = _max(maxLineLength, getLineLength(line, layoutOptions))
                });
                return maxLineLength
            }

            function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
                var initPosition, lineLength = getLineLength(line, layoutOptions);
                switch (layoutOptions.itemsAlignment) {
                    case RIGHT:
                        initPosition = maxLineLength - lineLength;
                        break;
                    case CENTER:
                        initPosition = (maxLineLength - lineLength) / 2;
                        break;
                    default:
                        initPosition = 0
                }
                return initPosition
            }

            function getPos(layoutOptions) {
                switch (layoutOptions.itemTextPosition) {
                    case BOTTOM:
                        return {
                            horizontal: CENTER,
                            vertical: TOP
                        };
                    case TOP:
                        return {
                            horizontal: CENTER,
                            vertical: BOTTOM
                        };
                    case LEFT:
                        return {
                            horizontal: RIGHT,
                            vertical: CENTER
                        };
                    case RIGHT:
                        return {
                            horizontal: LEFT,
                            vertical: CENTER
                        }
                }
            }

            function getLines(lines, layoutOptions, itemIndex) {
                var tableLine = {};
                if (itemIndex % layoutOptions.countItem === 0) {
                    if (layoutOptions.markerOffset) {
                        lines.push([], [])
                    } else {
                        lines.push([])
                    }
                }
                if (layoutOptions.markerOffset) {
                    tableLine.firstLine = lines[lines.length - 1];
                    tableLine.secondLine = lines[lines.length - 2]
                } else {
                    tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1]
                }
                return tableLine
            }

            function setMaxInLine(line, measure) {
                var maxLineSize = 0;
                _each(line, function(_, item) {
                    if (!item) {
                        return
                    }
                    maxLineSize = _max(maxLineSize, item[measure])
                });
                _each(line, function(_, item) {
                    if (!item) {
                        return
                    }
                    item[measure] = maxLineSize
                })
            }

            function transpose(array) {
                var i, j, width = array.length,
                    height = array[0].length,
                    transposeArray = [];
                for (i = 0; i < height; i++) {
                    transposeArray[i] = [];
                    for (j = 0; j < width; j++) {
                        transposeArray[i][j] = array[j][i]
                    }
                }
                return transposeArray
            }

            function getAlign(position) {
                switch (position) {
                    case TOP:
                    case BOTTOM:
                        return CENTER;
                    case LEFT:
                        return RIGHT;
                    case RIGHT:
                        return LEFT
                }
            }
            var _Legend = exports.Legend = function(settings) {
                var that = this;
                that._renderer = settings.renderer;
                that._legendGroup = settings.group;
                that._backgroundClass = settings.backgroundClass;
                that._itemGroupClass = settings.itemGroupClass;
                that._textField = settings.textField;
                that._getCustomizeObject = settings.getFormatObject;
                that._patterns = []
            };
            var legendPrototype = _Legend.prototype = objectUtils.clone(layoutElementModule.LayoutElement.prototype);
            $.extend(legendPrototype, {
                constructor: _Legend,
                update: function(data, options) {
                    var that = this;
                    that._data = data;
                    that._boundingRect = {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
                    that._options = parseOptions(options, that._textField);
                    return that
                },
                draw: function(width, height) {
                    var that = this,
                        options = that._options,
                        renderer = that._renderer,
                        items = that._data;
                    this._size = {
                        width: width,
                        height: height
                    };
                    that.erase();
                    if (!(options && options.visible && items && items.length)) {
                        return that
                    }
                    that._insideLegendGroup = renderer.g().append(that._legendGroup);
                    that._createBackground();
                    that._createItems(that._getItemData());
                    that._locateElements(options);
                    that._finalUpdate(options);
                    if (that.getLayoutOptions().width > width || that.getLayoutOptions().height > height) {
                        that._options._incidentOccurred("W2104");
                        that.erase()
                    }
                    return that
                },
                probeDraw: function(width, height) {
                    return this.draw(width, height)
                },
                _createItems: function(items) {
                    var bbox, that = this,
                        options = that._options,
                        initMarkerSize = options.markerSize,
                        renderer = that._renderer,
                        i = 0,
                        maxBboxHeight = 0,
                        createMarker = getMarkerCreator(options.markerShape || options.markerType);
                    that._markersId = {};
                    for (; i < that._patterns.length; i++) {
                        that._patterns[i].dispose()
                    }
                    that._patterns = [];
                    that._items = vizUtils.map(items, function(dataItem, i) {
                        var group = that._insideLegendGroup,
                            markerSize = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize),
                            stateOfDataItem = dataItem.states,
                            normalState = stateOfDataItem.normal,
                            normalStateFill = normalState.fill,
                            marker = createMarker(renderer, markerSize).attr({
                                fill: normalStateFill || options.markerColor,
                                opacity: normalState.opacity
                            }).append(group),
                            label = that._createLabel(dataItem, group),
                            hoverPattern = getPattern(renderer, stateOfDataItem, "hover", normalStateFill),
                            selectionPattern = getPattern(renderer, stateOfDataItem, "selection", normalStateFill),
                            states = {
                                normal: {
                                    fill: normalStateFill
                                }
                            },
                            labelBBox = label.getBBox();
                        if (hoverPattern) {
                            states.hovered = {
                                fill: hoverPattern.id
                            };
                            that._patterns.push(hoverPattern)
                        }
                        if (selectionPattern) {
                            states.selected = {
                                fill: selectionPattern.id
                            };
                            that._patterns.push(selectionPattern)
                        }
                        if (void 0 !== dataItem.id) {
                            that._markersId[dataItem.id] = i
                        }
                        bbox = getSizeItem(options, markerSize, labelBBox);
                        maxBboxHeight = _max(maxBboxHeight, bbox.height);
                        that._createHint(dataItem, label);
                        return {
                            label: label,
                            labelBBox: labelBBox,
                            group: group,
                            bbox: bbox,
                            marker: marker,
                            markerSize: markerSize,
                            tracker: {
                                id: dataItem.id,
                                argument: dataItem.argument
                            },
                            states: states,
                            itemTextPosition: options.itemTextPosition,
                            markerOffset: 0,
                            bboxs: []
                        }
                    });
                    if (options.equalRowHeight) {
                        _each(that._items, function(_, item) {
                            item.bbox.height = maxBboxHeight
                        })
                    }
                },
                _getItemData: function() {
                    var items = this._data;
                    if (this._options.inverted) {
                        items = items.slice().reverse()
                    }
                    return items
                },
                _finalUpdate: function(options) {
                    this._adjustBackgroundSettings(options);
                    this._setBoundingRect(options.margin)
                },
                erase: function() {
                    var that = this,
                        insideLegendGroup = that._insideLegendGroup;
                    insideLegendGroup && insideLegendGroup.dispose();
                    that._insideLegendGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
                    return that
                },
                _locateElements: function(locationOptions) {
                    this._moveInInitialValues();
                    this._locateRowsColumns(locationOptions)
                },
                _moveInInitialValues: function() {
                    var that = this;
                    that._legendGroup && that._legendGroup.move(0, 0);
                    that._background && that._background.attr({
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    })
                },
                applySelected: function(id) {
                    applyMarkerState(id, this._markersId, this._items, "selected");
                    return this
                },
                applyHover: function(id) {
                    applyMarkerState(id, this._markersId, this._items, "hovered");
                    return this
                },
                resetItem: function(id) {
                    applyMarkerState(id, this._markersId, this._items, "normal");
                    return this
                },
                _createLabel: function(data, group) {
                    var labelFormatObject = this._getCustomizeObject(data),
                        align = getAlign(this._options.itemTextPosition),
                        text = this._options.customizeText.call(labelFormatObject, labelFormatObject),
                        fontStyle = _isDefined(data.textOpacity) ? _extend({}, this._options.font, {
                            opacity: data.textOpacity
                        }) : this._options.font;
                    return this._renderer.text(text, 0, 0).css(vizUtils.patchFontOptions(fontStyle)).attr({
                        align: align
                    }).append(group)
                },
                _createHint: function(data, label) {
                    var labelFormatObject = this._getCustomizeObject(data),
                        text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
                    if (_isDefined(text) && "" !== text) {
                        label.setTitle(text)
                    }
                },
                _createBackground: function() {
                    var that = this,
                        isInside = that._options.position === INSIDE,
                        color = that._options.backgroundColor,
                        fill = color || (isInside ? that._options.containerBackgroundColor : NONE);
                    if (that._options.border.visible || (isInside || color) && color !== NONE) {
                        that._background = that._renderer.rect(0, 0, 0, 0).attr({
                            fill: fill,
                            "class": that._backgroundClass
                        }).append(that._insideLegendGroup)
                    }
                },
                _locateRowsColumns: function() {
                    var lines, that = this,
                        iteration = 0,
                        layoutOptions = that._getItemsLayoutOptions(),
                        countItems = that._items.length;
                    do {
                        lines = [];
                        that._createLines(lines, layoutOptions);
                        that._alignLines(lines, layoutOptions);
                        iteration++
                    } while (checkLinesSize(lines, layoutOptions, countItems) && iteration < countItems);
                    that._applyItemPosition(lines, layoutOptions)
                },
                _createLines: function(lines, layoutOptions) {
                    _each(this._items, function(i, item) {
                        var firstItem, secondItem, tableLine = getLines(lines, layoutOptions, i),
                            labelBox = {
                                width: item.labelBBox.width,
                                height: item.labelBBox.height,
                                element: item.label,
                                bbox: item.labelBBox,
                                pos: getPos(layoutOptions),
                                itemIndex: i
                            },
                            markerBox = {
                                width: item.markerSize,
                                height: item.markerSize,
                                element: item.marker,
                                pos: {
                                    horizontal: CENTER,
                                    vertical: CENTER
                                },
                                bbox: {
                                    width: item.markerSize,
                                    height: item.markerSize,
                                    x: 0,
                                    y: 0
                                },
                                itemIndex: i
                            },
                            offsetDirection = layoutOptions.markerOffset ? "ortOffset" : "offset";
                        if (layoutOptions.inverseLabelPosition) {
                            firstItem = labelBox;
                            secondItem = markerBox
                        } else {
                            firstItem = markerBox;
                            secondItem = labelBox
                        }
                        firstItem[offsetDirection] = layoutOptions.labelOffset;
                        tableLine.secondLine.push(firstItem);
                        tableLine.firstLine.push(secondItem)
                    })
                },
                _alignLines: function(lines, layoutOptions) {
                    var i, measure = layoutOptions.ortMeasure;
                    _each(lines, processLine);
                    measure = layoutOptions.measure;
                    if (layoutOptions.itemsAlignment) {
                        if (layoutOptions.markerOffset) {
                            for (i = 0; i < lines.length;) {
                                _each(transpose([lines[i++], lines[i++]]), processLine)
                            }
                        }
                    } else {
                        _each(transpose(lines), processLine)
                    }

                    function processLine(_, line) {
                        setMaxInLine(line, measure)
                    }
                },
                _applyItemPosition: function(lines, layoutOptions) {
                    var that = this,
                        position = {
                            x: 0,
                            y: 0
                        },
                        maxLineLength = getMaxLineLength(lines, layoutOptions),
                        itemIndex = 0;
                    _each(lines, function(i, line) {
                        var firstItem = line[0],
                            ortOffset = firstItem.ortOffset || layoutOptions.ortSpacing;
                        position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
                        _each(line, function(_, item) {
                            var offset = item.offset || layoutOptions.spacing,
                                wrap = new layoutElementModule.WrapperLayoutElement(item.element, item.bbox),
                                itemBBox = new layoutElementModule.WrapperLayoutElement(null, {
                                    x: position.x,
                                    y: position.y,
                                    width: item.width,
                                    height: item.height
                                }),
                                itemLegend = that._items[item.itemIndex];
                            wrap.position({
                                of: itemBBox,
                                my: item.pos,
                                at: item.pos
                            });
                            itemLegend.bboxs.push(itemBBox);
                            position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
                            itemIndex++
                        });
                        position[layoutOptions.ortDirection] += firstItem[layoutOptions.ortMeasure] + ortOffset
                    });
                    _each(this._items, function(_, item) {
                        var itemBBox = calculateBboxLabelAndMarker(item.bboxs[0].getLayoutOptions(), item.bboxs[1].getLayoutOptions()),
                            horizontal = that._options.columnItemSpacing / 2,
                            vertical = that._options.rowItemSpacing / 2;
                        item.tracker.left = itemBBox.left - horizontal;
                        item.tracker.right = itemBBox.right + horizontal;
                        item.tracker.top = itemBBox.top - vertical;
                        item.tracker.bottom = itemBBox.bottom + vertical
                    })
                },
                _getItemsLayoutOptions: function() {
                    var that = this,
                        options = that._options,
                        orientation = options.orientation,
                        layoutOptions = {
                            itemsAlignment: options.itemsAlignment,
                            orientation: options.orientation
                        },
                        width = that._size.width - 2 * options.paddingLeftRight,
                        height = that._size.height - 2 * options.paddingTopBottom;
                    if (orientation === HORIZONTAL) {
                        layoutOptions.length = width;
                        layoutOptions.ortLength = height;
                        layoutOptions.spacing = options.columnItemSpacing;
                        layoutOptions.direction = "x";
                        layoutOptions.measure = WIDTH;
                        layoutOptions.ortMeasure = HEIGHT;
                        layoutOptions.ortDirection = "y";
                        layoutOptions.ortSpacing = options.rowItemSpacing;
                        layoutOptions.countItem = options.columnCount;
                        layoutOptions.ortCountItem = options.rowCount;
                        layoutOptions.marginTextLabel = 4;
                        layoutOptions.labelOffset = 7;
                        if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
                            layoutOptions.labelOffset = 4;
                            layoutOptions.markerOffset = true
                        }
                    } else {
                        layoutOptions.length = height;
                        layoutOptions.ortLength = width;
                        layoutOptions.spacing = options.rowItemSpacing;
                        layoutOptions.direction = "y";
                        layoutOptions.measure = HEIGHT;
                        layoutOptions.ortMeasure = WIDTH;
                        layoutOptions.ortDirection = "x";
                        layoutOptions.ortSpacing = options.columnItemSpacing;
                        layoutOptions.countItem = options.rowCount;
                        layoutOptions.ortCountItem = options.columnCount;
                        layoutOptions.marginTextLabel = 7;
                        layoutOptions.labelOffset = 4;
                        if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
                            layoutOptions.labelOffset = 7;
                            layoutOptions.markerOffset = true
                        }
                    }
                    if (!layoutOptions.countItem) {
                        if (layoutOptions.ortCountItem) {
                            layoutOptions.countItem = _ceil(that._items.length / layoutOptions.ortCountItem)
                        } else {
                            layoutOptions.countItem = that._items.length
                        }
                    }
                    if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
                        layoutOptions.inverseLabelPosition = true
                    }
                    layoutOptions.itemTextPosition = options.itemTextPosition;
                    layoutOptions.ortCountItem = layoutOptions.ortCountItem || _ceil(that._items.length / layoutOptions.countItem);
                    return layoutOptions
                },
                _adjustBackgroundSettings: function(locationOptions) {
                    if (!this._background) {
                        return
                    }
                    var border = locationOptions.border,
                        legendBox = this._insideLegendGroup.getBBox(),
                        backgroundSettings = {
                            x: _round(legendBox.x - locationOptions.paddingLeftRight),
                            y: _round(legendBox.y - locationOptions.paddingTopBottom),
                            width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
                            height: _round(legendBox.height) + 2 * locationOptions.paddingTopBottom,
                            opacity: locationOptions.backgroundOpacity
                        };
                    if (border.visible && border.width && border.color && border.color !== NONE) {
                        backgroundSettings["stroke-width"] = border.width;
                        backgroundSettings.stroke = border.color;
                        backgroundSettings["stroke-opacity"] = border.opacity;
                        backgroundSettings.dashStyle = border.dashStyle;
                        backgroundSettings.rx = border.cornerRadius || 0;
                        backgroundSettings.ry = border.cornerRadius || 0
                    }
                    this._background.attr(backgroundSettings)
                },
                _setBoundingRect: function(margin) {
                    if (!this._insideLegendGroup) {
                        return
                    }
                    var box = this._insideLegendGroup.getBBox();
                    box.height += margin.top + margin.bottom;
                    box.width += margin.left + margin.right;
                    box.x -= margin.left;
                    box.y -= margin.top;
                    this._boundingRect = box
                },
                getActionCallback: function(point) {
                    var that = this;
                    if (that._options.visible) {
                        return function(act) {
                            that[act](point.index)
                        }
                    } else {
                        return $.noop
                    }
                },
                getLayoutOptions: function() {
                    var options = this._options,
                        boundingRect = this._insideLegendGroup ? this._boundingRect : {
                            width: 0,
                            height: 0,
                            x: 0,
                            y: 0
                        };
                    if (options) {
                        boundingRect.verticalAlignment = options.verticalAlignment;
                        boundingRect.horizontalAlignment = options.horizontalAlignment;
                        if (options.orientation === HORIZONTAL) {
                            boundingRect.cutLayoutSide = options.verticalAlignment;
                            boundingRect.cutSide = "vertical"
                        } else {
                            if (options.horizontalAlignment === CENTER) {
                                boundingRect.cutLayoutSide = options.verticalAlignment;
                                boundingRect.cutSide = "vertical"
                            } else {
                                boundingRect.cutLayoutSide = options.horizontalAlignment;
                                boundingRect.cutSide = "horizontal"
                            }
                        }
                        boundingRect.position = {
                            horizontal: options.horizontalAlignment,
                            vertical: options.verticalAlignment
                        };
                        return boundingRect
                    }
                    return null
                },
                shift: function(x, y) {
                    var that = this,
                        box = {};
                    if (that._insideLegendGroup) {
                        that._insideLegendGroup.attr({
                            translateX: x - that._boundingRect.x,
                            translateY: y - that._boundingRect.y
                        });
                        box = that._legendGroup.getBBox()
                    }
                    that._x1 = box.x;
                    that._y1 = box.y;
                    that._x2 = box.x + box.width;
                    that._y2 = box.y + box.height;
                    return that
                },
                getPosition: function() {
                    return this._options.position
                },
                coordsIn: function(x, y) {
                    return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2
                },
                getItemByCoord: function(x, y) {
                    var items = this._items,
                        legendGroup = this._insideLegendGroup;
                    x -= legendGroup.attr("translateX");
                    y -= legendGroup.attr("translateY");
                    for (var i = 0; i < items.length; i++) {
                        if (inRect(items[i].tracker, x, y)) {
                            return items[i].tracker
                        }
                    }
                    return null
                },
                dispose: function() {
                    var that = this;
                    that._legendGroup = that._insideLegendGroup = that._renderer = that._options = that._data = that._items = null;
                    return that
                }
            });
            var __getMarkerCreator = getMarkerCreator;
            exports._DEBUG_stubMarkerCreator = function(callback) {
                getMarkerCreator = function() {
                    return callback
                }
            };
            exports._DEBUG_restoreMarkerCreator = function() {
                getMarkerCreator = __getMarkerCreator
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/core/series_family.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _math = Math,
                _round = _math.round,
                _abs = _math.abs,
                _pow = _math.pow,
                _each = $.each,
                _noop = $.noop,
                vizUtils = __webpack_require__( /*! ./utils */ 6),
                _normalizeEnum = vizUtils.normalizeEnum;

            function getStacksWithArgument(stackKeepers, argument) {
                var stacksWithArgument = [];
                _each(stackKeepers, function(stackName, seriesInStack) {
                    _each(seriesInStack, function(_, singleSeries) {
                        var i, points = singleSeries.getPointsByArg(argument),
                            pointsLength = points.length;
                        for (i = 0; i < pointsLength; ++i) {
                            if (points[i].value) {
                                stacksWithArgument.push(stackName);
                                return false
                            }
                        }
                    })
                });
                return stacksWithArgument
            }

            function correctPointCoordinatesForStacks(stackKeepers, stacksWithArgument, argument, parameters) {
                _each(stackKeepers, function(stackName, seriesInStack) {
                    var offset, stackIndex = $.inArray(stackName, stacksWithArgument);
                    if (-1 === stackIndex) {
                        return
                    }
                    offset = getOffset(stackIndex, parameters);
                    _each(seriesInStack, function(_, singleSeries) {
                        correctPointCoordinates(singleSeries.getPointsByArg(argument) || [], parameters.width, offset)
                    })
                })
            }

            function adjustBarSeriesDimensionsCore(series, interval, stackCount, options, seriesStackIndexCallback) {
                var percentWidth, stackIndex, i, points, stackName, stacksWithArgument, parameters, argumentsKeeper = {},
                    stackKeepers = {},
                    barsArea = .7 * interval,
                    barWidth = options.barWidth;
                if (options.equalBarWidth) {
                    percentWidth = barWidth && (barWidth < 0 || barWidth > 1) ? 0 : barWidth;
                    parameters = calculateParams(barsArea, stackCount, percentWidth);
                    for (i = 0; i < series.length; i++) {
                        stackIndex = seriesStackIndexCallback(i, stackCount);
                        points = series[i].getPoints();
                        correctPointCoordinates(points, parameters.width, getOffset(stackIndex, parameters))
                    }
                } else {
                    _each(series, function(i, singleSeries) {
                        stackName = singleSeries.getStackName && singleSeries.getStackName();
                        stackName = stackName || i.toString();
                        if (!stackKeepers[stackName]) {
                            stackKeepers[stackName] = []
                        }
                        stackKeepers[stackName].push(singleSeries);
                        _each(singleSeries.getPoints(), function(_, point) {
                            var argument = point.argument;
                            if (!argumentsKeeper.hasOwnProperty(argument)) {
                                argumentsKeeper[argument.valueOf()] = 1
                            }
                        })
                    });
                    for (var argument in argumentsKeeper) {
                        stacksWithArgument = getStacksWithArgument(stackKeepers, argument);
                        parameters = calculateParams(barsArea, stacksWithArgument.length);
                        correctPointCoordinatesForStacks(stackKeepers, stacksWithArgument, argument, parameters)
                    }
                }
            }

            function calculateParams(barsArea, count, percentWidth) {
                var spacing, width, middleIndex = count / 2;
                if (!percentWidth) {
                    spacing = _round(barsArea / count * .2);
                    width = _round((barsArea - spacing * (count - 1)) / count);
                    width < 2 && (width = 2)
                } else {
                    width = _round(barsArea * percentWidth / count);
                    spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0)
                }
                return {
                    width: width,
                    spacing: spacing,
                    middleIndex: middleIndex
                }
            }

            function getOffset(stackIndex, parameters) {
                return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing
            }

            function correctPointCoordinates(points, width, offset) {
                _each(points, function(_, point) {
                    point.correctCoordinates({
                        width: width,
                        offset: offset
                    })
                })
            }

            function checkMinBarSize(value, minShownValue) {
                return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value
            }

            function getValueType(value) {
                return value >= 0 ? "positive" : "negative"
            }

            function getVisibleSeries(that) {
                return vizUtils.map(that.series, function(s) {
                    return s.isVisible() ? s : null
                })
            }

            function getAbsStackSumByArg(stackKeepers, stackName, argument) {
                var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0,
                    negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
                return positiveStackValue + negativeStackValue
            }

            function getSeriesStackIndexCallback(rotated, series, stackIndexes) {
                if (!rotated) {
                    return function(seriesIndex, stackCount) {
                        return stackIndexes ? stackIndexes[series[seriesIndex].getStackName()] : seriesIndex
                    }
                } else {
                    return function(seriesIndex, stackCount) {
                        return stackCount - (stackIndexes ? stackIndexes[series[seriesIndex].getStackName()] : seriesIndex) - 1
                    }
                }
            }

            function adjustBarSeriesDimensions(translators) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assert(translators, "translator was not passed or empty");
                var that = this,
                    series = getVisibleSeries(that);
                adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), series.length, that._options, getSeriesStackIndexCallback(that.rotated, series))
            }

            function adjustStackedBarSeriesDimensions(translators) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assert(translators, "translators was not passed or empty");
                var that = this,
                    series = getVisibleSeries(that),
                    stackIndexes = {},
                    stackCount = 0;
                _each(series, function() {
                    var stackName = this.getStackName();
                    if (!stackIndexes.hasOwnProperty(stackName)) {
                        stackIndexes[stackName] = stackCount++
                    }
                });
                adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), stackCount, that._options, getSeriesStackIndexCallback(that.rotated, series, stackIndexes))
            }

            function adjustStackedSeriesValues() {
                var that = this,
                    negativesAsZeroes = that._options.negativesAsZeroes,
                    series = getVisibleSeries(that),
                    stackKeepers = {
                        positive: {},
                        negative: {}
                    },
                    holesStack = {
                        left: {},
                        right: {}
                    };
                _each(series, function(seriesIndex, singleSeries) {
                    var points = singleSeries.getPoints(),
                        hole = false;
                    singleSeries._prevSeries = series[seriesIndex - 1];
                    singleSeries.holes = $.extend(true, {}, holesStack);
                    _each(points, function(index, point) {
                        var currentStack, value = point.initialValue,
                            argument = point.argument.valueOf(),
                            stackName = singleSeries.getStackName(),
                            stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
                        if (negativesAsZeroes && value < 0) {
                            stacks = stackKeepers.positive;
                            value = 0;
                            point.resetValue()
                        }
                        stacks[stackName] = stacks[stackName] || {};
                        currentStack = stacks[stackName];
                        if (currentStack[argument]) {
                            point.correctValue(currentStack[argument]);
                            currentStack[argument] += value
                        } else {
                            currentStack[argument] = value;
                            point.resetCorrection()
                        }
                        if (!point.hasValue()) {
                            var prevPoint = points[index - 1];
                            if (!hole && prevPoint && prevPoint.hasValue()) {
                                argument = prevPoint.argument.valueOf();
                                prevPoint._skipSetRightHole = true;
                                holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value - (isFinite(prevPoint.minValue) ? prevPoint.minValue : 0))
                            }
                            hole = true
                        } else {
                            if (hole) {
                                hole = false;
                                holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value - (isFinite(point.minValue) ? point.minValue : 0));
                                point._skipSetLeftHole = true
                            }
                        }
                    })
                });
                _each(series, function(seriesIndex, singleSeries) {
                    var points = singleSeries.getPoints(),
                        holes = singleSeries.holes;
                    _each(points, function(index, point) {
                        var argument = point.argument.valueOf();
                        point.resetHoles();
                        !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, "left");
                        !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, "right");
                        point._skipSetLeftHole = null;
                        point._skipSetRightHole = null
                    })
                });
                that._stackKeepers = stackKeepers;
                _each(series, function(_, singleSeries) {
                    _each(singleSeries.getPoints(), function(_, point) {
                        var argument = point.argument.valueOf();
                        point.setPercentValue(getAbsStackSumByArg(stackKeepers, singleSeries.getStackName(), argument), that.fullStacked, holesStack.left[argument], holesStack.right[argument])
                    })
                })
            }

            function updateStackedSeriesValues(translators) {
                var that = this,
                    series = getVisibleSeries(that),
                    stack = that._stackKeepers,
                    stackKeepers = {
                        positive: {},
                        negative: {}
                    };
                _each(series, function(_, singleSeries) {
                    var minBarSize = singleSeries.getOptions().minBarSize,
                        tr = singleSeries.axis ? translators.axesTrans[singleSeries.axis] : translators,
                        minShownBusinessValue = minBarSize && tr.val.getMinBarSize(minBarSize),
                        stackName = singleSeries.getStackName();
                    _each(singleSeries.getPoints(), function(index, point) {
                        if (!point.hasValue()) {
                            return
                        }
                        var updateValue, valueType, currentStack, value = point.initialValue,
                            argument = point.argument.valueOf();
                        if (that.fullStacked) {
                            value = value / getAbsStackSumByArg(stack, stackName, argument) || 0
                        }
                        updateValue = checkMinBarSize(value, minShownBusinessValue);
                        valueType = getValueType(updateValue);
                        currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                        if (currentStack[argument]) {
                            point.minValue = currentStack[argument];
                            currentStack[argument] += updateValue
                        } else {
                            currentStack[argument] = updateValue
                        }
                        point.value = currentStack[argument]
                    })
                });
                if (that.fullStacked) {
                    updateFullStackedSeriesValues(series, stackKeepers)
                }
            }

            function updateFullStackedSeriesValues(series, stackKeepers) {
                _each(series, function(_, singleSeries) {
                    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : "default";
                    _each(singleSeries.getPoints(), function(index, point) {
                        var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());
                        point.value = point.value / stackSum;
                        if (commonUtils.isNumber(point.minValue)) {
                            point.minValue = point.minValue / stackSum
                        }
                    })
                })
            }

            function updateBarSeriesValues(translators) {
                _each(this.series, function(_, singleSeries) {
                    var minBarSize = singleSeries.getOptions().minBarSize,
                        tr = singleSeries.axis ? translators.axesTrans[singleSeries.axis] : translators,
                        minShownBusinessValue = minBarSize && tr.val.getMinBarSize(minBarSize);
                    if (minShownBusinessValue) {
                        _each(singleSeries.getPoints(), function(index, point) {
                            if (point.hasValue()) {
                                point.value = checkMinBarSize(point.initialValue, minShownBusinessValue)
                            }
                        })
                    }
                })
            }

            function adjustCandlestickSeriesDimensions(translators) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assert(translators, "translator was not passed or empty");
                var series = getVisibleSeries(this);
                adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), series.length, {
                    barWidth: null,
                    equalBarWidth: true
                }, getSeriesStackIndexCallback(this.rotated, series))
            }

            function adjustBubbleSeriesDimensions(translators) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assert(translators, "translator was not passed or empty");
                var pointSize, bubbleArea, sizeProportion, sizeDispersion, areaDispersion, that = this,
                    series = getVisibleSeries(that),
                    options = that._options,
                    visibleAreaX = translators.arg.getCanvasVisibleArea(),
                    visibleAreaY = translators.val.getCanvasVisibleArea(),
                    min = _math.min(visibleAreaX.max - visibleAreaX.min, visibleAreaY.max - visibleAreaY.min),
                    minBubbleArea = _pow(options.minBubbleSize, 2),
                    maxBubbleArea = _pow(min * options.maxBubbleSize, 2),
                    equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2,
                    minPointSize = 1 / 0,
                    maxPointSize = 0;
                _each(series, function(_, seriesItem) {
                    _each(seriesItem.getPoints(), function(_, point) {
                        maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
                        minPointSize = minPointSize < point.size ? minPointSize : point.size
                    })
                });
                sizeDispersion = maxPointSize - minPointSize;
                areaDispersion = _abs(maxBubbleArea - minBubbleArea);
                minPointSize = minPointSize < 0 ? 0 : minPointSize;
                _each(series, function(_, seriesItem) {
                    _each(seriesItem.getPoints(), function(_, point) {
                        if (maxPointSize === minPointSize) {
                            pointSize = _round(equalBubbleSize)
                        } else {
                            sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;
                            bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
                            pointSize = _round(_math.sqrt(bubbleArea))
                        }
                        point.correctCoordinates(pointSize)
                    })
                })
            }

            function SeriesFamily(options) {
                var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                debug.assert(options.type, "type was not passed or empty");
                var that = this;
                that.type = _normalizeEnum(options.type);
                that.pane = options.pane;
                that.rotated = options.rotated;
                that.series = [];
                that.updateOptions(options);
                switch (that.type) {
                    case "bar":
                        that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                        that.updateSeriesValues = updateBarSeriesValues;
                        break;
                    case "rangebar":
                        that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                        break;
                    case "fullstackedbar":
                        that.fullStacked = true;
                        that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                        that.adjustSeriesValues = adjustStackedSeriesValues;
                        that.updateSeriesValues = updateStackedSeriesValues;
                        break;
                    case "stackedbar":
                        that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                        that.adjustSeriesValues = adjustStackedSeriesValues;
                        that.updateSeriesValues = updateStackedSeriesValues;
                        break;
                    case "fullstackedarea":
                    case "fullstackedline":
                    case "fullstackedspline":
                    case "fullstackedsplinearea":
                        that.fullStacked = true;
                        that.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    case "stackedarea":
                    case "stackedsplinearea":
                    case "stackedline":
                    case "stackedspline":
                        that.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    case "candlestick":
                    case "stock":
                        that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
                        break;
                    case "bubble":
                        that.adjustSeriesDimensions = adjustBubbleSeriesDimensions
                }
            }
            exports.SeriesFamily = SeriesFamily;
            SeriesFamily.prototype = {
                constructor: SeriesFamily,
                adjustSeriesDimensions: _noop,
                adjustSeriesValues: _noop,
                updateSeriesValues: _noop,
                updateOptions: function(options) {
                    this._options = options
                },
                dispose: function() {
                    this.series = this.translators = null
                },
                add: function(series) {
                    var type = this.type;
                    this.series = vizUtils.map(series, function(singleSeries) {
                        return singleSeries.type === type ? singleSeries : null
                    })
                },
                getStackPoints: function() {
                    var stackPoints = {};
                    $.each(this.series, function(_, singleSeries) {
                        var points = singleSeries.getPoints(),
                            stackName = singleSeries.getStackName() || null;
                        if (!singleSeries.isVisible()) {
                            return
                        }
                        _each(points, function(_, point) {
                            var argument = point.argument;
                            if (!stackPoints[argument]) {
                                stackPoints[argument] = {}
                            }
                            if (!stackPoints[argument][stackName]) {
                                stackPoints[argument][stackName] = []
                            }
                            stackPoints[argument][stackName].push(point)
                        })
                    });
                    return stackPoints
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/viz/gauges/base_range_container.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseElement = __webpack_require__( /*! ./base_indicators */ 235).BaseElement,
                _Number = Number,
                _abs = Math.abs,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isString = commonUtils.isString,
                _isArray = commonUtils.isArray,
                _isFinite = isFinite,
                _each = $.each,
                _map = $.map;
            var BaseRangeContainer = BaseElement.inherit({
                _init: function() {
                    this._root = this._renderer.g().attr({
                        "class": "dxg-range-container"
                    }).linkOn(this._container, "range-container")
                },
                _dispose: function() {
                    this._root.linkOff()
                },
                clean: function() {
                    this._root.linkRemove().clear();
                    this._options = this.enabled = null;
                    return this
                },
                _getRanges: function() {
                    var that = this,
                        options = that._options,
                        translator = that._translator,
                        totalStart = translator.getDomain()[0],
                        totalEnd = translator.getDomain()[1],
                        totalDelta = totalEnd - totalStart,
                        isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDes,
                        subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDes,
                        list = [],
                        ranges = [],
                        backgroundRanges = [{
                            start: totalStart,
                            end: totalEnd
                        }],
                        threshold = _abs(totalDelta) / 1e4,
                        palette = that._themeManager.createPalette(options.palette, {
                            type: "indicatingSet"
                        }),
                        backgroundColor = _isString(options.backgroundColor) ? options.backgroundColor : "none",
                        width = options.width || {},
                        startWidth = _Number(width > 0 ? width : width.start),
                        endWidth = _Number(width > 0 ? width : width.end),
                        deltaWidth = endWidth - startWidth;
                    if (void 0 !== options.ranges && !_isArray(options.ranges)) {
                        return null
                    }
                    if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
                        return null
                    }
                    list = _map(_isArray(options.ranges) ? options.ranges : [], function(rangeOptions, i) {
                        rangeOptions = rangeOptions || {};
                        var start = translator.adjust(rangeOptions.startValue),
                            end = translator.adjust(rangeOptions.endValue);
                        return _isFinite(start) && _isFinite(end) && isNotEmptySegment(start, end, threshold) ? {
                            start: start,
                            end: end,
                            color: rangeOptions.color,
                            classIndex: i
                        } : null
                    });
                    _each(list, function(i, item) {
                        var paletteColor = palette.getNextColor();
                        item.color = _isString(item.color) && item.color || paletteColor || "none";
                        item.className = "dxg-range dxg-range-" + item.classIndex;
                        delete item.classIndex
                    });
                    _each(list, function(_, item) {
                        var i, ii, sub, subs, range, newRanges = [],
                            newBackgroundRanges = [];
                        for (i = 0, ii = ranges.length; i < ii; ++i) {
                            range = ranges[i];
                            subs = subtractSegment(range.start, range.end, item.start, item.end);
                            (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
                            (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub)
                        }
                        newRanges.push(item);
                        ranges = newRanges;
                        for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
                            range = backgroundRanges[i];
                            subs = subtractSegment(range.start, range.end, item.start, item.end);
                            (sub = subs[0]) && newBackgroundRanges.push(sub);
                            (sub = subs[1]) && newBackgroundRanges.push(sub)
                        }
                        backgroundRanges = newBackgroundRanges
                    });
                    _each(backgroundRanges, function(_, range) {
                        range.color = backgroundColor;
                        range.className = "dxg-range dxg-background-range";
                        ranges.push(range)
                    });
                    _each(ranges, function(_, range) {
                        range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
                        range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth
                    });
                    return ranges
                },
                render: function(options) {
                    var that = this;
                    that._options = options;
                    that._processOptions();
                    that._ranges = that._getRanges();
                    if (that._ranges) {
                        that.enabled = true;
                        that._root.linkAppend()
                    }
                    return that
                },
                resize: function(layout) {
                    var that = this;
                    that._root.clear();
                    if (that._isVisible(layout)) {
                        _each(that._ranges, function(_, range) {
                            that._createRange(range, layout).attr({
                                fill: range.color,
                                "class": range.className
                            }).append(that._root)
                        })
                    }
                    return that
                },
                _processOptions: null,
                _isVisible: null,
                _createRange: null,
                getColorForValue: function(value) {
                    var color = null;
                    _each(this._ranges, function(_, range) {
                        if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
                            color = range.color;
                            return false
                        }
                    });
                    return color
                }
            });

            function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
                var result;
                if (otherStart > segmentStart && otherEnd < segmentEnd) {
                    result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }]
                } else {
                    if (otherStart >= segmentEnd || otherEnd <= segmentStart) {
                        result = [{
                            start: segmentStart,
                            end: segmentEnd
                        }]
                    } else {
                        if (otherStart <= segmentStart && otherEnd >= segmentEnd) {
                            result = []
                        } else {
                            if (otherStart > segmentStart) {
                                result = [{
                                    start: segmentStart,
                                    end: otherStart
                                }]
                            } else {
                                if (otherEnd < segmentEnd) {
                                    result = [{
                                        start: otherEnd,
                                        end: segmentEnd
                                    }]
                                }
                            }
                        }
                    }
                }
                return result
            }

            function subtractSegmentDes(segmentStart, segmentEnd, otherStart, otherEnd) {
                var result;
                if (otherStart < segmentStart && otherEnd > segmentEnd) {
                    result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }]
                } else {
                    if (otherStart <= segmentEnd || otherEnd >= segmentStart) {
                        result = [{
                            start: segmentStart,
                            end: segmentEnd
                        }]
                    } else {
                        if (otherStart >= segmentStart && otherEnd <= segmentEnd) {
                            result = []
                        } else {
                            if (otherStart < segmentStart) {
                                result = [{
                                    start: segmentStart,
                                    end: otherStart
                                }]
                            } else {
                                if (otherEnd > segmentEnd) {
                                    result = [{
                                        start: otherEnd,
                                        end: segmentEnd
                                    }]
                                }
                            }
                        }
                    }
                }
                return result
            }

            function isNotEmptySegmentAsc(start, end, threshold) {
                return end - start >= threshold
            }

            function isNotEmptySegmentDes(start, end, threshold) {
                return start - end >= threshold
            }
            module.exports = BaseRangeContainer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/gauges/circular_gauge.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _isFinite = isFinite,
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 128).dxBaseGauge,
                dxGauge = __webpack_require__( /*! ./common */ 191).dxGauge,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _normalizeAngle = vizUtils.normalizeAngle,
                _getCosAndSin = vizUtils.getCosAndSin,
                polarTranslatorModule = __webpack_require__( /*! ../translators/polar_translator */ 340),
                circularIndicatorsModule = __webpack_require__( /*! ./circular_indicators */ 523),
                createIndicatorCreator = __webpack_require__( /*! ./common */ 191).createIndicatorCreator,
                CircularRangeContainer = __webpack_require__( /*! ./circular_range_container */ 524),
                ThemeManager = __webpack_require__( /*! ./theme_manager */ 334),
                _abs = Math.abs,
                _max = Math.max,
                _min = Math.min,
                _round = Math.round,
                _each = $.each,
                SHIFT_ANGLE = 90,
                PI = Math.PI;

            function getSides(startAngle, endAngle) {
                var startCosSin = _getCosAndSin(startAngle),
                    endCosSin = _getCosAndSin(endAngle),
                    startCos = startCosSin.cos,
                    startSin = startCosSin.sin,
                    endCos = endCosSin.cos,
                    endSin = endCosSin.sin;
                return {
                    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : _min(startCos, endCos, 0),
                    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : _max(startCos, endCos, 0),
                    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -_max(startSin, endSin, 0),
                    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -_min(startSin, endSin, 0)
                }
            }
            var dxCircularGauge = dxGauge.inherit({
                _rootClass: "dxg-circular-gauge",
                _factoryMethods: {
                    rangeContainer: "createCircularRangeContainer",
                    indicator: "createCircularIndicator"
                },
                _gridSpacingFactor: 17,
                _scaleTypes: {
                    type: "polarAxes",
                    drawingType: "circular"
                },
                _initScaleTranslator: function(range) {
                    return new polarTranslatorModule.PolarTranslator({
                        arg: range,
                        val: {}
                    }, this._canvas, {})
                },
                _getScaleTranslatorComponent: function(name) {
                    return this._scaleTranslator.getComponent(name)
                },
                _updateScaleTickIndent: function(scaleOptions) {
                    var indentFromTick = scaleOptions.label.indentFromTick,
                        length = scaleOptions.tick.length,
                        textParams = this._scale.measureLabels(),
                        tickCorrection = length;
                    if ("inside" === scaleOptions.orientation) {
                        tickCorrection = 0
                    } else {
                        if ("center" === scaleOptions.orientation) {
                            tickCorrection = .5 * length
                        }
                    }
                    scaleOptions.label.indentFromAxis = indentFromTick >= 0 ? indentFromTick + tickCorrection : indentFromTick - tickCorrection - _max(textParams.width, textParams.height);
                    this._scale.updateOptions(scaleOptions)
                },
                _updateScaleAngles: function() {
                    var angles = this._translator.getCodomain();
                    this._scaleTranslator.setAngles(SHIFT_ANGLE - angles[0], SHIFT_ANGLE - angles[1])
                },
                _setupCodomain: function() {
                    var sides, that = this,
                        geometry = that.option("geometry") || {},
                        startAngle = geometry.startAngle,
                        endAngle = geometry.endAngle;
                    startAngle = _isFinite(startAngle) ? _normalizeAngle(startAngle) : 225;
                    endAngle = _isFinite(endAngle) ? _normalizeAngle(endAngle) : -45;
                    if (_abs(startAngle - endAngle) < 1) {
                        endAngle -= 360;
                        sides = {
                            left: -1,
                            up: -1,
                            right: 1,
                            down: 1
                        }
                    } else {
                        startAngle < endAngle && (endAngle -= 360);
                        sides = getSides(startAngle, endAngle)
                    }
                    that._area = {
                        x: 0,
                        y: 0,
                        radius: 100,
                        startCoord: startAngle,
                        endCoord: endAngle,
                        sides: sides
                    };
                    that._translator.setCodomain(startAngle, endAngle)
                },
                _shiftScale: function(layout) {
                    var centerCoords, scaleTranslator = this._scaleTranslator,
                        scale = this._scale;
                    scaleTranslator.setCanvasDimension(2 * layout.radius);
                    scale.setTranslator(scaleTranslator.getComponent("arg"), scaleTranslator.getComponent("val"));
                    scale.draw();
                    centerCoords = scaleTranslator.getCenter();
                    scale.shift(layout.x - centerCoords.x, layout.y - centerCoords.y)
                },
                _getScaleLayoutValue: function() {
                    return this._area.radius
                },
                _getTicksOrientation: function(scaleOptions) {
                    return scaleOptions.orientation
                },
                _getTicksCoefficients: function(options) {
                    var coefs = {
                        inner: 0,
                        outer: 1
                    };
                    if ("inside" === options.orientation) {
                        coefs.inner = 1;
                        coefs.outer = 0
                    } else {
                        if ("center" === options.orientation) {
                            coefs.inner = coefs.outer = .5
                        }
                    }
                    return coefs
                },
                _correctScaleIndents: function(result, indentFromTick, textParams) {
                    if (indentFromTick >= 0) {
                        result.horizontalOffset = indentFromTick + textParams.width;
                        result.verticalOffset = indentFromTick + textParams.height
                    } else {
                        result.horizontalOffset = result.verticalOffset = 0;
                        result.min -= -indentFromTick + _max(textParams.width, textParams.height)
                    }
                    result.inverseHorizontalOffset = textParams.width / 2;
                    result.inverseVerticalOffset = textParams.height / 2
                },
                _measureMainElements: function(elements, scaleMeasurement) {
                    var that = this,
                        radius = that._area.radius,
                        maxRadius = 0,
                        minRadius = 1 / 0,
                        maxHorizontalOffset = 0,
                        maxVerticalOffset = 0,
                        maxInverseHorizontalOffset = 0,
                        maxInverseVerticalOffset = 0,
                        scale = that._scale;
                    _each(elements.concat(scale), function(_, element) {
                        var bounds = element.measure ? element.measure({
                            radius: radius - element.getOffset()
                        }) : scaleMeasurement;
                        bounds.min > 0 && (minRadius = _min(minRadius, bounds.min));
                        bounds.max > 0 && (maxRadius = _max(maxRadius, bounds.max));
                        bounds.horizontalOffset > 0 && (maxHorizontalOffset = _max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
                        bounds.verticalOffset > 0 && (maxVerticalOffset = _max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
                        bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = _max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
                        bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = _max(maxInverseVerticalOffset, bounds.inverseVerticalOffset))
                    });
                    maxHorizontalOffset = _max(maxHorizontalOffset - maxRadius, 0);
                    maxVerticalOffset = _max(maxVerticalOffset - maxRadius, 0);
                    return {
                        minRadius: minRadius,
                        maxRadius: maxRadius,
                        horizontalMargin: maxHorizontalOffset,
                        verticalMargin: maxVerticalOffset,
                        inverseHorizontalMargin: maxInverseHorizontalOffset,
                        inverseVerticalMargin: maxInverseVerticalOffset
                    }
                },
                _applyMainLayout: function(elements, scaleMeasurement) {
                    var x, y, measurements = this._measureMainElements(elements, scaleMeasurement),
                        area = this._area,
                        sides = area.sides,
                        margins = {
                            left: (sides.left < -.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                            right: (sides.right > .1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                            top: (sides.up < -.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
                            bottom: (sides.down > .1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
                        },
                        rect = selectRectByAspectRatio(this._innerRect, (sides.down - sides.up) / (sides.right - sides.left), margins),
                        radius = _min(getWidth(rect) / (sides.right - sides.left), getHeight(rect) / (sides.down - sides.up));
                    radius = radius - measurements.maxRadius + area.radius;
                    x = rect.left - getWidth(rect) * sides.left / (sides.right - sides.left);
                    y = rect.top - getHeight(rect) * sides.up / (sides.down - sides.up);
                    area.x = _round(x);
                    area.y = _round(y);
                    area.radius = radius;
                    rect.left -= margins.left;
                    rect.right += margins.right;
                    rect.top -= margins.top;
                    rect.bottom += margins.bottom;
                    this._innerRect = rect
                },
                _getElementLayout: function(offset) {
                    return {
                        x: this._area.x,
                        y: this._area.y,
                        radius: _round(this._area.radius - offset)
                    }
                },
                _getApproximateScreenRange: function() {
                    var that = this,
                        area = that._area,
                        r = _min(that._canvas.width / (area.sides.right - area.sides.left), that._canvas.height / (area.sides.down - area.sides.up));
                    r > area.totalRadius && (r = area.totalRadius);
                    r = .8 * r;
                    return -that._translator.getCodomainRange() * r * PI / 180
                },
                _getDefaultSize: function() {
                    return {
                        width: 300,
                        height: 300
                    }
                },
                _factory: objectUtils.clone(dxBaseGauge.prototype._factory)
            });

            function getWidth(rect) {
                return rect.right - rect.left
            }

            function getHeight(rect) {
                return rect.bottom - rect.top
            }

            function selectRectByAspectRatio(srcRect, aspectRatio, margins) {
                var selfAspectRatio, rect = $.extend({}, srcRect),
                    width = 0,
                    height = 0;
                margins = margins || {};
                if (aspectRatio > 0) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (getWidth(rect) > 0 && getHeight(rect) > 0) {
                        selfAspectRatio = getHeight(rect) / getWidth(rect);
                        if (selfAspectRatio > 1) {
                            aspectRatio < selfAspectRatio ? width = getWidth(rect) : height = getHeight(rect)
                        } else {
                            aspectRatio > selfAspectRatio ? height = getHeight(rect) : width = getWidth(rect)
                        }
                        width > 0 || (width = height / aspectRatio);
                        height > 0 || (height = width * aspectRatio);
                        width = (getWidth(rect) - width) / 2;
                        height = (getHeight(rect) - height) / 2;
                        rect.left += width;
                        rect.right -= width;
                        rect.top += height;
                        rect.bottom -= height
                    } else {
                        rect.left = rect.right = (rect.left + rect.right) / 2;
                        rect.top = rect.bottom = (rect.top + rect.bottom) / 2
                    }
                }
                return rect
            }
            dxCircularGauge._TESTS_selectRectByAspectRatio = selectRectByAspectRatio;
            var indicators = dxCircularGauge.prototype._factory.indicators = {};
            dxCircularGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);
            indicators._default = circularIndicatorsModule._default;
            indicators.rectangleneedle = circularIndicatorsModule.rectangleneedle;
            indicators.triangleneedle = circularIndicatorsModule.triangleneedle;
            indicators.twocolorneedle = circularIndicatorsModule.twocolorneedle;
            indicators.trianglemarker = circularIndicatorsModule.trianglemarker;
            indicators.textcloud = circularIndicatorsModule.textcloud;
            indicators.rangebar = circularIndicatorsModule.rangebar;
            dxCircularGauge.prototype._factory.RangeContainer = CircularRangeContainer;
            dxCircularGauge.prototype._factory.ThemeManager = ThemeManager.inherit({
                _subTheme: "_circular"
            });
            registerComponent("dxCircularGauge", dxCircularGauge);
            module.exports = dxCircularGauge
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/viz/gauges/theme_manager.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _extend = $.extend,
                BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager;
            var ThemeManager = BaseThemeManager.inherit({
                _themeSection: "gauge",
                _fontFields: ["scale.label.font", "valueIndicators.rangebar.text.font", "valueIndicators.textcloud.text.font", "title.font", "title.subtitle.font", "tooltip.font", "indicator.text.font", "loadingIndicator.font", "export.font"],
                _initializeTheme: function() {
                    var subTheme, that = this;
                    if (that._subTheme) {
                        subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);
                        _extend(true, that._theme, subTheme)
                    }
                    that.callBase.apply(that, arguments)
                }
            });
            module.exports = ThemeManager
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/series/points/candlestick_point.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                barPoint = __webpack_require__( /*! ./bar_point */ 194),
                _isNumeric = $.isNumeric,
                _extend = $.extend,
                _math = Math,
                _abs = _math.abs,
                _min = _math.min,
                _max = _math.max,
                _round = _math.round,
                DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
            module.exports = _extend({}, barPoint, {
                _getContinuousPoints: function(minValueName, maxValueName) {
                    var points, that = this,
                        x = that.x,
                        createPoint = that._options.rotated ? function(x, y) {
                            return [y, x]
                        } : function(x, y) {
                            return [x, y]
                        },
                        width = that.width,
                        min = that[minValueName],
                        max = that[maxValueName];
                    if (min === max) {
                        points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY))
                    } else {
                        points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max))
                    }
                    return points
                },
                _getCategoryPoints: function(y) {
                    var that = this,
                        x = that.x,
                        createPoint = that._options.rotated ? function(x, y) {
                            return [y, x]
                        } : function(x, y) {
                            return [x, y]
                        };
                    return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y))
                },
                _getPoints: function() {
                    var points, minValueName, maxValueName, that = this,
                        openValue = that.openValue,
                        closeValue = that.closeValue;
                    if (_isNumeric(openValue) && _isNumeric(closeValue)) {
                        minValueName = openValue > closeValue ? "closeY" : "openY";
                        maxValueName = openValue > closeValue ? "openY" : "closeY";
                        points = that._getContinuousPoints(minValueName, maxValueName)
                    } else {
                        if (openValue === closeValue) {
                            points = [that.x, that.highY, that.x, that.lowY]
                        } else {
                            points = that._getCategoryPoints(_isNumeric(openValue) ? that.openY : that.closeY)
                        }
                    }
                    return points
                },
                getColor: function() {
                    var that = this;
                    return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor()
                },
                _drawMarkerInGroup: function(group, attributes, renderer) {
                    var that = this;
                    that.graphic = renderer.path(that._getPoints(), "area").attr({
                        "stroke-linecap": "square"
                    }).attr(attributes).data({
                        "chart-data-point": that
                    }).sharp().append(group)
                },
                _fillStyle: function() {
                    var that = this,
                        styles = that._options.styles;
                    if (that._isReduction && that._isPositive) {
                        that._styles = styles.reductionPositive
                    } else {
                        if (that._isReduction) {
                            that._styles = styles.reduction
                        } else {
                            if (that._isPositive) {
                                that._styles = styles.positive
                            } else {
                                that._styles = styles
                            }
                        }
                    }
                },
                _getMinTrackerWidth: function() {
                    return 2 + 2 * this._styles.normal["stroke-width"]
                },
                correctCoordinates: function(correctOptions) {
                    var minWidth = this._getMinTrackerWidth(),
                        maxWidth = 10,
                        width = correctOptions.width;
                    width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
                    this.width = width + width % 2;
                    this.xCorrection = correctOptions.offset
                },
                _getMarkerGroup: function(group) {
                    var markerGroup, that = this;
                    if (that._isReduction && that._isPositive) {
                        markerGroup = group.reductionPositiveMarkersGroup
                    } else {
                        if (that._isReduction) {
                            markerGroup = group.reductionMarkersGroup
                        } else {
                            if (that._isPositive) {
                                markerGroup = group.defaultPositiveMarkersGroup
                            } else {
                                markerGroup = group.defaultMarkersGroup
                            }
                        }
                    }
                    return markerGroup
                },
                _drawMarker: function(renderer, group) {
                    this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer)
                },
                _getSettingsForTracker: function() {
                    var x, y, width, height, that = this,
                        highY = that.highY,
                        lowY = that.lowY,
                        rotated = that._options.rotated;
                    if (highY === lowY) {
                        highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
                        lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN
                    }
                    if (rotated) {
                        x = _min(lowY, highY);
                        y = that.x - that.width / 2;
                        width = _abs(lowY - highY);
                        height = that.width
                    } else {
                        x = that.x - that.width / 2;
                        y = _min(lowY, highY);
                        width = that.width;
                        height = _abs(lowY - highY)
                    }
                    return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
                },
                _getGraphicBbox: function() {
                    var that = this,
                        rotated = that._options.rotated,
                        x = that.x,
                        width = that.width,
                        lowY = that.lowY,
                        highY = that.highY;
                    return {
                        x: !rotated ? x - _round(width / 2) : lowY,
                        y: !rotated ? highY : x - _round(width / 2),
                        width: !rotated ? width : highY - lowY,
                        height: !rotated ? lowY - highY : width
                    }
                },
                getTooltipParams: function(location) {
                    var that = this;
                    if (that.graphic) {
                        var x, y, min, max, minValue = _min(that.lowY, that.highY),
                            maxValue = _max(that.lowY, that.highY),
                            visibleAreaX = that.translators.x.getCanvasVisibleArea(),
                            visibleAreaY = that.translators.y.getCanvasVisibleArea(),
                            edgeLocation = "edge" === location;
                        if (!that._options.rotated) {
                            min = _max(visibleAreaY.min, minValue);
                            max = _min(visibleAreaY.max, maxValue);
                            x = that.x;
                            y = edgeLocation ? min : min + (max - min) / 2
                        } else {
                            min = _max(visibleAreaX.min, minValue);
                            max = _min(visibleAreaX.max, maxValue);
                            y = that.x;
                            x = edgeLocation ? max : min + (max - min) / 2
                        }
                        return {
                            x: x,
                            y: y,
                            offset: 0
                        }
                    }
                },
                hasValue: function() {
                    return null !== this.highValue && null !== this.lowValue
                },
                _translate: function() {
                    var centerValue, height, that = this,
                        rotated = that._options.rotated,
                        translators = that.translators,
                        argTranslator = rotated ? translators.y : translators.x,
                        valTranslator = rotated ? translators.x : translators.y;
                    that.vx = that.vy = that.x = argTranslator.translate(that.argument) + (that.xCorrection || 0);
                    that.openY = null !== that.openValue ? valTranslator.translate(that.openValue) : null;
                    that.highY = valTranslator.translate(that.highValue);
                    that.lowY = valTranslator.translate(that.lowValue);
                    that.closeY = null !== that.closeValue ? valTranslator.translate(that.closeValue) : null;
                    height = _abs(that.lowY - that.highY);
                    centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
                    that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x)
                },
                getCrosshairData: function(x, y) {
                    var yValue, coords, that = this,
                        rotated = that._options.rotated,
                        origY = rotated ? x : y,
                        argument = that.argument,
                        coord = "low";
                    if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
                        yValue = that.lowY
                    } else {
                        yValue = that.closeY;
                        coord = "close"
                    }
                    if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
                        yValue = that.openY;
                        coord = "open"
                    }
                    if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
                        yValue = that.highY;
                        coord = "high"
                    }
                    if (rotated) {
                        coords = {
                            y: that.vy,
                            x: yValue,
                            xValue: that[coord + "Value"],
                            yValue: argument
                        }
                    } else {
                        coords = {
                            x: that.vx,
                            y: yValue,
                            xValue: argument,
                            yValue: that[coord + "Value"]
                        }
                    }
                    coords.axis = that.series.axis;
                    return coords
                },
                _updateData: function(data) {
                    var that = this,
                        label = that._label,
                        reductionColor = this._options.reduction.color;
                    that.value = that.initialValue = data.reductionValue;
                    that.originalValue = data.value;
                    that.lowValue = that.originalLowValue = data.lowValue;
                    that.highValue = that.originalHighValue = data.highValue;
                    that.openValue = that.originalOpenValue = data.openValue;
                    that.closeValue = that.originalCloseValue = data.closeValue;
                    that._isPositive = data.openValue < data.closeValue;
                    that._isReduction = data.isReduction;
                    if (that._isReduction) {
                        label.setColor(reductionColor)
                    }
                },
                _updateMarker: function(animationEnabled, style, group) {
                    var that = this,
                        graphic = that.graphic;
                    graphic.attr({
                        points: that._getPoints()
                    }).attr(style || that._getStyle()).sharp();
                    group && graphic.append(that._getMarkerGroup(group))
                },
                _getLabelFormatObject: function() {
                    var that = this;
                    return {
                        openValue: that.openValue,
                        highValue: that.highValue,
                        lowValue: that.lowValue,
                        closeValue: that.closeValue,
                        reductionValue: that.initialValue,
                        argument: that.initialArgument,
                        value: that.initialValue,
                        seriesName: that.series.name,
                        originalOpenValue: that.originalOpenValue,
                        originalCloseValue: that.originalCloseValue,
                        originalLowValue: that.originalLowValue,
                        originalHighValue: that.originalHighValue,
                        originalArgument: that.originalArgument,
                        point: that
                    }
                },
                _getFormatObject: function(tooltip) {
                    var that = this,
                        highValue = tooltip.formatValue(that.highValue),
                        openValue = tooltip.formatValue(that.openValue),
                        closeValue = tooltip.formatValue(that.closeValue),
                        lowValue = tooltip.formatValue(that.lowValue),
                        symbolMethods = symbolPoint,
                        formatObject = symbolMethods._getFormatObject.call(that, tooltip);
                    return _extend({}, formatObject, {
                        valueText: "h: " + highValue + ("" !== openValue ? " o: " + openValue : "") + ("" !== closeValue ? " c: " + closeValue : "") + " l: " + lowValue,
                        highValueText: highValue,
                        openValueText: openValue,
                        closeValueText: closeValue,
                        lowValueText: lowValue
                    })
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/viz/series/points/label.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _format = __webpack_require__( /*! ../../core/format */ 162),
                vizUtils = __webpack_require__( /*! ../../core/utils */ 6),
                _degreesToRadians = vizUtils.degreesToRadians,
                _patchFontOptions = vizUtils.patchFontOptions,
                _round = Math.round,
                _getCosAndSin = vizUtils.getCosAndSin,
                _rotateBBox = vizUtils.rotateBBox,
                LABEL_BACKGROUND_PADDING_X = 8,
                LABEL_BACKGROUND_PADDING_Y = 4;

            function getClosestCoord(point, coords) {
                var closestCoord, closestDistance = 1 / 0;
                $.each(coords, function(_, coord) {
                    var x = point[0] - coord[0],
                        y = point[1] - coord[1],
                        distance = x * x + y * y;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestCoord = coord
                    }
                });
                return closestCoord
            }
            var barPointStrategy = {
                isLabelInside: function(labelPoint, figure) {
                    return labelPoint.x >= figure.x && labelPoint.x <= figure.x + figure.width && labelPoint.y >= figure.y && labelPoint.y <= figure.y + figure.height
                },
                prepareLabelPoints: function(points) {
                    return points
                },
                getFigureCenter: function(figure) {
                    return [figure.x + figure.width / 2, figure.y + figure.height / 2]
                },
                findFigurePoint: function(figure, labelPoint) {
                    var figureCenter = barPointStrategy.getFigureCenter(figure),
                        point = getClosestCoord(labelPoint, [
                            [figure.x, figureCenter[1]],
                            [figureCenter[0], figure.y + figure.height],
                            [figure.x + figure.width, figureCenter[1]],
                            [figureCenter[0], figure.y]
                        ]);
                    return [_round(point[0]), _round(point[1])]
                }
            };
            var symbolPointStrategy = {
                isLabelInside: function() {
                    return false
                },
                prepareLabelPoints: barPointStrategy.prepareLabelPoints,
                getFigureCenter: function(figure) {
                    return [figure.x, figure.y]
                },
                findFigurePoint: function(figure, labelPoint) {
                    var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
                    return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))]
                }
            };
            var piePointStrategy = {
                isLabelInside: function(_0, _1, isOutside) {
                    return !isOutside
                },
                prepareLabelPoints: function(points, center, angle) {
                    var rotatedPoints = [],
                        x0 = center[0],
                        y0 = center[1],
                        cossin = _getCosAndSin(angle || 0);
                    $.each(points, function(_, point) {
                        rotatedPoints.push([_round((point[0] - x0) * cossin.cos + (point[1] - y0) * cossin.sin + x0), _round(-(point[0] - x0) * cossin.sin + (point[1] - y0) * cossin.cos + y0)])
                    });
                    return rotatedPoints
                },
                getFigureCenter: symbolPointStrategy.getFigureCenter,
                findFigurePoint: function(figure, labelPoint) {
                    var x = figure.x + (figure.y - labelPoint[1]) / Math.tan(_degreesToRadians(figure.angle)),
                        point = [figure.x, figure.y];
                    if (figure.x <= x && x <= labelPoint[0] || figure.x >= x && x >= labelPoint[0]) {
                        point.push(_round(x), labelPoint[1])
                    }
                    return point
                }
            };

            function selectStrategy(figure) {
                return void 0 !== figure.angle && piePointStrategy || void 0 !== figure.r && symbolPointStrategy || barPointStrategy
            }

            function disposeItem(obj, field) {
                obj[field] && obj[field].dispose();
                obj[field] = null
            }

            function checkBackground(background) {
                return background && (background.fill && "none" !== background.fill || background["stroke-width"] > 0 && background.stroke && "none" !== background.stroke)
            }

            function checkConnector(connector) {
                return connector && connector["stroke-width"] > 0 && connector.stroke && "none" !== connector.stroke
            }

            function formatText(data, options) {
                data.valueText = _format(data.value, options);
                data.argumentText = _format(data.argument, {
                    format: options.argumentFormat,
                    precision: options.argumentPrecision
                });
                if (void 0 !== data.percent) {
                    data.percentText = _format(data.percent, {
                        format: {
                            type: "percent",
                            precision: options.format && options.format.percentPrecision || options.percentPrecision
                        }
                    })
                }
                if (void 0 !== data.total) {
                    data.totalText = _format(data.total, options)
                }
                if (void 0 !== data.openValue) {
                    data.openValueText = _format(data.openValue, options)
                }
                if (void 0 !== data.closeValue) {
                    data.closeValueText = _format(data.closeValue, options)
                }
                if (void 0 !== data.lowValue) {
                    data.lowValueText = _format(data.lowValue, options)
                }
                if (void 0 !== data.highValue) {
                    data.highValueText = _format(data.highValue, options)
                }
                if (void 0 !== data.reductionValue) {
                    data.reductionValueText = _format(data.reductionValue, options)
                }
                return options.customizeText ? options.customizeText.call(data, data) : data.valueText
            }

            function Label(renderSettings) {
                this._renderer = renderSettings.renderer;
                this._container = renderSettings.labelsGroup;
                this._point = renderSettings.point
            }
            Label.prototype = {
                constructor: Label,
                _setVisibility: function(value, state) {
                    this._group && this._group.attr({
                        visibility: value
                    });
                    this._visible = state
                },
                clearVisibility: function() {
                    this._setVisibility(null, true)
                },
                hide: function() {
                    this._setVisibility("hidden", false)
                },
                show: function() {
                    var that = this;
                    if (that._point.hasValue()) {
                        that._draw();
                        that._point.correctLabelPosition(that)
                    }
                },
                isVisible: function() {
                    return this._visible
                },
                setColor: function(color) {
                    this._color = color
                },
                setOptions: function(options) {
                    this._options = options
                },
                setData: function(data) {
                    this._data = data
                },
                setDataField: function(fieldName, fieldValue) {
                    this._data = this._data || {};
                    this._data[fieldName] = fieldValue
                },
                getData: function() {
                    return this._data
                },
                setFigureToDrawConnector: function(figure) {
                    this._figure = figure
                },
                dispose: function() {
                    var that = this;
                    disposeItem(that, "_group");
                    that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null
                },
                _draw: function() {
                    var that = this,
                        renderer = that._renderer,
                        container = that._container,
                        options = that._options || {},
                        text = that._textContent = formatText(that._data, that._options) || null;
                    that.clearVisibility();
                    if (text) {
                        if (!that._group) {
                            that._group = renderer.g().append(container);
                            that._insideGroup = renderer.g().append(that._group);
                            that._text = renderer.text("", 0, 0).append(that._insideGroup)
                        }
                        that._text.css(options.attributes ? _patchFontOptions(options.attributes.font) : {});
                        if (checkBackground(options.background)) {
                            that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();
                            that._background.attr(options.background);
                            that._color && that._background.attr({
                                fill: that._color
                            })
                        } else {
                            disposeItem(that, "_background")
                        }
                        if (checkConnector(options.connector)) {
                            that._connector = that._connector || renderer.path([], "line").sharp().append(that._group).toBackground();
                            that._connector.attr(options.connector);
                            that._color && that._connector.attr({
                                stroke: that._color
                            })
                        } else {
                            disposeItem(that, "_connector")
                        }
                        that._text.attr({
                            text: text
                        });
                        that._updateBackground(that._text.getBBox());
                        that._setVisibility("visible", true)
                    } else {
                        that.hide()
                    }
                    return that
                },
                _updateBackground: function(bbox) {
                    var that = this;
                    that._textSize = [bbox.width, bbox.height];
                    if (that._background) {
                        bbox.x -= LABEL_BACKGROUND_PADDING_X;
                        bbox.y -= LABEL_BACKGROUND_PADDING_Y;
                        bbox.width += 2 * LABEL_BACKGROUND_PADDING_X;
                        bbox.height += 2 * LABEL_BACKGROUND_PADDING_Y;
                        that._background.attr(bbox)
                    }
                    if (that._options.rotationAngle) {
                        that._insideGroup.rotate(that._options.rotationAngle, bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
                        bbox = _rotateBBox(bbox, [bbox.x + bbox.width / 2, bbox.y + bbox.height / 2], -that._options.rotationAngle)
                    }
                    that._bbox = bbox
                },
                _getConnectorPoints: function() {
                    var labelPoint, figurePoint, xc, yc, that = this,
                        figure = that._figure,
                        strategy = selectStrategy(figure),
                        bbox = that.getBoundingRect(),
                        points = [];
                    if (!strategy.isLabelInside(bbox, figure, "inside" !== that._options.position)) {
                        xc = bbox.x + bbox.width / 2;
                        yc = bbox.y + bbox.height / 2;
                        points = strategy.prepareLabelPoints([
                            [xc, yc - that._textSize[1] / 2],
                            [xc + that._textSize[0] / 2, yc],
                            [xc, yc + that._textSize[1] / 2],
                            [xc - that._textSize[0] / 2, yc]
                        ], [xc, yc], -that._options.rotationAngle || 0);
                        labelPoint = getClosestCoord(strategy.getFigureCenter(figure), points);
                        labelPoint = [_round(labelPoint[0]), _round(labelPoint[1])];
                        figurePoint = strategy.findFigurePoint(figure, labelPoint);
                        points = figurePoint.concat(labelPoint)
                    }
                    return points
                },
                fit: function(maxWidth) {
                    this._text && this._text.applyEllipsis(maxWidth);
                    this._updateBackground(this._text.getBBox())
                },
                setTrackerData: function(point) {
                    this._text.data({
                        "chart-data-point": point
                    });
                    this._background && this._background.data({
                        "chart-data-point": point
                    })
                },
                shift: function(x, y) {
                    var that = this;
                    if (that._textContent) {
                        that._insideGroup.attr({
                            translateX: that._x = _round(x - that._bbox.x),
                            translateY: that._y = _round(y - that._bbox.y)
                        });
                        if (that._connector) {
                            that._connector.attr({
                                points: that._getConnectorPoints()
                            })
                        }
                    }
                    return that
                },
                getBoundingRect: function() {
                    var bbox = this._bbox;
                    return this._textContent ? {
                        x: bbox.x + this._x,
                        y: bbox.y + this._y,
                        width: bbox.width,
                        height: bbox.height
                    } : {}
                },
                getLayoutOptions: function() {
                    var options = this._options;
                    return {
                        alignment: options.alignment,
                        background: checkBackground(options.background),
                        horizontalOffset: options.horizontalOffset,
                        verticalOffset: options.verticalOffset,
                        radialOffset: options.radialOffset,
                        position: options.position
                    }
                }
            };
            exports.Label = Label;
            Label._DEBUG_formatText = formatText
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/viz/series/points/pie_point.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                CONNECTOR_LENGTH = 20,
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                _extend = $.extend,
                _round = Math.round,
                _sqrt = Math.sqrt,
                _acos = Math.acos,
                DEG = 180 / Math.PI,
                _abs = Math.abs,
                vizUtils = __webpack_require__( /*! ../../core/utils */ 6),
                _normalizeAngle = vizUtils.normalizeAngle,
                _getCosAndSin = vizUtils.getCosAndSin,
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                getVerticallyShiftedAngularCoords = vizUtils.getVerticallyShiftedAngularCoords,
                INDENT_FROM_PIE = __webpack_require__( /*! ../../components/consts */ 126).pieLabelIndent;
            module.exports = _extend({}, symbolPoint, {
                _updateData: function(data) {
                    var that = this;
                    symbolPoint._updateData.call(this, data);
                    that._visible = true;
                    that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : 0
                },
                animate: function(complete, duration, step) {
                    var that = this;
                    that.graphic.animate({
                        x: that.centerX,
                        y: that.centerY,
                        outerRadius: that.radiusOuter,
                        innerRadius: that.radiusInner,
                        startAngle: that.toAngle,
                        endAngle: that.fromAngle
                    }, {
                        partitionDuration: duration,
                        step: step
                    }, complete)
                },
                correctPosition: function(correction) {
                    var that = this;
                    that.correctRadius(correction);
                    that.correctLabelRadius(correction.radiusOuter);
                    that.centerX = correction.centerX;
                    that.centerY = correction.centerY
                },
                correctRadius: function(correction) {
                    this.radiusInner = correction.radiusInner;
                    this.radiusOuter = correction.radiusOuter
                },
                correctLabelRadius: function(radiusLabels) {
                    this.radiusLabels = radiusLabels
                },
                correctValue: function(correction, percent, base) {
                    var that = this;
                    that.value = (base || that.initialValue) + correction;
                    that.minValue = correction;
                    that.percent = percent;
                    that._label.setDataField("percent", percent)
                },
                setMaxLabelLength: function(maxLabelLength) {
                    this._maxLabelLength = maxLabelLength
                },
                _updateLabelData: function() {
                    this._label.setData(this._getLabelFormatObject())
                },
                _getShiftLabelCoords: function() {
                    var that = this,
                        bbox = that._label.getBoundingRect(),
                        coord = that._getLabelCoords(that._label),
                        visibleArea = that._getVisibleArea();
                    if (that._isLabelDrawingWithoutPoints) {
                        return that._checkLabelPosition(coord, bbox, visibleArea)
                    } else {
                        return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bbox, visibleArea), bbox)
                    }
                },
                _getLabelPosition: function(options) {
                    return options.position
                },
                _getLabelCoords: function(label) {
                    var rad, x, that = this,
                        bbox = label.getBoundingRect(),
                        options = label.getLayoutOptions(),
                        angleFunctions = _getCosAndSin(that.middleAngle),
                        position = that._getLabelPosition(options),
                        radiusInner = that.radiusInner,
                        radiusOuter = that.radiusOuter,
                        radiusLabels = that.radiusLabels;
                    if ("inside" === position) {
                        rad = radiusInner + (radiusOuter - radiusInner) / 2 + options.radialOffset;
                        x = that.centerX + rad * angleFunctions.cos - bbox.width / 2
                    } else {
                        rad = radiusLabels + options.radialOffset + INDENT_FROM_PIE;
                        if (angleFunctions.cos > .1) {
                            x = that.centerX + rad * angleFunctions.cos
                        } else {
                            if (angleFunctions.cos < -.1) {
                                x = that.centerX + rad * angleFunctions.cos - bbox.width
                            } else {
                                x = that.centerX + rad * angleFunctions.cos - bbox.width / 2
                            }
                        }
                    }
                    return {
                        x: x,
                        y: _round(that.centerY - rad * angleFunctions.sin - bbox.height / 2)
                    }
                },
                _getColumnsCoord: function(coord) {
                    var x, that = this,
                        label = that._label,
                        bbox = label.getBoundingRect(),
                        options = label.getLayoutOptions(),
                        rad = that.radiusLabels + options.radialOffset,
                        visibleArea = that._getVisibleArea(),
                        rightBorderX = visibleArea.maxX - bbox.width,
                        leftBorderX = visibleArea.minX,
                        angleOfPoint = _normalizeAngle(that.middleAngle);
                    if ("columns" !== options.position) {
                        return coord
                    }
                    rad += CONNECTOR_LENGTH;
                    if (angleOfPoint < 90 || angleOfPoint >= 270) {
                        x = that._maxLabelLength ? that.centerX + rad + that._maxLabelLength - bbox.width : rightBorderX;
                        x = x > rightBorderX ? rightBorderX : x
                    } else {
                        x = that._maxLabelLength ? that.centerX - rad - that._maxLabelLength : leftBorderX;
                        x = x < leftBorderX ? leftBorderX : x
                    }
                    coord.x = x;
                    return coord
                },
                drawLabel: function(translators) {
                    this.translate(translators);
                    this._isLabelDrawingWithoutPoints = true;
                    this._drawLabel();
                    this._isLabelDrawingWithoutPoints = false
                },
                updateLabelCoord: function() {
                    var that = this,
                        bbox = that._label.getBoundingRect(),
                        coord = that._getColumnsCoord(bbox);
                    coord = that._checkHorizontalLabelPosition(coord, bbox, that._getVisibleArea());
                    that._label.shift(_round(coord.x), _round(bbox.y))
                },
                _checkVerticalLabelPosition: function(coord, box, visibleArea) {
                    var x = coord.x,
                        y = coord.y;
                    if (coord.y + box.height > visibleArea.maxY) {
                        y = visibleArea.maxY - box.height
                    } else {
                        if (coord.y < visibleArea.minY) {
                            y = visibleArea.minY
                        }
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _getLabelExtraCoord: function(coord, shiftCoord, box) {
                    return coord.y !== shiftCoord.y ? getVerticallyShiftedAngularCoords({
                        x: coord.x,
                        y: coord.y,
                        width: box.width,
                        height: box.height
                    }, shiftCoord.y - coord.y, {
                        x: this.centerX,
                        y: this.centerY
                    }) : coord
                },
                _checkHorizontalLabelPosition: function(coord, box, visibleArea) {
                    var x = coord.x,
                        y = coord.y;
                    if (coord.x + box.width > visibleArea.maxX) {
                        x = visibleArea.maxX - box.width
                    } else {
                        if (coord.x < visibleArea.minX) {
                            x = visibleArea.minX
                        }
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                setLabelEllipsis: function() {
                    var that = this,
                        bbox = that._label.getBoundingRect(),
                        coord = that._checkHorizontalLabelPosition(bbox, bbox, that._getVisibleArea());
                    that._label.fit(bbox.width - _abs(coord.x - bbox.x))
                },
                setLabelTrackerData: function() {
                    this._label.setTrackerData(this)
                },
                _checkLabelPosition: function(coord, bbox, visibleArea) {
                    coord = this._checkHorizontalLabelPosition(coord, bbox, visibleArea);
                    return this._checkVerticalLabelPosition(coord, bbox, visibleArea)
                },
                getBoundaryCoords: function() {
                    var that = this,
                        rad = that.radiusOuter,
                        seriesStyle = that._options.styles.normal,
                        strokeWidthBy2 = seriesStyle["stroke-width"] / 2,
                        borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2),
                        angleFunctions = _getCosAndSin(_round(that.middleAngle));
                    return {
                        x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
                        y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin)
                    }
                },
                _getLabelConnector: function() {
                    var coords = this.getBoundaryCoords();
                    coords.angle = this.middleAngle;
                    return coords
                },
                _drawMarker: function(renderer, group, animationEnabled, firstDrawing) {
                    var that = this,
                        radiusOuter = that.radiusOuter,
                        radiusInner = that.radiusInner,
                        fromAngle = that.fromAngle,
                        toAngle = that.toAngle;
                    if (animationEnabled) {
                        radiusInner = radiusOuter = 0;
                        if (!firstDrawing) {
                            fromAngle = toAngle = that.shiftedAngle
                        }
                    }
                    that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
                        "stroke-linejoin": "round"
                    }).attr(that._getStyle()).data({
                        "chart-data-point": that
                    }).sharp().append(group)
                },
                getTooltipParams: function() {
                    var that = this,
                        angleFunctions = _getCosAndSin(that.middleAngle),
                        radiusInner = that.radiusInner,
                        radiusOuter = that.radiusOuter;
                    return {
                        x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
                        y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
                        offset: 0
                    }
                },
                _translate: function(translator) {
                    var that = this,
                        angle = that.shiftedAngle || 0,
                        value = that.value,
                        minValue = that.minValue;
                    that.fromAngle = translator.translate(minValue) + angle;
                    that.toAngle = translator.translate(value) + angle;
                    that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
                    if (!that.isVisible()) {
                        that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle
                    }
                },
                _getMarkerVisibility: function() {
                    return true
                },
                _updateMarker: function(animationEnabled, style) {
                    var that = this;
                    style = style || that._getStyle();
                    if (!animationEnabled) {
                        style = _extend({
                            x: that.centerX,
                            y: that.centerY,
                            outerRadius: that.radiusOuter,
                            innerRadius: that.radiusInner,
                            startAngle: that.toAngle,
                            endAngle: that.fromAngle
                        }, style)
                    }
                    that.graphic.attr(style).sharp()
                },
                getLegendStyles: function() {
                    return this._styles.legendStyles
                },
                isInVisibleArea: function() {
                    return true
                },
                hide: function() {
                    var that = this;
                    if (that._visible) {
                        that._visible = false;
                        that.hideTooltip();
                        that._options.visibilityChanged(that)
                    }
                },
                show: function() {
                    var that = this;
                    if (!that._visible) {
                        that._visible = true;
                        that._options.visibilityChanged(that)
                    }
                },
                setInvisibility: function() {
                    this._label.hide()
                },
                isVisible: function() {
                    return this._visible
                },
                _getFormatObject: function(tooltip) {
                    var formatObject = symbolPoint._getFormatObject.call(this, tooltip),
                        percent = this.percent;
                    formatObject.percent = percent;
                    formatObject.percentText = tooltip.formatValue(percent, "percent");
                    return formatObject
                },
                getColor: function() {
                    return this._styles.normal.fill
                },
                coordsIn: function(x, y) {
                    var angle, that = this,
                        lx = x - that.centerX,
                        ly = y - that.centerY,
                        r = _sqrt(lx * lx + ly * ly),
                        fromAngle = that.fromAngle % 360,
                        toAngle = that.toAngle % 360;
                    if (r < that.radiusInner || r > that.radiusOuter || 0 === r) {
                        return false
                    }
                    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
                    if (angle < 0) {
                        angle += 360
                    }
                    if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1e-4) {
                        return true
                    } else {
                        return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle)
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************************!*\
      !*** ./Scripts/viz/series/points/range_symbol_point.js ***!
      \*********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                labelModule = __webpack_require__( /*! ./label */ 336),
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                _extend = $.extend,
                _isDefined = commonUtils.isDefined,
                _math = Math,
                _abs = _math.abs,
                _min = _math.min,
                _max = _math.max,
                _round = _math.round,
                DEFAULT_IMAGE_WIDTH = 20,
                DEFAULT_IMAGE_HEIGHT = 20;
            module.exports = _extend({}, symbolPoint, {
                deleteLabel: function() {
                    var that = this;
                    that._topLabel.dispose();
                    that._topLabel = null;
                    that._bottomLabel.dispose();
                    that._bottomLabel = null
                },
                hideMarker: function(type) {
                    var graphic = this.graphic,
                        marker = graphic && graphic[type + "Marker"],
                        label = this["_" + type + "Label"];
                    if (marker && "hidden" !== marker.attr("visibility")) {
                        marker.attr({
                            visibility: "hidden"
                        })
                    }
                    label.hide()
                },
                setInvisibility: function() {
                    this.hideMarker("top");
                    this.hideMarker("bottom")
                },
                clearVisibility: function() {
                    var that = this,
                        graphic = that.graphic,
                        topMarker = graphic && graphic.topMarker,
                        bottomMarker = graphic && graphic.bottomMarker;
                    if (topMarker && topMarker.attr("visibility")) {
                        topMarker.attr({
                            visibility: null
                        })
                    }
                    if (bottomMarker && bottomMarker.attr("visibility")) {
                        bottomMarker.attr({
                            visibility: null
                        })
                    }
                    that._topLabel.clearVisibility();
                    that._bottomLabel.clearVisibility()
                },
                clearMarker: function() {
                    var that = this,
                        graphic = that.graphic,
                        topMarker = graphic && graphic.topMarker,
                        bottomMarker = graphic && graphic.bottomMarker,
                        emptySettings = that._emptySettings;
                    topMarker && topMarker.attr(emptySettings);
                    bottomMarker && bottomMarker.attr(emptySettings)
                },
                _getLabelPosition: function(markerType) {
                    var position, labelsInside = "inside" === this._options.label.position;
                    if (!this._options.rotated) {
                        position = "top" === markerType ^ labelsInside ? "top" : "bottom"
                    } else {
                        position = "top" === markerType ^ labelsInside ? "right" : "left"
                    }
                    return position
                },
                _getLabelMinFormatObject: function() {
                    var that = this;
                    return {
                        index: 0,
                        argument: that.initialArgument,
                        value: that.initialMinValue,
                        seriesName: that.series.name,
                        originalValue: that.originalMinValue,
                        originalArgument: that.originalArgument,
                        point: that
                    }
                },
                _updateLabelData: function() {
                    var maxFormatObject = this._getLabelFormatObject();
                    maxFormatObject.index = 1;
                    this._topLabel.setData(maxFormatObject);
                    this._bottomLabel.setData(this._getLabelMinFormatObject())
                },
                _updateLabelOptions: function() {
                    var that = this,
                        options = this._options.label;
                    (!that._topLabel || !that._bottomLabel) && that._createLabel();
                    that._topLabel.setOptions(options);
                    that._bottomLabel.setOptions(options)
                },
                _createLabel: function() {
                    var options = {
                        renderer: this.series._renderer,
                        labelsGroup: this.series._labelsGroup,
                        point: this
                    };
                    this._topLabel = new labelModule.Label(options);
                    this._bottomLabel = new labelModule.Label(options)
                },
                _getGraphicBbox: function(location) {
                    var bbox, options = this._options,
                        images = this._getImage(options.image),
                        image = "top" === location ? this._checkImage(images.top) : this._checkImage(images.bottom),
                        coord = this._getPositionFromLocation(location);
                    if (options.visible) {
                        bbox = image ? this._getImageBbox(coord.x, coord.y) : this._getSymbolBbox(coord.x, coord.y, options.styles.normal.r)
                    } else {
                        bbox = {
                            x: coord.x,
                            y: coord.y,
                            width: 0,
                            height: 0
                        }
                    }
                    return bbox
                },
                _getPositionFromLocation: function(location) {
                    var x, y, isTop = "top" === location;
                    if (!this._options.rotated) {
                        x = this.x;
                        y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY)
                    } else {
                        x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
                        y = this.y
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _checkOverlay: function(bottomCoord, topCoord, topValue) {
                    return bottomCoord < topCoord + topValue
                },
                _getOverlayCorrections: function(type, topCoords, bottomCoords) {
                    var isVertical = "vertical" === type,
                        coordSelector = isVertical ? "y" : "x",
                        valueSelector = isVertical ? "height" : "width",
                        visibleArea = this.translators[coordSelector].getCanvasVisibleArea(),
                        minBound = visibleArea.min,
                        maxBound = visibleArea.max,
                        delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2),
                        coord1 = topCoords[coordSelector] - delta,
                        coord2 = bottomCoords[coordSelector] + delta;
                    if (coord1 < minBound) {
                        delta = minBound - topCoords[coordSelector];
                        coord1 += delta;
                        coord2 += delta
                    } else {
                        if (coord2 + bottomCoords[valueSelector] > maxBound) {
                            delta = -(bottomCoords[coordSelector] + bottomCoords[valueSelector] - maxBound);
                            coord1 += delta;
                            coord2 += delta
                        }
                    }
                    return {
                        coord1: coord1,
                        coord2: coord2
                    }
                },
                _checkLabelsOverlay: function(topLocation) {
                    var that = this,
                        topCoords = that._topLabel.getBoundingRect(),
                        bottomCoords = that._bottomLabel.getBoundingRect(),
                        corrections = {};
                    if (!that._options.rotated) {
                        if ("top" === topLocation) {
                            if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
                                corrections = this._getOverlayCorrections("vertical", topCoords, bottomCoords);
                                that._topLabel.shift(topCoords.x, corrections.coord1);
                                that._bottomLabel.shift(bottomCoords.x, corrections.coord2)
                            }
                        } else {
                            if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
                                corrections = this._getOverlayCorrections("vertical", bottomCoords, topCoords);
                                that._topLabel.shift(topCoords.x, corrections.coord2);
                                that._bottomLabel.shift(bottomCoords.x, corrections.coord1)
                            }
                        }
                    } else {
                        if ("top" === topLocation) {
                            if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
                                corrections = this._getOverlayCorrections("horizontal", bottomCoords, topCoords);
                                that._topLabel.shift(corrections.coord2, topCoords.y);
                                that._bottomLabel.shift(corrections.coord1, bottomCoords.y)
                            }
                        } else {
                            if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
                                corrections = this._getOverlayCorrections("horizontal", topCoords, bottomCoords);
                                that._topLabel.shift(corrections.coord1, topCoords.y);
                                that._bottomLabel.shift(corrections.coord2, bottomCoords.y)
                            }
                        }
                    }
                },
                _drawLabel: function() {
                    var that = this,
                        labels = [],
                        notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY,
                        customVisibility = that._getCustomLabelVisibility(),
                        topLabel = that._topLabel,
                        bottomLabel = that._bottomLabel;
                    topLabel.pointPosition = notInverted ? "top" : "bottom";
                    bottomLabel.pointPosition = notInverted ? "bottom" : "top";
                    if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue()) {
                        false !== that.visibleTopMarker && labels.push(topLabel);
                        false !== that.visibleBottomMarker && labels.push(bottomLabel);
                        $.each(labels, function(_, label) {
                            label.show()
                        });
                        that._checkLabelsOverlay(that._topLabel.pointPosition)
                    } else {
                        topLabel.hide();
                        bottomLabel.hide()
                    }
                },
                _getImage: function(imageOption) {
                    var image = {};
                    if (_isDefined(imageOption)) {
                        if ("string" === typeof imageOption) {
                            image.top = image.bottom = imageOption
                        } else {
                            image.top = {
                                url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
                                width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
                                height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
                            };
                            image.bottom = {
                                url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
                                width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
                                height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
                            }
                        }
                    }
                    return image
                },
                _checkSymbol: function(oldOptions, newOptions) {
                    var that = this,
                        oldSymbol = oldOptions.symbol,
                        newSymbol = newOptions.symbol,
                        symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol,
                        oldImages = that._getImage(oldOptions.image),
                        newImages = that._getImage(newOptions.image),
                        topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top),
                        bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
                    return symbolChanged || topImageChanged || bottomImageChanged
                },
                _getSettingsForTwoMarkers: function(style) {
                    var that = this,
                        options = that._options,
                        settings = {},
                        x = options.rotated ? _min(that.x, that.minX) : that.x,
                        y = options.rotated ? that.y : _min(that.y, that.minY),
                        radius = style.r,
                        points = that._populatePointShape(options.symbol, radius);
                    settings.top = _extend({
                        translateX: x + that.width,
                        translateY: y,
                        r: radius
                    }, style);
                    settings.bottom = _extend({
                        translateX: x,
                        translateY: y + that.height,
                        r: radius
                    }, style);
                    if (points) {
                        settings.top.points = settings.bottom.points = points
                    }
                    return settings
                },
                _hasGraphic: function() {
                    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker
                },
                _drawOneMarker: function(renderer, markerType, imageSettings, settings) {
                    var that = this,
                        graphic = that.graphic;
                    if (graphic[markerType]) {
                        that._updateOneMarker(markerType, settings)
                    } else {
                        graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings)
                    }
                },
                _drawMarker: function(renderer, group, animationEnabled, firstDrawing, style) {
                    var that = this,
                        settings = that._getSettingsForTwoMarkers(style || that._getStyle()),
                        image = that._getImage(that._options.image);
                    if (that._checkImage(image.top)) {
                        settings.top = that._getImageSettings(settings.top, image.top)
                    }
                    if (that._checkImage(image.bottom)) {
                        settings.bottom = that._getImageSettings(settings.bottom, image.bottom)
                    }
                    that.graphic = that.graphic || renderer.g().append(group);
                    that.visibleTopMarker && that._drawOneMarker(renderer, "topMarker", image.top, settings.top);
                    that.visibleBottomMarker && that._drawOneMarker(renderer, "bottomMarker", image.bottom, settings.bottom)
                },
                _getSettingsForTracker: function(radius) {
                    var that = this,
                        rotated = that._options.rotated;
                    return {
                        translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
                        translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
                        width: that.width + 2 * radius,
                        height: that.height + 2 * radius
                    }
                },
                isInVisibleArea: function() {
                    var notVisibleByArg, notVisibleByVal, tmp, visibleArgArea, visibleValArea, that = this,
                        rotated = that._options.rotated,
                        argument = !rotated ? that.x : that.y,
                        maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x),
                        minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x),
                        translators = that.translators,
                        visibleTopMarker = true,
                        visibleBottomMarker = true,
                        visibleRangeArea = true;
                    if (translators) {
                        visibleArgArea = translators[!rotated ? "x" : "y"].getCanvasVisibleArea();
                        visibleValArea = translators[!rotated ? "y" : "x"].getCanvasVisibleArea();
                        notVisibleByArg = visibleArgArea.max < argument || visibleArgArea.min > argument;
                        notVisibleByVal = visibleValArea.min > minValue && visibleValArea.min > maxValue || visibleValArea.max < minValue && visibleValArea.max < maxValue;
                        if (notVisibleByArg || notVisibleByVal) {
                            visibleTopMarker = visibleBottomMarker = visibleRangeArea = false
                        } else {
                            visibleTopMarker = visibleValArea.min <= minValue && visibleValArea.max > minValue;
                            visibleBottomMarker = visibleValArea.min < maxValue && visibleValArea.max >= maxValue;
                            if (rotated) {
                                tmp = visibleTopMarker;
                                visibleTopMarker = visibleBottomMarker;
                                visibleBottomMarker = tmp
                            }
                        }
                    }
                    that.visibleTopMarker = visibleTopMarker;
                    that.visibleBottomMarker = visibleBottomMarker;
                    return visibleRangeArea
                },
                getTooltipParams: function() {
                    var x, y, min, max, minValue, that = this,
                        translators = that.translators,
                        visibleAreaX = translators.x.getCanvasVisibleArea(),
                        visibleAreaY = translators.y.getCanvasVisibleArea();
                    if (!that._options.rotated) {
                        minValue = _min(that.y, that.minY);
                        x = that.x;
                        min = visibleAreaY.min > minValue ? visibleAreaY.min : minValue;
                        max = visibleAreaY.max < minValue + that.height ? visibleAreaY.max : minValue + that.height;
                        y = min + (max - min) / 2
                    } else {
                        minValue = _min(that.x, that.minX);
                        y = that.y;
                        min = visibleAreaX.min > minValue ? visibleAreaX.min : minValue;
                        max = visibleAreaX.max < minValue + that.width ? visibleAreaX.max : minValue + that.width;
                        x = min + (max - min) / 2
                    }
                    return {
                        x: x,
                        y: y,
                        offset: 0
                    }
                },
                _translate: function(translators) {
                    var that = this,
                        rotated = that._options.rotated;
                    that.minX = that.minY = translators.y.translate(that.minValue);
                    symbolPoint._translate.call(that, translators);
                    that.height = rotated ? 0 : _abs(that.minY - that.y);
                    that.width = rotated ? _abs(that.x - that.minX) : 0
                },
                _updateData: function(data) {
                    var that = this;
                    symbolPoint._updateData.call(that, data);
                    that.minValue = that.initialMinValue = that.originalMinValue = data.minValue
                },
                _getImageSettings: function(settings, image) {
                    return {
                        href: image.url || image.toString(),
                        width: image.width || DEFAULT_IMAGE_WIDTH,
                        height: image.height || DEFAULT_IMAGE_HEIGHT,
                        translateX: settings.translateX,
                        translateY: settings.translateY
                    }
                },
                getCrosshairData: function(x, y) {
                    var that = this,
                        rotated = that._options.rotated,
                        minX = that.minX,
                        minY = that.minY,
                        vx = that.vx,
                        vy = that.vy,
                        value = that.value,
                        minValue = that.minValue,
                        argument = that.argument,
                        coords = {
                            axis: that.series.axis,
                            x: vx,
                            y: vy,
                            yValue: value,
                            xValue: argument
                        };
                    if (rotated) {
                        coords.yValue = argument;
                        if (_abs(vx - x) < _abs(minX - x)) {
                            coords.xValue = value
                        } else {
                            coords.x = minX;
                            coords.xValue = minValue
                        }
                    } else {
                        if (_abs(vy - y) >= _abs(minY - y)) {
                            coords.y = minY;
                            coords.yValue = minValue
                        }
                    }
                    return coords
                },
                _updateOneMarker: function(markerType, settings) {
                    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings)
                },
                _updateMarker: function(animationEnabled, style) {
                    this._drawMarker(void 0, void 0, false, false, style)
                },
                _getFormatObject: function(tooltip) {
                    var that = this,
                        initialMinValue = that.initialMinValue,
                        initialValue = that.initialValue,
                        initialArgument = that.initialArgument,
                        minValue = tooltip.formatValue(initialMinValue),
                        value = tooltip.formatValue(initialValue);
                    return {
                        argument: initialArgument,
                        argumentText: tooltip.formatValue(initialArgument, "argument"),
                        valueText: minValue + " - " + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: initialMinValue,
                        rangeValue2: initialValue,
                        seriesName: that.series.name,
                        point: that,
                        originalMinValue: that.originalMinValue,
                        originalValue: that.originalValue,
                        originalArgument: that.originalArgument
                    }
                },
                getLabel: function() {
                    return [this._topLabel, this._bottomLabel]
                },
                getBoundingRect: $.noop,
                coordsIn: function(x, y) {
                    var trackerRadius = this._storeTrackerR(),
                        xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius,
                        yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;
                    if (this._options.rotated) {
                        return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius)
                    } else {
                        return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius)
                    }
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/sparklines/base_sparkline.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseWidget = __webpack_require__( /*! ../core/base_widget */ 109),
                DEFAULT_LINE_SPACING = 2,
                DEFAULT_EVENTS_DELAY = 200,
                TOUCH_EVENTS_DELAY = 1e3,
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4),
                wheelEvent = __webpack_require__( /*! ../../events/core/wheel */ 78),
                baseThemeManagerModule = __webpack_require__( /*! ../core/base_theme_manager */ 103),
                translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 105),
                _abs = Math.abs,
                _extend = $.extend,
                _noop = $.noop;

            function generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled) {
                var lineSpacing = fontOptions.lineSpacing,
                    lineHeight = (void 0 !== lineSpacing && null !== lineSpacing ? lineSpacing : DEFAULT_LINE_SPACING) + fontOptions.size;
                return function(customizeObject) {
                    var html = "",
                        vt = customizeObject.valueText;
                    for (var i = 0; i < vt.length; i += 2) {
                        html += "<tr><td>" + vt[i] + "</td><td style='width: 15px'></td><td style='text-align: " + (rtlEnabled ? "left" : "right") + "'>" + vt[i + 1] + "</td></tr>"
                    }
                    return {
                        html: "<table style='border-spacing:0px; line-height: " + lineHeight + "px'>" + html + "</table>"
                    }
                }
            }

            function generateCustomizeTooltipCallback(customizeTooltip, fontOptions, rtlEnabled) {
                var defaultCustomizeTooltip = generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled);
                if ($.isFunction(customizeTooltip)) {
                    return function(customizeObject) {
                        var res = customizeTooltip.call(customizeObject, customizeObject);
                        if (!("html" in res) && !("text" in res)) {
                            _extend(res, defaultCustomizeTooltip.call(customizeObject, customizeObject))
                        }
                        return res
                    }
                } else {
                    return defaultCustomizeTooltip
                }
            }
            var BaseSparkline = BaseWidget.inherit({
                _setDeprecatedOptions: function() {
                    this.callBase();
                    _extend(this._deprecatedOptions, {
                        "tooltip.verticalAlignment": {
                            since: "15.1",
                            message: "Now tootips are aligned automatically"
                        },
                        "tooltip.horizontalAlignment": {
                            since: "15.1",
                            message: "Now tootips are aligned automatically"
                        }
                    })
                },
                _getLayoutItems: _noop,
                _useLinks: false,
                _themeDependentChanges: ["OPTIONS"],
                _initCore: function() {
                    var that = this;
                    that._tooltipTracker = that._renderer.root;
                    that._tooltipTracker.attr({
                        "pointer-events": "visible"
                    });
                    that._createHtmlElements();
                    that._initTooltipEvents()
                },
                _getDefaultSize: function() {
                    return this._defaultSize
                },
                _disposeCore: function() {
                    this._disposeWidgetElements();
                    this._disposeTooltipEvents();
                    this._ranges = null
                },
                _optionChangesOrder: ["OPTIONS"],
                _change_OPTIONS: function() {
                    this._prepareOptions();
                    this._change(["UPDATE"])
                },
                _customChangesOrder: ["UPDATE"],
                _change_UPDATE: function() {
                    this._update()
                },
                _update: function() {
                    var that = this;
                    if (that._tooltipShown) {
                        that._tooltipShown = false;
                        that._tooltip.hide()
                    }
                    that._cleanWidgetElements();
                    that._cleanTranslators();
                    that._updateWidgetElements();
                    that._drawWidgetElements()
                },
                _updateWidgetElements: function() {
                    this._updateRange();
                    this._updateTranslator()
                },
                _applySize: function(rect) {
                    this._allOptions.size = {
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1]
                    };
                    this._change(["UPDATE"])
                },
                _cleanTranslators: function() {
                    this._translatorX = null;
                    this._translatorY = null
                },
                _setupResizeHandler: _noop,
                _prepareOptions: function() {
                    return _extend(true, {}, this._themeManager.theme(), this.option())
                },
                _createThemeManager: function() {
                    var themeManager = new baseThemeManagerModule.BaseThemeManager;
                    themeManager._themeSection = this._widgetType;
                    themeManager._fontFields = ["tooltip.font"];
                    return themeManager
                },
                _getTooltipCoords: function() {
                    var canvas = this._canvas,
                        rootOffset = this._renderer.getRootOffset();
                    return {
                        x: canvas.width / 2 + rootOffset.left,
                        y: canvas.height / 2 + rootOffset.top
                    }
                },
                _initTooltipEvents: function() {
                    var that = this,
                        data = {
                            widget: that
                        };
                    that._showTooltipCallback = function() {
                        var tooltip;
                        that._showTooltipTimeout = null;
                        if (!that._tooltipShown) {
                            that._tooltipShown = true;
                            tooltip = that._getTooltip();
                            tooltip.isEnabled() && that._tooltip.show(that._getTooltipData(), that._getTooltipCoords(), {})
                        }
                        that._DEBUG_showCallback && that._DEBUG_showCallback()
                    };
                    that._hideTooltipCallback = function() {
                        var tooltipWasShown = that._tooltipShown;
                        that._hideTooltipTimeout = null;
                        if (that._tooltipShown) {
                            that._tooltipShown = false;
                            that._tooltip.hide()
                        }
                        that._DEBUG_hideCallback && that._DEBUG_hideCallback(tooltipWasShown)
                    };
                    that._disposeCallbacks = function() {
                        that = that._showTooltipCallback = that._hideTooltipCallback = that._disposeCallbacks = null
                    };
                    that._tooltipTracker.on(mouseEvents, data).on(touchEvents, data).on(mouseWheelEvents, data);
                    that._tooltipTracker.on(menuEvents)
                },
                _disposeTooltipEvents: function() {
                    var that = this;
                    clearTimeout(that._showTooltipTimeout);
                    clearTimeout(that._hideTooltipTimeout);
                    that._tooltipTracker.off();
                    that._disposeCallbacks()
                },
                _updateTranslator: function() {
                    var that = this,
                        canvas = this._canvas,
                        ranges = this._ranges;
                    that._translatorX = new translator2DModule.Translator2D(ranges.arg, canvas, {
                        isHorizontal: true
                    });
                    that._translatorY = new translator2DModule.Translator2D(ranges.val, canvas)
                },
                _getTooltip: function() {
                    var that = this;
                    if (!that._tooltip) {
                        _initTooltip.apply(this, arguments);
                        that._setTooltipRendererOptions(that._tooltipRendererOptions);
                        that._tooltipRendererOptions = null;
                        that._setTooltipOptions()
                    }
                    return that._tooltip
                }
            });
            var menuEvents = {
                "contextmenu.sparkline-tooltip": function(event) {
                    if (eventUtils.isTouchEvent(event) || eventUtils.isPointerEvent(event)) {
                        event.preventDefault()
                    }
                },
                "MSHoldVisual.sparkline-tooltip": function(event) {
                    event.preventDefault()
                }
            };
            var mouseEvents = {
                "mouseover.sparkline-tooltip": function(event) {
                    isPointerDownCalled = false;
                    var widget = event.data.widget;
                    widget._x = event.pageX;
                    widget._y = event.pageY;
                    widget._tooltipTracker.off(mouseMoveEvents).on(mouseMoveEvents, event.data);
                    widget._showTooltip(DEFAULT_EVENTS_DELAY)
                },
                "mouseout.sparkline-tooltip": function(event) {
                    if (isPointerDownCalled) {
                        return
                    }
                    var widget = event.data.widget;
                    widget._tooltipTracker.off(mouseMoveEvents);
                    widget._hideTooltip(DEFAULT_EVENTS_DELAY)
                }
            };
            var mouseWheelEvents = {};
            mouseWheelEvents[wheelEvent.name + ".sparkline-tooltip"] = function(event) {
                event.data.widget._hideTooltip()
            };
            var mouseMoveEvents = {
                "mousemove.sparkline-tooltip": function(event) {
                    var widget = event.data.widget;
                    if (widget._showTooltipTimeout && (_abs(widget._x - event.pageX) > 3 || _abs(widget._y - event.pageY) > 3)) {
                        widget._x = event.pageX;
                        widget._y = event.pageY;
                        widget._showTooltip(DEFAULT_EVENTS_DELAY)
                    }
                }
            };
            var active_touch_tooltip_widget = null,
                touchstartTooltipProcessing = function(event) {
                    event.preventDefault();
                    var widget = active_touch_tooltip_widget;
                    if (widget && widget !== event.data.widget) {
                        widget._hideTooltip(DEFAULT_EVENTS_DELAY)
                    }
                    widget = active_touch_tooltip_widget = event.data.widget;
                    widget._showTooltip(TOUCH_EVENTS_DELAY);
                    widget._touch = true
                },
                touchstartDocumentProcessing = function() {
                    var widget = active_touch_tooltip_widget;
                    if (widget) {
                        if (!widget._touch) {
                            widget._hideTooltip(DEFAULT_EVENTS_DELAY);
                            active_touch_tooltip_widget = null
                        }
                        widget._touch = null
                    }
                },
                touchendDocumentProcessing = function() {
                    var widget = active_touch_tooltip_widget;
                    if (widget) {
                        if (widget._showTooltipTimeout) {
                            widget._hideTooltip(DEFAULT_EVENTS_DELAY);
                            active_touch_tooltip_widget = null
                        }
                    }
                },
                isPointerDownCalled = false;
            var touchEvents = {
                "pointerdown.sparkline-tooltip": touchstartTooltipProcessing,
                "touchstart.sparkline-tooltip": touchstartTooltipProcessing
            };
            $(document).on({
                "pointerdown.sparkline-tooltip": function() {
                    isPointerDownCalled = true;
                    touchstartDocumentProcessing()
                },
                "touchstart.sparkline-tooltip": touchstartDocumentProcessing,
                "pointerup.sparkline-tooltip": touchendDocumentProcessing,
                "touchend.sparkline-tooltip": touchendDocumentProcessing
            });
            module.exports = BaseSparkline;
            module.exports._DEBUG_reset = function() {
                active_touch_tooltip_widget = null
            };
            BaseSparkline.addPlugin(__webpack_require__( /*! ../core/tooltip */ 165).plugin);
            var _initTooltip = BaseSparkline.prototype._initTooltip;
            BaseSparkline.prototype._initTooltip = _noop;
            var _disposeTooltip = BaseSparkline.prototype._disposeTooltip;
            BaseSparkline.prototype._disposeTooltip = function() {
                if (this._tooltip) {
                    _disposeTooltip.apply(this, arguments)
                }
            };
            BaseSparkline.prototype._setTooltipRendererOptions = function() {
                var options = this._getRendererOptions();
                if (this._tooltip) {
                    this._tooltip.setRendererOptions(options)
                } else {
                    this._tooltipRendererOptions = options
                }
            };
            BaseSparkline.prototype._setTooltipOptions = function() {
                var tooltip = this._tooltip,
                    options = tooltip && this._getOption("tooltip");
                tooltip && tooltip.update(_extend({}, options, {
                    customizeTooltip: generateCustomizeTooltipCallback(options.customizeTooltip, options.font, this.option("rtlEnabled")),
                    enabled: options.enabled && this._isTooltipEnabled()
                }))
            };
            BaseSparkline.prototype._showTooltip = function(delay) {
                var that = this;
                ++that._DEBUG_clearHideTooltipTimeout;
                clearTimeout(that._hideTooltipTimeout);
                that._hideTooltipTimeout = null;
                clearTimeout(that._showTooltipTimeout);
                ++that._DEBUG_showTooltipTimeoutSet;
                that._showTooltipTimeout = setTimeout(that._showTooltipCallback, delay)
            };
            BaseSparkline.prototype._hideTooltip = function(delay) {
                var that = this;
                ++that._DEBUG_clearShowTooltipTimeout;
                clearTimeout(that._showTooltipTimeout);
                that._showTooltipTimeout = null;
                clearTimeout(that._hideTooltipTimeout);
                if (delay) {
                    ++that._DEBUG_hideTooltipTimeoutSet;
                    that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay)
                } else {
                    that._hideTooltipCallback()
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/viz/translators/polar_translator.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                translator2DModule = __webpack_require__( /*! ./translator2d */ 105),
                SHIFT_ANGLE = 90,
                _round = Math.round;

            function PolarTranslator(businessRange, canvas, options) {
                var that = this;
                that._startAngle = options.startAngle;
                that._endAngle = options.endAngle;
                that._argCanvas = {
                    left: 0,
                    right: 0,
                    width: this._getAngle()
                };
                that._valCanvas = {
                    left: 0,
                    right: 0
                };
                that.canvas = $.extend({}, canvas);
                that._init();
                that._arg = new translator2DModule.Translator2D(businessRange.arg, that._argCanvas, {
                    isHorizontal: true,
                    conversionValue: true
                });
                that._val = new translator2DModule.Translator2D(businessRange.val, that._valCanvas, {
                    isHorizontal: true
                });
                that._businessRange = businessRange
            }
            PolarTranslator.prototype = {
                constructor: PolarTranslator,
                _init: function() {
                    var canvas = this.canvas;
                    this._setCoords({
                        x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
                        y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2,
                        r: Math.min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2
                    });
                    this._valCanvas.width = this._rad
                },
                reinit: function() {
                    this._init();
                    this._arg.reinit();
                    this._val.reinit()
                },
                _setCoords: function(coord) {
                    this._x0 = coord.x;
                    this._y0 = coord.y;
                    this._rad = coord.r < 0 ? 0 : coord.r
                },
                getBusinessRange: function() {
                    return this._businessRange
                },
                translate: function(arg, val, offsets) {
                    var x, y, that = this,
                        argTranslate = that._arg.translate(arg, offsets && offsets[0]),
                        radius = that._val.translate(val, offsets && offsets[1]),
                        angle = commonUtils.isDefined(argTranslate) ? argTranslate + that._startAngle - SHIFT_ANGLE : null,
                        cossin = vizUtils.getCosAndSin(angle);
                    y = _round(that._y0 + radius * cossin.sin);
                    x = _round(that._x0 + radius * cossin.cos);
                    return {
                        x: x,
                        y: y,
                        angle: angle,
                        radius: radius
                    }
                },
                setCanvasDimension: function(dimension) {
                    this.canvas.width = this.canvas.height = dimension;
                    this.reinit()
                },
                setAngles: function(startAngle, endAngle) {
                    var that = this;
                    that._startAngle = startAngle;
                    that._endAngle = endAngle;
                    that._argCanvas.width = that._getAngle();
                    that._arg.update(that._arg.getBusinessRange(), that._argCanvas)
                },
                getAngles: function() {
                    return [this._startAngle, this._endAngle]
                },
                getValLength: function() {
                    return this._rad
                },
                getCenter: function() {
                    return {
                        x: this._x0,
                        y: this._y0
                    }
                },
                getBaseAngle: function() {
                    return this._startAngle - SHIFT_ANGLE
                },
                getInterval: function() {
                    return this._arg.getInterval()
                },
                getValInterval: function() {
                    return this._val.getInterval()
                },
                _getAngle: function() {
                    return Math.abs(this._endAngle - this._startAngle)
                },
                getComponent: function(type) {
                    var that = this,
                        translator = this["_" + type];
                    translator.getRadius = function() {
                        return that.getValLength()
                    };
                    translator.getCenter = function() {
                        return that.getCenter()
                    };
                    translator.getAngles = function() {
                        return that.getAngles()
                    };
                    return translator
                },
                _untranslate: function(x, y) {
                    var radius = vizUtils.getDistance(this._x0, this._y0, x, y),
                        angle = Math.atan2(y - this._y0, x - this._x0);
                    return {
                        r: radius,
                        phi: angle
                    }
                },
                untranslate: function(x, y) {
                    var pos = this._untranslate(x, y);
                    pos.phi = _round(vizUtils.normalizeAngle(180 * pos.phi / Math.PI));
                    pos.r = _round(pos.r);
                    return pos
                },
                getVisibleCategories: $.noop,
                getCanvasVisibleArea: function() {
                    return {}
                },
                getMinBarSize: function(minBarSize) {
                    return this._val.getMinBarSize(minBarSize)
                }
            };
            exports.PolarTranslator = PolarTranslator
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/translators/translator1d.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _Number = Number;

            function Translator1D() {
                this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3])
            }
            Translator1D.prototype = {
                constructor: Translator1D,
                setDomain: function(domain1, domain2) {
                    var that = this;
                    that._domain1 = _Number(domain1);
                    that._domain2 = _Number(domain2);
                    that._domainDelta = that._domain2 - that._domain1;
                    return that
                },
                setCodomain: function(codomain1, codomain2) {
                    var that = this;
                    that._codomain1 = _Number(codomain1);
                    that._codomain2 = _Number(codomain2);
                    that._codomainDelta = that._codomain2 - that._codomain1;
                    return that
                },
                getDomain: function() {
                    return [this._domain1, this._domain2]
                },
                getCodomain: function() {
                    return [this._codomain1, this._codomain2]
                },
                getDomainStart: function() {
                    return this._domain1
                },
                getDomainEnd: function() {
                    return this._domain2
                },
                getCodomainStart: function() {
                    return this._codomain1
                },
                getCodomainEnd: function() {
                    return this._codomain2
                },
                getDomainRange: function() {
                    return this._domainDelta
                },
                getCodomainRange: function() {
                    return this._codomainDelta
                },
                translate: function(value) {
                    var ratio = (_Number(value) - this._domain1) / this._domainDelta;
                    return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN
                },
                adjust: function(value) {
                    var ratio = (_Number(value) - this._domain1) / this._domainDelta,
                        result = NaN;
                    if (ratio < 0) {
                        result = this._domain1
                    } else {
                        if (ratio > 1) {
                            result = this._domain2
                        } else {
                            if (0 <= ratio && ratio <= 1) {
                                result = _Number(value)
                            }
                        }
                    }
                    return result
                }
            };
            exports.Translator1D = Translator1D
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/viz/tree_map/colorizing.discrete.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            function discreteColorizer(options, themeManager, root) {
                var palette = themeManager.createPalette(options.palette, {
                    useHighlight: true
                });
                return (options.colorizeGroups ? discreteGroupColorizer : discreteLeafColorizer)(palette, root)
            }

            function generateColors(palette, colors, count) {
                var i;
                for (i = colors.length; i < count; ++i) {
                    colors.push(palette.getNextColor())
                }
            }

            function discreteLeafColorizer(palette) {
                var colors = [];
                generateColors(palette, colors, 4);
                return function(node) {
                    if (node.index >= colors.length) {
                        generateColors(palette, colors, 2 * colors.length)
                    }
                    return colors[node.index]
                }
            }

            function prepareDiscreteGroupColors(palette, root) {
                var i, node, colors = {},
                    allNodes = root.nodes.slice(),
                    ii = allNodes.length;
                for (i = 0; i < ii; ++i) {
                    node = allNodes[i];
                    if (node.isNode()) {
                        allNodes = allNodes.concat(node.nodes);
                        ii = allNodes.length
                    } else {
                        if (!colors[node.parent._id]) {
                            colors[node.parent._id] = palette.getNextColor()
                        }
                    }
                }
                return colors
            }

            function discreteGroupColorizer(palette, root) {
                var colors = prepareDiscreteGroupColors(palette, root);
                return function(node) {
                    return colors[node._id]
                }
            }
            __webpack_require__( /*! ./colorizing */ 106).addColorizer("discrete", discreteColorizer);
            module.exports = discreteColorizer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/viz/tree_map/hover.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                nodeProto = __webpack_require__( /*! ./node */ 168).prototype,
                common = __webpack_require__( /*! ./common */ 90),
                _parseScalar = __webpack_require__( /*! ../core/utils */ 6).parseScalar,
                _buildRectAppearance = common.buildRectAppearance,
                STATE_CODE = 1;
            __webpack_require__( /*! ./api */ 130);
            __webpack_require__( /*! ./states */ 344);
            proto._eventsMap.onHoverChanged = {
                name: "hoverChanged"
            };
            common.expand(proto._handlers, "calculateAdditionalStates", function(states, options) {
                states[1] = options.hoverStyle ? _buildRectAppearance(options.hoverStyle) : {}
            });
            __webpack_require__( /*! ./tree_map.base */ 51).addChange({
                code: "HOVER_ENABLED",
                handler: function() {
                    var hoverEnabled = _parseScalar(this._getOption("hoverEnabled", true), true);
                    if (!hoverEnabled) {
                        this.clearHover()
                    }
                    this._hoverEnabled = hoverEnabled
                },
                isThemeDependent: true,
                isOptionChange: true,
                option: "hoverEnabled"
            });
            nodeProto.statesMap[1] = 1;
            nodeProto.additionalStates.push(1);
            common.expand(proto, "_extendProxyType", function(proto) {
                var that = this;
                proto.setHover = function() {
                    that._hoverNode(this._id)
                };
                proto.isHovered = function() {
                    return that._hoverIndex === this._id
                }
            });
            common.expand(proto, "_onNodesCreated", function() {
                this._hoverIndex = -1
            });
            proto._applyHoverState = function(index, state) {
                setNodeStateRecursive(this._nodes[index], STATE_CODE, state);
                this._eventTrigger("hoverChanged", {
                    node: this._nodes[index].proxy
                })
            };

            function setNodeStateRecursive(node, code, state) {
                var i, nodes = node.isNode() && node.nodes,
                    ii = nodes && nodes.length;
                node.setState(code, state);
                for (i = 0; i < ii; ++i) {
                    setNodeStateRecursive(nodes[i], code, state)
                }
            }
            proto._hoverNode = function(index) {
                var that = this,
                    currentIndex = that._hoverIndex;
                if (that._hoverEnabled && currentIndex !== index) {
                    that._context.suspend();
                    that._hoverIndex = -1;
                    if (currentIndex >= 0) {
                        that._applyHoverState(currentIndex, false)
                    }
                    that._hoverIndex = index;
                    if (index >= 0) {
                        that._applyHoverState(index, true)
                    }
                    that._context.resume()
                }
            };
            proto.clearHover = function() {
                this._hoverNode(-1)
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/viz/tree_map/states.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                nodeProto = __webpack_require__( /*! ./node */ 168).prototype,
                handlers = proto._handlers,
                _calculateState = handlers.calculateState,
                _buildState = nodeProto._buildState,
                _extend = __webpack_require__( /*! jquery */ 1).extend;
            handlers.calculateState = function(options) {
                var states = {
                    0: _calculateState(options)
                };
                handlers.calculateAdditionalStates(states, options);
                return states
            };
            handlers.calculateAdditionalStates = __webpack_require__( /*! ./common */ 90).empty;
            nodeProto.code = 0;
            nodeProto.statesMap = {
                0: 0
            };
            nodeProto.additionalStates = [];
            nodeProto._buildState = function(state, extra) {
                var states = {
                    0: _buildState(state[0], extra)
                };
                if (this.additionalStates.length) {
                    buildAdditionalStates(states, states[0], state, this.additionalStates)
                }
                return states
            };
            nodeProto._getState = function() {
                return this.state[this.statesMap[this.code]]
            };
            nodeProto.setState = function(code, state) {
                if (state) {
                    this.code |= code
                } else {
                    this.code &= ~code
                }
                this.ctx.change(["TILES"])
            };

            function buildAdditionalStates(states, base, source, list) {
                var i, ii = list.length;
                for (i = 0; i < ii; ++i) {
                    states[list[i]] = _extend({}, base, source[list[i]])
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/tree_map/tiling.squarified.base.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _max = Math.max,
                _round = Math.round,
                _calculateRectangles = __webpack_require__( /*! ./tiling */ 107).calculateRectangles,
                _buildSidesData = __webpack_require__( /*! ./tiling */ 107).buildSidesData;

            function compare(a, b) {
                return b.value - a.value
            }

            function getAspectRatio(value) {
                return _max(value, 1 / value)
            }

            function findAppropriateCollection(nodes, head, context) {
                var nextAspectRatio, nextSum, i, j, totalAspectRatio, bestAspectRatio = 1 / 0,
                    sum = 0,
                    ii = nodes.length,
                    coeff = context.areaToValue / context.staticSide;
                for (i = head; i < ii;) {
                    nextSum = sum + nodes[i].value;
                    totalAspectRatio = context.staticSide / coeff / nextSum;
                    nextAspectRatio = 0;
                    for (j = head; j <= i; ++j) {
                        nextAspectRatio = context.accumulate(nextAspectRatio, getAspectRatio(totalAspectRatio * nodes[j].value / nextSum), j - head + 1)
                    }
                    if (nextAspectRatio < bestAspectRatio) {
                        bestAspectRatio = nextAspectRatio;
                        sum = nextSum;
                        ++i
                    } else {
                        break
                    }
                }
                return {
                    sum: sum,
                    count: i - head,
                    side: _round(coeff * sum)
                }
            }

            function getArea(rect) {
                return (rect[2] - rect[0]) * (rect[3] - rect[1])
            }

            function doStep(nodes, head, context) {
                var sidesData = context.sides || _buildSidesData(context.rect, context.directions),
                    rowData = sidesData.staticSide > 0 ? findAppropriateCollection(nodes, head, {
                        areaToValue: getArea(context.rect) / context.sum,
                        accumulate: context.accumulate,
                        staticSide: sidesData.staticSide
                    }) : {
                        sum: 1,
                        side: sidesData.variedSide,
                        count: nodes.length - head
                    };
                _calculateRectangles(nodes, head, context.rect, sidesData, rowData);
                context.sum -= rowData.sum;
                return head + rowData.count
            }
            module.exports = function(data, accumulate, isFixedStaticSide) {
                var i, items = data.items,
                    ii = items.length,
                    context = {
                        sum: data.sum,
                        rect: data.rect,
                        directions: data.directions,
                        accumulate: accumulate
                    };
                if (isFixedStaticSide) {
                    context.sides = _buildSidesData(context.rect, context.directions)
                }
                items.sort(compare);
                for (i = 0; i < ii;) {
                    i = doStep(items, i, context)
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/tree_map/tiling.squarified.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _max = Math.max,
                _squarify = __webpack_require__( /*! ./tiling.squarified.base */ 345);

            function accumulate(total, current) {
                return _max(total, current)
            }

            function squarified(data) {
                return _squarify(data, accumulate, false)
            }
            __webpack_require__( /*! ./tiling */ 107).addAlgorithm("squarified", squarified);
            module.exports = squarified
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/viz/tree_map/tooltip.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                common = __webpack_require__( /*! ./common */ 90);
            __webpack_require__( /*! ./api */ 130);
            common.expand(proto, "_extendProxyType", function(proto) {
                var that = this;
                proto.showTooltip = function(coords) {
                    that._showTooltip(this._id, coords)
                }
            });
            common.expand(proto, "_onNodesCreated", function() {
                if (this._tooltipIndex >= 0) {
                    this._tooltip.hide()
                }
                this._tooltipIndex = -1
            });
            common.expand(proto, "_onTilingPerformed", function() {
                if (this._tooltipIndex >= 0) {
                    this._moveTooltip(this._nodes[this._tooltipIndex])
                }
            });

            function getCoords(rect, renderer) {
                var offset = renderer.getRootOffset();
                return [(rect[0] + rect[2]) / 2 + offset.left, (rect[1] + rect[3]) / 2 + offset.top]
            }
            proto._showTooltip = function(index, coords) {
                var node, state, that = this,
                    tooltip = that._tooltip;
                if (tooltip.isEnabled()) {
                    node = that._nodes[index];
                    state = that._tooltipIndex === index || tooltip.show({
                        value: node.value,
                        valueText: tooltip.formatValue(node.value),
                        node: node.proxy
                    }, {
                        x: 0,
                        y: 0,
                        offset: 0
                    }, {
                        node: node.proxy
                    });
                    if (state) {
                        that._moveTooltip(node, coords)
                    } else {
                        tooltip.hide()
                    }
                    that._tooltipIndex = state ? index : -1
                }
            };
            proto._moveTooltip = function(node, coords) {
                var xy = coords || node.rect && getCoords(node.rect, this._renderer) || [-1e3, -1e3];
                this._tooltip.move(xy[0], xy[1], 0)
            };
            proto.hideTooltip = function() {
                if (this._tooltipIndex >= 0) {
                    this._tooltipIndex = -1;
                    this._tooltip.hide()
                }
            };
            __webpack_require__( /*! ./tree_map.base */ 51).addPlugin(__webpack_require__( /*! ../core/tooltip */ 165).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/vector_map/event_emitter.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1);
            var eventEmitterMethods = {
                _initEvents: function() {
                    var i, names = this._eventNames,
                        ii = names.length,
                        events = this._events = {};
                    for (i = 0; i < ii; ++i) {
                        events[names[i]] = $.Callbacks()
                    }
                },
                _disposeEvents: function() {
                    var name, events = this._events;
                    for (name in events) {
                        events[name].empty()
                    }
                    this._events = null
                },
                on: function(handlers) {
                    var name, events = this._events;
                    for (name in handlers) {
                        events[name].add(handlers[name])
                    }
                    return dispose;

                    function dispose() {
                        for (name in handlers) {
                            events[name].remove(handlers[name])
                        }
                    }
                },
                _fire: function(name, arg) {
                    this._events[name].fire(arg)
                }
            };
            exports.makeEventEmitter = function(target) {
                var name, prot = target.prototype;
                for (name in eventEmitterMethods) {
                    prot[name] = eventEmitterMethods[name]
                }
            };
            exports._TESTS_eventEmitterMethods = eventEmitterMethods
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/vector_map/projection.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var projectionModule = __webpack_require__( /*! ./projection.main */ 350),
                projection = projectionModule.projection,
                _min = Math.min,
                _max = Math.max,
                _sin = Math.sin,
                _asin = Math.asin,
                _tan = Math.tan,
                _atan = Math.atan,
                _exp = Math.exp,
                _log = Math.log,
                PI = Math.PI,
                PI_DIV_4 = PI / 4,
                GEO_LON_BOUND = 180,
                GEO_LAT_BOUND = 90,
                RADIANS = PI / 180,
                MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS,
                MILLER_LAT_BOUND = (2.5 * _atan(_exp(.8 * PI)) - .625 * PI) / RADIANS;

            function clamp(value, threshold) {
                return _max(_min(value, +threshold), -threshold)
            }
            projection.add("mercator", projection({
                aspectRatio: 1,
                to: function(coordinates) {
                    return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI]
                },
                from: function(coordinates) {
                    return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS]
                }
            }));
            projection.add("equirectangular", projection({
                aspectRatio: 2,
                to: function(coordinates) {
                    return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND]
                },
                from: function(coordinates) {
                    return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND]
                }
            }));
            projection.add("lambert", projection({
                aspectRatio: 2,
                to: function(coordinates) {
                    return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)]
                },
                from: function(coordinates) {
                    return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS]
                }
            }));
            projection.add("miller", projection({
                aspectRatio: 1,
                to: function(coordinates) {
                    return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * .4)) / PI]
                },
                from: function(coordinates) {
                    return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(.8 * coordinates[1] * PI)) - .625 * PI) / RADIANS]
                }
            }));
            exports.projection = projection
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/vector_map/projection.main.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                eventEmitterModule = __webpack_require__( /*! ./event_emitter */ 348);
            var _Number = Number,
                _min = Math.min,
                _max = Math.max,
                _abs = Math.abs,
                _round = Math.round,
                _ln = Math.log,
                _pow = Math.pow,
                TWO_TO_LN2 = 2 / Math.LN2,
                MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10,
                DEFAULT_MIN_ZOOM = 1,
                DEFAULT_MAX_ZOOM = 256,
                DEFAULT_CENTER = [NaN, NaN],
                DEFAULT_ENGINE_NAME = "mercator";

            function floatsEqual(f1, f2) {
                return _abs(f1 - f2) < 1e-8
            }

            function arraysEqual(a1, a2) {
                return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1])
            }

            function parseAndClamp(value, minValue, maxValue, defaultValue) {
                var val = _Number(value);
                return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue
            }

            function parseAndClampArray(value, minValue, maxValue, defaultValue) {
                return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])]
            }

            function getEngine(engine) {
                return engine instanceof Engine && engine || projection.get(engine) || projection.get(DEFAULT_ENGINE_NAME)
            }

            function Projection(parameters) {
                var that = this;
                that._initEvents();
                that._params = parameters;
                that._engine = getEngine();
                that._center = that._engine.center();
                that._adjustCenter()
            }
            Projection.prototype = {
                constructor: Projection,
                _minZoom: DEFAULT_MIN_ZOOM,
                _maxZoom: DEFAULT_MAX_ZOOM,
                _zoom: DEFAULT_MIN_ZOOM,
                _center: DEFAULT_CENTER,
                _canvas: {},
                _scale: [],
                dispose: function() {
                    this._disposeEvents()
                },
                setEngine: function(value) {
                    var that = this,
                        engine = getEngine(value);
                    if (that._engine !== engine) {
                        that._engine = engine;
                        that._fire("engine");
                        if (that._changeCenter(engine.center())) {
                            that._triggerCenterChanged()
                        }
                        if (that._changeZoom(that._minZoom)) {
                            that._triggerZoomChanged()
                        }
                        that._adjustCenter();
                        that._setupScreen()
                    }
                },
                setBounds: function(bounds) {
                    if (void 0 !== bounds) {
                        this.setEngine(this._engine.original().bounds(bounds))
                    }
                },
                _setupScreen: function() {
                    var that = this,
                        canvas = that._canvas,
                        width = canvas.width,
                        height = canvas.height,
                        aspectRatio = that._engine.ar();
                    that._x0 = canvas.left + width / 2;
                    that._y0 = canvas.top + height / 2;
                    if (width / height <= aspectRatio) {
                        that._xradius = width / 2;
                        that._yradius = width / 2 / aspectRatio
                    } else {
                        that._xradius = height / 2 * aspectRatio;
                        that._yradius = height / 2
                    }
                    that._fire("screen")
                },
                setSize: function(canvas) {
                    var that = this;
                    that._canvas = canvas;
                    that._setupScreen()
                },
                _toScreen: function(coordinates) {
                    return [this._x0 + this._xradius * coordinates[0], this._y0 + this._yradius * coordinates[1]]
                },
                _fromScreen: function(coordinates) {
                    return [(coordinates[0] - this._x0) / this._xradius, (coordinates[1] - this._y0) / this._yradius]
                },
                _toTransformed: function(coordinates) {
                    return [coordinates[0] * this._zoom + this._dxcenter, coordinates[1] * this._zoom + this._dycenter]
                },
                _toTransformedFast: function(coordinates) {
                    return [coordinates[0] * this._zoom, coordinates[1] * this._zoom]
                },
                _fromTransformed: function(coordinates) {
                    return [(coordinates[0] - this._dxcenter) / this._zoom, (coordinates[1] - this._dycenter) / this._zoom]
                },
                _adjustCenter: function() {
                    var that = this,
                        center = that._engine.project(that._center);
                    that._dxcenter = -center[0] * that._zoom || 0;
                    that._dycenter = -center[1] * that._zoom || 0
                },
                project: function(coordinates) {
                    return this._engine.project(coordinates)
                },
                transform: function(coordinates) {
                    return this._toScreen(this._toTransformedFast(coordinates))
                },
                isInvertible: function() {
                    return this._engine.isinv()
                },
                getSquareSize: function(size) {
                    return [size[0] * this._zoom * this._xradius, size[1] * this._zoom * this._yradius]
                },
                getZoom: function() {
                    return this._zoom
                },
                _changeZoom: function(value) {
                    var that = this,
                        oldZoom = that._zoom,
                        newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom),
                        isChanged = !floatsEqual(oldZoom, newZoom);
                    if (isChanged) {
                        that._adjustCenter();
                        that._fire("zoom")
                    }
                    return isChanged
                },
                setZoom: function(value) {
                    if (this._engine.isinv() && this._changeZoom(value)) {
                        this._triggerZoomChanged()
                    }
                },
                getScaledZoom: function() {
                    return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom))
                },
                setScaledZoom: function(scaledZoom) {
                    this.setZoom(this._scale[_round(scaledZoom)])
                },
                changeScaledZoom: function(deltaZoom) {
                    this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)])
                },
                getZoomScalePartition: function() {
                    return this._scale.length - 1
                },
                _setupScaling: function() {
                    var step, zoom, that = this,
                        k = _round(TWO_TO_LN2 * _ln(that._maxZoom)),
                        i = 1;
                    k = k > 4 ? k : 4;
                    step = _pow(that._maxZoom, 1 / k);
                    zoom = that._minZoom;
                    that._scale = [zoom];
                    for (; i <= k; ++i) {
                        that._scale.push(zoom *= step)
                    }
                },
                setMaxZoom: function(maxZoom) {
                    var that = this;
                    that._minZoom = DEFAULT_MIN_ZOOM;
                    that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);
                    that._setupScaling();
                    if (that._zoom > that._maxZoom) {
                        that.setZoom(that._maxZoom)
                    }
                    that._fire("max-zoom")
                },
                getCenter: function() {
                    return this._center.slice()
                },
                setCenter: function(value) {
                    if (this._engine.isinv() && this._changeCenter(value || [])) {
                        this._triggerCenterChanged()
                    }
                },
                _changeCenter: function(value) {
                    var that = this,
                        engine = that._engine,
                        oldCenter = that._center,
                        newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center()),
                        isChanged = !arraysEqual(oldCenter, newCenter);
                    if (isChanged) {
                        that._adjustCenter();
                        that._fire("center")
                    }
                    return isChanged
                },
                _triggerCenterChanged: function() {
                    this._params.centerChanged(this.getCenter())
                },
                _triggerZoomChanged: function() {
                    this._params.zoomChanged(this.getZoom())
                },
                setCenterByPoint: function(coordinates, screenPosition) {
                    var that = this,
                        p = that._engine.project(coordinates),
                        q = that._fromScreen(screenPosition);
                    that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]))
                },
                beginMoveCenter: function() {
                    if (this._engine.isinv()) {
                        this._moveCenter = this._center
                    }
                },
                endMoveCenter: function() {
                    var that = this;
                    if (that._moveCenter) {
                        if (!arraysEqual(that._moveCenter, that._center)) {
                            that._triggerCenterChanged()
                        }
                        that._moveCenter = null
                    }
                },
                moveCenter: function(shift) {
                    var current, center, that = this;
                    if (that._moveCenter) {
                        current = that._toScreen(that._toTransformed(that._engine.project(that._center)));
                        center = that._engine.unproject(that._fromTransformed(that._fromScreen([current[0] + shift[0], current[1] + shift[1]])));
                        that._changeCenter(center)
                    }
                },
                getViewport: function() {
                    var that = this,
                        unproject = that._engine.unproject,
                        lt = unproject(that._fromTransformed([-1, -1])),
                        lb = unproject(that._fromTransformed([-1, 1])),
                        rt = unproject(that._fromTransformed([1, -1])),
                        rb = unproject(that._fromTransformed([1, 1])),
                        minmax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);
                    return [].concat(minmax.min, minmax.max)
                },
                setViewport: function(viewport) {
                    var engine = this._engine,
                        data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];
                    this.setZoom(data[0]);
                    this.setCenter(data[1])
                },
                getTransform: function() {
                    return {
                        translateX: this._dxcenter * this._xradius,
                        translateY: this._dycenter * this._yradius
                    }
                },
                fromScreenPoint: function(coordinates) {
                    return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)))
                },
                _eventNames: ["engine", "screen", "center", "zoom", "max-zoom"]
            };
            eventEmitterModule.makeEventEmitter(Projection);

            function selectFarthestPoint(point1, point2, basePoint1, basePoint2) {
                var basePoint = (basePoint1 + basePoint2) / 2;
                return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2
            }

            function selectClosestPoint(point1, point2, basePoint1, basePoint2) {
                var basePoint = (basePoint1 + basePoint2) / 2;
                return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2
            }

            function getZoomAndCenterFromViewport(project, unproject, viewport) {
                var lt = project([viewport[0], viewport[3]]),
                    lb = project([viewport[0], viewport[1]]),
                    rt = project([viewport[2], viewport[3]]),
                    rb = project([viewport[2], viewport[1]]),
                    l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]),
                    r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]),
                    t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]),
                    b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);
                return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])]
            }

            function Engine(parameters, _original) {
                var that = this,
                    aspectRatio = parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1,
                    project = createProjectMethod(parameters.to),
                    unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER),
                    center = unproject([0, 0]),
                    minmax = findMinMax([unproject([-1, 0])[0], unproject([0, 1])[1]], [unproject([1, 0])[0], unproject([0, -1])[1]]);
                that.project = project;
                that.unproject = unproject;
                that.original = returnValue(_original || that);
                that.source = function() {
                    return $.extend({}, parameters)
                };
                that.isinv = returnValue(!!parameters.from);
                that.ar = returnValue(aspectRatio);
                that.center = returnArray(center);
                that.min = returnArray(minmax.min);
                that.max = returnArray(minmax.max)
            }
            Engine.prototype.aspectRatio = function(aspectRatio) {
                var parameters = this.source();
                parameters.aspectRatio = aspectRatio;
                return new Engine(parameters, this)
            };
            Engine.prototype.bounds = function(bounds) {
                bounds = bounds || [];
                var parameters = this.source(),
                    min = this.min(),
                    max = this.max(),
                    p1 = parameters.to(parseAndClampArray([bounds[0], bounds[1]], min, max, min)),
                    p2 = parameters.to(parseAndClampArray([bounds[2], bounds[3]], min, max, max)),
                    delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);
                if (delta < 2) {
                    $.extend(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta))
                }
                return new Engine(parameters, this)
            };

            function isEngine(engine) {
                return engine instanceof Engine
            }

            function invertVerticalAxis(pair) {
                return [pair[0], -pair[1]]
            }

            function createProjectMethod(method) {
                return function(arg) {
                    return invertVerticalAxis(method(arg))
                }
            }

            function createUnprojectMethod(method) {
                return function(arg) {
                    return method(invertVerticalAxis(arg))
                }
            }

            function returnValue(value) {
                return function() {
                    return value
                }
            }

            function returnArray(value) {
                return function() {
                    return value.slice()
                }
            }

            function projection(parameters) {
                return parameters && parameters.to ? new Engine(parameters) : null
            }

            function findMinMax(p1, p2) {
                return {
                    min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
                    max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]
                }
            }
            var projectionsCache = {};
            projection.get = function(name) {
                return projectionsCache[name] || null
            };
            projection.add = function(name, engine) {
                if (!projectionsCache[name] && isEngine(engine)) {
                    projectionsCache[name] = engine
                }
                return projection
            };

            function createProjectUnprojectMethods(project, unproject, p1, p2, delta) {
                var x0 = (p1[0] + p2[0]) / 2 - delta / 2,
                    y0 = (p1[1] + p2[1]) / 2 - delta / 2,
                    k = 2 / delta;
                return {
                    to: function(coordinates) {
                        var p = project(coordinates);
                        return [-1 + (p[0] - x0) * k, -1 + (p[1] - y0) * k]
                    },
                    from: function(coordinates) {
                        var p = [x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k];
                        return unproject(p)
                    }
                }
            }
            exports.Projection = Projection;
            exports.projection = projection;
            exports._TESTS_Engine = Engine
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** external "window.JSZip" ***!
      \*******************************/
    function(module, exports) {
        module.exports = window.JSZip
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
    /*!****************************************!*\
      !*** ./Scripts/bundles/modules/viz.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./core */ 97);
            module.exports = DevExpress.viz = DevExpress.viz || {}
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
    /*!***************************************************!*\
      !*** ./Scripts/viz/axes/datetime_tick_manager.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                tickManagerContinuous = __webpack_require__( /*! ./numeric_tick_manager */ 189).continuous,
                _isDefined = commonUtils.isDefined,
                _convertDateUnitToMilliseconds = dateUtils.convertDateUnitToMilliseconds,
                _correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning,
                _dateToMilliseconds = dateUtils.dateToMilliseconds,
                _convertMillisecondsToDateUnits = dateUtils.convertMillisecondsToDateUnits,
                _math = Math,
                _abs = _math.abs,
                _ceil = _math.ceil,
                _floor = _math.floor,
                _round = _math.round,
                MINOR_TICKS_COUNT_LIMIT = 50,
                DEFAULT_DATETIME_MULTIPLIERS = {
                    millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
                    second: [1, 2, 3, 5, 10, 15, 20, 30],
                    minute: [1, 2, 3, 5, 10, 15, 20, 30],
                    hour: [1, 2, 3, 4, 6, 8, 12],
                    day: [1, 2, 3, 5, 7, 10, 14],
                    month: [1, 2, 3, 6]
                };

            function correctDate(date, tickInterval, correctionMethod) {
                var interval = _dateToMilliseconds(tickInterval),
                    timezoneOffset = 60 * date.getTimezoneOffset() * 1e3;
                return new Date(Math[correctionMethod]((date - 0 - timezoneOffset) / interval) * interval + timezoneOffset)
            }
            exports.datetime = $.extend({}, tickManagerContinuous, {
                _correctInterval: function(step) {
                    var tickIntervalInMs = _dateToMilliseconds(this._tickInterval);
                    this._tickInterval = _convertMillisecondsToDateUnits(tickIntervalInMs * step)
                },
                _correctMax: function(tickInterval) {
                    this._max = correctDate(this._max, tickInterval, "ceil")
                },
                _correctMin: function(tickInterval) {
                    this._min = correctDate(this._min, tickInterval, "floor");
                    if (this._options.setTicksAtUnitBeginning) {
                        _correctDateWithUnitBeginning(this._min, tickInterval)
                    }
                },
                _findTickIntervalForCustomTicks: function() {
                    return _convertMillisecondsToDateUnits(_abs(this._customTicks[1] - this._customTicks[0]))
                },
                _getBoundInterval: function() {
                    var that = this,
                        interval = that._tickInterval,
                        intervalInMs = _dateToMilliseconds(interval),
                        boundCoef = that._options.boundCoef,
                        boundIntervalInMs = _isDefined(boundCoef) && isFinite(boundCoef) ? intervalInMs * _abs(boundCoef) : intervalInMs / 2;
                    return _convertMillisecondsToDateUnits(boundIntervalInMs)
                },
                _getInterval: function(deltaCoef) {
                    var factor, i, key, specificMultipliers, yearsCount, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
                        multipliers = this._options.numberMultipliers,
                        result = {};
                    if (interval > 0 && interval < 1) {
                        return {
                            milliseconds: 1
                        }
                    }
                    if (0 === interval) {
                        return 0
                    }
                    for (key in DEFAULT_DATETIME_MULTIPLIERS) {
                        if (DEFAULT_DATETIME_MULTIPLIERS.hasOwnProperty(key)) {
                            specificMultipliers = DEFAULT_DATETIME_MULTIPLIERS[key];
                            for (i = 0; i < specificMultipliers.length; i++) {
                                if (interval <= _convertDateUnitToMilliseconds(key, specificMultipliers[i])) {
                                    result[key + "s"] = specificMultipliers[i];
                                    return result
                                }
                            }
                        }
                    }
                    for (factor = 1;; factor *= 10) {
                        for (i = 0; i < multipliers.length; i++) {
                            yearsCount = factor * multipliers[i];
                            if (interval <= _convertDateUnitToMilliseconds("year", yearsCount)) {
                                return {
                                    years: yearsCount
                                }
                            }
                        }
                    }
                    return 0
                },
                _getMarginValue: function(min, max, margin) {
                    return _convertMillisecondsToDateUnits(_round(_abs(max - min) * margin))
                },
                _getMinorInterval: function(screenDelta, businessDelta) {
                    var interval, intervalInMs, intervalsCount, count, that = this,
                        options = that._options;
                    if (_isDefined(options.minorTickInterval) && that._isTickIntervalCorrect(options.minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
                        interval = options.minorTickInterval;
                        intervalInMs = _dateToMilliseconds(interval);
                        count = intervalInMs < businessDelta ? _ceil(businessDelta / intervalInMs) - 1 : 0
                    } else {
                        intervalsCount = _isDefined(options.minorTickCount) ? options.minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
                        count = intervalsCount - 1;
                        interval = count > 0 ? _convertMillisecondsToDateUnits(businessDelta / intervalsCount) : 0
                    }
                    that._minorTickInterval = interval;
                    that._minorTickCount = count
                },
                _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
                    var newValue = dateUtils.addInterval(value, tickInterval, isTickIntervalNegative);
                    if (this._options.setTicksAtUnitBeginning && false !== withCorrection) {
                        _correctDateWithUnitBeginning(newValue, tickInterval, true);
                        this._correctDateWithUnitBeginningCalled = true
                    }
                    return newValue
                },
                _getUnitBeginningMinorTicks: function(minorTicks) {
                    var that = this,
                        ticks = that._ticks,
                        tickInterval = that._findMinorTickInterval(ticks[1], ticks[2]),
                        isTickIntervalNegative = true,
                        isTickIntervalWithPow = false,
                        needCorrectTick = false,
                        startTick = that._getNextTickValue(ticks[1], tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                    if (that._isTickIntervalValid(tickInterval)) {
                        minorTicks = that._createTicks(minorTicks, tickInterval, startTick, ticks[0], isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick)
                    }
                    return minorTicks
                },
                _hasUnitBeginningTickCorrection: function() {
                    var ticks = this._ticks;
                    if (ticks.length < 3) {
                        return false
                    }
                    return ticks[1] - ticks[0] !== ticks[2] - ticks[1] && this._options.setTicksAtUnitBeginning && this._options.minorTickCount
                },
                _isTickIntervalValid: function(tickInterval) {
                    return _isDefined(tickInterval) && 0 !== _dateToMilliseconds(tickInterval)
                },
                _checkBoundedDatesOverlapping: function() {
                    var dates = this._ticks,
                        overlappingBehavior = this.getOverlappingBehavior();
                    return dates.length > 2 && "stagger" !== overlappingBehavior.mode && "ignore" !== overlappingBehavior.mode && !this._areDisplayValuesValid(dates[0], dates[1])
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/axes/logarithmic_tick_manager.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _addInterval = dateUtils.addInterval,
                _adjustValue = vizUtils.adjustValue,
                tickManagerContinuous = __webpack_require__( /*! ./numeric_tick_manager */ 189).continuous,
                _getLog = vizUtils.getLog,
                _raiseTo = vizUtils.raiseTo,
                _math = Math,
                _abs = _math.abs,
                _ceil = _math.ceil,
                _floor = _math.floor,
                _round = _math.round;
            exports.logarithmic = $.extend({}, tickManagerContinuous, {
                _correctMax: function() {
                    var base = this._options.base;
                    this._max = _adjustValue(_raiseTo(_ceil(_adjustValue(_getLog(this._max, base))), base))
                },
                _correctMin: function() {
                    var base = this._options.base;
                    this._min = _adjustValue(_raiseTo(_floor(_adjustValue(_getLog(this._min, base))), base))
                },
                _findBusinessDelta: function(min, max, isTickIntervalWithPow) {
                    var delta;
                    if (min <= 0 || max <= 0) {
                        return 0
                    }
                    if (false === isTickIntervalWithPow) {
                        delta = tickManagerContinuous._findBusinessDelta(min, max)
                    } else {
                        delta = _round(_abs(_getLog(min, this._options.base) - _getLog(max, this._options.base)))
                    }
                    return delta
                },
                _findTickIntervalForCustomTicks: function() {
                    return _adjustValue(_getLog(this._customTicks[1] / this._customTicks[0], this._options.base))
                },
                _getInterval: function(deltaCoef) {
                    var factor, i, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
                        multipliers = this._options.numberMultipliers,
                        result = 0,
                        hasResult = false;
                    if (0 !== interval) {
                        for (factor = 1; !hasResult; factor *= 10) {
                            for (i = 0; i < multipliers.length; i++) {
                                result = multipliers[i] * factor;
                                if (interval <= result) {
                                    hasResult = true;
                                    break
                                }
                            }
                        }
                    }
                    return _adjustValue(result)
                },
                _getMinorInterval: function(screenDelta, businessDelta) {
                    var that = this,
                        options = that._options,
                        minorTickCount = options.minorTickCount,
                        intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor),
                        count = intervalsCount - 1,
                        interval = count > 0 ? businessDelta / intervalsCount : 0;
                    that._minorTickInterval = interval;
                    that._minorTickCount = count
                },
                _getMarginValue: function() {
                    return null
                },
                _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow) {
                    var pow, nextTickValue, that = this;
                    tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval;
                    if (false === isTickIntervalWithPow) {
                        nextTickValue = value + tickInterval
                    } else {
                        pow = _addInterval(_getLog(value, that._options.base), tickInterval, that._min > that._max);
                        nextTickValue = _adjustValue(_raiseTo(pow, that._options.base))
                    }
                    return nextTickValue
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************!*\
      !*** ./Scripts/viz/axes/polar_axes.js ***!
      \****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var circularAxes, polarAxes, $ = __webpack_require__( /*! jquery */ 1),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                constants = __webpack_require__( /*! ./axes_constants */ 230),
                xyAxesLinear = __webpack_require__( /*! ./xy_axes */ 326).linear,
                _map = vizUtils.map,
                _math = Math,
                _abs = _math.abs,
                _round = _math.round,
                convertPolarToXY = vizUtils.convertPolarToXY,
                _extend = $.extend,
                _noop = $.noop,
                HALF_PI_ANGLE = 90;

            function getPolarQuarter(angle) {
                var quarter;
                angle = vizUtils.normalizeAngle(angle);
                if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
                    quarter = 1
                } else {
                    if (angle >= 45 && angle < 135) {
                        quarter = 2
                    } else {
                        if (angle >= 135 && angle < 225) {
                            quarter = 3
                        } else {
                            if (angle >= 225 && angle < 315) {
                                quarter = 4
                            }
                        }
                    }
                }
                return quarter
            }
            polarAxes = exports;
            circularAxes = polarAxes.circular = {
                _overlappingBehaviorType: "circular",
                _createAxisElement: function() {
                    var additionalTranslator = this._additionalTranslator;
                    return this._renderer.circle(additionalTranslator.getCenter().x, additionalTranslator.getCenter().y, additionalTranslator.getRadius())
                },
                _setBoundingRect: function() {
                    this.boundingRect = {
                        width: 0,
                        height: 0
                    }
                },
                _boundaryTicksVisibility: {
                    min: true
                },
                _getOverlappingBehaviorOptions: function() {
                    var that = this,
                        additionalTranslator = that._additionalTranslator,
                        angles = additionalTranslator.getAngles(),
                        options = xyAxesLinear._getOverlappingBehaviorOptions.call(that),
                        translator = that._translator,
                        indentFromAxis = that._options.label.indentFromAxis || 0;
                    if (options.overlappingBehavior) {
                        options.overlappingBehavior = {
                            mode: constants.validateOverlappingMode(options.overlappingBehavior.mode)
                        }
                    }
                    options.translate = function(value) {
                        return convertPolarToXY(additionalTranslator.getCenter(), angles[0], translator.translate(value), additionalTranslator.translate(constants.canvasPositionBottom))
                    };
                    options.circularRadius = additionalTranslator.getRadius() + indentFromAxis;
                    options.circularStartAngle = angles[0];
                    options.circularEndAngle = angles[1];
                    options.isHorizontal = false;
                    return options
                },
                _addBoundaryTick: function(ticks) {
                    var boundaryTicks = this._tickManager.getBoundaryTicks();
                    boundaryTicks.length && ticks.unshift({
                        value: boundaryTicks[0]
                    })
                },
                _getSpiderCategoryOption: function() {
                    return this._options.firstPointOnStartAngle
                },
                _getMinMax: function() {
                    var max, options = this._options,
                        min = commonUtils.isNumber(options.originValue) ? options.originValue : void 0;
                    if (options.period > 0 && options.argumentType === constants.numeric) {
                        min = min || 0;
                        max = min + options.period
                    }
                    return {
                        min: min,
                        max: max
                    }
                },
                _getStick: function() {
                    return this._options.firstPointOnStartAngle || this._options.type !== constants.discrete
                },
                measureLabels: function(withIndents) {
                    var maxLabelParams, that = this,
                        options = that._options,
                        indentFromAxis = options.label.indentFromAxis || 0,
                        widthAxis = options.visible ? options.width : 0,
                        halfTickLength = .5 * options.tick.length,
                        indent = withIndents ? indentFromAxis + halfTickLength : 0;
                    if (!that._axisElementsGroup || !that._options.label.visible) {
                        return {
                            height: widthAxis,
                            width: widthAxis
                        }
                    }
                    that._updateTickManager();
                    maxLabelParams = that._tickManager.getMaxLabelParams();
                    return {
                        height: maxLabelParams.height + indent,
                        width: maxLabelParams.width + indent
                    }
                },
                _getTranslatedCoord: function(value, offset) {
                    return this._translator.translate(value, offset) - HALF_PI_ANGLE
                },
                _getCanvasStartEnd: function() {
                    return {
                        start: 0 - HALF_PI_ANGLE,
                        end: 360 - HALF_PI_ANGLE
                    }
                },
                _createStrip: function(fromAngle, toAngle, attr) {
                    var center = this._additionalTranslator.getCenter(),
                        r = this._additionalTranslator.getRadius();
                    return this._renderer.arc(center.x, center.y, 0, r, -toAngle, -fromAngle).attr(attr)
                },
                _getStripLabelCoords: function(_, stripFrom, stripTo) {
                    var that = this,
                        angle = stripFrom + (stripTo - stripFrom) / 2,
                        cossin = vizUtils.getCosAndSin(-angle),
                        halfRad = that._additionalTranslator.getRadius() / 2,
                        center = that._additionalTranslator.getCenter(),
                        x = _round(center.x + halfRad * cossin.cos),
                        y = _round(center.y - halfRad * cossin.sin);
                    return {
                        x: x,
                        y: y,
                        align: constants.center
                    }
                },
                _createConstantLine: function(value, attr) {
                    var center = this._additionalTranslator.getCenter(),
                        r = this._additionalTranslator.getRadius();
                    return this._createPathElement([center.x, center.y, center.x + r, center.y], attr).rotate(value, center.x, center.y)
                },
                _getConstantLineLabelsCoords: function(value) {
                    var that = this,
                        cossin = vizUtils.getCosAndSin(-value),
                        halfRad = that._additionalTranslator.getRadius() / 2,
                        center = that._additionalTranslator.getCenter(),
                        x = _round(center.x + halfRad * cossin.cos),
                        y = _round(center.y - halfRad * cossin.sin);
                    return {
                        x: x,
                        y: y,
                        align: constants.center
                    }
                },
                _checkAlignmentConstantLineLabels: _noop,
                _getScreenDelta: function() {
                    return 2 * Math.PI * this._additionalTranslator.getRadius()
                },
                _getTickCoord: function(tick) {
                    var center = this._additionalTranslator.getCenter(),
                        r = this._additionalTranslator.getRadius(),
                        corrections = {
                            inside: -1,
                            center: -.5,
                            outside: 0
                        },
                        tickCorrection = tick.length * corrections[this._options.tickOrientation || "center"],
                        radiusWithTicks = r + tickCorrection;
                    return {
                        x1: center.x + radiusWithTicks,
                        y1: center.y,
                        x2: center.x + radiusWithTicks + tick.length,
                        y2: center.y,
                        angle: tick.angle
                    }
                },
                _getLabelAdjustedCoord: function(tick) {
                    var that = this,
                        pos = tick.labelPos,
                        cossin = vizUtils.getCosAndSin(pos.angle),
                        cos = cossin.cos,
                        sin = cossin.sin,
                        box = tick.label.getBBox(),
                        halfWidth = box.width / 2,
                        halfHeight = box.height / 2,
                        indentFromAxis = that._options.label.indentFromAxis || 0,
                        x = pos.x + indentFromAxis * cos,
                        y = pos.y + (pos.y - box.y - halfHeight) + indentFromAxis * sin;
                    switch (getPolarQuarter(pos.angle)) {
                        case 1:
                            x += halfWidth;
                            y += halfHeight * sin;
                            break;
                        case 2:
                            x += halfWidth * cos;
                            y += halfHeight;
                            break;
                        case 3:
                            x += -halfWidth;
                            y += halfHeight * sin;
                            break;
                        case 4:
                            x += halfWidth * cos;
                            y += -halfHeight
                    }
                    return {
                        x: x,
                        y: y
                    }
                },
                _getGridLineDrawer: function() {
                    var that = this,
                        r = that._additionalTranslator.getRadius(),
                        center = that._additionalTranslator.getCenter();
                    return function(tick) {
                        return that._createPathElement([center.x, center.y, center.x + r, center.y], tick.gridStyle).rotate(tick.angle, center.x, center.y)
                    }
                },
                _getTranslatedValue: function(value, _, offset) {
                    var additionalTranslator = this._additionalTranslator,
                        startAngle = additionalTranslator.getAngles()[0],
                        angle = this._translator.translate(value, -offset),
                        coords = convertPolarToXY(additionalTranslator.getCenter(), startAngle, angle, additionalTranslator.translate(constants.canvasPositionBottom));
                    return {
                        x: coords.x,
                        y: coords.y,
                        angle: angle + startAngle - HALF_PI_ANGLE
                    }
                },
                _getAdjustedStripLabelCoords: function(_, label) {
                    var y, box = label.getBBox();
                    y = label.attr("y") - box.y - box.height / 2;
                    return {
                        x: 0,
                        y: y
                    }
                },
                coordsIn: function(x, y) {
                    return vizUtils.convertXYToPolar(this._additionalTranslator.getCenter(), x, y).r > this._additionalTranslator.getRadius()
                },
                _rotateTick: function(tick, angle) {
                    var center = this._additionalTranslator.getCenter();
                    tick.graphic.rotate(angle, center.x, center.y)
                }
            };
            exports.circularSpider = _extend({}, circularAxes, {
                _createAxisElement: function() {
                    var points = _map(this.getSpiderTicks(), function(tick) {
                        return {
                            x: tick.posX,
                            y: tick.posY
                        }
                    });
                    return this._renderer.path(points, "area")
                },
                _getStick: function() {
                    return true
                },
                _getSpiderCategoryOption: function() {
                    return true
                },
                getSpiderTicks: function() {
                    var that = this;
                    that._spiderTicks = constants.convertValuesToTicks(that._tickManager.getFullTicks());
                    that._initTicks(that._spiderTicks, {
                        tickStyle: {},
                        gridStyle: {}
                    }, false, that._getSkippedCategory(), that._tickOffset);
                    return that._spiderTicks
                },
                _createStrip: function(fromAngle, toAngle, attr) {
                    var firstTick, lastTick, nextTick, tick, center = this._additionalTranslator.getCenter(),
                        spiderTicks = this.getSpiderTicks(),
                        points = [],
                        i = 0,
                        len = spiderTicks.length;
                    while (i < len) {
                        tick = spiderTicks[i];
                        if (tick.angle >= fromAngle && tick.angle <= toAngle) {
                            if (!firstTick) {
                                firstTick = spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1];
                                points.push((tick.posX + firstTick.posX) / 2, (tick.posY + firstTick.posY) / 2)
                            }
                            points.push(tick.posX, tick.posY);
                            nextTick = spiderTicks[i + 1] || spiderTicks[0];
                            lastTick = {
                                x: (tick.posX + nextTick.posX) / 2,
                                y: (tick.posY + nextTick.posY) / 2
                            }
                        }
                        i++
                    }
                    points.push(lastTick.x, lastTick.y);
                    points.push(center.x, center.y);
                    return this._renderer.path(points, "area").attr(attr)
                },
                _getTranslatedCoord: function(value, offset) {
                    return this._translator.translate(value, offset) - HALF_PI_ANGLE
                },
                _setTickOffset: function() {
                    this._tickOffset = false
                }
            });
            polarAxes.linear = {
                _overlappingBehaviorType: "linear",
                _getMinMax: circularAxes._getMinMax,
                _getStick: xyAxesLinear._getStick,
                _getSpiderCategoryOption: $.noop,
                _createAxisElement: function() {
                    var additionalTranslator = this._additionalTranslator,
                        centerCoord = additionalTranslator.getCenter(),
                        points = [centerCoord.x, centerCoord.y, centerCoord.x + additionalTranslator.getRadius(), centerCoord.y];
                    return this._renderer.path(points, "line").rotate(additionalTranslator.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y)
                },
                _setBoundingRect: circularAxes._setBoundingRect,
                _getScreenDelta: function() {
                    return this._additionalTranslator.getRadius()
                },
                _getTickCoord: function(tick) {
                    return {
                        x1: tick.posX - tick.length / 2,
                        y1: tick.posY,
                        x2: tick.posX + tick.length / 2,
                        y2: tick.posY,
                        angle: tick.angle + HALF_PI_ANGLE
                    }
                },
                _getOverlappingBehaviorOptions: function() {
                    var that = this,
                        translator = that._translator,
                        orthTranslator = that._additionalTranslator,
                        options = xyAxesLinear._getOverlappingBehaviorOptions.call(this),
                        startAngle = vizUtils.normalizeAngle(that._additionalTranslator.getAngles()[0]);
                    if (options.overlappingBehavior) {
                        options.overlappingBehavior = {
                            mode: constants.validateOverlappingMode(options.overlappingBehavior.mode)
                        }
                    }
                    options.isHorizontal = startAngle > 45 && startAngle < 135 || startAngle > 225 && startAngle < 315 ? true : false;
                    options.translate = function(value) {
                        return convertPolarToXY(orthTranslator.getCenter(), that._options.startAngle, orthTranslator.translate(constants.canvasPositionTop), translator.translate(value)).x
                    };
                    return options
                },
                _getLabelAdjustedCoord: function(tick) {
                    var x, y, that = this,
                        pos = tick.labelPos,
                        cossin = vizUtils.getCosAndSin(pos.angle),
                        indentFromAxis = that._options.label.indentFromAxis || 0,
                        box = tick.label.getBBox();
                    x = pos.x - _abs(indentFromAxis * cossin.sin) + _abs(box.width / 2 * cossin.cos);
                    y = pos.y + (pos.y - box.y) - _abs(box.height / 2 * cossin.sin) + _abs(indentFromAxis * cossin.cos);
                    return {
                        x: x,
                        y: y
                    }
                },
                _getGridLineDrawer: function() {
                    var that = this,
                        pos = that._additionalTranslator.getCenter();
                    return function(tick) {
                        return that._renderer.circle(pos.x, pos.y, vizUtils.getDistance(pos.x, pos.y, tick.posX, tick.posY)).attr(tick.gridStyle).sharp()
                    }
                },
                _getTranslatedValue: function(value, _, offset) {
                    var additionalTranslator = this._additionalTranslator,
                        startAngle = additionalTranslator.getAngles()[0],
                        angle = additionalTranslator.translate(constants.canvasPositionStart),
                        xy = convertPolarToXY(additionalTranslator.getCenter(), startAngle, angle, this._translator.translate(value, offset));
                    return {
                        x: xy.x,
                        y: xy.y,
                        angle: angle + startAngle - HALF_PI_ANGLE
                    }
                },
                _getTranslatedCoord: function(value, offset) {
                    return this._translator.translate(value, offset)
                },
                _getCanvasStartEnd: function() {
                    return {
                        start: 0,
                        end: this._additionalTranslator.getRadius()
                    }
                },
                _createStrip: function(fromPoint, toPoint, attr) {
                    var center = this._additionalTranslator.getCenter();
                    return this._renderer.arc(center.x, center.y, fromPoint, toPoint, 0, 360).attr(attr)
                },
                _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
                _getStripLabelCoords: function(_, stripFrom, stripTo) {
                    var that = this,
                        labelPos = stripFrom + (stripTo - stripFrom) / 2,
                        center = that._additionalTranslator.getCenter(),
                        y = _round(center.y - labelPos);
                    return {
                        x: center.x,
                        y: y,
                        align: constants.center
                    }
                },
                _createConstantLine: function(value, attr) {
                    var center = this._additionalTranslator.getCenter();
                    return this._renderer.circle(center.x, center.y, value).attr(attr).sharp()
                },
                _getConstantLineLabelsCoords: function(value) {
                    var that = this,
                        center = that._additionalTranslator.getCenter(),
                        y = _round(center.y - value);
                    return {
                        x: center.x,
                        y: y,
                        align: constants.center
                    }
                },
                _checkAlignmentConstantLineLabels: _noop,
                _rotateTick: function(tick, angle) {
                    tick.graphic.rotate(angle, tick.posX, tick.posY)
                }
            };
            polarAxes.linearSpider = _extend({}, polarAxes.linear, {
                _createPathElement: function(points, attr) {
                    return this._renderer.path(points, "area").attr(attr).sharp()
                },
                setSpiderTicks: function(ticks) {
                    this._spiderTicks = ticks
                },
                _getGridLineDrawer: function() {
                    var that = this,
                        pos = that._additionalTranslator.getCenter();
                    return function(tick) {
                        var radius = vizUtils.getDistance(pos.x, pos.y, tick.posX, tick.posY);
                        return that._createPathElement(that._getGridPoints(pos, radius), tick.gridStyle)
                    }
                },
                _getGridPoints: function(pos, radius) {
                    return _map(this._spiderTicks, function(tick) {
                        var cossin = vizUtils.getCosAndSin(tick.angle);
                        return {
                            x: _round(pos.x + radius * cossin.cos),
                            y: _round(pos.y + radius * cossin.sin)
                        }
                    })
                },
                _createStrip: function(fromPoint, toPoint, attr) {
                    var center = this._additionalTranslator.getCenter(),
                        innerPoints = this._getGridPoints(center, toPoint),
                        outerPoints = this._getGridPoints(center, fromPoint);
                    return this._renderer.path([outerPoints, innerPoints.reverse()], "area").attr(attr)
                },
                _createConstantLine: function(value, attr) {
                    var center = this._additionalTranslator.getCenter(),
                        points = this._getGridPoints(center, value);
                    return this._createPathElement(points, attr)
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/axes/tick_overlapping_manager.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                numericTickManager = __webpack_require__( /*! ./numeric_tick_manager */ 189),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _addInterval = __webpack_require__( /*! ../../core/utils/date */ 12).addInterval,
                _isDefined = commonUtils.isDefined,
                _isNumber = commonUtils.isNumber,
                _math = Math,
                _abs = _math.abs,
                _ceil = _math.ceil,
                _floor = _math.floor,
                _atan = _math.atan,
                _max = _math.max,
                _each = $.each,
                _noop = $.noop,
                _isFunction = $.isFunction,
                _extend = $.extend,
                SCREEN_DELTA_KOEF = 4,
                AXIS_STAGGER_OVERLAPPING_KOEF = 2,
                STAGGER = "stagger",
                ROTATE = "rotate",
                MIN_ARRANGEMENT_TICKS_COUNT = 2,
                outOfScreen = {
                    x: -1e3,
                    y: -1e3
                };

            function nextState(state) {
                switch (state) {
                    case "overlap":
                        return STAGGER;
                    case STAGGER:
                        return ROTATE;
                    default:
                        return "end"
                }
            }

            function defaultGetTextFunc(value) {
                return value.toString()
            }

            function convertDateIntervalToNumeric(interval) {
                if (!_isNumber(interval)) {
                    var date = new Date;
                    interval = _addInterval(date, interval) - date
                }
                return interval
            }
            exports.base = {
                _applyOverlappingBehavior: function() {
                    var that = this,
                        options = that._options,
                        overlappingBehavior = options.overlappingBehavior;
                    if ("ignore" !== overlappingBehavior.mode) {
                        that._useAutoArrangement = true;
                        that._correctTicks();
                        if ("_auto" === overlappingBehavior.mode) {
                            that._applyAutoOverlappingBehavior();
                            that._useAutoArrangement = options.overlappingBehavior.isOverlapped
                        }
                        if (that._useAutoArrangement) {
                            if (overlappingBehavior.mode === STAGGER) {
                                that._screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF
                            }
                            that._applyAutoArrangement()
                        }
                    }
                },
                checkBoundedTicksOverlapping: function() {
                    return {
                        overlappedDates: this._checkBoundedDatesOverlapping(),
                        overlappedStartEnd: this._checkStartEndOverlapping()
                    }
                },
                getMaxLabelParams: function(ticks) {
                    var tickWithMaxLength, tickTextWithMaxLength, that = this,
                        getText = that._options.getText || defaultGetTextFunc,
                        maxLength = 0;
                    ticks = ticks || that._calculateMajorTicks();
                    _each(ticks, function(_, item) {
                        var text = getText(item, that._options.labelOptions),
                            length = _isDefined(text) ? text.length : -1;
                        if (maxLength < length) {
                            maxLength = length;
                            tickWithMaxLength = item;
                            tickTextWithMaxLength = text
                        }
                    });
                    return maxLength > 0 ? that._getTextElementBbox(tickWithMaxLength, tickTextWithMaxLength) : {
                        width: 0,
                        height: 0,
                        length: 0,
                        y: 0
                    }
                },
                _applyAutoArrangement: function() {
                    var arrangementStep, maxDisplayValueSize, that = this,
                        options = that._options;
                    if (that._useAutoArrangement) {
                        maxDisplayValueSize = that._getTicksSize();
                        arrangementStep = that._getAutoArrangementStep(maxDisplayValueSize);
                        if (arrangementStep > 1) {
                            if (_isDefined(that._tickInterval) || _isDefined(that._customTicks)) {
                                that._ticks = that._getAutoArrangementTicks(arrangementStep)
                            } else {
                                options.gridSpacingFactor = maxDisplayValueSize;
                                that._ticks = that._createTicks([], that._findTickInterval(), that._min, that._max)
                            }
                        }
                    }
                },
                _getAutoArrangementTicks: function(step) {
                    var i, that = this,
                        ticks = that._ticks,
                        ticksLength = ticks.length,
                        resultTicks = ticks,
                        decimatedTicks = that._decimatedTicks || [];
                    if (step > 1) {
                        resultTicks = [];
                        for (i = 0; i < ticksLength; i++) {
                            if (i % step === 0) {
                                resultTicks.push(ticks[i])
                            } else {
                                decimatedTicks.push(ticks[i])
                            }
                        }
                        that._correctInterval(step)
                    }
                    return resultTicks
                },
                _isOverlappedTicks: function(screenDelta) {
                    return this._getAutoArrangementStep(this._getTicksSize(), screenDelta, -1) > 1
                },
                _areDisplayValuesValid: function(value1, value2) {
                    var hasHorizontalOverlapping, hasVerticalOverlapping, result, that = this,
                        options = that._options,
                        getText = options.getText || defaultGetTextFunc,
                        rotationAngle = options.overlappingBehavior && _isNumber(options.overlappingBehavior.rotationAngle) ? options.overlappingBehavior.rotationAngle : 0,
                        bBox1 = that._getTextElementBbox(value1, getText(value1, options.labelOptions)),
                        bBox2 = that._getTextElementBbox(value2, getText(value2, options.labelOptions)),
                        horizontalInverted = bBox1.x > bBox2.x,
                        verticalInverted = bBox1.y > bBox2.y;
                    if (0 !== rotationAngle) {
                        result = that._getDistanceByAngle(bBox1, rotationAngle) <= _abs(bBox2.x - bBox1.x)
                    } else {
                        hasHorizontalOverlapping = !horizontalInverted ? bBox1.x + bBox1.width > bBox2.x : bBox2.x + bBox2.width > bBox1.x;
                        hasVerticalOverlapping = !verticalInverted ? bBox1.y + bBox1.height > bBox2.y : bBox2.y + bBox2.height > bBox1.y;
                        result = !(hasHorizontalOverlapping && hasVerticalOverlapping)
                    }
                    return result
                },
                checkUserTickInterval: function(userTickInterval, calculatedTickInterval) {
                    var tickInterval1, tickInterval2, behavior = this._options.overlappingBehavior;
                    if (!behavior || "enlargeTickInterval" !== behavior.mode) {
                        return userTickInterval || calculatedTickInterval
                    }
                    if (!userTickInterval) {
                        return calculatedTickInterval
                    }
                    tickInterval1 = convertDateIntervalToNumeric(userTickInterval);
                    tickInterval2 = convertDateIntervalToNumeric(calculatedTickInterval);
                    if (_isNumber(tickInterval1) && _isNumber(tickInterval2)) {
                        if (tickInterval1 > tickInterval2) {
                            return userTickInterval
                        }
                    }
                    return calculatedTickInterval
                }
            };
            exports.circular = _extend({}, exports.base, {
                checkUserTickInterval: function(userTickInterval, calculatedTickInterval) {
                    return userTickInterval || calculatedTickInterval
                },
                _correctTicks: _noop,
                _applyAutoOverlappingBehavior: function() {
                    this._options.overlappingBehavior.isOverlapped = true
                },
                _getTextElementBbox: function(value, text) {
                    var bbox, textOptions = _extend({}, this._options.textOptions, {
                            rotate: 0
                        }),
                        delta = _isFunction(this._options.translate) ? this._options.translate(value) : {
                            x: 0,
                            y: 0
                        };
                    text = this._options.renderText(text, delta.x, delta.y).css(this._options.textFontStyles).attr(textOptions);
                    bbox = text.getBBox();
                    text.remove();
                    return bbox
                },
                _getTicksSize: function() {
                    return this.getMaxLabelParams(this._ticks)
                },
                _checkStartEndOverlapping: function() {
                    var ticks = this._ticks,
                        lastTick = ticks[ticks.length - 1];
                    return ticks.length > 1 && !this._areDisplayValuesValid(ticks[0], lastTick)
                },
                _getAutoArrangementStep: function(maxDisplayValueSize) {
                    var that = this,
                        options = that._options,
                        radius = options.circularRadius,
                        startAngle = options.circularStartAngle,
                        endAngle = options.circularEndAngle,
                        circleDelta = startAngle === endAngle ? 360 : _abs(startAngle - endAngle),
                        businessDelta = that._businessDelta || that._ticks.length,
                        degreesPerTick = that._tickInterval * circleDelta / businessDelta,
                        width = maxDisplayValueSize.width,
                        height = maxDisplayValueSize.height,
                        angle1 = _abs(2 * _atan(height / (2 * radius - width)) * 180 / _math.PI),
                        angle2 = _abs(2 * _atan(width / (2 * radius - height)) * 180 / _math.PI),
                        minAngleForTick = _max(angle1, angle2),
                        step = 1;
                    if (degreesPerTick < minAngleForTick) {
                        step = _ceil(minAngleForTick / degreesPerTick)
                    }
                    return _max(1, step)
                }
            });
            exports.linear = _extend({}, exports.base, {
                _correctTicks: function() {
                    var arrangementStep, getIntervalFunc = numericTickManager.continuous._getInterval;
                    if (this._testingGetIntervalFunc) {
                        getIntervalFunc = this._testingGetIntervalFunc
                    }
                    arrangementStep = _ceil(getIntervalFunc.call(this, this._getDeltaCoef(this._screenDelta * SCREEN_DELTA_KOEF, this._ticks.length))) || this._ticks.length;
                    this._appliedArrangementStep = arrangementStep;
                    this._ticks = this._getAutoArrangementTicks(arrangementStep)
                },
                _getTextElementBbox: function(value, text) {
                    var bbox, textOptions = _extend({}, this._options.textOptions, {
                            rotate: 0
                        }),
                        x = 0,
                        y = 0,
                        delta = _isFunction(this._options.translate) ? this._options.translate(value) : 0;
                    if (this._options.isHorizontal) {
                        x += delta
                    } else {
                        y += delta
                    }
                    text = this._options.renderText(text, x, y).css(this._options.textFontStyles).attr(textOptions);
                    bbox = text.getBBox();
                    text.remove();
                    return bbox
                },
                _checkStartEndOverlapping: _noop,
                _getAutoArrangementStep: function(maxDisplayValueSize, screenDelta, minArrangementTicksStep) {
                    var requiredValuesCount, that = this,
                        options = that._options,
                        textSpacing = options.textSpacing || 0,
                        addedSpacing = options.isHorizontal ? textSpacing : 0;
                    screenDelta = screenDelta || that._screenDelta;
                    minArrangementTicksStep = _isDefined(minArrangementTicksStep) ? minArrangementTicksStep : 1;
                    if (options.getCustomAutoArrangementStep) {
                        return options.getCustomAutoArrangementStep(that._ticks, options)
                    }
                    if (maxDisplayValueSize > 0) {
                        requiredValuesCount = _floor((screenDelta + textSpacing) / (maxDisplayValueSize + addedSpacing));
                        requiredValuesCount = requiredValuesCount <= minArrangementTicksStep ? MIN_ARRANGEMENT_TICKS_COUNT : requiredValuesCount;
                        return _ceil((options.ticksCount || that._ticks.length) / requiredValuesCount)
                    }
                    return 1
                },
                _getOptimalRotationAngle: function() {
                    var that = this,
                        options = that._options,
                        tick1 = that._ticks[0],
                        tick2 = that._ticks[1],
                        textOptions = that._textOptions,
                        getText = options.getText || defaultGetTextFunc,
                        textFontStyles = options.textFontStyles,
                        svgElement1 = options.renderText(getText(tick1, options.labelOptions), outOfScreen.x + options.translate(tick1, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
                        svgElement2 = options.renderText(getText(tick2, options.labelOptions), outOfScreen.x + options.translate(tick2, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
                        bBox1 = svgElement1.getBBox(),
                        bBox2 = svgElement2.getBBox(),
                        angle = 180 * _math.asin((bBox1.height + options.textSpacing) / (bBox2.x - bBox1.x)) / Math.PI;
                    svgElement1.remove();
                    svgElement2.remove();
                    return isNaN(angle) ? 90 : _ceil(angle)
                },
                _applyAutoOverlappingBehavior: function() {
                    var that = this,
                        overlappingBehavior = that._options.overlappingBehavior,
                        screenDelta = that._screenDelta,
                        isOverlapped = false,
                        rotationAngle = null,
                        mode = null,
                        state = "overlap";
                    while ("end" !== state) {
                        isOverlapped = rotationAngle && 90 !== rotationAngle ? false : that._isOverlappedTicks(screenDelta);
                        state = nextState(isOverlapped ? state : null);
                        switch (state) {
                            case STAGGER:
                                screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
                                mode = state;
                                break;
                            case ROTATE:
                                rotationAngle = that._getOptimalRotationAngle();
                                screenDelta = that._screenDelta;
                                mode = state
                        }
                    }
                    overlappingBehavior.isOverlapped = isOverlapped;
                    overlappingBehavior.mode = mode;
                    overlappingBehavior.rotationAngle = rotationAngle
                },
                _getDistanceByAngle: function(bBox, rotationAngle) {
                    var a = rotationAngle * (_math.PI / 180);
                    if (a >= _atan(bBox.height / bBox.width)) {
                        return bBox.height / _abs(_math.sin(a))
                    } else {
                        return bBox.width
                    }
                },
                _getTicksSize: function() {
                    var bBox = this.getMaxLabelParams(this._ticks),
                        options = this._options,
                        rotationAngle = options.overlappingBehavior ? options.overlappingBehavior.rotationAngle : 0,
                        isRotate = _isNumber(rotationAngle) && 0 !== rotationAngle;
                    return _ceil(isRotate ? this._getDistanceByAngle(bBox, rotationAngle) : options.isHorizontal ? bBox.width : bBox.height)
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************!*\
      !*** ./Scripts/viz/bar_gauge.js ***!
      \**********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./gauges/bar_gauge */ 522).dxBarGauge
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/viz/bullet.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./sparklines/bullet */ 552)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************!*\
      !*** ./Scripts/viz/chart.js ***!
      \******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                vizUtils = __webpack_require__( /*! ./core/utils */ 6),
                overlapping = __webpack_require__( /*! ./chart_components/base_chart */ 232).overlapping,
                translatorsModule = __webpack_require__( /*! ./translators/translator2d */ 105),
                rangeModule = __webpack_require__( /*! ./translators/range */ 89),
                LayoutManagerModule = __webpack_require__( /*! ./chart_components/layout_manager */ 328),
                multiAxesSynchronizer = __webpack_require__( /*! ./chart_components/multi_axes_synchronizer */ 508),
                AdvancedChart = __webpack_require__( /*! ./chart_components/advanced_chart */ 327).AdvancedChart,
                scrollBarModule = __webpack_require__( /*! ./chart_components/scroll_bar */ 509),
                crosshairModule = __webpack_require__( /*! ./chart_components/crosshair */ 506),
                MAX_ADJUSTMENT_ATTEMPTS = 5,
                DEFAULT_PANE_NAME = "default",
                DEFAULT_PANES = [{
                    name: DEFAULT_PANE_NAME,
                    border: {}
                }],
                _map = vizUtils.map,
                _each = $.each,
                _extend = $.extend,
                _isArray = commonUtils.isArray,
                _isDefined = commonUtils.isDefined;

            function getFirstAxisNameForPane(axes, paneName) {
                var result;
                for (var i = 0; i < axes.length; i++) {
                    if (axes[i].pane === paneName) {
                        result = axes[i].name;
                        break
                    }
                }
                if (!result) {
                    result = axes[0].name
                }
                return result
            }

            function hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes) {
                var firstShownAxis, axesForPane = [];
                _each(valAxes, function(_, axis) {
                    if (axis.pane === paneName) {
                        axesForPane.push(axis)
                    }
                });
                if (axesForPane.length > 1 && synchronizeMultiAxes) {
                    _each(axesForPane, function(_, axis) {
                        var gridOpt = axis.getOptions().grid,
                            minorGridOpt = axis.getOptions().minorGrid;
                        if (firstShownAxis && gridOpt && gridOpt.visible) {
                            gridOpt.visible = false;
                            minorGridOpt && (minorGridOpt.visible = false)
                        } else {
                            firstShownAxis = firstShownAxis ? firstShownAxis : gridOpt && gridOpt.visible
                        }
                    })
                }
            }

            function getPaneForAxis(paneAxis, axisNameWithoutPane) {
                var result;
                _each(paneAxis, function(paneName, pane) {
                    _each(pane, function(axisName) {
                        if (axisNameWithoutPane === axisName) {
                            result = paneName;
                            return false
                        }
                    })
                });
                return result
            }

            function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
                var result, axInd;
                for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {
                    if (valueAxesOptions[axInd].name === axisName) {
                        result = valueAxesOptions[axInd];
                        result.priority = axInd;
                        break
                    }
                }
                if (!result) {
                    for (axInd = 0; axInd < valueAxes.length; axInd++) {
                        if (valueAxes[axInd].name === axisName) {
                            result = valueAxes[axInd].getOptions();
                            result.priority = valueAxes[axInd].priority;
                            break
                        }
                    }
                }
                return result
            }

            function findAxis(paneName, axisName, axes) {
                var axis, i;
                for (i = 0; i < axes.length; i++) {
                    axis = axes[i];
                    if (axis.name === axisName && axis.pane === paneName) {
                        return axis
                    }
                }
            }

            function prepareSegmentRectPoints(left, top, width, height, borderOptions) {
                var maxSW = ~~((width < height ? width : height) / 2),
                    sw = borderOptions.width || 0,
                    newSW = sw < maxSW ? sw : maxSW;
                left += newSW / 2;
                top += newSW / 2;
                width -= newSW;
                height -= newSW;
                var segmentSequence, right = left + width,
                    bottom = top + height,
                    points = [],
                    segments = [],
                    visiblyOpt = 0,
                    prevSegmentVisibility = 0;
                var allSegment = {
                    top: [
                        [left, top],
                        [right, top]
                    ],
                    right: [
                        [right, top],
                        [right, bottom]
                    ],
                    bottom: [
                        [right, bottom],
                        [left, bottom]
                    ],
                    left: [
                        [left, bottom],
                        [left, top]
                    ]
                };
                _each(allSegment, function(seg) {
                    var visibility = !!borderOptions[seg];
                    visiblyOpt = 2 * visiblyOpt + ~~visibility
                });
                switch (visiblyOpt) {
                    case 13:
                    case 9:
                        segmentSequence = ["left", "top", "right", "bottom"];
                        break;
                    case 11:
                        segmentSequence = ["bottom", "left", "top", "right"];
                        break;
                    default:
                        segmentSequence = ["top", "right", "bottom", "left"]
                }
                _each(segmentSequence, function(_, seg) {
                    var segmentVisibility = !!borderOptions[seg];
                    if (!prevSegmentVisibility && segments.length) {
                        points.push(segments);
                        segments = []
                    }
                    if (segmentVisibility) {
                        _each(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
                            segments = segments.concat(segment)
                        })
                    }
                    prevSegmentVisibility = ~~segmentVisibility
                });
                segments.length && points.push(segments);
                1 === points.length && (points = points[0]);
                return {
                    points: points,
                    pathType: 15 === visiblyOpt ? "area" : "line"
                }
            }

            function applyClipSettings(clipRects, settings) {
                _each(clipRects || [], function(_, c) {
                    c && c.attr(settings)
                })
            }

            function reinitTranslators(translators) {
                _each(translators, function(_, axisTrans) {
                    _each(axisTrans, function(_, translator) {
                        translator.arg.reinit();
                        translator.val.reinit()
                    })
                })
            }

            function compareAxes(a, b) {
                return a.priority - b.priority
            }

            function doesPaneExist(panes, paneName) {
                var found = false;
                _each(panes, function(_, pane) {
                    if (pane.name === paneName) {
                        found = true;
                        return false
                    }
                });
                return found
            }
            var dxChart = AdvancedChart.inherit({
                _chartType: "chart",
                _initCore: function() {
                    this.paneAxis = {};
                    this._panesClipRects = {};
                    this.callBase()
                },
                _disposeCore: function() {
                    var that = this,
                        disposeObjectsInArray = this._disposeObjectsInArray,
                        panesClipRects = that._panesClipRects;
                    that.callBase();
                    disposeObjectsInArray.call(panesClipRects, "fixed");
                    disposeObjectsInArray.call(panesClipRects, "base");
                    disposeObjectsInArray.call(panesClipRects, "wide");
                    that._panesClipRects = null
                },
                _correctAxes: function() {
                    this._correctValueAxes()
                },
                _getExtraOptions: $.noop,
                _processSingleSeries: $.noop,
                _groupSeries: function() {
                    var that = this,
                        panes = that.panes,
                        valAxes = that._valueAxes,
                        paneList = _map(panes, function(pane) {
                            return pane.name
                        }),
                        series = that.series,
                        paneAxis = that.paneAxis,
                        synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes"),
                        groupedSeries = that._groupsData = {
                            groups: []
                        };
                    _each(series, function(i, particularSeries) {
                        particularSeries.axis = particularSeries.axis || getFirstAxisNameForPane(valAxes, particularSeries.pane);
                        if (particularSeries.axis) {
                            paneAxis[particularSeries.pane] = paneAxis[particularSeries.pane] || {};
                            paneAxis[particularSeries.pane][particularSeries.axis] = true
                        }
                    });
                    _each(valAxes, function(_, axis) {
                        if (axis.name && axis.pane && -1 !== $.inArray(axis.pane, paneList)) {
                            paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                            paneAxis[axis.pane][axis.name] = true
                        }
                    });
                    that._correctValueAxes();
                    _each(paneAxis, function(paneName, pane) {
                        hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes);
                        _each(pane, function(axisName) {
                            var group = {
                                series: []
                            };
                            _each(series, function(_, particularSeries) {
                                if (particularSeries.pane === paneName && particularSeries.axis === axisName) {
                                    group.series.push(particularSeries)
                                }
                            });
                            groupedSeries.groups.push(group);
                            group.valueAxis = findAxis(paneName, axisName, valAxes);
                            group.valueOptions = group.valueAxis.getOptions()
                        })
                    });
                    groupedSeries.argumentAxes = that._argumentAxes;
                    groupedSeries.argumentOptions = groupedSeries.argumentAxes[0].getOptions()
                },
                _cleanPanesClipRects: function(clipArrayName) {
                    var that = this,
                        clipArray = that._panesClipRects[clipArrayName];
                    _each(clipArray || [], function(_, clipRect) {
                        clipRect && clipRect.dispose()
                    });
                    that._panesClipRects[clipArrayName] = []
                },
                _createPanes: function() {
                    var defaultPane, that = this,
                        panes = that.option("panes"),
                        panesNameCounter = 0;
                    if (!panes || _isArray(panes) && !panes.length) {
                        panes = DEFAULT_PANES
                    }
                    that._cleanPanesClipRects("fixed");
                    that._cleanPanesClipRects("base");
                    that._cleanPanesClipRects("wide");
                    defaultPane = that.option("defaultPane");
                    panes = _extend(true, [], _isArray(panes) ? panes : [panes]);
                    _each(panes, function(_, pane) {
                        pane.name = !_isDefined(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name
                    });
                    if (_isDefined(defaultPane)) {
                        if (!doesPaneExist(panes, defaultPane)) {
                            that._incidentOccurred("W2101", [defaultPane]);
                            defaultPane = panes[panes.length - 1].name
                        }
                    } else {
                        defaultPane = panes[panes.length - 1].name
                    }
                    that.defaultPane = defaultPane;
                    panes = that._isRotated() ? panes.reverse() : panes;
                    return panes
                },
                _getAxisRenderingOptions: function() {
                    return {
                        axisType: "xyAxes",
                        drawingType: "linear"
                    }
                },
                _prepareAxisOptions: function(typeSelector, userOptions, rotated) {
                    return {
                        isHorizontal: "argumentAxis" === typeSelector !== rotated
                    }
                },
                _checkPaneName: function(seriesTheme) {
                    var paneList = _map(this.panes, function(pane) {
                        return pane.name
                    });
                    seriesTheme.pane = seriesTheme.pane || this.defaultPane;
                    return -1 !== $.inArray(seriesTheme.pane, paneList)
                },
                _correctValueAxes: function() {
                    var that = this,
                        rotated = that._isRotated(),
                        valueAxisOptions = that.option("valueAxis") || {},
                        valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                        valueAxes = that._valueAxes || [],
                        defaultAxisName = valueAxes[0].name,
                        paneAxis = that.paneAxis,
                        neededAxis = {};
                    _each(valueAxes, function(_, axis) {
                        var pane;
                        if (!axis.pane) {
                            pane = getPaneForAxis(paneAxis, axis.name);
                            if (!pane) {
                                pane = that.defaultPane;
                                (paneAxis[pane] = paneAxis[pane] || {})[axis.name] = true
                            }
                            axis.setPane(pane)
                        }
                    });
                    _each(that.panes, function(_, pane) {
                        var name = pane.name;
                        if (!paneAxis[name]) {
                            paneAxis[name] = {};
                            paneAxis[name][defaultAxisName] = true
                        }
                    });
                    _each(paneAxis, function(paneName, axisNames) {
                        _each(axisNames, function(axisName) {
                            var axisOptions;
                            neededAxis[axisName + "-" + paneName] = true;
                            if (!findAxis(paneName, axisName, valueAxes)) {
                                axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
                                if (!axisOptions) {
                                    that._incidentOccurred("W2102", [axisName]);
                                    axisOptions = {
                                        name: axisName,
                                        priority: valueAxes.length
                                    }
                                }
                                valueAxes.push(that._createAxis("valueAxis", axisOptions, {
                                    pane: paneName,
                                    name: axisName
                                }, rotated))
                            }
                        })
                    });
                    that._valueAxes = $.grep(valueAxes, function(elem) {
                        return !!neededAxis[elem.name + "-" + elem.pane]
                    }).sort(compareAxes)
                },
                _getSeriesForPane: function(paneName) {
                    var paneSeries = [];
                    _each(this.series, function(_, oneSeries) {
                        if (oneSeries.pane === paneName) {
                            paneSeries.push(oneSeries)
                        }
                    });
                    return paneSeries
                },
                _createTranslator: function(range, canvas, options) {
                    return new translatorsModule.Translator2D(range, canvas, options)
                },
                _createPanesBorderOptions: function() {
                    var commonBorderOptions = this._themeManager.getOptions("commonPaneSettings").border,
                        panesBorderOptions = {};
                    _each(this.panes, function(_, pane) {
                        panesBorderOptions[pane.name] = _extend(true, {}, commonBorderOptions, pane.border)
                    });
                    return panesBorderOptions
                },
                _createScrollBar: function() {
                    var that = this,
                        scrollBarOptions = that._themeManager.getOptions("scrollBar") || {},
                        scrollBarGroup = that._scrollBarGroup;
                    if (scrollBarOptions.visible) {
                        scrollBarOptions.rotated = that._isRotated();
                        that._scrollBar = (that._scrollBar || new scrollBarModule.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions)
                    } else {
                        scrollBarGroup.linkRemove();
                        that._scrollBar && that._scrollBar.dispose();
                        that._scrollBar = null
                    }
                },
                _prepareToRender: function(drawOptions) {
                    var that = this,
                        panesBorderOptions = that._createPanesBorderOptions(),
                        useAggregation = that._options.useAggregation;
                    that._createPanesBackground();
                    that._appendAxesGroups();
                    that._transformed && that._resetTransform();
                    that._createTranslators(drawOptions);
                    if (useAggregation) {
                        _each(that.series, function(_, series) {
                            series.resamplePoints(that._getTranslator(series.pane, series.axis).arg, that._zoomMinArg, that._zoomMaxArg)
                        })
                    }
                    if (useAggregation || _isDefined(that._zoomMinArg) || _isDefined(that._zoomMaxArg)) {
                        that._populateBusinessRange({
                            adjustOnZoom: that._themeManager.getOptions("adjustOnZoom"),
                            minArg: that._zoomMinArg,
                            maxArg: that._zoomMaxArg,
                            notApplyMargins: that._notApplyMargins
                        });
                        that._updateTranslators()
                    }
                    return panesBorderOptions
                },
                _isLegendInside: function() {
                    return this._legend && "inside" === this._legend.getPosition()
                },
                _renderAxes: function(drawOptions, panesBorderOptions, rotated, adjustUnits) {
                    if (drawOptions && drawOptions.recreateCanvas) {
                        vizUtils.updatePanesCanvases(this.panes, this._canvas, rotated)
                    }
                    this._drawAxes(panesBorderOptions, drawOptions, adjustUnits)
                },
                _isRotated: function() {
                    return this._themeManager.getOptions("rotated")
                },
                _getLayoutTargets: function() {
                    return this.panes
                },
                _applyClipRects: function(panesBorderOptions) {
                    var i, that = this,
                        canvasClipRectID = that._getCanvasClipRectID();
                    that._drawPanesBorders(panesBorderOptions);
                    that._createClipRectsForPanes();
                    for (i = 0; i < that._argumentAxes.length; i++) {
                        that._argumentAxes[i].applyClipRects(that._getElementsClipRectID(that._argumentAxes[i].pane), canvasClipRectID)
                    }
                    for (i = 0; i < that._valueAxes.length; i++) {
                        that._valueAxes[i].applyClipRects(that._getElementsClipRectID(that._valueAxes[i].pane), canvasClipRectID)
                    }
                    that._fillPanesBackground()
                },
                _updateLegendPosition: function(drawOptions, legendHasInsidePosition) {
                    var that = this;
                    if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {
                        var panes = that.panes,
                            newCanvas = _extend({}, panes[0].canvas),
                            layoutManager = new LayoutManagerModule.LayoutManager;
                        newCanvas.right = panes[panes.length - 1].canvas.right;
                        newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
                        layoutManager.setOptions({
                            width: 0,
                            height: 0
                        });
                        layoutManager.layoutElements([that._legend], newCanvas, $.noop, [{
                            canvas: newCanvas
                        }], void 0, {
                            horizontalAxes: [],
                            verticalAxes: []
                        })
                    }
                },
                _prepareTranslators: function(series, _, rotated) {
                    var tr = this._getTranslator(series.pane, series.axis),
                        translators = {};
                    translators[rotated ? "x" : "y"] = tr.val;
                    translators[rotated ? "y" : "x"] = tr.arg;
                    return translators
                },
                _applyExtraSettings: function(series, drawOptions) {
                    var that = this,
                        paneIndex = that._getPaneIndex(series.pane),
                        panesClipRects = that._panesClipRects,
                        wideClipRect = panesClipRects.wide[paneIndex];
                    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex))
                },
                _createTranslators: function(drawOptions) {
                    var translators, that = this,
                        rotated = that._isRotated();
                    if (!drawOptions.recreateCanvas) {
                        return
                    }
                    that.translators = translators = {};
                    vizUtils.updatePanesCanvases(that.panes, that._canvas, rotated);
                    _each(that.paneAxis, function(paneName, pane) {
                        translators[paneName] = translators[paneName] || {};
                        _each(pane, function(axisName) {
                            var translator = that._createTranslator(new rangeModule.Range(that._getBusinessRange(paneName, axisName).val), that._getCanvasForPane(paneName), {
                                isHorizontal: !!rotated
                            });
                            translator.pane = paneName;
                            translator.axis = axisName;
                            translators[paneName][axisName] = {
                                val: translator
                            }
                        })
                    });
                    _each(that._argumentAxes, function(_, axis) {
                        var translator = that._createTranslator(new rangeModule.Range(that._getBusinessRange(axis.pane).arg), that._getCanvasForPane(axis.pane), {
                            isHorizontal: !rotated
                        });
                        _each(translators[axis.pane], function(valAxis, paneAxisTran) {
                            paneAxisTran.arg = translator
                        })
                    })
                },
                _updateTranslators: function() {
                    var that = this;
                    _each(that.translators, function(pane, axisTrans) {
                        _each(axisTrans, function(axis, translator) {
                            translator.arg.updateBusinessRange(new rangeModule.Range(that._getBusinessRange(pane).arg));
                            delete translator.arg._originalBusinessRange;
                            translator.val.updateBusinessRange(new rangeModule.Range(that._getBusinessRange(pane, axis).val));
                            delete translator.val._originalBusinessRange
                        })
                    })
                },
                _getAxesForTransform: function(rotated) {
                    return {
                        verticalAxes: !rotated ? this._getValueAxes() : this._getArgumentAxes(),
                        horizontalAxes: !rotated ? this._getArgumentAxes() : this._getValueAxes()
                    }
                },
                _getAxisDrawingMethods: function(drawOptions, preparedOptions, isRotated) {
                    var that = this;
                    return function(adjustUnits) {
                        that._renderAxes(drawOptions, preparedOptions, isRotated, adjustUnits)
                    }
                },
                _reinitTranslators: function() {
                    var that = this;
                    _each(that._argumentAxes, function(_, axis) {
                        var translator = that._getTranslator(axis.pane);
                        if (translator) {
                            translator.arg.reinit();
                            axis.setTranslator(translator.arg, translator.val)
                        }
                    });
                    _each(that._valueAxes, function(_, axis) {
                        var translator = that._getTranslator(axis.pane, axis.name);
                        if (translator) {
                            translator.val.reinit();
                            axis.setTranslator(translator.val, translator.arg)
                        }
                    })
                },
                _saveBusinessRange: function() {
                    var savedBusinessRange = this._savedBusinessRange;
                    $.each(this.translators, function(name, pane) {
                        savedBusinessRange[name] = {};
                        $.each(pane, function(axisName, translator) {
                            savedBusinessRange[name][axisName] = {};
                            savedBusinessRange[name][axisName].arg = $.extend(true, {}, translator.arg.getBusinessRange());
                            savedBusinessRange[name][axisName].val = $.extend(true, {}, translator.val.getBusinessRange())
                        })
                    })
                },
                _restoreOriginalBusinessRange: function() {
                    var savedBusinessRange = this._savedBusinessRange;
                    $.each(this.translators, function(name, pane) {
                        $.each(pane, function(axisName, translator) {
                            translator.arg.updateBusinessRange($.extend(true, {}, savedBusinessRange[name][axisName].arg));
                            translator.val.updateBusinessRange($.extend(true, {}, savedBusinessRange[name][axisName].val))
                        })
                    })
                },
                _prepareAxesAndDraw: function(drawAxes, drawStaticAxisElements, drawOptions) {
                    var that = this,
                        i = 0,
                        layoutManager = that.layoutManager,
                        rotated = that._isRotated(),
                        adjustmentCounter = 0,
                        synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes"),
                        layoutTargets = that._getLayoutTargets(),
                        verticalAxes = rotated ? that._argumentAxes : that._valueAxes,
                        horizontalAxes = rotated ? that._valueAxes : that._argumentAxes,
                        hElements = horizontalAxes,
                        vElements = verticalAxes;
                    if (that._scrollBar) {
                        that._scrollBar.setPane(layoutTargets);
                        if (rotated) {
                            vElements = [that._scrollBar].concat(vElements)
                        } else {
                            hElements = hElements.concat([that._scrollBar])
                        }
                    }
                    do {
                        for (i = 0; i < that._argumentAxes.length; i++) {
                            that._argumentAxes[i].resetTicks()
                        }
                        for (i = 0; i < that._valueAxes.length; i++) {
                            that._valueAxes[i].resetTicks()
                        }
                        if (synchronizeMultiAxes) {
                            multiAxesSynchronizer.synchronize(that._valueAxes)
                        }
                        drawAxes(horizontalAxes);
                        layoutManager.requireAxesRedraw = false;
                        if (drawOptions.adjustAxes) {
                            layoutManager.applyHorizontalAxesLayout(hElements, layoutTargets, rotated);
                            !layoutManager.stopDrawAxes && reinitTranslators(that.translators)
                        }
                        drawAxes(verticalAxes);
                        if (drawOptions.adjustAxes && !layoutManager.stopDrawAxes) {
                            layoutManager.applyVerticalAxesLayout(vElements, layoutTargets, rotated);
                            !layoutManager.stopDrawAxes && reinitTranslators(that.translators)
                        }
                        adjustmentCounter += 1
                    } while (!layoutManager.stopDrawAxes && layoutManager.requireAxesRedraw && adjustmentCounter < MAX_ADJUSTMENT_ATTEMPTS);
                    drawStaticAxisElements(verticalAxes);
                    drawStaticAxisElements(horizontalAxes);
                    that._scrollBar && that._scrollBar.applyLayout();
                    that.__axisAdjustmentsCount = adjustmentCounter
                },
                _getPanesParameters: function() {
                    var i, that = this,
                        panes = that.panes,
                        params = [];
                    for (i = 0; i < panes.length; i++) {
                        if (that._getPaneBorderVisibility(i)) {
                            params.push({
                                coords: panes[i].borderCoords,
                                clipRect: that._panesClipRects.fixed[i]
                            })
                        }
                    }
                    return params
                },
                _createCrosshairCursor: function() {
                    var that = this,
                        options = that._themeManager.getOptions("crosshair") || {},
                        index = that._displayedArgumentAxisIndex,
                        axes = !that._isRotated() ? [
                            [that._argumentAxes[index]], that._valueAxes
                        ] : [that._valueAxes, [that._argumentAxes[index]]],
                        parameters = {
                            canvas: that._getCommonCanvas(),
                            panes: that._getPanesParameters(),
                            axes: axes
                        };
                    if (!options || !options.enabled) {
                        return
                    }
                    if (!that._crosshair) {
                        that._crosshair = new crosshairModule.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup)
                    } else {
                        that._crosshair.update(options, parameters)
                    }
                    that._crosshair.render()
                },
                _getCommonCanvas: function() {
                    var i, canvas, commonCanvas, panes = this.panes;
                    for (i = 0; i < panes.length; i++) {
                        canvas = panes[i].canvas;
                        if (!commonCanvas) {
                            commonCanvas = _extend({}, canvas)
                        } else {
                            commonCanvas.right = canvas.right;
                            commonCanvas.bottom = canvas.bottom
                        }
                    }
                    return commonCanvas
                },
                _createPanesBackground: function() {
                    var backgroundColor, rect, i, that = this,
                        defaultBackgroundColor = that._themeManager.getOptions("commonPaneSettings").backgroundColor,
                        renderer = that._renderer,
                        rects = [];
                    that._panesBackgroundGroup.clear();
                    for (i = 0; i < that.panes.length; i++) {
                        backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;
                        if (!backgroundColor || "none" === backgroundColor) {
                            rects.push(null);
                            continue
                        }
                        rect = renderer.rect(0, 0, 0, 0).attr({
                            fill: backgroundColor,
                            "stroke-width": 0
                        }).append(that._panesBackgroundGroup);
                        rects.push(rect)
                    }
                    that.panesBackground = rects
                },
                _fillPanesBackground: function() {
                    var bc, that = this;
                    _each(that.panes, function(i, pane) {
                        bc = pane.borderCoords;
                        if (null !== that.panesBackground[i]) {
                            that.panesBackground[i].attr({
                                x: bc.left,
                                y: bc.top,
                                width: bc.width,
                                height: bc.height
                            })
                        }
                    })
                },
                _calcPaneBorderCoords: function(pane) {
                    var canvas = pane.canvas,
                        bc = pane.borderCoords = pane.borderCoords || {};
                    bc.left = canvas.left;
                    bc.top = canvas.top;
                    bc.right = canvas.width - canvas.right;
                    bc.bottom = canvas.height - canvas.bottom;
                    bc.width = Math.max(bc.right - bc.left, 0);
                    bc.height = Math.max(bc.bottom - bc.top, 0)
                },
                _drawPanesBorders: function(panesBorderOptions) {
                    var that = this,
                        rotated = that._isRotated();
                    that._panesBorderGroup.linkRemove().clear();
                    _each(that.panes, function(i, pane) {
                        var bc, segmentRectParams, borderOptions = panesBorderOptions[pane.name],
                            attr = {
                                fill: "none",
                                stroke: borderOptions.color,
                                "stroke-opacity": borderOptions.opacity,
                                "stroke-width": borderOptions.width,
                                dashStyle: borderOptions.dashStyle,
                                "stroke-linecap": "square"
                            };
                        that._calcPaneBorderCoords(pane, rotated);
                        if (!borderOptions.visible) {
                            return
                        }
                        bc = pane.borderCoords;
                        segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);
                        that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup)
                    });
                    that._panesBorderGroup.linkAppend()
                },
                _createClipRect: function(clipArray, index, left, top, width, height) {
                    var that = this,
                        clipRect = clipArray[index];
                    if (!clipRect) {
                        clipRect = that._renderer.clipRect(left, top, width, height);
                        clipArray[index] = clipRect
                    } else {
                        clipRect.attr({
                            x: left,
                            y: top,
                            width: width,
                            height: height
                        })
                    }
                },
                _createClipRectsForPanes: function() {
                    var that = this,
                        canvas = that._canvas;
                    _each(that.panes, function(i, pane) {
                        var needWideClipRect = false,
                            bc = pane.borderCoords,
                            left = bc.left,
                            top = bc.top,
                            width = bc.width,
                            height = bc.height,
                            panesClipRects = that._panesClipRects;
                        that._createClipRect(panesClipRects.fixed, i, left, top, width, height);
                        that._createClipRect(panesClipRects.base, i, left, top, width, height);
                        _each(that.series, function(_, series) {
                            if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
                                needWideClipRect = true
                            }
                        });
                        if (needWideClipRect) {
                            if (that._isRotated()) {
                                top = 0;
                                height = canvas.height
                            } else {
                                left = 0;
                                width = canvas.width
                            }
                            that._createClipRect(panesClipRects.wide, i, left, top, width, height)
                        } else {
                            panesClipRects.wide.push(null)
                        }
                    })
                },
                _getPaneIndex: function(paneName) {
                    var paneIndex;
                    _each(this.panes, function(index, pane) {
                        if (pane.name === paneName) {
                            paneIndex = index;
                            return false
                        }
                    });
                    return paneIndex
                },
                _getPaneBorderVisibility: function(paneIndex) {
                    var commonPaneBorderVisible = this._themeManager.getOptions("commonPaneSettings").border.visible,
                        pane = this.panes[paneIndex] || {},
                        paneBorder = pane.border || {};
                    return "visible" in paneBorder ? paneBorder.visible : commonPaneBorderVisible
                },
                _getElementsClipRectID: function(paneName) {
                    return this._panesClipRects.fixed[this._getPaneIndex(paneName)].id
                },
                _getTranslator: function(paneName, axisName) {
                    var paneTrans = this.translators[paneName],
                        foundTranslator = null;
                    if (!paneTrans) {
                        return foundTranslator
                    }
                    foundTranslator = paneTrans[axisName];
                    if (!foundTranslator) {
                        _each(paneTrans, function(axis, trans) {
                            foundTranslator = trans;
                            return false
                        });
                        foundTranslator = _extend({
                            axesTrans: paneTrans
                        }, foundTranslator)
                    }
                    return foundTranslator
                },
                _getCanvasForPane: function(paneName) {
                    var i, panes = this.panes,
                        panesNumber = panes.length;
                    for (i = 0; i < panesNumber; i++) {
                        if (panes[i].name === paneName) {
                            return panes[i].canvas
                        }
                    }
                },
                _getBusinessRange: function(paneName, axisName) {
                    var foundRange, i, ranges = this.businessRanges || [],
                        rangesNumber = ranges.length;
                    for (i = 0; i < rangesNumber; i++) {
                        if (ranges[i].val.pane === paneName && ranges[i].val.axis === axisName) {
                            foundRange = ranges[i];
                            break
                        }
                    }
                    if (!foundRange) {
                        for (i = 0; i < rangesNumber; i++) {
                            if (ranges[i].val.pane === paneName) {
                                foundRange = ranges[i];
                                break
                            }
                        }
                    }
                    return foundRange
                },
                _transformArgument: function(translate, scale) {
                    var settings, clipSettings, that = this,
                        rotated = that._isRotated(),
                        panesClipRects = that._panesClipRects;
                    if (!that._transformed) {
                        that._transformed = true;
                        that._labelsGroup.remove();
                        that._resetIsReady();
                        _each(that.series || [], function(i, s) {
                            s.applyClip()
                        })
                    }
                    if (rotated) {
                        settings = {
                            translateY: translate,
                            scaleY: scale
                        };
                        clipSettings = {
                            translateY: -translate / scale,
                            scaleY: 1 / scale
                        }
                    } else {
                        settings = {
                            translateX: translate,
                            scaleX: scale
                        };
                        clipSettings = {
                            translateX: -translate / scale,
                            scaleX: 1 / scale
                        }
                    }
                    applyClipSettings(panesClipRects.base, clipSettings);
                    applyClipSettings(panesClipRects.wide, clipSettings);
                    that._seriesGroup.attr(settings);
                    that._scrollBar && that._scrollBar.transform(-translate, scale)
                },
                _resetTransform: function() {
                    var that = this,
                        settings = {
                            translateX: 0,
                            translateY: 0,
                            scaleX: null,
                            scaleY: null
                        },
                        panesClipRects = that._panesClipRects;
                    applyClipSettings(panesClipRects.base, settings);
                    applyClipSettings(panesClipRects.wide, settings);
                    that._seriesGroup.attr(settings);
                    _each(that.series || [], function(i, s) {
                        s.resetClip()
                    });
                    that._transformed = false
                },
                _getTrackerSettings: function() {
                    var that = this,
                        themeManager = that._themeManager;
                    return _extend(this.callBase(), {
                        chart: that,
                        zoomingMode: themeManager.getOptions("zoomingMode"),
                        scrollingMode: themeManager.getOptions("scrollingMode"),
                        rotated: that._isRotated(),
                        crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null
                    })
                },
                _resolveLabelOverlappingStack: function() {
                    var that = this,
                        isRotated = that._isRotated(),
                        shiftDirection = isRotated ? function(box, length) {
                            return {
                                x: box.x - length,
                                y: box.y
                            }
                        } : function(box, length) {
                            return {
                                x: box.x,
                                y: box.y - length
                            }
                        };
                    _each(that.seriesFamilies, function(_, family) {
                        _each(family.getStackPoints(), function(_, stacks) {
                            _each(stacks, function(_, points) {
                                overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, shiftDirection)
                            })
                        })
                    })
                },
                _getCrosshairOptions: function() {
                    return this._getOption("crosshair")
                },
                zoomArgument: function(min, max, gesturesUsed) {
                    var zoomArg, that = this;
                    if (!_isDefined(min) && !_isDefined(max)) {
                        return
                    }
                    zoomArg = that._argumentAxes[0].zoom(min, max, gesturesUsed);
                    that._zoomMinArg = zoomArg.min;
                    that._zoomMaxArg = zoomArg.max;
                    that._notApplyMargins = gesturesUsed;
                    that._doRender({
                        force: true,
                        drawTitle: false,
                        drawLegend: false,
                        adjustAxes: false,
                        animate: false
                    })
                },
                _resetZoom: function() {
                    var that = this;
                    that._zoomMinArg = that._zoomMaxArg = void 0;
                    that._argumentAxes[0] && that._argumentAxes[0].resetZoom()
                },
                getVisibleArgumentBounds: function() {
                    var range = this._argumentAxes[0].getTranslator().getBusinessRange(),
                        isDiscrete = "discrete" === range.axisType,
                        categories = range.categories;
                    return {
                        minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
                        maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
                    }
                }
            });
            registerComponent("dxChart", dxChart);
            module.exports = dxChart;
            module.exports._test_prepareSegmentRectPoints = function() {
                var original = prepareSegmentRectPoints.original || prepareSegmentRectPoints;
                if (arguments[0]) {
                    prepareSegmentRectPoints = arguments[0]
                }
                prepareSegmentRectPoints.original = original;
                prepareSegmentRectPoints.restore = function() {
                    prepareSegmentRectPoints = original
                };
                return prepareSegmentRectPoints
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/chart_components/crosshair.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                math = Math,
                mathAbs = math.abs,
                mathMin = math.min,
                mathMax = math.max,
                mathFloor = math.floor,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                HORIZONTAL = "horizontal",
                VERTICAL = "vertical",
                LABEL_BACKGROUND_PADDING_X = 8,
                LABEL_BACKGROUND_PADDING_Y = 4,
                CENTER = "center",
                RIGHT = "right",
                LEFT = "left",
                TOP = "top",
                BOTTOM = "bottom";

            function Crosshair(renderer, options, params, group) {
                var that = this;
                that._renderer = renderer;
                that._crosshairGroup = group;
                that._options = {};
                that.update(options, params)
            }
            Crosshair.prototype = {
                constructor: Crosshair,
                update: function(options, params) {
                    var that = this,
                        canvas = params.canvas;
                    that._canvas = {
                        top: canvas.top,
                        bottom: canvas.height - canvas.bottom,
                        left: canvas.left,
                        right: canvas.width - canvas.right,
                        width: canvas.width,
                        height: canvas.height
                    };
                    that._axes = params.axes;
                    that._panes = params.panes;
                    that._prepareOptions(options, HORIZONTAL);
                    that._prepareOptions(options, VERTICAL)
                },
                dispose: function() {
                    var that = this;
                    that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null
                },
                _prepareOptions: function(options, direction) {
                    var lineOptions = options[direction + "Line"];
                    this._options[direction] = {
                        visible: lineOptions.visible,
                        line: {
                            stroke: lineOptions.color || options.color,
                            "stroke-width": lineOptions.width || options.width,
                            dashStyle: lineOptions.dashStyle || options.dashStyle,
                            opacity: lineOptions.opacity || options.opacity,
                            "stroke-linecap": "butt"
                        },
                        label: $.extend(true, {}, options.label, lineOptions.label)
                    }
                },
                _createLines: function(options, sharpParam, group) {
                    var lines = [],
                        canvas = this._canvas,
                        points = [canvas.left, canvas.top, canvas.left, canvas.top];
                    for (var i = 0; i < 2; i++) {
                        lines.push(this._renderer.path(points, "line").attr(options).sharp(sharpParam).append(group))
                    }
                    return lines
                },
                render: function() {
                    var that = this,
                        renderer = that._renderer,
                        options = that._options,
                        verticalOptions = options.vertical,
                        horizontalOptions = options.horizontal,
                        extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line,
                        circleOptions = {
                            stroke: extraOptions.stroke,
                            "stroke-width": extraOptions["stroke-width"],
                            dashStyle: extraOptions.dashStyle,
                            opacity: extraOptions.opacity
                        },
                        canvas = that._canvas;
                    that._horizontal = {};
                    that._vertical = {};
                    that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
                    that._horizontalGroup = renderer.g().append(that._crosshairGroup);
                    that._verticalGroup = renderer.g().append(that._crosshairGroup);
                    if (verticalOptions.visible) {
                        that._vertical.lines = that._createLines(verticalOptions.line, "h", that._verticalGroup);
                        that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup)
                    }
                    if (horizontalOptions.visible) {
                        that._horizontal.lines = that._createLines(horizontalOptions.line, "v", that._horizontalGroup);
                        that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup)
                    }
                    that.hide()
                },
                _createLabels: function(axes, options, isHorizontal, group) {
                    var x, y, text, background, currentLabelPos, bbox, that = this,
                        canvas = that._canvas,
                        renderer = that._renderer,
                        labels = [],
                        labelOptions = options.label;
                    if (!labelOptions || !labelOptions.visible) {
                        return
                    }
                    $.each(axes, function(_, axis) {
                        var align, position = axis.getOptions().position;
                        if (axis.getTranslator().getBusinessRange().stubData) {
                            return
                        }
                        currentLabelPos = axis.getLabelsParams().pos;
                        if (isHorizontal) {
                            y = canvas.top;
                            x = currentLabelPos
                        } else {
                            x = canvas.left;
                            y = currentLabelPos
                        }
                        align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
                        background = renderer.rect(0, 0, 0, 0).attr({
                            fill: labelOptions.backgroundColor || options.line.stroke
                        }).append(group);
                        text = renderer.text("0", x, y).css(vizUtils.patchFontOptions(options.label.font)).attr({
                            align: align
                        }).append(group);
                        bbox = text.getBBox();
                        text.attr({
                            y: isHorizontal ? 2 * y - bbox.y - bbox.height / 2 : position === BOTTOM ? 2 * y - bbox.y : 2 * y - (bbox.y + bbox.height)
                        });
                        labels.push({
                            text: text,
                            background: background,
                            axis: axis,
                            options: labelOptions,
                            pos: {
                                coord: currentLabelPos,
                                side: position,
                                align: align
                            }
                        })
                    });
                    return labels
                },
                _updateText: function(value, labels, axisName, point, isHorizontalLine) {
                    var bbox, text, textElement, backgroundElement, axisLabelsParams, labelSide, that = this;
                    if (!labels) {
                        return
                    }
                    $.each(labels, function(i, label) {
                        var axis = label.axis;
                        text = "";
                        textElement = label.text;
                        backgroundElement = label.background;
                        if (!textElement) {
                            return
                        }
                        if (!axis.name || axis.name === axisName) {
                            text = axis.getFormattedValue(value, label.options, point)
                        }
                        if (text) {
                            textElement.attr({
                                text: text
                            });
                            bbox = textElement.getBBox();
                            axisLabelsParams = axis.getLabelsParams();
                            labelSide = label.pos.side;
                            if (isHorizontalLine) {
                                if (axisLabelsParams.width < bbox.width) {
                                    textElement.attr({
                                        align: labelSide,
                                        x: axisLabelsParams.pos + (labelSide === LEFT ? -1 : 1) * axisLabelsParams.width
                                    })
                                } else {
                                    textElement.attr({
                                        align: label.pos.align,
                                        x: axisLabelsParams.pos
                                    })
                                }
                                bbox = textElement.getBBox()
                            }
                            that._updateLinesCanvas(labelSide, label.pos.coord);
                            backgroundElement.attr({
                                x: bbox.x - LABEL_BACKGROUND_PADDING_X,
                                y: bbox.y - LABEL_BACKGROUND_PADDING_Y,
                                width: bbox.width + 2 * LABEL_BACKGROUND_PADDING_X,
                                height: bbox.height + 2 * LABEL_BACKGROUND_PADDING_Y
                            })
                        } else {
                            textElement.attr({
                                text: ""
                            });
                            backgroundElement.attr({
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            })
                        }
                    })
                },
                hide: function() {
                    this._crosshairGroup.attr({
                        visibility: "hidden"
                    })
                },
                _updateLinesCanvas: function(position, labelPosition) {
                    var coords = this._linesCanvas,
                        canvas = this._canvas;
                    coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelPosition - canvas[position]) ? coords[position] : labelPosition
                },
                _updateLines: function(lines, x, y, r, isHorizontal) {
                    var coords = this._linesCanvas,
                        canvas = this._canvas,
                        points = isHorizontal ? [
                            [mathMin(x - r, coords.left), canvas.top, x - r, canvas.top],
                            [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]
                        ] : [
                            [canvas.left, mathMin(coords.top, y - r), canvas.left, y - r],
                            [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]
                        ];
                    for (var i = 0; i < 2; i++) {
                        lines[i].attr({
                            points: points[i]
                        })
                    }
                },
                _resetLinesCanvas: function() {
                    var canvas = this._canvas;
                    this._linesCanvas = {
                        left: canvas.left,
                        right: canvas.right,
                        top: canvas.top,
                        bottom: canvas.bottom
                    }
                },
                _getClipRectForPane: function(x, y) {
                    var i, coords, panes = this._panes;
                    for (i = 0; i < panes.length; i++) {
                        coords = panes[i].coords;
                        if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
                            return panes[i].clipRect
                        }
                    }
                    return {
                        id: null
                    }
                },
                show: function(data) {
                    var clipRect, that = this,
                        point = data.point,
                        pointData = point.getCrosshairData(data.x, data.y),
                        r = point.getPointRadius(),
                        horizontal = that._horizontal,
                        vertical = that._vertical,
                        rad = !r ? 0 : r + 3,
                        canvas = that._canvas,
                        x = mathFloor(pointData.x),
                        y = mathFloor(pointData.y);
                    if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
                        that._crosshairGroup.attr({
                            visibility: "visible"
                        });
                        that._resetLinesCanvas();
                        clipRect = that._getClipRectForPane(x, y);
                        that._circle.attr({
                            cx: x,
                            cy: y,
                            r: rad,
                            clipId: clipRect.id
                        });
                        if (horizontal.lines) {
                            that._updateText(pointData.yValue, horizontal.labels, pointData.axis, point, true);
                            that._updateLines(horizontal.lines, x, y, rad, true);
                            that._horizontalGroup.attr({
                                translateY: y - canvas.top
                            })
                        }
                        if (vertical.lines) {
                            that._updateText(pointData.xValue, vertical.labels, pointData.axis, point, false);
                            that._updateLines(vertical.lines, x, y, rad, false);
                            that._verticalGroup.attr({
                                translateX: x - canvas.left
                            })
                        }
                    } else {
                        that.hide()
                    }
                }
            };
            exports.Crosshair = Crosshair
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/chart_components/header_block.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                LayoutElementModule = __webpack_require__( /*! ../core/layout_element */ 190),
                _extend = $.extend,
                _each = $.each;

            function HeaderBlock(elements) {}
            _extend(HeaderBlock.prototype, LayoutElementModule.LayoutElement.prototype, {
                update: function(elements, canvas) {
                    this._elements = $.map(elements, function(element) {
                        return element.getLayoutOptions() ? element : null
                    });
                    this._canvas = canvas
                },
                dispose: function() {
                    this._elements = null
                },
                measure: function(size) {
                    var result, that = this,
                        layoutOptions = that.getLayoutOptions();
                    if (layoutOptions) {
                        result = {
                            size: [layoutOptions.width, layoutOptions.height],
                            alignment: [layoutOptions.horizontalAlignment, layoutOptions.verticalAlignment],
                            side: 1
                        };
                        _each(that._elements, function(_, elem) {
                            elem.draw(layoutOptions.width, layoutOptions.height, that._canvas)
                        })
                    }
                    return result || null
                },
                getLayoutOptions: function() {
                    var firstElement, layout, elementLayout, that = this,
                        elements = that._elements,
                        length = elements.length,
                        i = 1;
                    if (!length) {
                        return null
                    }
                    firstElement = elements[0];
                    layout = _extend(true, {}, firstElement.getLayoutOptions());
                    layout.position = {};
                    for (i; i < length; i++) {
                        elementLayout = elements[i].getLayoutOptions();
                        if (elementLayout.height > layout.height) {
                            layout.height = elementLayout.height
                        }
                        if (elementLayout.width > layout.width) {
                            layout.width = elementLayout.width
                        }
                        if (elementLayout.position) {
                            layout.position = elementLayout.position;
                            layout.verticalAlignment = elementLayout.position.vertical;
                            layout.horizontalAlignment = elementLayout.position.horizontal
                        }
                    }
                    return layout
                },
                probeDraw: function(width, height) {
                    _each(this._elements, function(_, elem) {
                        elem.probeDraw(width, height)
                    })
                },
                draw: function(width, height) {
                    var that = this;
                    _each(this._elements, function(_, elem) {
                        elem.draw(width, height, that._canvas)
                    })
                },
                shift: function(x, y) {
                    _each(this._elements, function(_, elem) {
                        elem.shift(x, y)
                    })
                }
            });
            exports.HeaderBlock = HeaderBlock
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************************!*\
      !*** ./Scripts/viz/chart_components/multi_axes_synchronizer.js ***!
      \*****************************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug,
                Range = __webpack_require__( /*! ../translators/range */ 89).Range,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _adjustValue = vizUtils.adjustValue,
                _applyPrecisionByMinDelta = vizUtils.applyPrecisionByMinDelta,
                _isDefined = commonUtils.isDefined,
                _math = Math,
                _floor = _math.floor,
                _max = _math.max,
                _abs = _math.abs,
                _each = $.each,
                _map = __webpack_require__( /*! ../core/utils */ 6).map,
                MIN_RANGE_FOR_ADJUST_BOUNDS = .1;
            var getValueAxesPerPanes = function(valueAxes) {
                var result = {};
                _each(valueAxes, function(_, axis) {
                    var pane = axis.pane;
                    if (!result[pane]) {
                        result[pane] = []
                    }
                    result[pane].push(axis)
                });
                return result
            };
            var restoreOriginalBusinessRange = function(axis) {
                var businessRange, translator = axis.getTranslator();
                if (!translator._originalBusinessRange) {
                    translator._originalBusinessRange = new Range(translator.getBusinessRange())
                } else {
                    businessRange = new Range(translator._originalBusinessRange);
                    translator.updateBusinessRange(businessRange)
                }
            };
            var linearConverter = {
                transform: function(v, b) {
                    return vizUtils.getLog(v, b)
                },
                addInterval: function(v, i) {
                    return v + i
                },
                getInterval: function(base, tickInterval) {
                    return tickInterval
                },
                adjustValue: _floor
            };
            var logConverter = {
                transform: function(v, b) {
                    return vizUtils.raiseTo(v, b)
                },
                addInterval: function(v, i) {
                    return v * i
                },
                getInterval: function(base, tickInterval) {
                    return _math.pow(base, tickInterval)
                },
                adjustValue: _adjustValue
            };
            var convertAxisInfo = function(axisInfo, converter) {
                if (!axisInfo.isLogarithmic) {
                    return
                }
                var tick, interval, i, base = axisInfo.logarithmicBase,
                    tickValues = axisInfo.tickValues,
                    ticks = [];
                axisInfo.minValue = converter.transform(axisInfo.minValue, base);
                axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
                axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
                axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
                axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
                if (axisInfo.tickInterval < 1) {
                    axisInfo.tickInterval = 1
                }
                interval = converter.getInterval(base, axisInfo.tickInterval);
                tick = converter.transform(tickValues[0], base);
                for (i = 0; i < tickValues.length; i++) {
                    ticks.push(converter.adjustValue(tick));
                    tick = converter.addInterval(tick, interval)
                }
                ticks.tickInterval = axisInfo.tickInterval;
                axisInfo.tickValues = ticks
            };
            var populateAxesInfo = function(axes) {
                return _map(axes, function(axis) {
                    restoreOriginalBusinessRange(axis);
                    var minValue, maxValue, businessRange, tickInterval, synchronizedValue, ticksValues = axis.getTicksValues(),
                        majorTicks = ticksValues.majorTicksValues,
                        options = axis.getOptions(),
                        axisInfo = null;
                    if (majorTicks && majorTicks.length > 0 && commonUtils.isNumber(majorTicks[0]) && "discrete" !== options.type) {
                        businessRange = axis.getTranslator().getBusinessRange();
                        tickInterval = axis._tickManager.getTickInterval();
                        minValue = businessRange.minVisible;
                        maxValue = businessRange.maxVisible;
                        synchronizedValue = options.synchronizedValue;
                        if (minValue === maxValue && _isDefined(synchronizedValue)) {
                            tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
                            minValue = majorTicks[0] - tickInterval;
                            maxValue = majorTicks[0] + tickInterval
                        }
                        axisInfo = {
                            axis: axis,
                            isLogarithmic: "logarithmic" === options.type,
                            logarithmicBase: businessRange.base,
                            tickValues: majorTicks,
                            minorValues: ticksValues.minorTicksValues,
                            minValue: minValue,
                            oldMinValue: minValue,
                            maxValue: maxValue,
                            oldMaxValue: maxValue,
                            inverted: businessRange.invert,
                            tickInterval: tickInterval,
                            synchronizedValue: synchronizedValue
                        };
                        if (businessRange.stubData) {
                            axisInfo.stubData = true;
                            axisInfo.tickInterval = axisInfo.tickInterval || options.tickInterval;
                            axisInfo.isLogarithmic = false
                        }
                        convertAxisInfo(axisInfo, linearConverter);
                        debug.assert(void 0 !== axisInfo.tickInterval && null !== axisInfo.tickInterval, "tickInterval was not provided")
                    }
                    return axisInfo
                })
            };
            var updateTickValues = function(axesInfo) {
                var maxTicksCount = 0;
                _each(axesInfo, function(_, axisInfo) {
                    maxTicksCount = _max(maxTicksCount, axisInfo.tickValues.length)
                });
                _each(axesInfo, function(_, axisInfo) {
                    var ticksMultiplier, ticksCount, additionalStartTicksCount = 0,
                        synchronizedValue = axisInfo.synchronizedValue,
                        tickValues = axisInfo.tickValues,
                        tickInterval = axisInfo.tickInterval;
                    if (_isDefined(synchronizedValue)) {
                        axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
                        axisInfo.tickValues = [axisInfo.baseTickValue]
                    } else {
                        if (tickValues.length > 1 && tickInterval) {
                            ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
                            ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
                            additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
                            while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {
                                tickValues.unshift(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[0] - tickInterval));
                                additionalStartTicksCount--
                            }
                            while (tickValues.length < ticksCount) {
                                tickValues.push(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[tickValues.length - 1] + tickInterval))
                            }
                            axisInfo.tickInterval = tickInterval / ticksMultiplier
                        }
                        axisInfo.baseTickValue = tickValues[0];
                        axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]
                    }
                })
            };
            var getAxisRange = function(axisInfo) {
                return axisInfo.maxValue - axisInfo.minValue || 1
            };
            var getMainAxisInfo = function(axesInfo) {
                for (var i = 0; i < axesInfo.length; i++) {
                    if (!axesInfo[i].stubData) {
                        return axesInfo[i]
                    }
                }
                return null
            };
            var correctMinMaxValues = function(axesInfo) {
                var mainAxisInfo = getMainAxisInfo(axesInfo),
                    mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
                _each(axesInfo, function(_, axisInfo) {
                    var scale, move, mainAxisBaseValueOffset, valueFromAxisInfo;
                    if (axisInfo !== mainAxisInfo) {
                        if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
                            if (axisInfo.stubData && _isDefined(axisInfo.synchronizedValue)) {
                                axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
                                axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval
                            }
                            scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
                            axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale
                        }
                        if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
                            mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue
                        } else {
                            mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue
                        }
                        valueFromAxisInfo = getAxisRange(axisInfo);
                        move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
                        axisInfo.minValue -= move;
                        axisInfo.maxValue -= move
                    }
                })
            };
            var calculatePaddings = function(axesInfo) {
                var minPadding, maxPadding, startPadding = 0,
                    endPadding = 0;
                _each(axesInfo, function(_, axisInfo) {
                    var inverted = axisInfo.inverted;
                    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
                    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
                    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
                    endPadding = _max(endPadding, inverted ? minPadding : maxPadding)
                });
                return {
                    start: startPadding,
                    end: endPadding
                }
            };
            var correctMinMaxValuesByPaddings = function(axesInfo, paddings) {
                _each(axesInfo, function(_, info) {
                    var range = getAxisRange(info),
                        inverted = info.inverted;
                    info.minValue -= paddings[inverted ? "end" : "start"] * range;
                    info.maxValue += paddings[inverted ? "start" : "end"] * range;
                    if (range > MIN_RANGE_FOR_ADJUST_BOUNDS) {
                        info.minValue = _math.min(info.minValue, _adjustValue(info.minValue));
                        info.maxValue = _max(info.maxValue, _adjustValue(info.maxValue))
                    }
                })
            };
            var updateTickValuesIfSynchronizedValueUsed = function(axesInfo) {
                var hasSynchronizedValue = false;
                _each(axesInfo, function(_, info) {
                    hasSynchronizedValue = hasSynchronizedValue || _isDefined(info.synchronizedValue)
                });
                _each(axesInfo, function(_, info) {
                    var lastTickValue, tickInterval = info.tickInterval,
                        tickValues = info.tickValues,
                        maxValue = info.maxValue,
                        minValue = info.minValue;
                    if (hasSynchronizedValue && tickInterval) {
                        while (tickValues[0] - tickInterval >= minValue) {
                            tickValues.unshift(_adjustValue(tickValues[0] - tickInterval))
                        }
                        lastTickValue = tickValues[tickValues.length - 1];
                        while ((lastTickValue += tickInterval) <= maxValue) {
                            tickValues.push(commonUtils.isExponential(lastTickValue) ? _adjustValue(lastTickValue) : _applyPrecisionByMinDelta(minValue, tickInterval, lastTickValue))
                        }
                    }
                    while (tickValues[0] < minValue) {
                        tickValues.shift()
                    }
                    while (tickValues[tickValues.length - 1] > maxValue) {
                        tickValues.pop()
                    }
                })
            };
            var applyMinMaxValues = function(axesInfo) {
                _each(axesInfo, function(_, info) {
                    var axis = info.axis,
                        range = axis.getTranslator().getBusinessRange();
                    if (range.min === range.minVisible) {
                        range.min = info.minValue
                    }
                    if (range.max === range.maxVisible) {
                        range.max = info.maxValue
                    }
                    range.minVisible = info.minValue;
                    range.maxVisible = info.maxValue;
                    if (_isDefined(info.stubData)) {
                        range.stubData = info.stubData
                    }
                    if (range.min > range.minVisible) {
                        range.min = range.minVisible
                    }
                    if (range.max < range.maxVisible) {
                        range.max = range.maxVisible
                    }
                    range.isSynchronized = true;
                    axis.getTranslator().updateBusinessRange(range);
                    axis.setTicks({
                        majorTicks: info.tickValues,
                        minorTicks: info.minorValues
                    })
                })
            };
            var correctAfterSynchronize = function(axesInfo) {
                var correctValue, validAxisInfo, invalidAxisInfo = [];
                _each(axesInfo, function(i, info) {
                    if (info.oldMaxValue - info.oldMinValue === 0) {
                        invalidAxisInfo.push(info)
                    } else {
                        if (!_isDefined(correctValue) && !_isDefined(info.synchronizedValue)) {
                            correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] || info.maxValue));
                            validAxisInfo = info
                        }
                    }
                });
                if (!_isDefined(correctValue)) {
                    return
                }
                _each(invalidAxisInfo, function(i, info) {
                    var firstTick = info.tickValues[0],
                        correctedTick = firstTick * correctValue,
                        tickValues = validAxisInfo.tickValues,
                        centralTick = tickValues[_floor(tickValues.length / 2)];
                    if (firstTick > 0) {
                        info.maxValue = correctedTick;
                        info.minValue = 0
                    } else {
                        if (firstTick < 0) {
                            info.minValue = correctedTick;
                            info.maxValue = 0
                        } else {
                            if (0 === firstTick) {
                                info.maxValue = validAxisInfo.maxValue - centralTick;
                                info.minValue = validAxisInfo.minValue - centralTick
                            }
                        }
                    }
                })
            };
            var multiAxesSynchronizer = {
                synchronize: function(valueAxes) {
                    _each(getValueAxesPerPanes(valueAxes), function(_, axes) {
                        var axesInfo, paddings;
                        if (axes.length > 1) {
                            axesInfo = populateAxesInfo(axes);
                            if (0 === axesInfo.length || !getMainAxisInfo(axesInfo)) {
                                return
                            }
                            updateTickValues(axesInfo);
                            correctMinMaxValues(axesInfo);
                            paddings = calculatePaddings(axesInfo);
                            correctMinMaxValuesByPaddings(axesInfo, paddings);
                            correctAfterSynchronize(axesInfo);
                            updateTickValuesIfSynchronizedValueUsed(axesInfo);
                            _each(axesInfo, function() {
                                convertAxisInfo(this, logConverter)
                            });
                            applyMinMaxValues(axesInfo)
                        }
                    })
                }
            };
            module.exports = multiAxesSynchronizer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/viz/chart_components/scroll_bar.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                MIN_SCROLL_BAR_SIZE = 2,
                translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 105),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                pointerEvents = __webpack_require__( /*! ../../events/pointer */ 13),
                isDefined = commonUtils.isDefined,
                _min = Math.min,
                _max = Math.max;
            var ScrollBar = function(renderer, group) {
                this._translator = new translator2DModule.Translator2D({}, {}, {});
                this._scroll = renderer.rect().append(group);
                this._addEvents()
            };

            function _getXCoord(canvas, pos, offset, width) {
                var x = 0;
                if ("right" === pos) {
                    x = canvas.width - canvas.right + offset
                } else {
                    if ("left" === pos) {
                        x = canvas.left - offset - width
                    }
                }
                return x
            }

            function _getYCoord(canvas, pos, offset, width) {
                var y = 0;
                if ("top" === pos) {
                    y = canvas.top - offset
                } else {
                    if ("bottom" === pos) {
                        y = canvas.height - canvas.bottom + width + offset
                    }
                }
                return y
            }
            ScrollBar.prototype = {
                _addEvents: function() {
                    var that = this,
                        $scroll = $(that._scroll.element),
                        startPosX = 0,
                        startPosY = 0,
                        scrollChangeHandler = function(e) {
                            var dX = (startPosX - e.pageX) * that._scale,
                                dY = (startPosY - e.pageY) * that._scale;
                            $scroll.trigger(new $.Event("dxc-scroll-move", $.extend(e, {
                                type: "dxc-scroll-move",
                                pointers: [{
                                    pageX: startPosX + dX,
                                    pageY: startPosY + dY
                                }]
                            })))
                        };
                    $scroll.on(pointerEvents.down, function(e) {
                        startPosX = e.pageX;
                        startPosY = e.pageY;
                        $scroll.trigger(new $.Event("dxc-scroll-start", {
                            pointers: [{
                                pageX: startPosX,
                                pageY: startPosY
                            }]
                        }));
                        $(document).on(pointerEvents.move, scrollChangeHandler)
                    });
                    $(document).on(pointerEvents.up, function() {
                        $(document).off(pointerEvents.move, scrollChangeHandler)
                    })
                },
                update: function(options) {
                    var that = this,
                        position = options.position,
                        isVertical = options.rotated,
                        defaultPosition = isVertical ? "right" : "top",
                        secondaryPosition = isVertical ? "left" : "bottom";
                    if (position !== defaultPosition && position !== secondaryPosition) {
                        position = defaultPosition
                    }
                    that._scroll.attr({
                        rotate: !options.rotated ? -90 : 0,
                        rotateX: 0,
                        rotateY: 0,
                        fill: options.color,
                        width: options.width,
                        opacity: options.opacity
                    });
                    that._layoutOptions = {
                        width: options.width,
                        offset: options.offset,
                        vertical: isVertical,
                        position: position
                    };
                    return that
                },
                init: function(range, canvas) {
                    var that = this;
                    that._translateWithOffset = "discrete" === range.axisType && !range.stick && 1 || 0;
                    that._translator.update($.extend({}, range, {
                        minVisible: null,
                        maxVisible: null,
                        visibleCategories: null
                    }), $.extend({}, canvas), {
                        isHorizontal: !that._layoutOptions.vertical
                    });
                    return that
                },
                getOptions: function() {
                    return this._layoutOptions
                },
                shift: function(x, y) {
                    this._scroll.attr({
                        translateX: x,
                        translateY: y
                    })
                },
                setPane: function(panes) {
                    var pane, position = this._layoutOptions.position;
                    if ("left" === position || "top" === position) {
                        pane = panes[0]
                    } else {
                        pane = panes[panes.length - 1]
                    }
                    this.pane = pane.name;
                    this._canvas = pane.canvas;
                    return this
                },
                getMultipleAxesSpacing: function() {
                    return 0
                },
                getBoundingRect: function() {
                    var options = this._layoutOptions,
                        isVertical = options.vertical,
                        offset = options.offset,
                        width = options.width,
                        pos = options.position,
                        size = width + offset,
                        canvas = this._canvas;
                    return isVertical ? {
                        x: _getXCoord(canvas, pos, offset, width),
                        y: canvas.top,
                        width: size,
                        height: canvas.height - canvas.top - canvas.bottom
                    } : {
                        x: canvas.left,
                        y: _getYCoord(canvas, pos, offset, width),
                        width: canvas.width - canvas.left - canvas.right,
                        height: size
                    }
                },
                applyLayout: function() {
                    var canvas = this._canvas,
                        options = this._layoutOptions,
                        pos = options.position,
                        offset = options.offset,
                        width = options.width;
                    this.shift(_getXCoord(canvas, pos, offset, width), _getYCoord(canvas, pos, offset, width))
                },
                setPosition: function(min, max) {
                    var that = this,
                        translator = that._translator,
                        minPoint = isDefined(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate("canvas_position_start"),
                        maxPoint = isDefined(max) ? translator.translate(max, that._translateWithOffset) : translator.translate("canvas_position_end");
                    that._offset = _min(minPoint, maxPoint);
                    that._scale = translator.getScale(min, max);
                    that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint))
                },
                transform: function(translate, scale) {
                    var translator = this._translator,
                        x = translator.getCanvasVisibleArea().min,
                        dx = x - (x * scale - translate),
                        lx = this._offset + dx / (this._scale * scale);
                    this._applyPosition(lx, lx + translator.canvasLength / (this._scale * scale))
                },
                dispose: function() {
                    this._scroll.dispose();
                    this._scroll = this._translator = null
                },
                _applyPosition: function(x1, x2) {
                    var height, that = this,
                        visibleArea = that._translator.getCanvasVisibleArea();
                    x1 = _max(x1, visibleArea.min);
                    x1 = _min(x1, visibleArea.max);
                    x2 = _min(x2, visibleArea.max);
                    x2 = _max(x2, visibleArea.min);
                    height = Math.abs(x2 - x1);
                    that._scroll.attr({
                        y: x1,
                        height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
                    })
                }
            };
            exports.ScrollBar = ScrollBar
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/chart_components/tracker.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                clickEvent = __webpack_require__( /*! ../../events/click */ 9),
                eventsConsts = __webpack_require__( /*! ../components/consts */ 126).events,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                pointerEvents = __webpack_require__( /*! ../../events/pointer */ 13),
                wheelEvent = __webpack_require__( /*! ../../events/core/wheel */ 78),
                holdEvent = __webpack_require__( /*! ../../events/hold */ 63),
                devices = __webpack_require__( /*! ../../core/devices */ 7),
                isDefined = commonUtils.isDefined,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _floor = Math.floor,
                _each = $.each,
                _inArray = $.inArray,
                _noop = $.noop,
                MULTIPLE_MODE = "multiple",
                ALL_ARGUMENTS_POINTS_MODE = "allargumentpoints",
                ALL_SERIES_POINTS_MODE = "allseriespoints",
                NONE_MODE = "none",
                POINTER_ACTION = [pointerEvents.down, pointerEvents.move].join(" "),
                POINT_SELECTION_CHANGED = "pointSelectionChanged",
                LEGEND_CLICK = "legendClick",
                SERIES_CLICK = "seriesClick",
                POINT_CLICK = "pointClick",
                RELEASE_POINT_SELECTED_STATE = "releasePointSelectedState",
                SET_POINT_SELECTED_STATE = "setPointSelectedState",
                SET_POINT_HOVER_STATE = "setPointHoverState",
                SERIES_HOVER_CHANGED = "seriesHoverChanged",
                POINT_HOVER_CHANGED = "pointHoverChanged",
                RELEASE_POINT_HOVER_STATE = "releasePointHoverState",
                SERIES_SELECTION_CHANGED = "seriesSelectionChanged",
                POINT_DATA = "chart-data-point",
                SERIES_DATA = "chart-data-series",
                ARG_DATA = "chart-data-argument",
                DELAY = 100;

            function getData(event, dataKey) {
                var target = event.target;
                return ("tspan" === target.tagName ? target.parentNode : target)[dataKey]
            }

            function eventCanceled(event, target) {
                return event.cancel || !target.getOptions()
            }

            function inCanvas(canvas, x, y) {
                return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom
            }

            function setPointsSpecState(points, targetPoint, func, eventName, eventTrigger) {
                _each(points, function(_, currentPoint) {
                    var series = currentPoint.series;
                    if (currentPoint === targetPoint) {
                        series[func]({
                            point: currentPoint,
                            setState: true
                        });
                        eventName && eventTrigger(eventName, {
                            target: currentPoint
                        })
                    } else {
                        series[func]({
                            point: currentPoint
                        })
                    }
                })
            }

            function getArgumentPointsByIndex(storedSeries, argument, targetPointIndex) {
                var points = [];
                _each(storedSeries, function(_, series) {
                    _each(series.getPointsByArg(argument), function(_, currentPoint) {
                        if (targetPointIndex === currentPoint.index) {
                            points.push(currentPoint)
                        }
                    })
                });
                return points
            }
            var baseTrackerPrototype = {
                ctor: function(options) {
                    var that = this,
                        data = {
                            tracker: that
                        };
                    that._renderer = options.renderer;
                    that._legend = options.legend;
                    that._tooltip = options.tooltip;
                    that._eventTrigger = options.eventTrigger;
                    options.seriesGroup.off().on(eventsConsts.selectSeries, data, that._selectSeries).on(eventsConsts.deselectSeries, data, that._deselectSeries).on(eventsConsts.selectPoint, data, that._selectPoint).on(eventsConsts.deselectPoint, data, that._deselectPoint).on(eventsConsts.showPointTooltip, data, that._showPointTooltip).on(eventsConsts.hidePointTooltip, data, that._hidePointTooltip);
                    that._renderer.root.off(POINTER_ACTION).off([clickEvent.name, holdEvent.name].join(" ")).on(POINTER_ACTION, data, that._pointerHandler).on(clickEvent.name, data, that._clickHandler).on(holdEvent.name, {
                        timeout: 300
                    }, _noop)
                },
                _setSelectedPoint: _noop,
                _releaseSelectedPoint: _noop,
                _releaseSelectedSeries: _noop,
                _setSelectedSeries: _noop,
                update: function(options) {
                    var that = this;
                    if (_normalizeEnum(options.pointSelectionMode) === MULTIPLE_MODE) {
                        that._setSelectedPoint = that._selectPointMultipleMode;
                        that._releaseSelectedPoint = that._releaseSelectedPointMultipleMode
                    } else {
                        that._setSelectedPoint = that._selectPointSingleMode;
                        that._releaseSelectedPoint = that._releaseSelectedPointSingleMode
                    }
                    if (_normalizeEnum(options.seriesSelectionMode) === MULTIPLE_MODE) {
                        that._releaseSelectedSeries = that._releaseSelectedSeriesMultipleMode;
                        that._setSelectedSeries = that._setSelectedSeriesMultipleMode
                    } else {
                        that._releaseSelectedSeries = that._releaseSelectedSeriesSingleMode;
                        that._setSelectedSeries = that._setSelectedSeriesSingleMode
                    }
                    that._prepare()
                },
                updateSeries: function(series) {
                    var that = this;
                    if (that._storedSeries !== series) {
                        that._storedSeries = series || [];
                        that._clean()
                    } else {
                        that._hideTooltip(that.pointAtShownTooltip);
                        that._clearHover();
                        that.clearSelection()
                    }
                },
                setCanvases: function(mainCanvas, paneCanvases) {
                    this._mainCanvas = mainCanvas;
                    this._canvases = paneCanvases
                },
                repairTooltip: function() {
                    var point = this.pointAtShownTooltip;
                    if (point && !point.isVisible()) {
                        this._hideTooltip(point, true)
                    } else {
                        this._showTooltip(point)
                    }
                },
                _prepare: function() {
                    this._toggleParentsScrollSubscription(true)
                },
                _toggleParentsScrollSubscription: function(subscribe) {
                    var that = this,
                        $parents = $(that._renderer.root.element).parents(),
                        scrollEvents = "scroll.dxChartTracker";
                    if ("generic" === devices.real().platform) {
                        $parents = $parents.add(window)
                    }
                    $().add(that._$prevRootParents).off(scrollEvents);
                    if (subscribe) {
                        $parents.on(scrollEvents, function(e) {
                            that._pointerOut()
                        });
                        that._$prevRootParents = $parents
                    }
                },
                _selectPointMultipleMode: function(point) {
                    var that = this;
                    that._selectedPoint = that._selectedPoint || [];
                    if (_inArray(point, that._selectedPoint) < 0) {
                        that._selectedPoint.push(point);
                        that._setPointState(point, SET_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point))
                    }
                },
                _releaseSelectedPointMultipleMode: function(point) {
                    var that = this,
                        points = that._selectedPoint || [],
                        pointIndex = _inArray(point, points);
                    if (pointIndex >= 0) {
                        that._setPointState(point, RELEASE_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point));
                        points.splice(pointIndex, 1)
                    } else {
                        if (!point) {
                            _each(points, function(_, point) {
                                that._releaseSelectedPoint(point)
                            })
                        }
                    }
                },
                _selectPointSingleMode: function(point) {
                    var that = this;
                    if (that._selectedPoint !== point) {
                        that._releaseSelectedPoint();
                        that._selectedPoint = point;
                        that._setPointState(point, SET_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point))
                    }
                },
                _releaseSelectedPointSingleMode: function() {
                    var that = this,
                        point = that._selectedPoint;
                    if (point) {
                        that._setPointState(point, RELEASE_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point));
                        that._selectedPoint = null
                    }
                },
                _setHoveredPoint: function(point, mode) {
                    var that = this;
                    var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                    debug.assert(point.series, "series was not assigned to point or empty");
                    if (that.hoveredPoint === point || !point.series) {
                        return
                    }
                    that._releaseHoveredPoint();
                    if (point && point.getOptions() && mode !== NONE_MODE) {
                        that.hoveredPoint = point;
                        that._setPointState(point, SET_POINT_HOVER_STATE, mode || _normalizeEnum(point.getOptions().hoverMode), POINT_HOVER_CHANGED, that._legend.getActionCallback(point))
                    }
                },
                _releaseHoveredPoint: function() {
                    var that = this,
                        point = that.hoveredPoint,
                        eventTrigger = that._eventTrigger;
                    if (!point || !point.getOptions()) {
                        return
                    }
                    that._releasePoint(point, eventTrigger);
                    if (that._tooltip.isEnabled()) {
                        that._hideTooltip(point)
                    }
                    that.hoveredPoint = null
                },
                _setSelectedSeriesMultipleMode: function(series, mode) {
                    var that = this;
                    that._selectedSeries = that._selectedSeries || [];
                    if (_inArray(series, that._selectedSeries) < 0) {
                        that._selectedSeries.push(series);
                        series.setSelectedState(true, mode, that._legend.getActionCallback(series));
                        that._eventTrigger(SERIES_SELECTION_CHANGED, {
                            target: series
                        })
                    }
                },
                _setSelectedSeriesSingleMode: function(series, mode) {
                    var that = this;
                    if (series !== that._selectedSeries || series.lastSelectionMode !== mode) {
                        that._releaseSelectedSeries();
                        that._selectedSeries = series;
                        series.setSelectedState(true, mode, that._legend.getActionCallback(series));
                        that._eventTrigger(SERIES_SELECTION_CHANGED, {
                            target: series
                        })
                    }
                },
                _releaseSelectedSeriesMultipleMode: function(series) {
                    var that = this,
                        selectedSeries = that._selectedSeries || [],
                        seriesIndex = _inArray(series, selectedSeries);
                    if (seriesIndex >= 0) {
                        series.setSelectedState(false, void 0, that._legend.getActionCallback(series));
                        that._eventTrigger(SERIES_SELECTION_CHANGED, {
                            target: series
                        });
                        selectedSeries.splice(seriesIndex, 1)
                    } else {
                        if (!series) {
                            _each(selectedSeries, function(_, series) {
                                that._releaseSelectedSeries(series)
                            })
                        }
                    }
                },
                _releaseSelectedSeriesSingleMode: function(series) {
                    var that = this,
                        selectedSeries = that._selectedSeries;
                    if (selectedSeries && (!series || series === selectedSeries)) {
                        selectedSeries.setSelectedState(false, void 0, that._legend.getActionCallback(selectedSeries));
                        that._eventTrigger(SERIES_SELECTION_CHANGED, {
                            target: selectedSeries
                        });
                        that._selectedSeries = null
                    }
                },
                _setHoveredSeries: function(series, mode) {
                    var that = this;
                    if (mode !== NONE_MODE && that.hoveredSeries !== series || that._isModeChanged(series, mode)) {
                        that._clearHover();
                        series.setHoverState(true, mode, that._legend.getActionCallback(series));
                        that._eventTrigger(SERIES_HOVER_CHANGED, {
                            target: series
                        });
                        that.hoveredSeries = series
                    }
                },
                _releaseHoveredSeries: function(needSetHoverView, hoveredPoint) {
                    var that = this,
                        hoveredSeries = that.hoveredSeries,
                        seriesWithHoverView = that._seriesWithHoverView;
                    if (hoveredSeries) {
                        hoveredSeries.setHoverState(false, void 0, that._legend.getActionCallback(hoveredSeries));
                        if (needSetHoverView && hoveredPoint && hoveredPoint.series === hoveredSeries) {
                            that._seriesWithHoverView = hoveredSeries.setHoverView()
                        }
                        that._eventTrigger(SERIES_HOVER_CHANGED, {
                            target: hoveredSeries
                        });
                        that.hoveredSeries = null
                    } else {
                        if (seriesWithHoverView && !needSetHoverView) {
                            seriesWithHoverView.releaseHoverView();
                            that._seriesWithHoverView = null
                        }
                    }
                },
                _selectSeries: function(event, mode) {
                    event.data.tracker._setSelectedSeries(event.target, mode)
                },
                _deselectSeries: function(event, mode) {
                    event.data.tracker._releaseSelectedSeries(event.target, mode)
                },
                _selectPoint: function(event, point) {
                    event.data.tracker._setSelectedPoint(point)
                },
                _deselectPoint: function(event, point) {
                    event.data.tracker._releaseSelectedPoint(point)
                },
                clearSelection: function() {
                    this._releaseSelectedPoint();
                    this._releaseSelectedSeries()
                },
                _clean: function() {
                    var that = this;
                    that._selectedPoint = that._selectedSeries = that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = that._seriesWithHoverView = null;
                    that._hideTooltip(that.pointAtShownTooltip)
                },
                _clearHover: function() {
                    this._releaseHoveredSeries(false);
                    this._releaseHoveredPoint()
                },
                _hideTooltip: function(point, silent) {
                    var that = this;
                    if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
                        return
                    }
                    if (!silent && that.pointAtShownTooltip) {
                        that.pointAtShownTooltip = null
                    }
                    that._tooltip.hide()
                },
                _showTooltip: function(point) {
                    var tooltipFormatObject, eventData, that = this;
                    if (point && point.getOptions()) {
                        tooltipFormatObject = point.getTooltipFormatObject(that._tooltip);
                        if (!isDefined(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
                            return
                        }
                        if (!that.pointAtShownTooltip || that.pointAtShownTooltip !== point) {
                            eventData = {
                                target: point
                            }
                        }
                        var coords = point.getTooltipParams(that._tooltip.getLocation()),
                            rootOffset = that._renderer.getRootOffset();
                        coords.x += rootOffset.left;
                        coords.y += rootOffset.top;
                        if (!that._tooltip.show(tooltipFormatObject, coords, eventData)) {
                            return
                        }
                        that.pointAtShownTooltip = point
                    }
                },
                _showPointTooltip: function(event, point) {
                    var that = event.data.tracker,
                        pointWithTooltip = that.pointAtShownTooltip;
                    if (pointWithTooltip && pointWithTooltip !== point) {
                        that._hideTooltip(pointWithTooltip)
                    }
                    that._showTooltip(point)
                },
                _hidePointTooltip: function(event, point) {
                    event.data.tracker._hideTooltip(point)
                },
                _enableOutHandler: function() {
                    if (this._outHandler) {
                        return
                    }
                    var that = this,
                        handler = function(e) {
                            var rootOffset = that._renderer.getRootOffset(),
                                x = _floor(e.pageX - rootOffset.left),
                                y = _floor(e.pageY - rootOffset.top);
                            if (!inCanvas(that._mainCanvas, x, y)) {
                                that._pointerOut();
                                that._disableOutHandler()
                            }
                        };
                    $(document).on(POINTER_ACTION, handler);
                    this._outHandler = handler
                },
                _disableOutHandler: function() {
                    this._outHandler && $(document).off(POINTER_ACTION, this._outHandler);
                    this._outHandler = null
                },
                _pointerOut: function() {
                    this._clearHover();
                    this._tooltip.isEnabled() && this._hideTooltip(this.pointAtShownTooltip)
                },
                _triggerLegendClick: function(eventArgs, elementClick) {
                    var eventTrigger = this._eventTrigger;
                    eventTrigger(LEGEND_CLICK, eventArgs, function() {
                        !eventCanceled(eventArgs.jQueryEvent, eventArgs.target) && eventTrigger(elementClick, eventArgs)
                    })
                },
                _hoverLegendItem: function(x, y) {
                    var series, that = this,
                        item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        series = that._storedSeries[item.id];
                        that._setHoveredSeries(series, that._legend._options.hoverMode);
                        that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip)
                    } else {
                        that._clearHover()
                    }
                },
                _pointerHandler: function(e) {
                    var that = e.data.tracker,
                        rootOffset = that._renderer.getRootOffset(),
                        x = _floor(e.pageX - rootOffset.left),
                        y = _floor(e.pageY - rootOffset.top),
                        canvas = that._getCanvas(x, y),
                        series = getData(e, SERIES_DATA),
                        point = getData(e, POINT_DATA) || series && series.getPointByCoord(x, y);
                    that._enableOutHandler();
                    if (that._checkGestureEvents(e, canvas, rootOffset)) {
                        return
                    }
                    if (that._legend.coordsIn(x, y)) {
                        that._hoverLegendItem(x, y);
                        return
                    }
                    if (that.hoveredSeries && that.hoveredSeries !== that._stickedSeries) {
                        that._releaseHoveredSeries()
                    }
                    if (that._hoverArgumentAxis(x, y, e)) {
                        return
                    }
                    if (that._isPointerOut(canvas, point)) {
                        that._pointerOut()
                    }
                    if (!canvas && !point) {
                        return
                    }
                    if (series && !point) {
                        point = series.getNeighborPoint(x, y);
                        if (series !== that.hoveredSeries) {
                            that._setTimeout(function() {
                                that._setHoveredSeries(series, series.getOptions().hoverMode);
                                that._stickedSeries = series;
                                that._pointerComplete(point, x, y)
                            }, series);
                            return
                        }
                    } else {
                        if (point) {
                            if (that.hoveredSeries) {
                                that._setTimeout(function() {
                                    that._pointerOnPoint(point, x, y)
                                }, point)
                            } else {
                                that._pointerOnPoint(point, x, y);
                                that._setSeriesWithHoverView(point)
                            }
                            return
                        } else {
                            if (that._setStickedSeries(x, y)) {
                                series = that._stickedSeries;
                                point = series.getNeighborPoint(x, y);
                                that._releaseHoveredSeries();
                                point && that._setHoveredPoint(point)
                            }
                        }
                    }
                    that._pointerComplete(point, x, y)
                },
                _pointerOnPoint: function(point, x, y) {
                    this._setHoveredPoint(point);
                    this._pointerComplete(point, x, y)
                },
                _pointerComplete: function(point) {
                    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point)
                },
                _clickHandler: function(e) {
                    var that = e.data.tracker,
                        rootOffset = that._renderer.getRootOffset(),
                        x = _floor(e.pageX - rootOffset.left),
                        y = _floor(e.pageY - rootOffset.top),
                        point = getData(e, POINT_DATA),
                        series = that._stickedSeries || getData(e, SERIES_DATA) || point && point.series,
                        axis = that._argumentAxis;
                    if (that._legend.coordsIn(x, y)) {
                        var item = that._legend.getItemByCoord(x, y);
                        if (item) {
                            that._legendClick(item, e)
                        }
                    } else {
                        if (axis && axis.coordsIn(x, y)) {
                            var argument = getData(e, ARG_DATA);
                            if (isDefined(argument)) {
                                that._eventTrigger("argumentAxisClick", {
                                    argument: argument,
                                    jQueryEvent: e
                                })
                            }
                        } else {
                            if (series) {
                                point = point || series.getPointByCoord(x, y);
                                if (point) {
                                    that._pointClick(point, e)
                                } else {
                                    getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
                                        target: series,
                                        jQueryEvent: e
                                    })
                                }
                            }
                        }
                    }
                },
                dispose: function() {
                    var that = this;
                    that._disableOutHandler();
                    that._toggleParentsScrollSubscription();
                    _each(that, function(k) {
                        that[k] = null
                    })
                }
            };
            var ChartTracker = function(options) {
                this.ctor(options)
            };
            $.extend(ChartTracker.prototype, baseTrackerPrototype, {
                _pointClick: function(point, event) {
                    var that = this,
                        eventTrigger = that._eventTrigger,
                        series = point.series;
                    eventTrigger(POINT_CLICK, {
                        target: point,
                        jQueryEvent: event
                    }, function() {
                        !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {
                            target: series,
                            jQueryEvent: event
                        })
                    })
                },
                __trackerDelay: DELAY,
                update: function(options) {
                    var that = this;
                    that._zoomingMode = _normalizeEnum(options.zoomingMode);
                    that._scrollingMode = _normalizeEnum(options.scrollingMode);
                    baseTrackerPrototype.update.call(this, options);
                    that._argumentAxis = options.argumentAxis || {};
                    that._axisHoverEnabled = that._argumentAxis && _normalizeEnum(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENTS_POINTS_MODE;
                    that._chart = options.chart;
                    that._rotated = options.rotated;
                    that._crosshair = options.crosshair
                },
                _getCanvas: function(x, y) {
                    var that = this,
                        canvases = that._canvases || [];
                    for (var i = 0; i < canvases.length; i++) {
                        var c = canvases[i];
                        if (inCanvas(c, x, y)) {
                            return c
                        }
                    }
                    return null
                },
                _getPointSeries: function(point) {
                    return point.series
                },
                _isModeChanged: function(series, mode) {
                    return series.lastHoverMode !== mode
                },
                _isPointerOut: function(canvas) {
                    return !canvas && this._stickedSeries
                },
                _resetHoveredArgument: function() {
                    if (isDefined(this.hoveredArgument)) {
                        this._toAllArgumentPoints(this.hoveredArgument, RELEASE_POINT_HOVER_STATE);
                        this.hoveredArgument = null
                    }
                },
                _toAllArgumentPoints: function(argument, func, eventName, targetPoint) {
                    var that = this;
                    _each(that._storedSeries, function(_, series) {
                        setPointsSpecState(series.getPointsByArg(argument), targetPoint, func, eventName, that._eventTrigger)
                    })
                },
                _hideCrosshair: function() {
                    this._crosshair && this._crosshair.hide()
                },
                _moveCrosshair: function(point, x, y) {
                    if (point && this._crosshair && point.isVisible()) {
                        this._crosshair.show({
                            point: point,
                            x: x,
                            y: y
                        })
                    }
                },
                _releasePoint: function(point, eventTrigger) {
                    var that = this,
                        mode = _normalizeEnum(point.getOptions().hoverMode);
                    if (mode === ALL_SERIES_POINTS_MODE) {
                        setPointsSpecState(point.series.getPoints(), point, RELEASE_POINT_HOVER_STATE, POINT_HOVER_CHANGED, eventTrigger)
                    } else {
                        if (mode === ALL_ARGUMENTS_POINTS_MODE) {
                            that._toAllArgumentPoints(point.argument, RELEASE_POINT_HOVER_STATE, POINT_HOVER_CHANGED, point)
                        } else {
                            if ("none" !== mode) {
                                that._getPointSeries(point).releasePointHoverState({
                                    point: point,
                                    setState: true,
                                    legendCallback: that._legend.getActionCallback(point)
                                });
                                eventTrigger(POINT_HOVER_CHANGED, {
                                    target: point
                                })
                            }
                        }
                    }
                },
                _setPointState: function(point, action, mode, eventName, legendCallback) {
                    var series, that = this,
                        eventTrigger = that._eventTrigger;
                    switch (mode) {
                        case ALL_ARGUMENTS_POINTS_MODE:
                            that._toAllArgumentPoints(point.argument, action, eventName, point);
                            break;
                        case ALL_SERIES_POINTS_MODE:
                            setPointsSpecState(point.series.getPoints(), point, action, eventName, eventTrigger);
                            break;
                        case NONE_MODE:
                            break;
                        default:
                            series = that._getPointSeries(point);
                            series[action]({
                                point: point,
                                legendCallback: legendCallback,
                                setState: true
                            });
                            eventTrigger(eventName, {
                                target: point
                            })
                    }
                },
                _prepare: function() {
                    var that = this,
                        root = that._renderer.root,
                        touchScrollingEnabled = "all" === that._scrollingMode || "touch" === that._scrollingMode,
                        touchZoomingEnabled = "all" === that._zoomingMode || "touch" === that._zoomingMode,
                        cssValue = (!touchScrollingEnabled ? "pan-x pan-y " : "") + (!touchZoomingEnabled ? "pinch-zoom" : "") || "none",
                        rootStyles = {
                            "touch-action": cssValue,
                            "-ms-touch-action": cssValue
                        },
                        wheelzoomingEnabled = "all" === that._zoomingMode || "mouse" === that._zoomingMode;
                    root.off(wheelEvent.name + " dxc-scroll-start dxc-scroll-move");
                    baseTrackerPrototype._prepare.call(that);
                    if (!that._gestureEndHandler) {
                        that._gestureEndHandler = function() {
                            that._gestureEnd && that._gestureEnd()
                        };
                        $(document).on(pointerEvents.up, that._gestureEndHandler)
                    }
                    wheelzoomingEnabled && root.on(wheelEvent.name, function(e) {
                        var rootOffset = that._renderer.getRootOffset(),
                            x = that._rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left,
                            scale = that._argumentAxis.getTranslator().getMinScale(e.delta > 0),
                            translate = x - x * scale,
                            zoom = that._argumentAxis.getTranslator().zoom(-translate, scale);
                        that._pointerOut();
                        that._chart.zoomArgument(zoom.min, zoom.max, true);
                        e.preventDefault();
                        e.stopPropagation()
                    });
                    root.on("dxc-scroll-start", function(e) {
                        that._gestureStart(that._getGestureParams(e, {
                            left: 0,
                            top: 0
                        }))
                    }).on("dxc-scroll-move", function(e) {
                        that._gestureChange(that._getGestureParams(e, {
                            left: 0,
                            top: 0
                        })) && e.preventDefault()
                    });
                    root.css(rootStyles)
                },
                _getGestureParams: function(e, offset) {
                    var x1, x2, left, right, that = this,
                        touches = e.pointers.length,
                        eventCoordField = that._rotated ? "pageY" : "pageX";
                    offset = that._rotated ? offset.top : offset.left;
                    if (2 === touches) {
                        x1 = e.pointers[0][eventCoordField] - offset, x2 = e.pointers[1][eventCoordField] - offset
                    } else {
                        if (1 === touches) {
                            x1 = x2 = e.pointers[0][eventCoordField] - offset
                        }
                    }
                    left = Math.min(x1, x2);
                    right = Math.max(x1, x2);
                    return {
                        center: left + (right - left) / 2,
                        distance: right - left,
                        touches: touches,
                        scale: 1,
                        pointerType: e.pointerType
                    }
                },
                _gestureStart: function(gestureParams) {
                    var that = this;
                    that._startGesture = that._startGesture || gestureParams;
                    if (that._startGesture.touches !== gestureParams.touches) {
                        that._startGesture = gestureParams
                    }
                },
                _gestureChange: function(gestureParams) {
                    var that = this,
                        startGesture = that._startGesture,
                        gestureChanged = false,
                        scrollingEnabled = "all" === that._scrollingMode || "none" !== that._scrollingMode && that._scrollingMode === gestureParams.pointerType,
                        zoomingEnabled = "all" === that._zoomingMode || "touch" === that._zoomingMode;
                    if (!startGesture) {
                        return gestureChanged
                    }
                    if (1 === startGesture.touches && Math.abs(startGesture.center - gestureParams.center) < 3) {
                        that._gestureStart(gestureParams);
                        return gestureChanged
                    }
                    if (2 === startGesture.touches && zoomingEnabled) {
                        gestureChanged = true;
                        startGesture.scale = gestureParams.distance / startGesture.distance;
                        startGesture.scroll = gestureParams.center - startGesture.center + (startGesture.center - startGesture.center * startGesture.scale)
                    } else {
                        if (1 === startGesture.touches && scrollingEnabled) {
                            gestureChanged = true;
                            startGesture.scroll = gestureParams.center - startGesture.center
                        }
                    }
                    if (gestureChanged) {
                        startGesture.changed = gestureChanged;
                        that._chart._transformArgument(startGesture.scroll, startGesture.scale)
                    }
                    return gestureChanged
                },
                _gestureEnd: function() {
                    var zoom, that = this,
                        startGesture = that._startGesture,
                        renderer = that._renderer;
                    that._startGesture = null;

                    function complete() {
                        that._chart.zoomArgument(zoom.min, zoom.max, true)
                    }
                    if (startGesture && startGesture.changed) {
                        zoom = that._argumentAxis._translator.zoom(-startGesture.scroll, startGesture.scale);
                        if (renderer.animationEnabled() && (-startGesture.scroll !== zoom.translate || startGesture.scale !== zoom.scale)) {
                            var translateDelta = -(startGesture.scroll + zoom.translate),
                                scaleDelta = startGesture.scale - zoom.scale;
                            renderer.root.animate({
                                _: 0
                            }, {
                                step: function(pos) {
                                    var translateValue = -startGesture.scroll - translateDelta * pos,
                                        scaleValue = startGesture.scale - scaleDelta * pos;
                                    that._chart._transformArgument(-translateValue, scaleValue)
                                },
                                complete: complete,
                                duration: 250
                            })
                        } else {
                            complete()
                        }
                    }
                },
                _clean: function() {
                    var that = this;
                    baseTrackerPrototype._clean.call(that);
                    that._resetTimer();
                    that._stickedSeries = null
                },
                _getSeriesForShared: function(x, y) {
                    var that = this,
                        points = [],
                        point = null,
                        distance = 1 / 0;
                    if (that._tooltip.isShared() && !that.hoveredSeries) {
                        _each(that._storedSeries, function(_, series) {
                            var point = series.getNeighborPoint(x, y);
                            point && points.push(point)
                        });
                        _each(points, function(_, p) {
                            var coords = p.getCrosshairData(x, y),
                                d = vizUtils.getDistance(x, y, coords.x, coords.y);
                            if (d < distance) {
                                point = p;
                                distance = d
                            }
                        })
                    }
                    return point && point.series
                },
                _setTimeout: function(callback, keeper) {
                    var that = this;
                    if (that._timeoutKeeper !== keeper) {
                        that._resetTimer();
                        that._hoverTimeout = setTimeout(function() {
                            callback();
                            that._timeoutKeeper = null
                        }, DELAY);
                        that._timeoutKeeper = keeper
                    }
                },
                _resetTimer: function() {
                    clearTimeout(this._hoverTimeout);
                    this._timeoutKeeper = this._hoverTimeout = null
                },
                _checkGestureEvents: function(e, canvas, rootOffset) {
                    var that = this;
                    if (e.type === pointerEvents.down) {
                        canvas && that._gestureStart(that._getGestureParams(e, rootOffset))
                    } else {
                        if (that._startGesture && canvas) {
                            if (that._gestureChange(that._getGestureParams(e, rootOffset))) {
                                that._pointerOut();
                                e.preventDefault();
                                return true
                            }
                        }
                    }
                },
                _setStickedSeries: function(x, y) {
                    this._stickedSeries = this._stickedSeries || this._getSeriesForShared(x, y);
                    return !!this._stickedSeries
                },
                _setSeriesWithHoverView: function(point) {
                    this._seriesWithHoverView = point.series.setHoverView()
                },
                _pointerOut: function() {
                    var that = this;
                    that._stickedSeries = null;
                    that._hideCrosshair();
                    that._resetHoveredArgument();
                    that._resetTimer();
                    baseTrackerPrototype._pointerOut.call(that)
                },
                _hoverArgumentAxis: function(x, y, e) {
                    var that = this;
                    that._resetHoveredArgument();
                    if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
                        var argument = getData(e, ARG_DATA);
                        if (isDefined(argument) && that.hoveredArgument !== argument) {
                            that._clearHover();
                            that._toAllArgumentPoints(argument, SET_POINT_HOVER_STATE);
                            that.hoveredArgument = argument
                        }
                        return true
                    }
                },
                _pointerComplete: function(point, x, y) {
                    var that = this;
                    that.hoveredSeries && that.hoveredSeries.updateHover(x, y);
                    that._resetTimer();
                    that._moveCrosshair(point, x, y);
                    baseTrackerPrototype._pointerComplete.call(that, point)
                },
                _legendClick: function(item, e) {
                    var series = this._storedSeries[item.id];
                    this._triggerLegendClick({
                        target: series,
                        jQueryEvent: e
                    }, SERIES_CLICK)
                },
                _hoverLegendItem: function(x, y) {
                    this._stickedSeries = null;
                    this._hideCrosshair();
                    baseTrackerPrototype._hoverLegendItem.call(this, x, y)
                },
                _pointerOnPoint: function(point, x, y) {
                    var that = this,
                        seriesWithHoverView = that._seriesWithHoverView,
                        seriesFromPoint = point.series;
                    that._stickedSeries = seriesFromPoint;
                    that._releaseHoveredSeries(!seriesWithHoverView || seriesWithHoverView === seriesFromPoint, point);
                    baseTrackerPrototype._pointerOnPoint.call(that, point, x, y)
                },
                dispose: function() {
                    this._gestureEndHandler && $(document).off(pointerEvents.up, this._gestureEndHandler);
                    this._resetTimer();
                    baseTrackerPrototype.dispose.call(this)
                }
            });
            var PieTracker = function(options) {
                this.ctor(options)
            };
            $.extend(PieTracker.prototype, baseTrackerPrototype, {
                _getPointSeries: function(point) {
                    return this._storedSeries[point.index]
                },
                _isModeChanged: function() {
                    return false
                },
                _isPointerOut: function(_, point) {
                    return !point
                },
                _legendClick: function(item, e) {
                    var points, that = this,
                        argument = item.argument;
                    if (1 === that._storedSeries.length) {
                        points = getArgumentPointsByIndex(that._storedSeries, argument, item.id);
                        that._triggerLegendClick({
                            target: points[0],
                            jQueryEvent: e
                        }, POINT_CLICK)
                    } else {
                        that._eventTrigger(LEGEND_CLICK, {
                            target: argument,
                            jQueryEvent: e
                        })
                    }
                },
                _pointClick: function(point, e) {
                    this._eventTrigger(POINT_CLICK, {
                        target: point,
                        jQueryEvent: e
                    })
                },
                _releasePoint: function(point, eventTrigger) {
                    var that = this,
                        mode = _normalizeEnum(point.getOptions().hoverMode);
                    if ("none" !== mode) {
                        that._getPointSeries(point).releasePointHoverState({
                            point: point,
                            setState: true,
                            legendCallback: that._legend.getActionCallback(point)
                        });
                        eventTrigger(POINT_HOVER_CHANGED, {
                            target: point
                        })
                    }
                },
                _setPointState: function(point, action, mode, eventName, legendCallback) {
                    var series, that = this,
                        eventTrigger = that._eventTrigger;
                    if ("none" !== mode) {
                        series = that._getPointSeries(point);
                        series[action]({
                            point: point,
                            legendCallback: legendCallback,
                            setState: true
                        });
                        eventTrigger(eventName, {
                            target: point
                        })
                    }
                },
                _hoverArgumentAxis: _noop,
                _setStickedSeries: _noop,
                _setSeriesWithHoverView: _noop,
                _getCanvas: _noop,
                _checkGestureEvents: _noop
            });
            exports.ChartTracker = ChartTracker;
            exports.PieTracker = PieTracker
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/viz/circular_gauge.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./gauges/circular_gauge */ 333)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/core/android.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var ANDROID5_LIGHT = "android5.light",
                themeModule = __webpack_require__( /*! ../themes */ 69),
                registerThemeAlias = themeModule.registerThemeAlias,
                SECONDARY_TEXT_COLOR = "#767676",
                BORDER_COLOR = "#e8e8e8",
                BLACK = "#000000";
            themeModule.registerTheme({
                name: ANDROID5_LIGHT,
                backgroundColor: "#ffffff",
                primaryTitleColor: "#232323",
                secondaryTitleColor: SECONDARY_TEXT_COLOR,
                axisColor: "#d3d3d3",
                axisLabelColor: SECONDARY_TEXT_COLOR,
                tooltip: {
                    color: BORDER_COLOR,
                    font: {
                        color: SECONDARY_TEXT_COLOR
                    }
                },
                legend: {
                    font: {
                        color: BLACK
                    }
                },
                pieIE8: {
                    commonSeriesSettings: {
                        pie: {
                            hoverStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            }
                        },
                        donut: {
                            hoverStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            }
                        },
                        doughnut: {
                            hoverStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BORDER_COLOR
                                }
                            }
                        }
                    }
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            color: BLACK,
                            opacity: .17
                        },
                        minorTick: {
                            color: BLACK,
                            opacity: .05
                        }
                    }
                }
            }, "generic.light");
            registerThemeAlias("android", ANDROID5_LIGHT);
            registerThemeAlias("android.holo-dark", ANDROID5_LIGHT);
            registerThemeAlias("android.holo-light", ANDROID5_LIGHT);
            registerThemeAlias("android.dark", ANDROID5_LIGHT);
            registerThemeAlias("android.light", ANDROID5_LIGHT)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/core/default.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var WHITE = "#ffffff",
                BLACK = "#000000",
                LIGHT_GREY = "#d3d3d3",
                GREY_GREEN = "#303030",
                SOME_GREY = "#2b2b2b",
                RED = "#ff0000",
                PRIMARY_TITLE_COLOR = "#232323",
                SECONDARY_TITLE_COLOR = "#767676",
                CONTRAST_ACTIVE = "#cf00da",
                MARKER_COLOR = "#f8ca00",
                TARGET_COLOR = "#8e8e8e",
                POSITIVE_COLOR = "#b8b8b8",
                LINE_COLOR = "#c7c7c7",
                AREA_LAYER_COLOR = "#686868",
                RANGE_COLOR = "#b5b5b5",
                NONE = "none",
                SOLID = "solid",
                TOP = "top",
                RIGHT = "right",
                BOTTOM = "bottom",
                LEFT = "left",
                CENTER = "center",
                INSIDE = "inside",
                OUTSIDE = "outside",
                themeModule = __webpack_require__( /*! ../themes */ 69),
                registerTheme = themeModule.registerTheme,
                registerThemeAlias = themeModule.registerThemeAlias;
            registerTheme({
                name: "generic.light",
                font: {
                    color: SECONDARY_TITLE_COLOR,
                    family: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 400,
                    size: 12,
                    cursor: "default"
                },
                redrawOnResize: true,
                backgroundColor: WHITE,
                primaryTitleColor: PRIMARY_TITLE_COLOR,
                secondaryTitleColor: SECONDARY_TITLE_COLOR,
                axisColor: LIGHT_GREY,
                axisLabelColor: SECONDARY_TITLE_COLOR,
                title: {
                    backgroundColor: WHITE,
                    font: {
                        size: 28,
                        family: "'Segoe UI Light', 'Helvetica Neue Light', 'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 200
                    },
                    subtitle: {
                        font: {
                            size: 16
                        }
                    }
                },
                loadingIndicator: {
                    text: "Loading..."
                },
                "export": {
                    backgroundColor: WHITE,
                    font: {
                        size: 14,
                        color: PRIMARY_TITLE_COLOR,
                        weight: 400
                    },
                    button: {
                        "default": {
                            color: "#333",
                            borderColor: "#ddd",
                            backgroundColor: WHITE
                        },
                        hover: {
                            color: "#333",
                            borderColor: "#bebebe",
                            backgroundColor: "#e6e6e6"
                        },
                        focus: {
                            color: BLACK,
                            borderColor: "#9d9d9d",
                            backgroundColor: "#e6e6e6"
                        },
                        active: {
                            color: "#333",
                            borderColor: "#9d9d9d",
                            backgroundColor: "#d4d4d4"
                        }
                    },
                    shadowColor: LIGHT_GREY
                },
                tooltip: {
                    enabled: false,
                    border: {
                        width: 1,
                        color: LIGHT_GREY,
                        dashStyle: SOLID,
                        visible: true
                    },
                    font: {
                        color: PRIMARY_TITLE_COLOR
                    },
                    color: WHITE,
                    arrowLength: 10,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    shared: false,
                    location: CENTER,
                    shadow: {
                        opacity: .4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: BLACK
                    }
                },
                legend: {
                    hoverMode: "includePoints",
                    verticalAlignment: TOP,
                    horizontalAlignment: RIGHT,
                    position: OUTSIDE,
                    visible: true,
                    margin: 10,
                    markerSize: 12,
                    border: {
                        visible: false,
                        width: 1,
                        cornerRadius: 0,
                        dashStyle: SOLID
                    },
                    paddingLeftRight: 20,
                    paddingTopBottom: 15,
                    columnCount: 0,
                    rowCount: 0,
                    columnItemSpacing: 20,
                    rowItemSpacing: 8
                },
                "chart:common": {
                    animation: {
                        enabled: true,
                        duration: 1e3,
                        easing: "easeOutCubic",
                        maxPointCountSupported: 300
                    },
                    commonSeriesSettings: {
                        border: {
                            visible: false,
                            width: 2
                        },
                        showInLegend: true,
                        visible: true,
                        hoverMode: "nearestPoint",
                        selectionMode: "includePoints",
                        hoverStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 2,
                                step: 6,
                                opacity: .75
                            },
                            border: {
                                visible: false,
                                width: 3
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: RIGHT,
                                width: 2,
                                step: 6,
                                opacity: .5
                            },
                            border: {
                                visible: false,
                                width: 3
                            }
                        },
                        valueErrorBar: {
                            displayMode: "auto",
                            value: 1,
                            color: BLACK,
                            lineWidth: 2,
                            edgeLength: 8
                        },
                        label: {
                            visible: false,
                            alignment: CENTER,
                            rotationAngle: 0,
                            horizontalOffset: 0,
                            verticalOffset: 0,
                            radialOffset: 0,
                            showForZeroValues: true,
                            customizeText: void 0,
                            maxLabelCount: void 0,
                            position: OUTSIDE,
                            font: {
                                color: WHITE
                            },
                            border: {
                                visible: false,
                                width: 1,
                                color: LIGHT_GREY,
                                dashStyle: SOLID
                            },
                            connector: {
                                visible: false,
                                width: 1
                            }
                        }
                    },
                    seriesSelectionMode: "single",
                    pointSelectionMode: "single",
                    equalRowHeight: true,
                    dataPrepareSettings: {
                        checkTypeForAllData: false,
                        convertToAxisDataType: true,
                        sortingMethod: true
                    },
                    title: {
                        margin: 10
                    },
                    adaptiveLayout: {
                        width: 80,
                        height: 80,
                        keepLabels: true
                    },
                    _rtl: {
                        legend: {
                            itemTextPosition: LEFT
                        }
                    },
                    resolveLabelOverlapping: NONE
                },
                "chart:common:axis": {
                    visible: false,
                    setTicksAtUnitBeginning: true,
                    valueMarginsEnabled: true,
                    placeholderSize: null,
                    logarithmBase: 10,
                    discreteAxisDivisionMode: "betweenLabels",
                    width: 1,
                    label: {
                        visible: true
                    },
                    grid: {
                        visible: false,
                        width: 1
                    },
                    minorGrid: {
                        visible: false,
                        width: 1,
                        opacity: .3
                    },
                    tick: {
                        visible: false,
                        width: 1,
                        length: 8
                    },
                    minorTick: {
                        visible: false,
                        width: 1,
                        opacity: .3,
                        length: 8
                    },
                    stripStyle: {
                        paddingLeftRight: 10,
                        paddingTopBottom: 5
                    },
                    constantLineStyle: {
                        width: 1,
                        color: BLACK,
                        dashStyle: SOLID,
                        label: {
                            visible: true,
                            position: INSIDE
                        }
                    },
                    marker: {
                        label: {}
                    }
                },
                chart: {
                    commonSeriesSettings: {
                        type: "line",
                        stack: "default",
                        point: {
                            visible: true,
                            symbol: "circle",
                            size: 12,
                            border: {
                                visible: false,
                                width: 1
                            },
                            hoverMode: "onlyPoint",
                            selectionMode: "onlyPoint",
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    width: 4
                                },
                                size: 12
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    width: 4
                                },
                                size: 12
                            }
                        },
                        scatter: {},
                        line: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        stackedline: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        stackedspline: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        fullstackedline: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        fullstackedspline: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        stepline: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        area: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        stackedarea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        fullstackedarea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        fullstackedsplinearea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        steparea: {
                            border: {
                                visible: true,
                                width: 2
                            },
                            point: {
                                visible: false
                            },
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    width: 3
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    width: 3
                                }
                            },
                            opacity: .5
                        },
                        spline: {
                            width: 2,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        splinearea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        stackedsplinearea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        bar: {
                            cornerRadius: 0,
                            point: {
                                hoverStyle: {
                                    border: {
                                        visible: false
                                    }
                                },
                                selectionStyle: {
                                    border: {
                                        visible: false
                                    }
                                }
                            }
                        },
                        stackedbar: {
                            cornerRadius: 0,
                            point: {
                                hoverStyle: {
                                    border: {
                                        visible: false
                                    }
                                },
                                selectionStyle: {
                                    border: {
                                        visible: false
                                    }
                                }
                            },
                            label: {
                                position: INSIDE
                            }
                        },
                        fullstackedbar: {
                            cornerRadius: 0,
                            point: {
                                hoverStyle: {
                                    border: {
                                        visible: false
                                    }
                                },
                                selectionStyle: {
                                    border: {
                                        visible: false
                                    }
                                }
                            },
                            label: {
                                position: INSIDE
                            }
                        },
                        rangebar: {
                            cornerRadius: 0,
                            point: {
                                hoverStyle: {
                                    border: {
                                        visible: false
                                    }
                                },
                                selectionStyle: {
                                    border: {
                                        visible: false
                                    }
                                }
                            }
                        },
                        rangearea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        rangesplinearea: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        bubble: {
                            opacity: .5,
                            point: {
                                hoverStyle: {
                                    border: {
                                        visible: false
                                    }
                                },
                                selectionStyle: {
                                    border: {
                                        visible: false
                                    }
                                }
                            }
                        },
                        candlestick: {
                            width: 1,
                            reduction: {
                                color: RED
                            },
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            },
                            point: {
                                border: {
                                    visible: true
                                }
                            }
                        },
                        stock: {
                            width: 1,
                            reduction: {
                                color: RED
                            },
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            },
                            point: {
                                border: {
                                    visible: true
                                }
                            }
                        }
                    },
                    crosshair: {
                        enabled: false,
                        color: "#f05b41",
                        width: 1,
                        dashStyle: SOLID,
                        label: {
                            visible: false,
                            font: {
                                color: WHITE,
                                size: 12
                            }
                        },
                        verticalLine: {
                            visible: true
                        },
                        horizontalLine: {
                            visible: true
                        }
                    },
                    commonAxisSettings: {
                        multipleAxesSpacing: 5,
                        label: {
                            overlappingBehavior: {
                                mode: "enlargeTickInterval",
                                rotationAngle: 90,
                                staggeringSpacing: 5
                            },
                            indentFromAxis: 10
                        },
                        title: {
                            font: {
                                size: 16
                            },
                            margin: 6
                        },
                        constantLineStyle: {
                            paddingLeftRight: 10,
                            paddingTopBottom: 10
                        }
                    },
                    horizontalAxis: {
                        position: BOTTOM,
                        axisDivisionFactor: 50,
                        label: {
                            alignment: CENTER
                        },
                        stripStyle: {
                            label: {
                                horizontalAlignment: CENTER,
                                verticalAlignment: TOP
                            }
                        },
                        constantLineStyle: {
                            label: {
                                horizontalAlignment: RIGHT,
                                verticalAlignment: TOP
                            }
                        },
                        constantLines: {}
                    },
                    verticalAxis: {
                        position: LEFT,
                        axisDivisionFactor: 30,
                        label: {
                            alignment: RIGHT,
                            overlappingBehavior: {
                                mode: "enlargeTickInterval"
                            }
                        },
                        stripStyle: {
                            label: {
                                horizontalAlignment: LEFT,
                                verticalAlignment: CENTER
                            }
                        },
                        constantLineStyle: {
                            label: {
                                horizontalAlignment: LEFT,
                                verticalAlignment: TOP
                            }
                        },
                        constantLines: {}
                    },
                    argumentAxis: {},
                    valueAxis: {
                        grid: {
                            visible: true
                        }
                    },
                    commonPaneSettings: {
                        backgroundColor: NONE,
                        border: {
                            color: LIGHT_GREY,
                            width: 1,
                            visible: false,
                            top: true,
                            bottom: true,
                            left: true,
                            right: true,
                            dashStyle: SOLID
                        }
                    },
                    scrollBar: {
                        visible: false,
                        offset: 5,
                        color: "gray",
                        width: 10
                    },
                    useAggregation: false,
                    adjustOnZoom: true,
                    rotated: false,
                    zoomingMode: NONE,
                    scrollingMode: NONE,
                    synchronizeMultiAxes: true,
                    equalBarWidth: true,
                    minBubbleSize: 12,
                    maxBubbleSize: .2
                },
                pie: {
                    innerRadius: .5,
                    type: "pie",
                    commonSeriesSettings: {
                        pie: {
                            border: {
                                visible: false,
                                width: 2,
                                color: WHITE
                            },
                            hoverStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .75
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .5
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            }
                        },
                        doughnut: {
                            border: {
                                visible: false,
                                width: 2,
                                color: WHITE
                            },
                            hoverStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .75
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .5
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            }
                        },
                        donut: {
                            border: {
                                visible: false,
                                width: 2,
                                color: WHITE
                            },
                            hoverStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .75
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    direction: RIGHT,
                                    width: 4,
                                    step: 10,
                                    opacity: .5
                                },
                                border: {
                                    visible: false,
                                    width: 2
                                }
                            }
                        }
                    },
                    legend: {
                        hoverMode: "allArgumentPoints",
                        backgroundColor: NONE
                    },
                    adaptiveLayout: {
                        keepLabels: false
                    }
                },
                pieIE8: {
                    commonSeriesSettings: {
                        pie: {
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            }
                        },
                        donut: {
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            }
                        },
                        doughnut: {
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    color: WHITE
                                }
                            }
                        }
                    }
                },
                gauge: {
                    scale: {
                        tick: {
                            visible: true,
                            length: 5,
                            width: 2,
                            opacity: 1
                        },
                        minorTick: {
                            visible: false,
                            length: 3,
                            width: 1,
                            opacity: 1
                        },
                        label: {
                            visible: true,
                            alignment: CENTER,
                            overlappingBehavior: {
                                hideFirstOrLast: "last",
                                useAutoArrangement: true
                            }
                        },
                        position: TOP
                    },
                    rangeContainer: {
                        offset: 0,
                        width: 5,
                        backgroundColor: "#808080"
                    },
                    valueIndicators: {
                        _default: {
                            color: "#c2c2c2"
                        },
                        rangebar: {
                            space: 2,
                            size: 10,
                            color: "#cbc5cf",
                            backgroundColor: NONE,
                            text: {
                                indent: 0,
                                font: {
                                    size: 14,
                                    color: null
                                }
                            }
                        },
                        twocolorneedle: {
                            secondColor: "#e18e92"
                        },
                        trianglemarker: {
                            space: 2,
                            length: 14,
                            width: 13,
                            color: "#8798a5"
                        },
                        textcloud: {
                            arrowLength: 5,
                            horizontalOffset: 6,
                            verticalOffset: 3,
                            color: "#679ec5",
                            text: {
                                font: {
                                    color: WHITE,
                                    size: 18
                                }
                            }
                        }
                    },
                    indicator: {
                        hasPositiveMeaning: true,
                        layout: {
                            horizontalAlignment: CENTER,
                            verticalAlignment: BOTTOM
                        },
                        text: {
                            font: {
                                size: 18
                            }
                        }
                    },
                    _circular: {
                        scale: {
                            orientation: OUTSIDE,
                            label: {
                                indentFromTick: 10
                            }
                        },
                        rangeContainer: {
                            orientation: OUTSIDE
                        },
                        valueIndicatorType: "rectangleneedle",
                        subvalueIndicatorType: "trianglemarker",
                        valueIndicators: {
                            _type: "rectangleneedle",
                            _default: {
                                offset: 20,
                                indentFromCenter: 0,
                                width: 2,
                                spindleSize: 14,
                                spindleGapSize: 10
                            },
                            triangleneedle: {
                                width: 4
                            },
                            twocolorneedle: {
                                space: 2,
                                secondFraction: .4
                            },
                            rangebar: {
                                offset: 30
                            },
                            trianglemarker: {
                                offset: 6
                            },
                            textcloud: {
                                offset: -6
                            }
                        }
                    },
                    _linear: {
                        scale: {
                            horizontalOrientation: RIGHT,
                            verticalOrientation: BOTTOM,
                            label: {
                                indentFromTick: -10
                            }
                        },
                        rangeContainer: {
                            horizontalOrientation: RIGHT,
                            verticalOrientation: BOTTOM
                        },
                        valueIndicatorType: "rangebar",
                        subvalueIndicatorType: "trianglemarker",
                        valueIndicators: {
                            _type: "rectangle",
                            _default: {
                                offset: 2.5,
                                length: 15,
                                width: 15
                            },
                            rectangle: {
                                width: 10
                            },
                            rangebar: {
                                offset: 10,
                                horizontalOrientation: RIGHT,
                                verticalOrientation: BOTTOM
                            },
                            trianglemarker: {
                                offset: 10,
                                horizontalOrientation: LEFT,
                                verticalOrientation: TOP
                            },
                            textcloud: {
                                offset: -1,
                                horizontalOrientation: LEFT,
                                verticalOrientation: TOP
                            }
                        }
                    }
                },
                barGauge: {
                    backgroundColor: "#e0e0e0",
                    relativeInnerRadius: .3,
                    barSpacing: 4,
                    label: {
                        indent: 20,
                        connectorWidth: 2,
                        font: {
                            size: 16
                        }
                    },
                    indicator: {
                        hasPositiveMeaning: true,
                        layout: {
                            horizontalAlignment: CENTER,
                            verticalAlignment: BOTTOM
                        },
                        text: {
                            font: {
                                size: 18
                            }
                        }
                    }
                },
                rangeSelector: {
                    scale: {
                        width: 1,
                        color: BLACK,
                        opacity: .1,
                        showCustomBoundaryTicks: true,
                        showMinorTicks: true,
                        useTicksAutoArrangement: true,
                        setTicksAtUnitBeginning: true,
                        label: {
                            alignment: "center",
                            visible: true,
                            topIndent: 7,
                            font: {
                                size: 11
                            }
                        },
                        tick: {
                            width: 1,
                            color: BLACK,
                            opacity: .17,
                            visible: true,
                            length: 12
                        },
                        minorTick: {
                            width: 1,
                            color: BLACK,
                            opacity: .05,
                            visible: true,
                            length: 12
                        },
                        marker: {
                            width: 1,
                            color: "#000000",
                            opacity: .1,
                            visible: true,
                            separatorHeight: 33,
                            topIndent: 10,
                            textLeftIndent: 7,
                            textTopIndent: 11,
                            label: {}
                        },
                        logarithmBase: 10
                    },
                    selectedRangeColor: "#606060",
                    sliderMarker: {
                        visible: true,
                        paddingTopBottom: 2,
                        paddingLeftRight: 4,
                        color: "#606060",
                        invalidRangeColor: RED,
                        font: {
                            color: WHITE,
                            size: 11
                        }
                    },
                    sliderHandle: {
                        width: 1,
                        color: BLACK,
                        opacity: .2
                    },
                    shutter: {
                        opacity: .75
                    },
                    background: {
                        color: "#c0bae1",
                        visible: true,
                        image: {
                            location: "full"
                        }
                    },
                    behavior: {
                        snapToTicks: true,
                        animationEnabled: true,
                        moveSelectedRangeByClick: true,
                        manualRangeSelectionEnabled: true,
                        allowSlidersSwap: true,
                        callSelectedRangeChanged: "onMovingComplete"
                    },
                    redrawOnResize: true,
                    chart: {
                        useAggregation: false,
                        equalBarWidth: true,
                        minBubbleSize: 12,
                        maxBubbleSize: .2,
                        topIndent: .1,
                        bottomIndent: 0,
                        valueAxis: {
                            inverted: false,
                            logarithmBase: 10
                        },
                        commonSeriesSettings: {
                            type: "area",
                            point: {
                                visible: false
                            },
                            scatter: {
                                point: {
                                    visible: true
                                }
                            }
                        }
                    }
                },
                map: {
                    title: {
                        margin: 10
                    },
                    background: {
                        borderWidth: 1,
                        borderColor: "#cacaca"
                    },
                    layer: {
                        label: {
                            enabled: false,
                            stroke: WHITE,
                            "stroke-width": 1,
                            "stroke-opacity": .7,
                            font: {
                                color: SOME_GREY,
                                size: 12
                            }
                        }
                    },
                    "layer:area": {
                        borderWidth: 1,
                        borderColor: WHITE,
                        color: "#d2d2d2",
                        hoveredBorderColor: GREY_GREEN,
                        selectedBorderWidth: 2,
                        selectedBorderColor: GREY_GREEN,
                        label: {
                            "stroke-width": 2,
                            font: {
                                size: 16
                            }
                        }
                    },
                    "layer:line": {
                        borderWidth: 2,
                        color: "#ba8365",
                        hoveredColor: "#a94813",
                        selectedBorderWidth: 3,
                        selectedColor: "#e55100",
                        label: {
                            "stroke-width": 2,
                            font: {
                                size: 16
                            }
                        }
                    },
                    "layer:marker": {
                        label: {
                            enabled: true,
                            "stroke-width": 1,
                            font: {
                                size: 12
                            }
                        }
                    },
                    "layer:marker:dot": {
                        borderWidth: 2,
                        borderColor: WHITE,
                        color: "#ba4d51",
                        size: 8,
                        selectedStep: 2,
                        backStep: 18,
                        backColor: WHITE,
                        backOpacity: .32,
                        shadow: true
                    },
                    "layer:marker:bubble": {
                        minSize: 20,
                        maxSize: 50,
                        color: "#ba4d51",
                        hoveredBorderWidth: 1,
                        hoveredBorderColor: GREY_GREEN,
                        selectedBorderWidth: 2,
                        selectedBorderColor: GREY_GREEN
                    },
                    "layer:marker:pie": {
                        size: 50,
                        hoveredBorderWidth: 1,
                        hoveredBorderColor: GREY_GREEN,
                        selectedBorderWidth: 2,
                        selectedBorderColor: GREY_GREEN
                    },
                    "layer:marker:image": {
                        size: 20
                    },
                    legend: {
                        verticalAlignment: BOTTOM,
                        horizontalAlignment: RIGHT,
                        position: INSIDE,
                        backgroundOpacity: .65,
                        border: {
                            visible: true
                        },
                        paddingLeftRight: 16,
                        paddingTopBottom: 12,
                        markerColor: "#ba4d51"
                    },
                    controlBar: {
                        borderColor: "#5d5d5d",
                        borderWidth: 3,
                        color: WHITE,
                        margin: 20,
                        opacity: .3
                    },
                    _rtl: {
                        legend: {
                            itemTextPosition: LEFT
                        }
                    }
                },
                treeMap: {
                    tile: {
                        border: {
                            width: 1,
                            opacity: .2,
                            color: "#000000"
                        },
                        color: "#5f8b95",
                        hoverStyle: {
                            hatching: {
                                opacity: .75,
                                step: 6,
                                width: 2,
                                direction: "right"
                            },
                            border: {}
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: .5,
                                step: 6,
                                width: 2,
                                direction: "right"
                            },
                            border: {
                                opacity: 1
                            }
                        },
                        label: {
                            visible: true,
                            paddingLeftRight: 5,
                            paddingTopBottom: 4,
                            stroke: "#000000",
                            "stroke-width": 1,
                            "stroke-opacity": .3,
                            font: {
                                color: "#ffffff",
                                weight: 300
                            },
                            shadow: {
                                opacity: .8,
                                offsetX: 0,
                                offsetY: 1,
                                blur: 1,
                                color: "#000000"
                            }
                        }
                    },
                    group: {
                        padding: 4,
                        border: {
                            width: 1
                        },
                        color: "#eeeeee",
                        hoverStyle: {
                            hatching: {
                                opacity: 0,
                                step: 6,
                                width: 2,
                                direction: "right"
                            },
                            border: {}
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: 0,
                                step: 6,
                                width: 2,
                                direction: "right"
                            },
                            border: {}
                        },
                        label: {
                            visible: true,
                            paddingLeftRight: 5,
                            paddingTopBottom: 4,
                            font: {
                                weight: 600
                            }
                        }
                    },
                    title: {
                        subtitle: {}
                    },
                    tooltip: {},
                    loadingIndicator: {}
                },
                sparkline: {
                    lineColor: "#666666",
                    lineWidth: 2,
                    areaOpacity: .2,
                    minColor: "#e8c267",
                    maxColor: "#e55253",
                    barPositiveColor: "#a9a9a9",
                    barNegativeColor: "#d7d7d7",
                    winColor: "#a9a9a9",
                    lossColor: "#d7d7d7",
                    firstLastColor: "#666666",
                    pointSymbol: "circle",
                    pointColor: WHITE,
                    pointSize: 4,
                    type: "line",
                    argumentField: "arg",
                    valueField: "val",
                    winlossThreshold: 0,
                    showFirstLast: true,
                    showMinMax: false,
                    tooltip: {
                        enabled: true
                    }
                },
                bullet: {
                    color: "#e8c267",
                    targetColor: "#666666",
                    targetWidth: 4,
                    showTarget: true,
                    showZeroLevel: true,
                    tooltip: {
                        enabled: true
                    }
                },
                polar: {
                    commonSeriesSettings: {
                        type: "scatter",
                        closed: true,
                        point: {
                            visible: true,
                            symbol: "circle",
                            size: 12,
                            border: {
                                visible: false,
                                width: 1
                            },
                            hoverMode: "onlyPoint",
                            selectionMode: "onlyPoint",
                            hoverStyle: {
                                border: {
                                    visible: true,
                                    width: 4
                                },
                                size: 12
                            },
                            selectionStyle: {
                                border: {
                                    visible: true,
                                    width: 4
                                },
                                size: 12
                            }
                        },
                        scatter: {},
                        line: {
                            width: 2,
                            dashStyle: SOLID,
                            hoverStyle: {
                                width: 3,
                                hatching: {
                                    direction: NONE
                                }
                            },
                            selectionStyle: {
                                width: 3
                            }
                        },
                        area: {
                            point: {
                                visible: false
                            },
                            opacity: .5
                        },
                        stackedline: {
                            width: 2
                        },
                        bar: {
                            opacity: .8
                        },
                        stackedbar: {
                            opacity: .8
                        }
                    },
                    adaptiveLayout: {
                        width: 170,
                        height: 170,
                        keepLabels: true
                    },
                    equalBarWidth: true,
                    commonAxisSettings: {
                        visible: true,
                        label: {
                            overlappingBehavior: {
                                mode: "enlargeTickInterval"
                            },
                            indentFromAxis: 5
                        },
                        grid: {
                            visible: true
                        },
                        minorGrid: {
                            visible: true
                        },
                        tick: {
                            visible: true
                        },
                        title: {
                            font: {
                                size: 16
                            },
                            margin: 10
                        }
                    },
                    argumentAxis: {
                        startAngle: 0,
                        firstPointOnStartAngle: false,
                        period: void 0
                    },
                    valueAxis: {
                        tick: {
                            visible: false
                        }
                    },
                    horizontalAxis: {
                        position: TOP,
                        axisDivisionFactor: 50,
                        label: {
                            alignment: CENTER
                        }
                    },
                    verticalAxis: {
                        position: TOP,
                        axisDivisionFactor: 30,
                        label: {
                            alignment: RIGHT
                        }
                    }
                }
            });
            registerTheme({
                name: "generic.dark",
                font: {
                    color: "#808080"
                },
                backgroundColor: "#2a2a2a",
                primaryTitleColor: "#dedede",
                secondaryTitleColor: "#a3a3a3",
                axisColor: "#555555",
                axisLabelColor: "#a3a3a3",
                "export": {
                    backgroundColor: "#2a2a2a",
                    font: {
                        color: "#dbdbdb"
                    },
                    button: {
                        "default": {
                            color: "#dedede",
                            borderColor: "#4d4d4d",
                            backgroundColor: "#2e2e2e"
                        },
                        hover: {
                            color: "#dedede",
                            borderColor: "#6c6c6c",
                            backgroundColor: "#444"
                        },
                        focus: {
                            color: "#dedede",
                            borderColor: "#8d8d8d",
                            backgroundColor: "#444444"
                        },
                        active: {
                            color: "#dedede",
                            borderColor: "#8d8d8d",
                            backgroundColor: "#555555"
                        }
                    },
                    shadowColor: "#292929"
                },
                tooltip: {
                    color: SOME_GREY,
                    border: {
                        color: "#494949"
                    },
                    font: {
                        color: "#929292"
                    }
                },
                "chart:common": {
                    commonSeriesSettings: {
                        label: {
                            border: {
                                color: "#494949"
                            }
                        },
                        valueErrorBar: {
                            color: WHITE
                        }
                    }
                },
                "chart:common:axis": {
                    constantLineStyle: {
                        color: WHITE
                    }
                },
                chart: {
                    commonPaneSettings: {
                        border: {
                            color: "#494949"
                        }
                    }
                },
                pieIE8: {
                    commonSeriesSettings: {
                        pie: {
                            hoverStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            }
                        },
                        donut: {
                            hoverStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            }
                        },
                        doughnut: {
                            hoverStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: SOME_GREY
                                }
                            }
                        }
                    }
                },
                gauge: {
                    rangeContainer: {
                        backgroundColor: RANGE_COLOR
                    },
                    valueIndicators: {
                        _default: {
                            color: RANGE_COLOR
                        },
                        rangebar: {
                            color: "#84788b"
                        },
                        twocolorneedle: {
                            secondColor: "#ba544d"
                        },
                        trianglemarker: {
                            color: "#b7918f"
                        },
                        textcloud: {
                            color: "#ba544d"
                        }
                    }
                },
                barGauge: {
                    backgroundColor: "#3c3c3c"
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            color: WHITE,
                            opacity: .32
                        },
                        minorTick: {
                            color: WHITE,
                            opacity: .1
                        }
                    },
                    selectedRangeColor: RANGE_COLOR,
                    sliderMarker: {
                        color: RANGE_COLOR,
                        font: {
                            color: GREY_GREEN
                        }
                    },
                    sliderHandle: {
                        color: WHITE,
                        opacity: .2
                    },
                    shutter: {
                        color: SOME_GREY,
                        opacity: .9
                    }
                },
                map: {
                    background: {
                        borderColor: "#3f3f3f"
                    },
                    layer: {
                        label: {
                            stroke: BLACK,
                            font: {
                                color: WHITE
                            }
                        }
                    },
                    "layer:area": {
                        borderColor: GREY_GREEN,
                        color: AREA_LAYER_COLOR,
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE
                    },
                    "layer:line": {
                        color: "#c77244",
                        hoveredColor: "#ff5d04",
                        selectedColor: "#ff784f"
                    },
                    "layer:marker:bubble": {
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE
                    },
                    "layer:marker:pie": {
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE
                    },
                    legend: {
                        border: {
                            color: "#3f3f3f"
                        },
                        font: {
                            color: WHITE
                        }
                    },
                    controlBar: {
                        borderColor: LINE_COLOR,
                        color: GREY_GREEN
                    }
                },
                treeMap: {
                    group: {
                        color: "#4c4c4c"
                    }
                },
                sparkline: {
                    lineColor: LINE_COLOR,
                    firstLastColor: LINE_COLOR,
                    barPositiveColor: POSITIVE_COLOR,
                    barNegativeColor: TARGET_COLOR,
                    winColor: POSITIVE_COLOR,
                    lossColor: TARGET_COLOR,
                    pointColor: GREY_GREEN
                },
                bullet: {
                    targetColor: TARGET_COLOR
                }
            }, "generic.light");
            registerTheme({
                name: "generic.contrast",
                defaultPalette: "Bright",
                font: {
                    color: WHITE
                },
                backgroundColor: BLACK,
                primaryTitleColor: WHITE,
                secondaryTitleColor: WHITE,
                axisColor: WHITE,
                axisLabelColor: WHITE,
                "export": {
                    backgroundColor: BLACK,
                    font: {
                        color: WHITE
                    },
                    button: {
                        "default": {
                            color: WHITE,
                            borderColor: WHITE,
                            backgroundColor: BLACK
                        },
                        hover: {
                            color: WHITE,
                            borderColor: WHITE,
                            backgroundColor: "#cf00d7"
                        },
                        focus: {
                            color: WHITE,
                            borderColor: "#cf00d7",
                            backgroundColor: BLACK
                        },
                        active: {
                            color: BLACK,
                            borderColor: WHITE,
                            backgroundColor: WHITE
                        }
                    },
                    borderColor: WHITE,
                    menuButtonColor: BLACK,
                    activeBackgroundColor: WHITE,
                    activeColor: BLACK,
                    selectedBorderColor: CONTRAST_ACTIVE,
                    selectedColor: CONTRAST_ACTIVE,
                    shadowColor: "none"
                },
                tooltip: {
                    border: {
                        color: WHITE
                    },
                    font: {
                        color: WHITE
                    },
                    color: BLACK
                },
                "chart:common": {
                    commonSeriesSettings: {
                        valueErrorBar: {
                            color: WHITE
                        },
                        hoverStyle: {
                            hatching: {
                                opacity: .5
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                opacity: .35
                            }
                        },
                        label: {
                            font: {
                                color: WHITE
                            },
                            border: {
                                color: WHITE
                            }
                        }
                    }
                },
                "chart:common:axis": {
                    constantLineStyle: {
                        color: WHITE
                    }
                },
                chart: {
                    commonSeriesSettings: {},
                    commonPaneSettings: {
                        backgroundColor: BLACK,
                        border: {
                            color: WHITE
                        }
                    },
                    scrollBar: {
                        color: WHITE
                    }
                },
                pie: {
                    commonSeriesSettings: {
                        pie: {
                            hoverStyle: {
                                hatching: {
                                    opacity: .5
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    opacity: .35
                                }
                            }
                        },
                        doughnut: {
                            hoverStyle: {
                                hatching: {
                                    opacity: .5
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    opacity: .35
                                }
                            }
                        },
                        donut: {
                            hoverStyle: {
                                hatching: {
                                    opacity: .5
                                }
                            },
                            selectionStyle: {
                                hatching: {
                                    opacity: .35
                                }
                            }
                        }
                    },
                    legend: {
                        backgroundColor: BLACK
                    }
                },
                gauge: {
                    rangeContainer: {
                        backgroundColor: WHITE
                    },
                    valueIndicators: {
                        _default: {
                            color: WHITE
                        },
                        rangebar: {
                            color: WHITE,
                            backgroundColor: BLACK
                        },
                        twocolorneedle: {
                            secondColor: WHITE
                        },
                        trianglemarker: {
                            color: WHITE
                        },
                        textcloud: {
                            color: WHITE,
                            text: {
                                font: {
                                    color: BLACK
                                }
                            }
                        }
                    }
                },
                barGauge: {
                    backgroundColor: "#3c3c3c"
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            opacity: .4
                        },
                        minorTick: {
                            opacity: .12
                        }
                    },
                    selectedRangeColor: CONTRAST_ACTIVE,
                    sliderMarker: {
                        color: CONTRAST_ACTIVE
                    },
                    sliderHandle: {
                        color: CONTRAST_ACTIVE,
                        opacity: 1
                    },
                    shutter: {
                        opacity: .75
                    },
                    background: {
                        color: BLACK
                    }
                },
                map: {
                    background: {
                        borderColor: WHITE
                    },
                    layer: {
                        label: {
                            stroke: BLACK,
                            font: {
                                color: WHITE
                            }
                        }
                    },
                    "layer:area": {
                        borderColor: BLACK,
                        color: AREA_LAYER_COLOR,
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE,
                        label: {
                            font: {
                                opacity: 1
                            }
                        }
                    },
                    "layer:line": {
                        color: "#267cff",
                        hoveredColor: "#f613ff",
                        selectedColor: WHITE
                    },
                    "layer:marker:dot": {
                        borderColor: BLACK,
                        color: MARKER_COLOR,
                        backColor: BLACK,
                        backOpacity: .32
                    },
                    "layer:marker:bubble": {
                        color: MARKER_COLOR,
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE
                    },
                    "layer:marker:pie": {
                        hoveredBorderColor: WHITE,
                        selectedBorderColor: WHITE
                    },
                    legend: {
                        markerColor: MARKER_COLOR
                    },
                    controlBar: {
                        borderColor: WHITE,
                        color: BLACK,
                        opacity: .3
                    }
                },
                treeMap: {
                    tile: {
                        color: "#70c92f"
                    },
                    group: {
                        color: "#797979"
                    }
                },
                sparkline: {
                    pointColor: BLACK
                },
                bullet: {},
                polar: {
                    commonSeriesSettings: {}
                }
            }, "generic.light");
            themeModule.currentTheme("generic.light");
            registerThemeAlias("desktop.light", "generic.light");
            registerThemeAlias("desktop.dark", "generic.dark")
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/viz/core/errors_warnings.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var errorUtils = __webpack_require__( /*! ../../core/utils/error */ 94),
                errors = __webpack_require__( /*! ../../core/errors */ 10);
            /**
             * @docid
             * @name Errors and Warnings
             * @publicName Errors and Warnings
             * @description Errors and Warnings
             */
            module.exports = errorUtils(errors.ERROR_MESSAGES, {
                E2001: "Invalid data source",
                E2002: "Axis type and data type are incompatible",
                E2003: '"{0}" data source field contains data of unsupported type',
                E2004: '"{0}" data source field is inconsistent',
                E2101: "Unknown series type was specified: {0}",
                E2102: "Ambiguity occurred between two value axes with the same name",
                E2103: '"{0}" option must be a function',
                E2104: "Invalid logarithm base",
                E2105: 'Invalid value of a "{0}"',
                E2106: "Invalid visible range",
                E2202: "Invalid scale {0} value",
                E2203: 'The "{0}" field of the "selectedRange" configuration object is not valid',
                W2002: "The {0} data field is absent",
                W2003: "Tick interval is too small",
                W2101: 'The "{0}" pane does not exist; the last pane is used by default',
                W2102: 'Value axis with the "{0}" name was created automatically',
                W2103: "Chart title was hidden due to container size",
                W2104: "Legend was hidden due to container size",
                W2105: 'Title of "{0}" axis was hidden due to container size',
                W2106: 'Labels of "{0}" axis were hidden due to container size',
                W2301: "Invalid value range"
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/core/helpers.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _extend = __webpack_require__( /*! jquery */ 1).extend;

            function Flags() {
                this.reset()
            }
            Flags.prototype = {
                constructor: Flags,
                add: function(codes) {
                    var i, ii = codes.length,
                        flags = this._flags;
                    for (i = 0; i < ii; ++i) {
                        flags[codes[i]] = 1
                    }
                    this._k += ii
                },
                has: function(code) {
                    return this._flags[code] > 0
                },
                count: function() {
                    return this._k
                },
                reset: function() {
                    this._flags = {};
                    this._k = 0
                }
            };

            function combineMaps(baseMap, thisMap) {
                return baseMap !== thisMap ? _extend({}, baseMap, thisMap) : _extend({}, baseMap)
            }

            function combineLists(baseList, thisList) {
                return baseList !== thisList ? baseList.concat(thisList) : baseList.slice()
            }

            function buildTotalChanges(proto) {
                proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder)
            }

            function addChange(settings) {
                var proto = this.prototype,
                    code = settings.code;
                proto["_change_" + code] = settings.handler;
                if (settings.isThemeDependent) {
                    proto._themeDependentChanges.push(code)
                }
                if (settings.option) {
                    proto._optionChangesMap[settings.option] = code
                }(settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
                buildTotalChanges(proto)
            }

            function addPlugin(plugin) {
                this.prototype._plugins.push(plugin);
                if (plugin.members) {
                    _extend(this.prototype, plugin.members)
                }
                if (plugin.customize) {
                    plugin.customize(this)
                }
            }
            exports.replaceInherit = function(widget) {
                var _inherit = widget.inherit;
                widget.inherit = function(members) {
                    var proto = this.prototype,
                        plugins = proto._plugins,
                        eventsMap = proto._eventsMap,
                        initialChanges = proto._initialChanges,
                        themeDependentChanges = proto._themeDependentChanges,
                        optionChangesMap = proto._optionChangesMap,
                        optionChangesOrder = proto._optionChangesOrder,
                        layoutChangesOrder = proto._layoutChangesOrder,
                        customChangesOrder = proto._customChangesOrder,
                        ret = _inherit.apply(this, arguments);
                    proto = ret.prototype;
                    proto._plugins = combineLists(plugins, proto._plugins);
                    proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
                    proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
                    proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
                    proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
                    proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
                    proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
                    proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
                    buildTotalChanges(proto);
                    ret.addPlugin = addPlugin;
                    return ret
                };
                widget.prototype._plugins = [];
                widget.addChange = addChange;
                widget.addPlugin = addPlugin
            };
            exports.changes = function() {
                return new Flags
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/viz/core/ios.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var themeModule = __webpack_require__( /*! ../themes */ 69),
                IOS7_DEFAULT = "ios7.default",
                SECONDARY_TEXT_COLOR = "#767676",
                BORDER_COLOR = "#d3d3d3",
                BLACK = "#000000";
            themeModule.registerTheme({
                name: IOS7_DEFAULT,
                backgroundColor: "#ffffff",
                primaryTitleColor: BLACK,
                secondaryTitleColor: SECONDARY_TEXT_COLOR,
                axisColor: "#ececec",
                axisLabelColor: SECONDARY_TEXT_COLOR,
                legend: {
                    font: {
                        color: BLACK
                    }
                },
                tooltip: {
                    font: {
                        color: SECONDARY_TEXT_COLOR
                    }
                },
                "chart:common": {
                    commonSeriesSettings: {
                        label: {
                            border: {
                                color: BORDER_COLOR
                            }
                        }
                    }
                },
                chart: {
                    commonPaneSettings: {
                        border: {
                            color: BORDER_COLOR
                        }
                    }
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            color: BLACK,
                            opacity: .1
                        },
                        minorTick: {
                            color: BLACK,
                            opacity: .03
                        }
                    }
                }
            }, "generic.light");
            themeModule.registerThemeAlias("ios", IOS7_DEFAULT)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/viz/core/layout.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _normalizeEnum = __webpack_require__( /*! ./utils */ 6).normalizeEnum,
                _min = Math.min,
                _max = Math.max,
                ALIGN_START = 0,
                ALIGN_MIDDLE = 1,
                ALIGN_END = 2,
                horizontalAlignmentMap = {
                    left: ALIGN_START,
                    center: ALIGN_MIDDLE,
                    right: ALIGN_END
                },
                verticalAlignmentMap = {
                    top: ALIGN_START,
                    center: ALIGN_MIDDLE,
                    bottom: ALIGN_END
                },
                sideMap = {
                    horizontal: 0,
                    vertical: 1
                },
                slicersMap = {};
            slicersMap[ALIGN_START] = function(a, b, size) {
                return [a, _min(b, a + size)]
            };
            slicersMap[ALIGN_MIDDLE] = function(a, b, size) {
                return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)]
            };
            slicersMap[ALIGN_END] = function(a, b, size) {
                return [_max(a, b - size), b]
            };

            function pickValue(value, map, defaultValue) {
                var val = _normalizeEnum(value);
                return val in map ? map[val] : defaultValue
            }

            function normalizeLayoutOptions(options) {
                var side = pickValue(options.side, sideMap, 1),
                    alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
                return {
                    side: side,
                    primary: bringToEdge(alignment[side]),
                    secondary: alignment[1 - side],
                    weak: options.weak
                }
            }

            function bringToEdge(primary) {
                return primary < 2 ? 0 : 2
            }

            function getConjugateSide(side) {
                return 1 - side
            }

            function getOppositeAlignment(alignment) {
                return 2 - alignment
            }

            function getSlice(alignment, a, b, size) {
                return slicersMap[alignment](a, b, size)
            }

            function getShrink(alignment, size) {
                return (alignment > 0 ? -1 : 1) * size
            }

            function processForward(item, rect) {
                var side = item.side,
                    size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]),
                    isValid = size[side] < rect[2 + side] - rect[side];
                if (isValid) {
                    rect[item.primary + side] += getShrink(item.primary, size[side]);
                    item.size = size
                }
                return isValid
            }

            function processBackward(item, rect) {
                var primarySide = item.side,
                    secondarySide = getConjugateSide(primarySide),
                    itemRect = [],
                    secondary = getSlice(item.secondary, rect[secondarySide], rect[2 + secondarySide], item.size[secondarySide]);
                itemRect[primarySide] = itemRect[2 + primarySide] = rect[item.primary + primarySide];
                itemRect[item.primary + primarySide] = rect[item.primary + primarySide] -= getShrink(item.primary, item.size[primarySide]);
                itemRect[secondarySide] = secondary[0];
                itemRect[2 + secondarySide] = secondary[1];
                item.element.move(itemRect)
            }

            function Layout() {
                this._targets = []
            }
            Layout.prototype = {
                constructor: Layout,
                dispose: function() {
                    this._targets = null
                },
                add: function(target) {
                    this._targets.push(target)
                },
                forward: function(targetRect) {
                    var i, rect = targetRect.slice(),
                        targets = createTargets(this._targets),
                        ii = targets.length,
                        cache = [];
                    for (i = 0; i < ii; ++i) {
                        if (processForward(targets[i], rect)) {
                            cache.push(targets[i])
                        }
                    }
                    this._cache = cache.reverse();
                    return rect
                },
                backward: function(targetRect) {
                    var i, rect = targetRect.slice(),
                        targets = this._cache,
                        ii = targets.length;
                    for (i = 0; i < ii; ++i) {
                        processBackward(targets[i], rect)
                    }
                    this._cache = null
                }
            };

            function createTargets(targets) {
                var i, layout, ii = targets.length,
                    collection = [];
                for (i = 0; i < ii; ++i) {
                    layout = targets[i].layoutOptions();
                    if (layout) {
                        layout = normalizeLayoutOptions(layout);
                        layout.element = targets[i];
                        collection.push(layout)
                    }
                }
                processWeakItems(collection);
                return collection
            }

            function processWeakItems(collection) {
                var i, ii, j, weakItem, isProcessed = true;
                while (isProcessed) {
                    isProcessed = false;
                    ii = collection.length;
                    for (i = 0; i < ii; ++i) {
                        if (collection[i].weak) {
                            weakItem = collection[i];
                            for (j = 0; j < ii; ++j) {
                                if (i !== j && weakItem.side === collection[j].side && weakItem.primary === collection[j].primary) {
                                    collection[_min(i, j)] = makePair(collection[_min(i, j)], collection[_max(i, j)]);
                                    collection.splice(_max(i, j), 1);
                                    isProcessed = true;
                                    break
                                }
                            }
                            if (isProcessed) {
                                break
                            }
                        }
                    }
                }
            }

            function makePair(first, second) {
                return {
                    side: first.side,
                    primary: first.primary,
                    secondary: first.secondary === second.secondary ? first.secondary : bringToEdge(first.secondary) || bringToEdge(second.secondary),
                    element: new PairElement(first, second)
                }
            }

            function PairElement(first, second) {
                this._first = first;
                this._second = second
            }
            PairElement.prototype.measure = function(targetSize) {
                var secondSize, first = this._first,
                    second = this._second,
                    size = targetSize.slice(),
                    primarySide = first.side,
                    secondarySide = getConjugateSide(primarySide),
                    firstSize = first.element.measure(size.slice());
                size[secondarySide] -= firstSize[secondarySide];
                secondSize = second.element.measure(size.slice());
                size[primarySide] = _max(firstSize[primarySide], secondSize[primarySide]);
                if (first.secondary === second.secondary) {
                    size[secondarySide] = firstSize[secondarySide] + secondSize[secondarySide]
                } else {
                    if (first.secondary === ALIGN_MIDDLE || second.secondary === ALIGN_MIDDLE) {
                        size[secondarySide] = targetSize[secondarySide] / 2 + (first.secondary === ALIGN_MIDDLE ? firstSize : secondSize)[secondarySide] / 2
                    } else {
                        size[secondarySide] = targetSize[secondarySide]
                    }
                }
                first.size = firstSize;
                second.size = secondSize;
                return size
            };
            PairElement.prototype.move = function(targetRect) {
                var primary, secondary, rect, first = this._first,
                    second = this._second,
                    primarySide = first.side,
                    secondarySide = getConjugateSide(primarySide),
                    alignment = first.secondary === second.secondary ? bringToEdge(first.secondary) : first.secondary === ALIGN_MIDDLE ? getOppositeAlignment(bringToEdge(second.secondary)) : bringToEdge(first.secondary);
                primary = getSlice(ALIGN_MIDDLE, targetRect[primarySide], targetRect[2 + primarySide], first.size[primarySide]);
                secondary = getSlice(alignment, targetRect[secondarySide], targetRect[2 + secondarySide], first.size[secondarySide]);
                rect = [];
                rect[primarySide] = primary[0];
                rect[2 + primarySide] = primary[1];
                rect[secondarySide] = secondary[0];
                rect[2 + secondarySide] = secondary[1];
                first.element.move(rect);
                primary = getSlice(ALIGN_MIDDLE, targetRect[primarySide], targetRect[2 + primarySide], second.size[primarySide]);
                secondary = getSlice(getOppositeAlignment(alignment), targetRect[secondarySide], targetRect[2 + secondarySide], targetRect[2 + secondarySide] - targetRect[secondarySide] - first.size[secondarySide]);
                secondary = getSlice(getOppositeAlignment(alignment), secondary[0], secondary[1], second.size[secondarySide]);
                rect = [];
                rect[primarySide] = primary[0];
                rect[2 + primarySide] = primary[1];
                rect[secondarySide] = secondary[0];
                rect[2 + secondarySide] = secondary[1];
                second.element.move(rect)
            };
            module.exports = Layout
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/core/renderers/animation.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var animationFrame = __webpack_require__( /*! ../../../animation/frame */ 75),
                noop = function() {},
                easingFunctions = {
                    easeOutCubic: function(pos, start, end) {
                        return 1 === pos ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
                    },
                    linear: function(pos, start, end) {
                        return 1 === pos ? end : pos * (end - start) + +start
                    }
                };
            exports.easingFunctions = easingFunctions;
            var animationSvgStep = {
                segments: function(elem, params, progress, easing, currentParams) {
                    var curSeg, seg, i, j, from = params.from,
                        to = params.to,
                        segments = [];
                    for (i = 0; i < from.length; i++) {
                        curSeg = from[i];
                        seg = [curSeg[0]];
                        if (curSeg.length > 1) {
                            for (j = 1; j < curSeg.length; j++) {
                                seg.push(easing(progress, curSeg[j], to[i][j]))
                            }
                        }
                        segments.push(seg)
                    }
                    currentParams.segments = params.end && 1 === progress ? params.end : segments;
                    elem.attr({
                        segments: segments
                    })
                },
                arc: function(elem, params, progress, easing) {
                    var from = params.from,
                        to = params.to,
                        current = {};
                    for (var i in from) {
                        current[i] = easing(progress, from[i], to[i])
                    }
                    elem.attr(current)
                },
                transform: function(elem, params, progress, easing, currentParams) {
                    var from = params.from,
                        to = params.to,
                        current = {};
                    for (var i in from) {
                        current[i] = currentParams[i] = easing(progress, from[i], to[i])
                    }
                    elem.attr(current)
                },
                base: function(elem, params, progress, easing, currentParams, attributeName) {
                    var obj = {};
                    obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
                    elem.attr(obj)
                },
                _: noop,
                complete: function(element, currentSettings) {
                    element.attr(currentSettings)
                }
            };

            function step(now) {
                var attrName, that = this,
                    animateStep = that._animateStep;
                that._progress = that._calcProgress(now);
                for (attrName in that.params) {
                    var anim = animateStep[attrName] || animateStep.base;
                    anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName)
                }
                that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
                if (1 === that._progress) {
                    return that.stop()
                }
                return true
            }

            function start(now) {
                this._startTime = now;
                this.tick = step;
                return true
            }

            function Animation(element, params, options) {
                var that = this;
                that._progress = 0;
                that.element = element;
                that.params = params;
                that.options = options;
                that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
                that._animateStep = options.animateStep || animationSvgStep;
                that._easing = easingFunctions[options.easing] || easingFunctions.easeOutCubic;
                that._currentParams = {};
                that.tick = start
            }
            Animation.prototype = {
                _calcProgress: function(now) {
                    return Math.min(1, (now - this._startTime) / this.duration)
                },
                stop: function(disableComplete) {
                    var that = this,
                        options = that.options,
                        animateStep = that._animateStep;
                    that.stop = that.tick = noop;
                    animateStep.complete && animateStep.complete(that.element, that._currentParams);
                    options.complete && !disableComplete && options.complete()
                }
            };

            function AnimationController(element) {
                var that = this;
                that._animationCount = 0;
                that._timerId = null;
                that._animations = {};
                that.element = element
            }
            exports.AnimationController = AnimationController;
            AnimationController.prototype = {
                _loop: function() {
                    var an, that = this,
                        animations = that._animations,
                        activeAnimation = 0,
                        now = (new Date).getTime(),
                        endAnimation = that._endAnimation;
                    for (an in animations) {
                        if (!animations[an].tick(now)) {
                            delete animations[an]
                        }
                        activeAnimation++
                    }
                    if (0 === activeAnimation) {
                        that.stop();
                        that._endAnimationTimer = endAnimation && setTimeout(function() {
                            if (0 === that._animationCount) {
                                endAnimation();
                                that._endAnimation = null
                            }
                        });
                        return
                    }
                    that._timerId = animationFrame.requestAnimationFrame.call(null, function() {
                        that._loop()
                    }, that.element)
                },
                addAnimation: function(animation) {
                    var that = this;
                    that._animations[that._animationCount++] = animation;
                    clearTimeout(that._endAnimationTimer);
                    if (!that._timerId) {
                        clearTimeout(that._startDelay);
                        that._startDelay = setTimeout(function() {
                            that._timerId = 1;
                            that._loop()
                        }, 0)
                    }
                },
                animateElement: function(elem, params, options) {
                    if (elem && params && options) {
                        elem.animation && elem.animation.stop();
                        this.addAnimation(elem.animation = new Animation(elem, params, options))
                    }
                },
                onEndAnimation: function(endAnimation) {
                    this._animationCount ? this._endAnimation = endAnimation : endAnimation()
                },
                dispose: function() {
                    this.stop();
                    this.element = null
                },
                stop: function() {
                    var that = this;
                    that._animations = {};
                    that._animationCount = 0;
                    animationFrame.cancelAnimationFrame(that._timerId);
                    clearTimeout(that._startDelay);
                    clearTimeout(that._endAnimationTimer);
                    that._timerId = null
                },
                lock: function() {
                    var an, unstoppable, hasUnstoppableInAnimations, animations = this._animations;
                    for (an in animations) {
                        unstoppable = animations[an].options.unstoppable;
                        hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;
                        if (!unstoppable) {
                            animations[an].stop(true);
                            delete animations[an]
                        }
                    }!hasUnstoppableInAnimations && this.stop()
                }
            };
            exports.animationSvgStep = animationSvgStep;
            exports.Animation = Animation;
            exports.noop = noop
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!****************************************************!*\
      !*** ./Scripts/viz/core/renderers/vml_renderer.js ***!
      \****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                svgRendererModule = __webpack_require__( /*! ./svg_renderer */ 261),
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                doc = document,
                math = Math,
                mathMin = math.min,
                mathMax = math.max,
                mathFloor = math.floor,
                mathSin = math.sin,
                mathCos = math.cos,
                isDefined = commonUtils.isDefined,
                _each = $.each,
                _normalizeEnum = __webpack_require__( /*! ../utils */ 6).normalizeEnum,
                baseElementPrototype = svgRendererModule.SvgElement.prototype,
                documentFragment = doc.createDocumentFragment(),
                STROKEWIDTH = "stroke-width",
                XMLNS = "urn:schemas-microsoft-com:vml",
                DEFAULT_STYLE = {
                    behavior: "url(#default#VML)",
                    display: "inline-block",
                    position: "absolute"
                },
                DEFAULT_ATTRS = {
                    xmlns: XMLNS
                },
                INHERITABLE_PROPERTIES = {
                    stroke: true,
                    fill: true,
                    opacity: true,
                    "stroke-width": true,
                    align: true,
                    dashStyle: true,
                    "stroke-opacity": true,
                    "fill-opacity": true,
                    rotate: true,
                    rotateX: true,
                    rotateY: true
                },
                stub = function() {},
                stubReturnedThis = function() {
                    return this
                },
                svgToVmlConv = {
                    circle: "oval",
                    g: "div",
                    path: "shape",
                    text: "span"
                },
                FONT_HEIGHT_OFFSET_K = .775,
                DEFAULTS = {
                    scaleX: 1,
                    scaleY: 1
                },
                pathAttr = svgRendererModule._createPathAttr(vmlAttr),
                arcAttr = svgRendererModule._createArcAttr(vmlAttr, buildArcPath),
                rectAttr = svgRendererModule._createRectAttr(vmlAttr),
                applyEllipsis = svgRendererModule._getEllipsis(prepareLines, setNewText, removeTextSpan);

            function extend(a, b) {
                for (var key in b) {
                    a[key] = b[key]
                }
                return a
            }

            function inArray(array, elem) {
                var i = 0;
                for (; i < array.length; i++) {
                    if (elem === array[i]) {
                        return i
                    }
                }
                return -1
            }

            function buildArcPath(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag, noArc) {
                var xOuterStart = x + outerR * startAngleCos,
                    yOuterStart = y - outerR * startAngleSin,
                    xOuterEnd = x + outerR * endAngleCos,
                    yOuterEnd = y - outerR * endAngleSin,
                    xInnerStart = x + innerR * endAngleCos,
                    yInnerStart = y - innerR * endAngleSin,
                    xInnerEnd = x + innerR * startAngleCos,
                    yInnerEnd = y - innerR * startAngleSin;
                return !noArc ? ["wr", mathFloor(x - innerR), mathFloor(y - innerR), mathFloor(x + innerR), mathFloor(y + innerR), mathFloor(xInnerStart), mathFloor(yInnerStart), mathFloor(xInnerEnd), mathFloor(yInnerEnd), isCircle ? "wr " : "at ", mathFloor(x - outerR), mathFloor(y - outerR), mathFloor(x + outerR), mathFloor(y + outerR), mathFloor(xOuterStart), mathFloor(yOuterStart), mathFloor(xOuterEnd), mathFloor(yOuterEnd), "x e"].join(" ") : "m 0 0 x e"
            }

            function getInheritSettings(settings) {
                var prop, value, result = {};
                for (prop in INHERITABLE_PROPERTIES) {
                    value = settings[prop];
                    void 0 !== value && (result[prop] = value)
                }
                return result
            }

            function correctBoundingRectWithStrokeWidth(rect, strokeWidth) {
                strokeWidth = Math.ceil(parseInt(strokeWidth) / 2);
                if (strokeWidth && strokeWidth > 1) {
                    rect.left -= strokeWidth;
                    rect.top -= strokeWidth;
                    rect.right += strokeWidth;
                    rect.bottom += strokeWidth
                }
                return rect
            }

            function shapeBBox() {
                var i, value, points = (this._settings.d || "").match(/[-0-9]+/g),
                    resultRect = {};
                for (i = 0; i < points.length; i++) {
                    value = parseInt(points[i]);
                    if (i % 2) {
                        resultRect.top = void 0 === resultRect.top || value < resultRect.top ? value : resultRect.top;
                        resultRect.bottom = void 0 === resultRect.bottom || value > resultRect.bottom ? value : resultRect.bottom
                    } else {
                        resultRect.left = void 0 === resultRect.left || value < resultRect.left ? value : resultRect.left;
                        resultRect.right = void 0 === resultRect.right || value > resultRect.right ? value : resultRect.right
                    }
                }
                resultRect.left = resultRect.left || 0;
                resultRect.top = resultRect.top || 0;
                resultRect.right = resultRect.right || 0;
                resultRect.bottom = resultRect.bottom || 0;
                return correctBoundingRectWithStrokeWidth(resultRect, this._fullSettings[STROKEWIDTH])
            }

            function baseAttr(that, attrs, inh) {
                var value, key, appliedAttr, elem, element = that.element,
                    settings = that._settings,
                    fullSettings = that._fullSettings,
                    params = {
                        style: {}
                    };
                if ("string" === typeof attrs) {
                    if (attrs in settings) {
                        return settings[attrs]
                    }
                    if (attrs in DEFAULTS) {
                        return DEFAULTS[attrs]
                    }
                    return 0
                }
                if (attrs && "transparent" === attrs.fill) {
                    attrs.fill = "none"
                }
                for (key in attrs) {
                    value = attrs[key];
                    if (void 0 === value) {
                        continue
                    }
                    appliedAttr = fullSettings[key];
                    !inh && (settings[key] = value);
                    fullSettings[key] = value;
                    if (INHERITABLE_PROPERTIES[key]) {
                        value = null === value ? that._parent && that._parent._fullSettings[key] || value : value
                    }
                    appliedAttr !== value && that.processAttr(element, key, value, params)
                }
                that._applyTransformation(params);
                that.css(params.style);
                for (var i = 0; i < that._children.length; i++) {
                    elem = that._children[i];
                    elem !== that._clipRect && elem.attr(extend(getInheritSettings(that._fullSettings), elem._settings), true);
                    elem._applyStyleSheet()
                }!inh && that._applyStyleSheet();
                if (element) {
                    if (element.strokecolor && "none" !== element.strokecolor.value && element.strokeweight) {
                        element.stroked = "t"
                    } else {
                        element.stroked = "f"
                    }
                }
                return that
            }

            function vmlAttr(that, attrs, inh) {
                var elem = that.element,
                    result = baseAttr(that, attrs, inh);
                for (var i = 0; i < elem.childNodes.length; i++) {
                    elem.childNodes[i].xmlns = XMLNS;
                    elem.childNodes[i].style.behavior = "url(#default#VML)";
                    elem.childNodes[i].style.display = "inline-block"
                }
                return result
            }

            function processVmlAttr(element, attr, value, params) {
                switch (attr) {
                    case "stroke":
                        value = value || "none";
                        attr += "color";
                        break;
                    case "fill":
                        value = value || "none";
                        element.filled = "none" === value ? "f" : "t";
                        attr += "color";
                        break;
                    case STROKEWIDTH:
                        attr = "strokeweight";
                        value += "px";
                        break;
                    case "stroke-linejoin":
                        element.stroke.joinstyle = value;
                        return;
                    case "stroke-linecap":
                        element.stroke.endcap = "butt" === value ? "flat" : value;
                        return;
                    case "opacity":
                        value = adjustOpacityValue(value);
                        element.fill.opacity = value;
                        element.stroke.opacity = value;
                        return;
                    case "fill-opacity":
                        element.fill.opacity = adjustOpacityValue(value);
                        return;
                    case "stroke-opacity":
                        element.stroke.opacity = adjustOpacityValue(value);
                        return;
                    case "dashStyle":
                        if (null === value) {
                            element.stroke[attr] = ""
                        } else {
                            value = _normalizeEnum(value);
                            if ("solid" === value || "none" === value) {
                                value = ""
                            } else {
                                value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "")
                            }
                            element.stroke[attr] = value
                        }
                        return;
                    case "d":
                        attr = "path";
                        value = _normalizeEnum(value).replace("z", "x e").replace(/([.]\d+)/g, "");
                        break;
                    case "href":
                        attr = "src";
                        break;
                    case "width":
                    case "height":
                    case "visibility":
                        params.style[attr] = value || "";
                        return;
                    case "class":
                        attr += "Name";
                        break;
                    case "translateX":
                    case "translateY":
                    case "rotate":
                    case "rotateX":
                    case "rotateY":
                    case "scale":
                    case "scaleX":
                    case "scaleY":
                    case "x":
                    case "y":
                        return
                }
                element[attr] = value
            }

            function adjustOpacityValue(value) {
                return value >= .002 ? value : null === value ? 1 : .002
            }

            function createElement(tagName) {
                var element = document.createElement(tagName);
                return documentFragment.appendChild(element)
            }
            var VmlElement = function() {
                this.ctor.apply(this, arguments)
            };

            function processAttr(element, attr, value, params) {
                if (!INHERITABLE_PROPERTIES[attr]) {
                    if ("visibility" === attr) {
                        params.style[attr] = value || ""
                    } else {
                        if ("width" === attr || "height" === attr) {
                            params.style[attr] = value
                        } else {
                            if ("clipId" === attr) {
                                this.applyClipID(value)
                            } else {
                                if ("translateX" === attr || "translateY" === attr || "x" === attr || "y" === attr) {
                                    return
                                } else {
                                    if ("class" === attr) {
                                        element.className = value
                                    } else {
                                        element[attr] = value
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function prepareLines(element) {
                var lines = [{
                        commonLength: 0,
                        parts: []
                    }],
                    lineIndex = 0;
                _each(element.childNodes || [], function(i, text) {
                    if ("BR" !== text.nodeName) {
                        var length = lines[lineIndex].commonLength,
                            textContent = $(text).text();
                        lines[lineIndex].parts.push({
                            span: text,
                            startIndex: length ? length + 1 : 0,
                            endIndex: length + textContent.length
                        });
                        lines[lineIndex].commonLength += textContent.length
                    } else {
                        lines.push({
                            commonLength: 0,
                            parts: []
                        });
                        lineIndex++
                    }
                });
                return lines
            }

            function setNewText(text, index) {
                var newText = $(text.span).text().substr(0, index) + "...";
                if ("#text" === text.span.nodeName) {
                    text.span.data = newText
                } else {
                    text.span.innerHTML = newText
                }
            }

            function removeTextSpan(text) {
                text.span.parentNode.removeChild(text.span)
            }
            var elementMixin = {
                div: {
                    processAttr: processAttr,
                    attr: function(attrs, inh) {
                        return baseAttr(this, attrs, inh)
                    },
                    _applyTransformation: function(params) {
                        var style = params.style,
                            settings = this._settings,
                            fullSettings = this._fullSettings;
                        if (fullSettings.rotate) {
                            fullSettings.rotateX = fullSettings.rotateX || 0;
                            fullSettings.rotateY = fullSettings.rotateY || 0
                        }
                        style.left = (settings.x || 0) + (settings.translateX || 0);
                        style.top = (settings.y || 0) + (settings.translateY || 0)
                    },
                    _getBBox: function() {
                        var child, translateX, translateY, childBBox, childSettings, left = 1 / 0,
                            top = 1 / 0,
                            right = -(1 / 0),
                            bottom = -(1 / 0),
                            i = 0,
                            children = this._children;
                        if (!children.length) {
                            left = top = bottom = right = 0
                        } else {
                            for (; i < children.length; i++) {
                                child = children[i];
                                if (child === this._clipRect) {
                                    continue
                                }
                                translateX = child._fullSettings.translateX || 0;
                                translateY = child._fullSettings.translateY || 0;
                                childSettings = child._fullSettings;
                                childBBox = child._getBBox();
                                left = mathMin(left, childBBox.left + translateX);
                                right = mathMax(right, childBBox.right + translateX);
                                top = mathMin(top, childBBox.top + translateY);
                                bottom = mathMax(bottom, childBBox.bottom + translateY)
                            }
                        }
                        return {
                            left: left,
                            right: right,
                            top: top,
                            bottom: bottom
                        }
                    },
                    defaultAttrs: {},
                    defaultStyle: {
                        position: "absolute"
                    }
                },
                shape: {
                    defaultAttrs: extend({
                        coordsize: "1,1",
                        "stroke-linejoin": "miter"
                    }, DEFAULT_ATTRS),
                    defaultStyle: extend({
                        width: 1,
                        height: 1
                    }, DEFAULT_STYLE),
                    _getBBox: shapeBBox
                },
                image: {
                    processAttr: function(element, attr, value, params) {
                        if ("fill" === attr || "stroke" === attr) {
                            return
                        }
                        processVmlAttr(element, attr, value, params)
                    }
                },
                oval: {
                    processAttr: function(element, attr, value, params) {
                        if ("cx" === attr || "cy" === attr) {
                            attr = attr[1]
                        } else {
                            if ("r" === attr) {
                                value *= 2;
                                processVmlAttr(element, "width", value, params);
                                attr = "height"
                            } else {
                                if ("x" === attr || "y" === attr) {
                                    return
                                }
                            }
                        }
                        processVmlAttr(element, attr, value, params)
                    },
                    _getBBox: function() {
                        var settings = this._fullSettings,
                            x = settings.cx || 0,
                            y = settings.cy || 0,
                            r = settings.r || 0;
                        return correctBoundingRectWithStrokeWidth({
                            left: x - r,
                            top: y - r,
                            right: x + r,
                            bottom: y + r
                        }, settings[STROKEWIDTH] || 1)
                    }
                },
                span: {
                    defaultAttrs: {},
                    defaultStyle: {
                        position: "absolute",
                        whiteSpace: "nowrap"
                    },
                    processAttr: function(element, attr, value, params) {
                        if ("text" === attr) {
                            value = isDefined(value) ? value.toString().replace(/\r/g, "") : "";
                            if (this.renderer.encodeHtml) {
                                value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;")
                            }
                            element.innerHTML = value.replace(/\n/g, "<br/>");
                            this.css({
                                filter: ""
                            });
                            this._bbox = null
                        } else {
                            processAttr(element, attr, value, params)
                        }
                    },
                    attr: function(attrs, inh) {
                        return baseAttr(this, attrs, inh)
                    },
                    applyEllipsis: applyEllipsis,
                    _applyTransformation: function(params) {
                        this.element.offsetHeight;
                        var radianAngle, that = this,
                            style = params.style,
                            settings = that._fullSettings,
                            x = isDefined(settings.x) ? settings.x : 0,
                            y = isDefined(settings.y) ? settings.y : 0,
                            bbox = that._bbox || that.element.getBoundingClientRect(),
                            textHeight = bbox.bottom - bbox.top,
                            textWidth = bbox.right - bbox.left,
                            rotateAngle = settings.rotate,
                            cos = 1,
                            sin = 0,
                            rotateX = isDefined(settings.rotateX) ? settings.rotateX : x,
                            rotateY = isDefined(settings.rotateY) ? settings.rotateY : y,
                            marginLeft = 0,
                            marginTop = 0,
                            fontHeightOffset = textHeight * FONT_HEIGHT_OFFSET_K,
                            filter = "",
                            alignMultiplier = {
                                center: .5,
                                right: 1
                            }[settings.align],
                            opacity = this._styles.opacity || settings.opacity || settings["fill-opacity"];
                        if (textHeight && textWidth) {
                            if (rotateAngle) {
                                radianAngle = rotateAngle * Math.PI / 180;
                                cos = mathCos(radianAngle);
                                sin = mathSin(radianAngle);
                                marginLeft = (x - rotateX) * cos - (y - rotateY) * sin + rotateX - x;
                                marginTop = (x - rotateX) * sin + (y - rotateY) * cos + rotateY - y;
                                filter = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + cos.toFixed(5) + ", M12 = " + (-sin).toFixed(5) + ", M21 = " + sin.toFixed(5) + ", M22 = " + cos.toFixed(5) + ")"
                            }
                            if (rotateAngle < 90) {
                                marginTop -= fontHeightOffset * cos;
                                marginLeft -= (textHeight - fontHeightOffset) * sin
                            } else {
                                if (rotateAngle < 180) {
                                    marginTop += (textHeight - fontHeightOffset) * cos;
                                    marginLeft += textWidth * cos - (textHeight - fontHeightOffset) * sin
                                } else {
                                    if (rotateAngle < 270) {
                                        marginTop += (textHeight - fontHeightOffset) * cos + textWidth * sin;
                                        marginLeft += textWidth * cos + fontHeightOffset * sin
                                    } else {
                                        marginTop += textWidth * sin - fontHeightOffset * cos;
                                        marginLeft += fontHeightOffset * sin
                                    }
                                }
                            }
                            if (rotateAngle && this.renderer.rtl) {
                                marginLeft -= textWidth - (textHeight * Math.abs(sin) + textWidth * Math.abs(cos))
                            }
                            if (alignMultiplier) {
                                marginLeft -= textWidth * alignMultiplier * cos;
                                marginTop -= textWidth * alignMultiplier * sin
                            }
                            if (isDefined(opacity)) {
                                filter += " progid:DXImageTransform.Microsoft.Alpha(Opacity=" + 100 * opacity + ")"
                            }
                            x += marginLeft;
                            y += marginTop;
                            this._bbox = bbox;
                            style.filter = (style.filter || "") + filter;
                            style.left = x + (settings.translateX || 0);
                            style.top = y + (settings.translateY || 0)
                        }
                    },
                    _getBBox: function() {
                        var element = this.element,
                            settings = this._fullSettings,
                            parentRect = (element.parentNode && element.parentNode.getBoundingClientRect ? element.parentNode : this.renderer.root.element).getBoundingClientRect(),
                            boundingRect = element.getBoundingClientRect(),
                            left = boundingRect.left - (settings.translateX || 0) - parentRect.left,
                            top = boundingRect.top - (settings.translateY || 0) - parentRect.top;
                        return {
                            left: left,
                            top: top,
                            right: left + element.offsetWidth,
                            bottom: top + element.offsetHeight
                        }
                    }
                }
            };
            extend(VmlElement.prototype, baseElementPrototype);
            extend(VmlElement.prototype, {
                defaultStyle: DEFAULT_STYLE,
                defaultAttrs: DEFAULT_ATTRS,
                ctor: function(renderer, tagName, type) {
                    var that = this,
                        tagPrefix = "<";
                    that.renderer = renderer;
                    that.type = type || "line";
                    that._children = [];
                    that._settings = {};
                    that._fullSettings = {};
                    that._styles = {};
                    if ("div" !== tagName && "span" !== tagName) {
                        tagPrefix = "<vml:"
                    }
                    if ("shape" === tagName) {
                        if ("arc" === that.type) {
                            that.attr = arcAttr
                        } else {
                            that.attr = pathAttr
                        }
                    } else {
                        if ("rect" === tagName) {
                            that.attr = rectAttr
                        }
                    }
                    extend(that, elementMixin[tagName]);
                    that.element = createElement(tagPrefix + tagName + "/>");
                    that.css(that.defaultStyle).attr(that.defaultAttrs);
                    that._$element = $(that.element)
                },
                dispose: function() {
                    this.remove();
                    this._$element.remove();
                    return this
                },
                attr: function(attrs, inh) {
                    return vmlAttr(this, attrs, inh)
                },
                processAttr: processVmlAttr,
                css: function(css) {
                    var value, appliedValue, key, elem = this.element;
                    for (key in css) {
                        appliedValue = this._styles[key];
                        value = css[key];
                        if (!isDefined(value)) {
                            continue
                        }
                        this._styles[key] = value;
                        if (appliedValue === value) {
                            continue
                        }
                        switch (key) {
                            case "fill":
                                key = "color";
                                break;
                            case "font-size":
                                key = "fontSize";
                                if ("number" === typeof value) {
                                    value += "px"
                                }
                                break;
                            case "font-weight":
                                key = "fontWeight";
                                break;
                            case "z-index":
                                key = "zIndex";
                                break;
                            case "opacity":
                                continue
                        }
                        try {
                            elem.style[key] = value
                        } catch (_) {
                            continue
                        }
                    }
                    return this
                },
                applyClipID: function(id) {
                    var clipRect, cssValue, renderer = this.renderer;
                    clipRect = renderer.getClipRect(id);
                    if (clipRect) {
                        cssValue = clipRect.getValue();
                        clipRect.addElement(this)
                    } else {
                        cssValue = "rect(-9999px 9999px 9999px -9999px)"
                    }
                    this._clipRect = this._clipRect || renderer.rect(0, 0, 0, 0).attr({
                        "class": "dxc-vml-clip",
                        fill: "none",
                        opacity: .001
                    });
                    this._clipRect.attr({
                        width: renderer.root.attr("width"),
                        height: renderer.root.attr("height")
                    });
                    this.css({
                        clip: cssValue,
                        width: renderer.root.attr("width"),
                        height: renderer.root.attr("height")
                    })
                },
                _onAppended: function(parent) {
                    var that = this;
                    if (parent._children) {
                        that._parent = parent;
                        if (-1 === inArray(parent._children, that)) {
                            parent._children.push(that)
                        }
                        that.attr(extend(getInheritSettings(parent._fullSettings), that._settings), true)
                    }
                    that._applyStyleSheet();
                    if (parent._clipRect && that !== parent._clipRect) {
                        parent._clipRect.append(parent)
                    }
                },
                append: function(parent) {
                    baseElementPrototype.append.apply(this, arguments);
                    this._onAppended(parent || this.renderer.root);
                    return this
                },
                _insert: function(parent) {
                    baseElementPrototype._insert.apply(this, arguments);
                    this._onAppended(parent)
                },
                _applyTransformation: function(params) {
                    var that = this,
                        style = params.style,
                        element = that.element,
                        settings = that._fullSettings,
                        x = "arc" !== that.type ? settings.x || settings.cx - settings.r || 0 : 0,
                        y = "arc" !== that.type ? settings.y || settings.cy - settings.r || 0 : 0;
                    if (settings.rotate) {
                        var radianAngle = settings.rotate * Math.PI / 180,
                            rotateX = isDefined(settings.rotateX) ? settings.rotateX : x,
                            rotateY = isDefined(settings.rotateY) ? settings.rotateY : y,
                            rx = x + (settings.width || 0 || parseInt(element.style.width || 0)) / 2,
                            ry = y + (settings.height || 0 || parseInt(element.style.height || 0)) / 2,
                            cos = mathCos(radianAngle),
                            sin = mathSin(radianAngle),
                            marginLeft = (rx - rotateX) * cos - (ry - rotateY) * sin + rotateX - rx,
                            marginTop = (rx - rotateX) * sin + (ry - rotateY) * cos + rotateY - ry;
                        x += marginLeft;
                        y += marginTop;
                        style.rotation = settings.rotate
                    }
                    style.left = x + (settings.translateX || 0);
                    style.top = y + (settings.translateY || 0)
                },
                remove: function() {
                    var parent = this._parent;
                    parent && parent._children.splice(inArray(parent._children, this), 1);
                    this._parent = null;
                    return baseElementPrototype.remove.apply(this, arguments)
                },
                clear: function() {
                    this._children = [];
                    return baseElementPrototype.clear.apply(this, arguments)
                },
                getBBox: function() {
                    var clientRect = this._getBBox(),
                        x = clientRect.left,
                        y = clientRect.top,
                        width = clientRect.right - x,
                        height = clientRect.bottom - y;
                    return {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        isEmpty: !x && !y && !width && !height
                    }
                },
                _getBBox: function() {
                    var element = this.element,
                        settings = this._fullSettings,
                        x = settings.x || 0,
                        y = settings.y || 0,
                        width = parseInt(element.style.width || 0),
                        height = parseInt(element.style.height || 0);
                    return correctBoundingRectWithStrokeWidth({
                        left: x,
                        top: y,
                        right: x + width,
                        bottom: y + height
                    }, settings[STROKEWIDTH] || 1)
                },
                _applyStyleSheet: function() {
                    if (this._useCSSTheme) {
                        this.attr(getInheritSettings(this.element.currentStyle), true)
                    }
                },
                setTitle: function(text) {
                    this.element.setAttribute("title", text)
                }
            });
            var ClipRect = function() {
                this.ctor.apply(this, arguments)
            };
            extend(ClipRect.prototype, VmlElement.prototype);
            extend(ClipRect.prototype, {
                ctor: function(renderer, id) {
                    this._settings = this._fullSettings = {};
                    this.renderer = renderer;
                    this._children = [];
                    this._elements = [];
                    this.id = id
                },
                attr: function(attrs, inh) {
                    var element, i, result = baseAttr(this, attrs, inh),
                        elements = this._elements.slice();
                    if (result === this) {
                        for (i = 0; i < elements.length; i++) {
                            element = elements[i];
                            if (element._fullSettings.clipId === this.id) {
                                elements[i].applyClipID(this.id)
                            } else {
                                this.removeElement(element)
                            }
                        }
                    }
                    return result
                },
                processAttr: stub,
                _applyTransformation: stub,
                append: stubReturnedThis,
                dispose: function() {
                    this._elements = null;
                    this.renderer.removeClipRect(this.id);
                    return this
                },
                addElement: function(element) {
                    var elements = this._elements;
                    if (-1 === inArray(elements, element)) {
                        elements.push(element)
                    }
                },
                removeElement: function(element) {
                    var index = inArray(this._elements, element);
                    index > -1 && this._elements.splice(index, 1)
                },
                getValue: function() {
                    var settings = this._settings,
                        left = (settings.x || 0) + (settings.translateX || 0),
                        top = (settings.y || 0) + (settings.translateY || 0);
                    return "rect(" + top + "px, " + (left + (settings.width || 0)) + "px, " + (top + (settings.height || 0)) + "px, " + left + "px)"
                },
                css: stubReturnedThis,
                remove: stubReturnedThis
            });

            function VmlRenderer() {
                svgRendererModule.SvgRenderer.apply(this, arguments)
            }
            extend(VmlRenderer.prototype, svgRendererModule.SvgRenderer.prototype);
            extend(VmlRenderer.prototype, {
                constructor: VmlRenderer,
                _rootTag: "div",
                _rootAttr: {
                    fill: "none",
                    stroke: "none",
                    "stroke-width": 0
                },
                _rootCss: {
                    position: "relative",
                    display: "inline-block",
                    overflow: "hidden"
                },
                _init: function() {
                    this._clipRects = [];
                    this._animationController = {
                        dispose: stubReturnedThis
                    };
                    this._animation = {
                        enabled: false
                    };
                    this._defs = {
                        clear: stubReturnedThis,
                        remove: stubReturnedThis,
                        append: stubReturnedThis,
                        dispose: stubReturnedThis
                    }
                },
                setOptions: function() {
                    svgRendererModule.SvgRenderer.prototype.setOptions.apply(this, arguments);
                    this.root.css({
                        direction: this.rtl ? "rtl" : "ltr"
                    });
                    return this
                },
                _createElement: function(tagName, attr, type) {
                    tagName = svgToVmlConv[tagName] || tagName;
                    var elem = new exports.VmlElement(this, tagName, type);
                    attr && elem.attr(attr);
                    return elem
                },
                shadowFilter: function() {
                    return {
                        ref: null,
                        append: stubReturnedThis,
                        dispose: stubReturnedThis,
                        attr: stubReturnedThis,
                        css: stubReturnedThis
                    }
                },
                clipRect: function(x, y, width, height) {
                    var clipRects = this._clipRects,
                        id = clipRects.length,
                        clipRect = new ClipRect(this, id).attr({
                            x: x || 0,
                            y: y || 0,
                            width: width || 0,
                            height: height || 0
                        });
                    clipRects.push(clipRect);
                    return clipRect
                },
                getClipRect: function(id) {
                    return this._clipRects[id]
                },
                removeClipRect: function(id) {
                    delete this._clipRects[id]
                },
                pattern: function(color) {
                    return {
                        id: color,
                        append: stubReturnedThis,
                        remove: stubReturnedThis,
                        dispose: stubReturnedThis
                    }
                },
                image: function(x, y, w, h, href, location) {
                    var image = this._createElement("image", {
                        x: x || 0,
                        y: y || 0,
                        width: w || 0,
                        height: h || 0,
                        location: location,
                        href: href
                    });
                    return image
                },
                rect: function(x, y, width, height) {
                    return this._createElement("rect", {
                        x: x || 0,
                        y: y || 0,
                        width: width || 0,
                        height: height || 0
                    })
                },
                path: function(points, type) {
                    return this._createElement("path", {
                        points: points || []
                    }, type)
                },
                arc: function(x, y, innerRadius, outerRadius, startAngle, endAngle) {
                    return this._createElement("path", {
                        x: x || 0,
                        y: y || 0,
                        innerRadius: innerRadius || 0,
                        outerRadius: outerRadius || 0,
                        startAngle: startAngle || 0,
                        endAngle: endAngle || 0
                    }, "arc")
                },
                text: function(text, x, y) {
                    return this._createElement("text", {
                        text: text,
                        x: x || 0,
                        y: y || 0
                    })
                },
                updateAnimationOptions: stubReturnedThis,
                stopAllAnimations: stubReturnedThis,
                svg: function() {
                    return ""
                },
                onEndAnimation: function(callback) {
                    callback()
                }
            });
            exports.VmlRenderer = VmlRenderer;
            exports.VmlElement = VmlElement;
            exports._VmlClipRect = ClipRect
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/viz/core/win.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var themeModule = __webpack_require__( /*! ../themes */ 69),
                registerTheme = themeModule.registerTheme,
                registerThemeSchemeAlias = themeModule.registerThemeSchemeAlias,
                BLACK = "#000000",
                WHITE = "#ffffff",
                WIN10_WHITE = "win10.white",
                WIN10_BLACK = "win10.black",
                WIN8_WHITE = "win8.white",
                WIN8_BLACK = "win8.black";
            registerTheme({
                name: WIN10_BLACK,
                backgroundColor: BLACK,
                primaryTitleColor: WHITE,
                secondaryTitleColor: "#d8d8d8",
                axisColor: "#4c4c4c",
                axisLabelColor: WHITE,
                title: {
                    font: {
                        color: WHITE
                    }
                },
                legend: {
                    font: {
                        color: WHITE
                    }
                },
                tooltip: {
                    color: BLACK,
                    font: {
                        color: WHITE
                    }
                },
                "chart:common": {
                    commonSeriesSettings: {
                        label: {
                            border: {
                                color: "#454545"
                            }
                        }
                    }
                },
                chart: {
                    commonPaneSettings: {
                        border: {
                            color: "#454545"
                        }
                    }
                },
                pieIE8: {
                    commonSeriesSettings: {
                        pie: {
                            hoverStyle: {
                                border: {
                                    color: BLACK
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BLACK
                                }
                            }
                        },
                        donut: {
                            hoverStyle: {
                                border: {
                                    color: BLACK
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BLACK
                                }
                            }
                        },
                        doughnut: {
                            hoverStyle: {
                                border: {
                                    color: BLACK
                                }
                            },
                            selectionStyle: {
                                border: {
                                    color: BLACK
                                }
                            }
                        }
                    }
                },
                barGauge: {
                    backgroundColor: "#2b3036"
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            color: WHITE,
                            opacity: .23
                        },
                        minorTick: {
                            color: WHITE,
                            opacity: .07
                        }
                    }
                }
            }, "generic.dark");
            registerTheme({
                name: WIN10_WHITE,
                backgroundColor: WHITE,
                primaryTitleColor: BLACK,
                secondaryTitleColor: "#767676",
                axisColor: "#ececec",
                axisLabelColor: BLACK,
                title: {
                    font: {
                        color: BLACK
                    }
                },
                legend: {
                    font: {
                        color: BLACK
                    }
                },
                tooltip: {
                    font: {
                        color: BLACK
                    }
                },
                rangeSelector: {
                    scale: {
                        tick: {
                            color: BLACK,
                            opacity: .1
                        },
                        minorTick: {
                            color: BLACK,
                            opacity: .03
                        }
                    }
                }
            }, "generic.light");
            registerThemeSchemeAlias("win10.dark", WIN10_BLACK);
            registerThemeSchemeAlias("win10.light", WIN10_WHITE);
            registerTheme({
                name: WIN8_BLACK
            }, WIN10_BLACK);
            registerTheme({
                name: WIN8_WHITE
            }, WIN10_WHITE);
            registerThemeSchemeAlias("win8.dark", WIN8_BLACK);
            registerThemeSchemeAlias("win8.light", WIN8_WHITE)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************!*\
      !*** ./Scripts/viz/export.js ***!
      \*******************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./core/export */ 127)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/viz/gauges/bar_gauge.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var PI_DIV_180 = Math.PI / 180,
                _abs = Math.abs,
                _round = Math.round,
                _floor = Math.floor,
                _min = Math.min,
                _max = Math.max,
                $ = __webpack_require__( /*! jquery */ 1),
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                baseGaugeModule = __webpack_require__( /*! ./base_gauge */ 128),
                dxBaseGauge = baseGaugeModule.dxBaseGauge,
                _getSampleText = baseGaugeModule.getSampleText,
                _formatValue = baseGaugeModule.formatValue,
                _compareArrays = baseGaugeModule.compareArrays,
                dxCircularGauge = __webpack_require__( /*! ./circular_gauge */ 333),
                BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager,
                _isArray = commonUtils.isArray,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace,
                _getCosAndSin = vizUtils.getCosAndSin,
                _patchFontOptions = vizUtils.patchFontOptions,
                _Number = Number,
                _isFinite = isFinite,
                _noop = $.noop,
                _extend = $.extend,
                OPTION_VALUES = "values";
            var dxBarGauge = dxBaseGauge.inherit({
                _rootClass: "dxbg-bar-gauge",
                _initCore: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._barsGroup = that._renderer.g().attr({
                        "class": "dxbg-bars"
                    }).linkOn(that._renderer.root, "bars");
                    that._values = [];
                    that._context = {
                        renderer: that._renderer,
                        translator: that._translator,
                        tracker: that._tracker,
                        group: that._barsGroup
                    };
                    that._animateStep = function(pos) {
                        var i, ii, bars = that._bars;
                        for (i = 0, ii = bars.length; i < ii; ++i) {
                            bars[i].animate(pos)
                        }
                    };
                    that._animateComplete = function() {
                        var i, ii, bars = that._bars;
                        for (i = 0, ii = bars.length; i < ii; ++i) {
                            bars[i].endAnimation()
                        }
                    }
                },
                _disposeCore: function() {
                    var that = this;
                    that._barsGroup.linkOff();
                    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;
                    that.callBase.apply(that, arguments)
                },
                _setupDomainCore: function() {
                    var that = this,
                        startValue = that.option("startValue"),
                        endValue = that.option("endValue");
                    _isFinite(startValue) || (startValue = 0);
                    _isFinite(endValue) || (endValue = 100);
                    that._translator.setDomain(startValue, endValue);
                    that._baseValue = that._translator.adjust(that.option("baseValue"));
                    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue)
                },
                _getDefaultSize: function() {
                    return {
                        width: 300,
                        height: 300
                    }
                },
                _setupCodomain: dxCircularGauge.prototype._setupCodomain,
                _getApproximateScreenRange: function() {
                    var that = this,
                        sides = that._area.sides,
                        width = that._canvas.width / (sides.right - sides.left),
                        height = that._canvas.height / (sides.down - sides.up),
                        r = width < height ? width : height;
                    return -that._translator.getCodomainRange() * r * PI_DIV_180
                },
                _setupAnimationSettings: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    if (that._animationSettings) {
                        that._animationSettings.step = that._animateStep;
                        that._animationSettings.complete = that._animateComplete
                    }
                },
                _cleanContent: function() {
                    var i, ii, that = this;
                    that._barsGroup.linkRemove();
                    that._animationSettings && that._barsGroup.stopAnimation();
                    for (i = 0, ii = that._bars ? that._bars.length : 0; i < ii; ++i) {
                        that._bars[i].dispose()
                    }
                    that._palette = that._bars = null
                },
                _renderContent: function() {
                    var text, bbox, that = this,
                        labelOptions = that.option("label"),
                        context = that._context;
                    that._barsGroup.linkAppend();
                    context.textEnabled = void 0 === labelOptions || labelOptions && (!("visible" in labelOptions) || labelOptions.visible);
                    if (context.textEnabled) {
                        context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;
                        labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
                        context.formatOptions = {
                            format: void 0 !== labelOptions.format ? labelOptions.format : that._defaultFormatOptions,
                            precision: labelOptions.precision,
                            customizeText: labelOptions.customizeText
                        };
                        context.textOptions = {
                            align: "center"
                        };
                        context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {
                            color: null
                        }));
                        that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
                        context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
                        context.lineColor = labelOptions.connectorColor || null;
                        text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);
                        bbox = text.getBBox();
                        text.remove();
                        context.textVerticalOffset = -bbox.y - bbox.height / 2;
                        context.textWidth = bbox.width;
                        context.textHeight = bbox.height
                    }
                    dxCircularGauge.prototype._applyMainLayout.call(that);
                    that._renderBars()
                },
                _measureMainElements: function() {
                    var result = {
                        maxRadius: this._area.radius
                    };
                    if (this._context.textEnabled) {
                        result.horizontalMargin = this._context.textWidth;
                        result.verticalMargin = this._context.textHeight
                    }
                    return result
                },
                _renderBars: function() {
                    var relativeInnerRadius, radius, that = this,
                        options = _extend({}, that._themeManager.theme(), that.option()),
                        area = that._area;
                    that._palette = that._themeManager.createPalette(options.palette, {
                        useHighlight: true
                    });
                    relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : .1;
                    radius = area.radius;
                    if (that._context.textEnabled) {
                        that._textIndent = _round(_min(that._textIndent, radius / 2));
                        radius -= that._textIndent
                    }
                    that._outerRadius = _floor(radius);
                    that._innerRadius = _floor(radius * relativeInnerRadius);
                    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;
                    _extend(that._context, {
                        backgroundColor: options.backgroundColor,
                        x: area.x,
                        y: area.y,
                        startAngle: area.startCoord,
                        endAngle: area.endCoord,
                        baseAngle: that._translator.translate(that._baseValue)
                    });
                    that._bars = [];
                    that._updateValues(that.option(OPTION_VALUES))
                },
                _arrangeBars: function(count) {
                    var spacing, _count, unitOffset, i, that = this,
                        radius = that._outerRadius - that._innerRadius,
                        context = that._context;
                    context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
                    spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;
                    _count = _min(_floor((radius + spacing) / context.barSize), count);
                    that._setBarsCount(_count);
                    radius = that._outerRadius;
                    context.textRadius = radius + that._textIndent;
                    that._palette.reset();
                    unitOffset = context.barSize + spacing;
                    for (i = 0; i < _count; ++i, radius -= unitOffset) {
                        that._bars[i].arrange({
                            radius: radius,
                            color: that._palette.getNextColor()
                        })
                    }
                },
                _setBarsCount: function(count) {
                    var i, ii, that = this;
                    if (that._bars.length > count) {
                        for (i = count, ii = that._bars.length; i < ii; ++i) {
                            that._bars[i].dispose()
                        }
                        that._bars.splice(count, ii - count)
                    } else {
                        if (that._bars.length < count) {
                            for (i = that._bars.length, ii = count; i < ii; ++i) {
                                that._bars.push(new BarWrapper(i, that._context))
                            }
                        }
                    }
                    if (that._bars.length > 0) {
                        if (that._dummyBackground) {
                            that._dummyBackground.dispose();
                            that._dummyBackground = null
                        }
                    } else {
                        if (!that._dummyBackground) {
                            that._dummyBackground = that._renderer.arc().attr({
                                "stroke-linejoin": "round"
                            }).append(that._barsGroup)
                        }
                        that._dummyBackground.attr({
                            x: that._context.x,
                            y: that._context.y,
                            outerRadius: that._outerRadius,
                            innerRadius: that._innerRadius,
                            startAngle: that._context.endAngle,
                            endAngle: that._context.startAngle,
                            fill: that._context.backgroundColor
                        })
                    }
                },
                _updateBars: function(values) {
                    var i, ii, that = this;
                    for (i = 0, ii = that._bars.length; i < ii; ++i) {
                        that._bars[i].setValue(values[i])
                    }
                },
                _animateBars: function(values) {
                    var i, that = this,
                        ii = that._bars.length;
                    if (ii > 0) {
                        for (i = 0; i < ii; ++i) {
                            that._bars[i].beginAnimation(values[i])
                        }
                        that._barsGroup.animate({
                            _: 0
                        }, that._animationSettings)
                    }
                },
                _updateValues: function(values) {
                    var i, value, that = this,
                        list = _isArray(values) && values || _isFinite(values) && [values] || [],
                        ii = list.length,
                        barValues = [];
                    that._values.length = ii;
                    for (i = 0; i < ii; ++i) {
                        value = list[i];
                        that._values[i] = value = _Number(_isFinite(value) ? value : that._values[i]);
                        if (_isFinite(value)) {
                            barValues.push(value)
                        }
                    }
                    that._animationSettings && that._barsGroup.stopAnimation();
                    that._beginValueChanging();
                    if (that._bars) {
                        that._arrangeBars(barValues.length);
                        if (that._animationSettings && !that._noAnimation) {
                            that._animateBars(barValues)
                        } else {
                            that._updateBars(barValues)
                        }
                    }
                    if (!that._resizing) {
                        if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {
                            that.option(OPTION_VALUES, that._values)
                        }
                    }
                    that._endValueChanging()
                },
                values: function(arg) {
                    if (void 0 !== arg) {
                        this._updateValues(arg);
                        return this
                    } else {
                        return this._values.slice(0)
                    }
                },
                _optionChangesMap: {
                    backgroundColor: "MOSTLY_TOTAL",
                    relativeInnerRadius: "MOSTLY_TOTAL",
                    barSpacing: "MOSTLY_TOTAL",
                    label: "MOSTLY_TOTAL",
                    palette: "MOSTLY_TOTAL",
                    values: "VALUES"
                },
                _customChangesOrder: ["VALUES"],
                _change_VALUES: function() {
                    this._updateValues(this.option(OPTION_VALUES))
                },
                _factory: objectUtils.clone(dxBaseGauge.prototype._factory)
            });
            var BarWrapper = function(index, context) {
                var that = this;
                that._context = context;
                that._background = context.renderer.arc().attr({
                    "stroke-linejoin": "round",
                    fill: context.backgroundColor
                }).append(context.group);
                that._bar = context.renderer.arc().attr({
                    "stroke-linejoin": "round"
                }).append(context.group);
                if (context.textEnabled) {
                    that._line = context.renderer.path([], "line").attr({
                        "stroke-width": context.lineWidth
                    }).append(context.group);
                    that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group)
                }
                that._tracker = context.renderer.arc().attr({
                    "stroke-linejoin": "round"
                });
                context.tracker.attach(that._tracker, that, {
                    index: index
                });
                that._index = index;
                that._angle = context.baseAngle;
                that._settings = {
                    x: context.x,
                    y: context.y,
                    startAngle: context.baseAngle,
                    endAngle: context.baseAngle
                }
            };
            _extend(BarWrapper.prototype, {
                dispose: function() {
                    var that = this;
                    that._background.dispose();
                    that._bar.dispose();
                    if (that._context.textEnabled) {
                        that._line.dispose();
                        that._text.dispose()
                    }
                    that._context.tracker.detach(that._tracker);
                    that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
                    return that
                },
                arrange: function(options) {
                    var that = this,
                        context = that._context;
                    that._settings.outerRadius = options.radius;
                    that._settings.innerRadius = options.radius - context.barSize;
                    that._background.attr(_extend({}, that._settings, {
                        startAngle: context.endAngle,
                        endAngle: context.startAngle
                    }));
                    that._bar.attr(that._settings);
                    that._tracker.attr(that._settings);
                    that._color = options.color;
                    that._bar.attr({
                        fill: options.color
                    });
                    if (context.textEnabled) {
                        that._line.attr({
                            points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius],
                            stroke: context.lineColor || options.color
                        }).sharp();
                        that._text.css({
                            fill: context.textColor || options.color
                        })
                    }
                    return that
                },
                getTooltipParameters: function() {
                    var that = this,
                        cossin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);
                    return {
                        x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cossin.cos),
                        y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cossin.sin),
                        offset: 0,
                        color: that._color,
                        value: that._value
                    }
                },
                setAngle: function(angle) {
                    var cossin, that = this;
                    that._angle = angle;
                    setAngles(that._settings, that._context.baseAngle, that._angle);
                    that._bar.attr(that._settings);
                    that._tracker.attr(that._settings);
                    if (that._context.textEnabled) {
                        that._line.rotate(_convertAngleToRendererSpace(that._angle), that._context.x, that._context.y);
                        cossin = _getCosAndSin(that._angle);
                        that._text.attr({
                            text: _formatValue(that._value, that._context.formatOptions, {
                                index: that._index
                            }),
                            x: that._context.x + (that._context.textRadius + .6 * that._context.textWidth) * cossin.cos,
                            y: that._context.y - (that._context.textRadius + .6 * that._context.textHeight) * cossin.sin + that._context.textVerticalOffset
                        })
                    }
                    return that
                },
                _processValue: function(value) {
                    this._value = this._context.translator.adjust(value);
                    return this._context.translator.translate(this._value)
                },
                setValue: function(value) {
                    return this.setAngle(this._processValue(value))
                },
                beginAnimation: function(value) {
                    var that = this,
                        angle = this._processValue(value);
                    if (!compareFloats(that._angle, angle)) {
                        that._start = that._angle;
                        that._delta = angle - that._angle;
                        that._tracker.attr({
                            visibility: "hidden"
                        });
                        if (that._context.textEnabled) {
                            that._line.attr({
                                visibility: "hidden"
                            });
                            that._text.attr({
                                visibility: "hidden"
                            })
                        }
                    } else {
                        that.animate = _noop;
                        that.setAngle(that._angle)
                    }
                },
                animate: function(pos) {
                    var that = this;
                    that._angle = that._start + that._delta * pos;
                    setAngles(that._settings, that._context.baseAngle, that._angle);
                    that._bar.attr(that._settings)
                },
                endAnimation: function() {
                    var that = this;
                    if (void 0 !== that._delta) {
                        if (compareFloats(that._angle, that._start + that._delta)) {
                            that._tracker.attr({
                                visibility: null
                            });
                            if (that._context.textEnabled) {
                                that._line.attr({
                                    visibility: null
                                });
                                that._text.attr({
                                    visibility: null
                                })
                            }
                            that.setAngle(that._angle)
                        }
                    } else {
                        delete that.animate
                    }
                    delete that._start;
                    delete that._delta
                }
            });

            function setAngles(target, angle1, angle2) {
                target.startAngle = angle1 < angle2 ? angle1 : angle2;
                target.endAngle = angle1 < angle2 ? angle2 : angle1
            }

            function compareFloats(value1, value2) {
                return _abs(value1 - value2) < 1e-4
            }
            dxBarGauge.prototype._factory.ThemeManager = BaseThemeManager.inherit({
                _themeSection: "barGauge",
                _fontFields: ["label.font", "title.font", "tooltip.font", "loadingIndicator.font"]
            });
            registerComponent("dxBarGauge", dxBarGauge);
            exports.dxBarGauge = dxBarGauge;
            var __BarWrapper = BarWrapper;
            exports.BarWrapper = __BarWrapper;
            exports.stubBarWrapper = function(barWrapperType) {
                BarWrapper = barWrapperType
            };
            exports.restoreBarWrapper = function() {
                BarWrapper = __BarWrapper
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/gauges/circular_indicators.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var baseIndicatorsModule = __webpack_require__( /*! ./base_indicators */ 235),
                BaseIndicator = baseIndicatorsModule.BaseIndicator,
                BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker,
                BaseRangeBar = baseIndicatorsModule.BaseRangeBar,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _Number = Number,
                _getCosAndSin = vizUtils.getCosAndSin,
                _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace;
            var SimpleIndicator = BaseIndicator.inherit({
                _move: function() {
                    var that = this,
                        options = that._options,
                        angle = _convertAngleToRendererSpace(that._actualPosition);
                    that._rootElement.rotate(angle, options.x, options.y);
                    that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y)
                },
                _isEnabled: function() {
                    return this._options.width > 0
                },
                _isVisible: function(layout) {
                    return layout.radius - _Number(this._options.indentFromCenter) > 0
                },
                _getTrackerSettings: function() {
                    var options = this._options,
                        x = options.x,
                        y = options.y - (options.radius + _Number(options.indentFromCenter)) / 2,
                        width = options.width / 2,
                        length = (options.radius - _Number(options.indentFromCenter)) / 2;
                    width > 10 || (width = 10);
                    length > 10 || (length = 10);
                    return {
                        points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
                    }
                },
                _renderSpindle: function() {
                    var gapSize, that = this,
                        options = that._options;
                    if (options.spindleSize > 0) {
                        gapSize = _Number(options.spindleGapSize) || 0;
                        if (gapSize > 0) {
                            gapSize = gapSize <= options.spindleSize ? gapSize : _Number(options.spindleSize)
                        }
                        that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
                        that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);
                        that._spindleOuter.attr({
                            "class": "dxg-spindle-border",
                            cx: options.x,
                            cy: options.y,
                            r: options.spindleSize / 2
                        });
                        that._spindleInner.attr({
                            "class": "dxg-spindle-hole",
                            cx: options.x,
                            cy: options.y,
                            r: gapSize / 2,
                            fill: options.containerBackgroundColor
                        })
                    }
                },
                _render: function() {
                    var that = this;
                    that._renderPointer();
                    that._renderSpindle()
                },
                _clearSpindle: function() {
                    delete this._spindleOuter;
                    delete this._spindleInner
                },
                _clearPointer: function() {
                    delete this._element
                },
                _clear: function() {
                    this._clearPointer();
                    this._clearSpindle()
                },
                measure: function(layout) {
                    var result = {
                        max: layout.radius
                    };
                    if (this._options.indentFromCenter < 0) {
                        result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter)
                    }
                    return result
                },
                getTooltipParameters: function() {
                    var options = this._options,
                        cossin = _getCosAndSin(this._actualPosition),
                        r = (options.radius + _Number(options.indentFromCenter)) / 2;
                    return {
                        x: options.x + cossin.cos * r,
                        y: options.y - cossin.sin * r,
                        value: this._currentValue,
                        color: options.color,
                        offset: options.width / 2
                    }
                }
            });
            var rectangleneedle = SimpleIndicator.inherit({
                _renderPointer: function() {
                    var that = this,
                        options = that._options,
                        y2 = options.y - options.radius,
                        y1 = options.y - _Number(options.indentFromCenter),
                        x1 = options.x - options.width / 2,
                        x2 = x1 + _Number(options.width);
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    that._element.attr({
                        points: [x1, y1, x1, y2, x2, y2, x2, y1]
                    })
                }
            });
            var triangleneedle = SimpleIndicator.inherit({
                _renderPointer: function() {
                    var that = this,
                        options = that._options,
                        y2 = options.y - options.radius,
                        y1 = options.y - _Number(options.indentFromCenter),
                        x1 = options.x - options.width / 2,
                        x2 = options.x + options.width / 2;
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    that._element.attr({
                        points: [x1, y1, options.x, y2, x2, y1]
                    })
                }
            });
            var twocolorneedle = SimpleIndicator.inherit({
                _renderPointer: function() {
                    var y2, y3, that = this,
                        options = that._options,
                        x1 = options.x - options.width / 2,
                        x2 = options.x + options.width / 2,
                        y4 = options.y - options.radius,
                        y1 = options.y - _Number(options.indentFromCenter),
                        fraction = _Number(options.secondFraction) || 0;
                    if (fraction >= 1) {
                        y2 = y3 = y1
                    } else {
                        if (fraction <= 0) {
                            y2 = y3 = y4
                        } else {
                            y3 = y4 + (y1 - y4) * fraction;
                            y2 = y3 + _Number(options.space)
                        }
                    }
                    that._firstElement = that._firstElement || that._renderer.path([], "area").append(that._rootElement);
                    that._spaceElement = that._spaceElement || that._renderer.path([], "area").append(that._rootElement);
                    that._secondElement = that._secondElement || that._renderer.path([], "area").append(that._rootElement);
                    that._firstElement.attr({
                        points: [x1, y1, x1, y2, x2, y2, x2, y1]
                    });
                    that._spaceElement.attr({
                        points: [x1, y2, x1, y3, x2, y3, x2, y2],
                        "class": "dxg-hole",
                        fill: options.containerBackgroundColor
                    });
                    that._secondElement.attr({
                        points: [x1, y3, x1, y4, x2, y4, x2, y3],
                        "class": "dxg-part",
                        fill: options.secondColor
                    })
                },
                _clearPointer: function() {
                    delete this._firstElement;
                    delete this._secondElement;
                    delete this._spaceElement
                }
            });
            var trianglemarker = SimpleIndicator.inherit({
                _isEnabled: function() {
                    return this._options.length > 0 && this._options.width > 0
                },
                _isVisible: function(layout) {
                    return layout.radius > 0
                },
                _render: function() {
                    var settings, that = this,
                        options = that._options,
                        x = options.x,
                        y1 = options.y - options.radius,
                        dx = options.width / 2 || 0,
                        y2 = y1 - _Number(options.length);
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    settings = {
                        points: [x, y1, x - dx, y2, x + dx, y2],
                        stroke: "none",
                        "stroke-width": 0,
                        "stroke-linecap": "square"
                    };
                    if (options.space > 0) {
                        settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                        settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || "none" : "none"
                    }
                    that._element.attr(settings).sharp()
                },
                _clear: function() {
                    delete this._element
                },
                _getTrackerSettings: function() {
                    var options = this._options,
                        x = options.x,
                        y = options.y - options.radius - options.length / 2,
                        width = options.width / 2,
                        length = options.length / 2;
                    width > 10 || (width = 10);
                    length > 10 || (length = 10);
                    return {
                        points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
                    }
                },
                measure: function(layout) {
                    return {
                        min: layout.radius,
                        max: layout.radius + _Number(this._options.length)
                    }
                },
                getTooltipParameters: function() {
                    var options = this._options,
                        cossin = _getCosAndSin(this._actualPosition),
                        r = options.radius + options.length / 2,
                        parameters = this.callBase();
                    parameters.x = options.x + cossin.cos * r;
                    parameters.y = options.y - cossin.sin * r;
                    parameters.offset = options.length / 2;
                    return parameters
                }
            });
            var textcloud = BaseTextCloudMarker.inherit({
                _isEnabled: function() {
                    return true
                },
                _isVisible: function(layout) {
                    return layout.radius > 0
                },
                _getTextCloudOptions: function() {
                    var that = this,
                        cossin = _getCosAndSin(that._actualPosition),
                        nangle = vizUtils.normalizeAngle(that._actualPosition);
                    return {
                        x: that._options.x + cossin.cos * that._options.radius,
                        y: that._options.y - cossin.sin * that._options.radius,
                        type: nangle > 270 ? "left-top" : nangle > 180 ? "top-right" : nangle > 90 ? "right-bottom" : "bottom-left"
                    }
                },
                measure: function(layout) {
                    var verticalOffset, horizontalOffset, that = this,
                        arrowLength = _Number(that._options.arrowLength) || 0;
                    that._measureText();
                    verticalOffset = that._textFullHeight + arrowLength;
                    horizontalOffset = that._textFullWidth + arrowLength;
                    return {
                        min: layout.radius,
                        max: layout.radius,
                        horizontalOffset: horizontalOffset,
                        verticalOffset: verticalOffset,
                        inverseHorizontalOffset: horizontalOffset,
                        inverseVerticalOffset: verticalOffset
                    }
                }
            });
            var rangebar = BaseRangeBar.inherit({
                _isEnabled: function() {
                    return this._options.size > 0
                },
                _isVisible: function(layout) {
                    return layout.radius - _Number(this._options.size) > 0
                },
                _createBarItem: function() {
                    return this._renderer.arc().attr({
                        "stroke-linejoin": "round"
                    }).append(this._rootElement)
                },
                _createTracker: function() {
                    return this._renderer.arc().attr({
                        "stroke-linejoin": "round"
                    })
                },
                _setBarSides: function() {
                    var that = this;
                    that._maxSide = that._options.radius;
                    that._minSide = that._maxSide - _Number(that._options.size)
                },
                _getSpace: function() {
                    var options = this._options;
                    return options.space > 0 ? 180 * options.space / options.radius / Math.PI : 0
                },
                _isTextVisible: function() {
                    var options = this._options.text || {};
                    return options.indent > 0
                },
                _setTextItemsSides: function() {
                    var that = this,
                        options = that._options,
                        indent = _Number(options.text.indent);
                    that._lineFrom = options.y - options.radius;
                    that._lineTo = that._lineFrom - indent;
                    that._textRadius = options.radius + indent
                },
                _getPositions: function() {
                    var mainPosition1, mainPosition2, that = this,
                        basePosition = that._basePosition,
                        actualPosition = that._actualPosition;
                    if (basePosition >= actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    } else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    return {
                        start: that._startPosition,
                        end: that._endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: Math.min(mainPosition1 + that._space, that._startPosition),
                        back2: Math.max(mainPosition2 - that._space, that._endPosition)
                    }
                },
                _buildItemSettings: function(from, to) {
                    var that = this;
                    return {
                        x: that._options.x,
                        y: that._options.y,
                        innerRadius: that._minSide,
                        outerRadius: that._maxSide,
                        startAngle: to,
                        endAngle: from
                    }
                },
                _updateTextPosition: function() {
                    var that = this,
                        cossin = _getCosAndSin(that._actualPosition),
                        x = that._options.x + that._textRadius * cossin.cos,
                        y = that._options.y - that._textRadius * cossin.sin;
                    x += cossin.cos * that._textWidth * .6;
                    y -= cossin.sin * that._textHeight * .6;
                    that._text.attr({
                        x: x,
                        y: y + that._textVerticalOffset
                    })
                },
                _updateLinePosition: function() {
                    var x1, x2, that = this,
                        x = that._options.x;
                    if (that._basePosition > that._actualPosition) {
                        x1 = x - 2;
                        x2 = x
                    } else {
                        if (that._basePosition < that._actualPosition) {
                            x1 = x;
                            x2 = x + 2
                        } else {
                            x1 = x - 1;
                            x2 = x + 1
                        }
                    }
                    that._line.attr({
                        points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]
                    }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp()
                },
                _getTooltipPosition: function() {
                    var that = this,
                        cossin = _getCosAndSin((that._basePosition + that._actualPosition) / 2),
                        r = (that._minSide + that._maxSide) / 2;
                    return {
                        x: that._options.x + cossin.cos * r,
                        y: that._options.y - cossin.sin * r
                    }
                },
                measure: function(layout) {
                    var that = this,
                        result = {
                            min: layout.radius - _Number(that._options.size),
                            max: layout.radius
                        };
                    that._measureText();
                    if (that._hasText) {
                        result.max += _Number(that._options.text.indent);
                        result.horizontalOffset = that._textWidth;
                        result.verticalOffset = that._textHeight
                    }
                    return result
                }
            });
            exports._default = rectangleneedle;
            exports.rectangleneedle = rectangleneedle;
            exports.triangleneedle = triangleneedle;
            exports.twocolorneedle = twocolorneedle;
            exports.trianglemarker = trianglemarker;
            exports.textcloud = textcloud;
            exports.rangebar = rangebar
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/gauges/circular_range_container.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BaseRangeContainer = __webpack_require__( /*! ./base_range_container */ 332),
                _Number = Number,
                _max = Math.max,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum;
            var CircularRangeContainer = BaseRangeContainer.inherit({
                _processOptions: function() {
                    var that = this;
                    that._inner = that._outer = 0;
                    switch (_normalizeEnum(that._options.orientation)) {
                        case "inside":
                            that._inner = 1;
                            break;
                        case "center":
                            that._inner = that._outer = .5;
                            break;
                        default:
                            that._outer = 1
                    }
                },
                _isVisible: function(layout) {
                    var width = this._options.width;
                    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                    return layout.radius - this._inner * width > 0
                },
                _createRange: function(range, layout) {
                    var that = this,
                        width = (range.startWidth + range.endWidth) / 2;
                    return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({
                        "stroke-linejoin": "round"
                    })
                },
                measure: function(layout) {
                    var width = this._options.width;
                    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                    return {
                        min: layout.radius - this._inner * width,
                        max: layout.radius + this._outer * width
                    }
                }
            });
            module.exports = CircularRangeContainer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/viz/gauges/linear_gauge.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _max = Math.max,
                _min = Math.min,
                _round = Math.round,
                _each = $.each,
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                dxBaseGauge = __webpack_require__( /*! ./base_gauge */ 128).dxBaseGauge,
                dxGauge = __webpack_require__( /*! ./common */ 191).dxGauge,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 105),
                linearIndicatorsModule = __webpack_require__( /*! ./linear_indicators */ 526),
                createIndicatorCreator = __webpack_require__( /*! ./common */ 191).createIndicatorCreator,
                LinearRangeContainer = __webpack_require__( /*! ./linear_range_container */ 527),
                ThemeManager = __webpack_require__( /*! ./theme_manager */ 334);
            var dxLinearGauge = dxGauge.inherit({
                _rootClass: "dxg-linear-gauge",
                _factoryMethods: {
                    rangeContainer: "createLinearRangeContainer",
                    indicator: "createLinearIndicator"
                },
                _gridSpacingFactor: 25,
                _scaleTypes: {
                    type: "xyAxes",
                    drawingType: "linear"
                },
                _initScaleTranslator: function(range) {
                    var canvas = $.extend({}, this._canvas);
                    return {
                        val: new translator2DModule.Translator2D(range, canvas),
                        arg: new translator2DModule.Translator2D(range, canvas, {
                            isHorizontal: true
                        })
                    }
                },
                _getScaleTranslatorComponent: function(name) {
                    return this._scaleTranslator["arg" === name !== this._area.vertical ? "arg" : "val"]
                },
                _updateScaleAngles: $.noop,
                _getTicksOrientation: function(scaleOptions) {
                    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation
                },
                _updateScaleTickIndent: function(scaleOptions) {
                    var orientation, textCorrection, tickCorrection, indentFromTick = scaleOptions.label.indentFromTick,
                        length = scaleOptions.tick.length,
                        textParams = this._scale.measureLabels(),
                        verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0,
                        isIndentPositive = indentFromTick > 0;
                    if (scaleOptions.isHorizontal) {
                        orientation = isIndentPositive ? {
                            center: .5,
                            middle: .5,
                            top: 0,
                            bottom: 1
                        } : {
                            center: .5,
                            middle: .5,
                            top: 1,
                            bottom: 0
                        };
                        tickCorrection = length * orientation[scaleOptions.verticalOrientation];
                        textCorrection = textParams.y
                    } else {
                        orientation = isIndentPositive ? {
                            center: .5,
                            left: 0,
                            right: 1
                        } : {
                            center: .5,
                            left: 1,
                            right: 0
                        };
                        tickCorrection = length * orientation[scaleOptions.horizontalOrientation];
                        textCorrection = -textParams.width
                    }
                    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);
                    this._scale.updateOptions(scaleOptions)
                },
                _shiftScale: function(layout, scaleOptions) {
                    var that = this,
                        canvas = $.extend({}, that._canvas),
                        isHorizontal = scaleOptions.isHorizontal,
                        translator = that._getScaleTranslatorComponent("arg"),
                        additionalTranslator = that._getScaleTranslatorComponent("val"),
                        scale = that._scale;
                    canvas[isHorizontal ? "left" : "top"] = that._area[isHorizontal ? "startCoord" : "endCoord"];
                    canvas[isHorizontal ? "right" : "bottom"] = canvas[isHorizontal ? "width" : "height"] - that._area[isHorizontal ? "endCoord" : "startCoord"];
                    translator.updateCanvas(canvas);
                    additionalTranslator.updateCanvas(canvas);
                    scale.setTranslator(translator, additionalTranslator);
                    scale.draw();
                    scale.shift(layout.x, layout.y)
                },
                _setupCodomain: function() {
                    var that = this,
                        geometry = that.option("geometry") || {},
                        vertical = "vertical" === _normalizeEnum(geometry.orientation);
                    that._area = {
                        vertical: vertical,
                        x: 0,
                        y: 0,
                        startCoord: -100,
                        endCoord: 100
                    };
                    that._rangeContainer.vertical = vertical
                },
                _getScaleLayoutValue: function() {
                    return this._area[this._area.vertical ? "x" : "y"]
                },
                _getTicksCoefficients: function(options) {
                    var coefs = {
                        inner: 0,
                        outer: 1
                    };
                    if (this._area.vertical) {
                        if ("left" === options.horizontalOrientation) {
                            coefs.inner = 1;
                            coefs.outer = 0
                        } else {
                            if ("center" === options.horizontalOrientation) {
                                coefs.inner = coefs.outer = .5
                            }
                        }
                    } else {
                        if ("top" === options.verticalOrientation) {
                            coefs.inner = 1;
                            coefs.outer = 0
                        } else {
                            if ("center" === options.verticalOrientation || "middle" === options.verticalOrientation) {
                                coefs.inner = coefs.outer = .5
                            }
                        }
                    }
                    return coefs
                },
                _correctScaleIndents: function(result, indentFromTick, textParams) {
                    var vertical = this._area.vertical;
                    if (indentFromTick >= 0) {
                        result.max += indentFromTick + textParams[vertical ? "width" : "height"]
                    } else {
                        result.min -= -indentFromTick + textParams[vertical ? "width" : "height"]
                    }
                    result.indent = textParams[vertical ? "height" : "width"] / 2
                },
                _measureMainElements: function(elements, scaleMeasurement) {
                    var that = this,
                        x = that._area.x,
                        y = that._area.y,
                        minBound = 1e3,
                        maxBound = 0,
                        indent = 0,
                        scale = that._scale;
                    _each(elements.concat(scale), function(_, element) {
                        var bounds = element.measure ? element.measure({
                            x: x + element.getOffset(),
                            y: y + element.getOffset()
                        }) : scaleMeasurement;
                        void 0 !== bounds.max && (maxBound = _max(maxBound, bounds.max));
                        void 0 !== bounds.min && (minBound = _min(minBound, bounds.min));
                        bounds.indent > 0 && (indent = _max(indent, bounds.indent))
                    });
                    return {
                        minBound: minBound,
                        maxBound: maxBound,
                        indent: indent
                    }
                },
                _applyMainLayout: function(elements, scaleMeasurement) {
                    var rect, offset, that = this,
                        measurements = that._measureMainElements(elements, scaleMeasurement),
                        area = that._area;
                    if (area.vertical) {
                        rect = selectRectBySizes(that._innerRect, {
                            width: measurements.maxBound - measurements.minBound
                        });
                        offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;
                        area.startCoord = rect.bottom - measurements.indent;
                        area.endCoord = rect.top + measurements.indent;
                        area.x = _round(area.x + offset)
                    } else {
                        rect = selectRectBySizes(that._innerRect, {
                            height: measurements.maxBound - measurements.minBound
                        });
                        offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;
                        area.startCoord = rect.left + measurements.indent;
                        area.endCoord = rect.right - measurements.indent;
                        area.y = _round(area.y + offset)
                    }
                    that._translator.setCodomain(area.startCoord, area.endCoord);
                    that._innerRect = rect
                },
                _getElementLayout: function(offset) {
                    return {
                        x: _round(this._area.x + offset),
                        y: _round(this._area.y + offset)
                    }
                },
                _getApproximateScreenRange: function() {
                    var that = this,
                        area = that._area,
                        s = area.vertical ? that._canvas.height : that._canvas.width;
                    s > area.totalSize && (s = area.totalSize);
                    s = .8 * s;
                    return s
                },
                _getDefaultSize: function() {
                    var geometry = this.option("geometry") || {};
                    if ("vertical" === geometry.orientation) {
                        return {
                            width: 100,
                            height: 300
                        }
                    } else {
                        return {
                            width: 300,
                            height: 100
                        }
                    }
                },
                _factory: objectUtils.clone(dxBaseGauge.prototype._factory)
            });

            function selectRectBySizes(srcRect, sizes, margins) {
                var step, rect = $.extend({}, srcRect);
                margins = margins || {};
                if (sizes) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (sizes.width > 0) {
                        step = (rect.right - rect.left - sizes.width) / 2;
                        if (step > 0) {
                            rect.left += step;
                            rect.right -= step
                        }
                    }
                    if (sizes.height > 0) {
                        step = (rect.bottom - rect.top - sizes.height) / 2;
                        if (step > 0) {
                            rect.top += step;
                            rect.bottom -= step
                        }
                    }
                }
                return rect
            }
            dxLinearGauge._TESTS_selectRectBySizes = selectRectBySizes;
            var indicators = dxLinearGauge.prototype._factory.indicators = {};
            dxLinearGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);
            indicators._default = linearIndicatorsModule._default;
            indicators.rectangle = linearIndicatorsModule.rectangle;
            indicators.rhombus = linearIndicatorsModule.rhombus;
            indicators.circle = linearIndicatorsModule.circle;
            indicators.trianglemarker = linearIndicatorsModule.trianglemarker;
            indicators.textcloud = linearIndicatorsModule.textcloud;
            indicators.rangebar = linearIndicatorsModule.rangebar;
            dxLinearGauge.prototype._factory.RangeContainer = LinearRangeContainer;
            dxLinearGauge.prototype._factory.ThemeManager = ThemeManager.inherit({
                _subTheme: "_linear"
            });
            registerComponent("dxLinearGauge", dxLinearGauge);
            module.exports = dxLinearGauge
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/gauges/linear_indicators.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var baseIndicatorsModule = __webpack_require__( /*! ./base_indicators */ 235),
                BaseIndicator = baseIndicatorsModule.BaseIndicator,
                BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker,
                BaseRangeBar = baseIndicatorsModule.BaseRangeBar,
                _Number = Number,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum;
            var SimpleIndicator = BaseIndicator.inherit({
                _move: function() {
                    var that = this,
                        delta = that._actualPosition - that._zeroPosition;
                    that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
                    that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0)
                },
                _isEnabled: function() {
                    this.vertical = this._options.vertical;
                    return this._options.length > 0 && this._options.width > 0
                },
                _isVisible: function() {
                    return true
                },
                _getTrackerSettings: function() {
                    var x1, x2, y1, y2, options = this._options,
                        width = options.width / 2,
                        length = options.length / 2,
                        p = this._zeroPosition;
                    width > 10 || (width = 10);
                    length > 10 || (length = 10);
                    if (this.vertical) {
                        x1 = options.x - length;
                        x2 = options.x + length;
                        y1 = p + width;
                        y2 = p - width
                    } else {
                        x1 = p - width;
                        x2 = p + width;
                        y1 = options.y + length;
                        y2 = options.y - length
                    }
                    return {
                        points: [x1, y1, x1, y2, x2, y2, x2, y1]
                    }
                },
                _render: function() {
                    var that = this;
                    that._zeroPosition = that._translator.getCodomainStart()
                },
                _clear: function() {
                    delete this._element
                },
                measure: function(layout) {
                    var p = this.vertical ? layout.x : layout.y;
                    return {
                        min: p - this._options.length / 2,
                        max: p + this._options.length / 2
                    }
                },
                getTooltipParameters: function() {
                    var that = this,
                        options = that._options,
                        p = that._actualPosition,
                        parameters = {
                            x: p,
                            y: p,
                            value: that._currentValue,
                            color: options.color,
                            offset: options.width / 2
                        };
                    that.vertical ? parameters.x = options.x : parameters.y = options.y;
                    return parameters
                }
            });
            var rectangle = SimpleIndicator.inherit({
                _render: function() {
                    var p, x1, x2, y1, y2, that = this,
                        options = that._options;
                    that.callBase();
                    p = that._zeroPosition;
                    if (that.vertical) {
                        x1 = options.x - options.length / 2;
                        x2 = options.x + options.length / 2;
                        y1 = p + options.width / 2;
                        y2 = p - options.width / 2
                    } else {
                        x1 = p - options.width / 2;
                        x2 = p + options.width / 2;
                        y1 = options.y + options.length / 2;
                        y2 = options.y - options.length / 2
                    }
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    that._element.attr({
                        points: [x1, y1, x1, y2, x2, y2, x2, y1]
                    })
                }
            });
            var rhombus = SimpleIndicator.inherit({
                _render: function() {
                    var x, y, dx, dy, that = this,
                        options = that._options;
                    that.callBase();
                    if (that.vertical) {
                        x = options.x;
                        y = that._zeroPosition;
                        dx = options.length / 2 || 0;
                        dy = options.width / 2 || 0
                    } else {
                        x = that._zeroPosition;
                        y = options.y;
                        dx = options.width / 2 || 0;
                        dy = options.length / 2 || 0
                    }
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    that._element.attr({
                        points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]
                    })
                }
            });
            var circle = SimpleIndicator.inherit({
                _render: function() {
                    var x, y, r, that = this,
                        options = that._options;
                    that.callBase();
                    if (that.vertical) {
                        x = options.x;
                        y = that._zeroPosition
                    } else {
                        x = that._zeroPosition;
                        y = options.y
                    }
                    r = options.length / 2 || 0;
                    that._element = that._element || that._renderer.circle().append(that._rootElement);
                    that._element.attr({
                        cx: x,
                        cy: y,
                        r: r
                    })
                }
            });
            var trianglemarker = SimpleIndicator.inherit({
                _isEnabled: function() {
                    var that = this;
                    that.vertical = that._options.vertical;
                    that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                    return that._options.length > 0 && that._options.width > 0
                },
                _isVisible: function() {
                    return true
                },
                _render: function() {
                    var x1, x2, y1, y2, that = this,
                        options = that._options,
                        settings = {
                            stroke: "none",
                            "stroke-width": 0,
                            "stroke-linecap": "square"
                        };
                    that.callBase();
                    if (that.vertical) {
                        x1 = options.x;
                        y1 = that._zeroPosition;
                        x2 = x1 + _Number(that._inverted ? options.length : -options.length);
                        settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2]
                    } else {
                        y1 = options.y;
                        x1 = that._zeroPosition;
                        y2 = y1 + _Number(that._inverted ? options.length : -options.length);
                        settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2]
                    }
                    if (options.space > 0) {
                        settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                        settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || "none" : "none"
                    }
                    that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                    that._element.attr(settings).sharp()
                },
                _getTrackerSettings: function() {
                    var x1, x2, y1, y2, result, that = this,
                        options = that._options,
                        width = options.width / 2,
                        length = _Number(options.length);
                    width > 10 || (width = 10);
                    length > 20 || (length = 20);
                    if (that.vertical) {
                        x1 = x2 = options.x;
                        x2 = x1 + (that._inverted ? length : -length);
                        y1 = that._zeroPosition + width;
                        y2 = that._zeroPosition - width;
                        result = [x1, y1, x2, y1, x2, y2, x1, y2]
                    } else {
                        y1 = options.y;
                        y2 = y1 + (that._inverted ? length : -length);
                        x1 = that._zeroPosition - width;
                        x2 = that._zeroPosition + width;
                        result = [x1, y1, x1, y2, x2, y2, x2, y1]
                    }
                    return {
                        points: result
                    }
                },
                measure: function(layout) {
                    var minbound, maxbound, that = this,
                        length = _Number(that._options.length);
                    if (that.vertical) {
                        minbound = maxbound = layout.x;
                        if (that._inverted) {
                            maxbound = minbound + length
                        } else {
                            minbound = maxbound - length
                        }
                    } else {
                        minbound = maxbound = layout.y;
                        if (that._inverted) {
                            maxbound = minbound + length
                        } else {
                            minbound = maxbound - length
                        }
                    }
                    return {
                        min: minbound,
                        max: maxbound,
                        indent: that._options.width / 2
                    }
                },
                getTooltipParameters: function() {
                    var that = this,
                        options = that._options,
                        s = (that._inverted ? options.length : -options.length) / 2,
                        parameters = that.callBase();
                    that.vertical ? parameters.x += s : parameters.y += s;
                    parameters.offset = options.length / 2;
                    return parameters
                }
            });
            var textcloud = BaseTextCloudMarker.inherit({
                _isEnabled: function() {
                    var that = this;
                    that.vertical = that._options.vertical;
                    that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                    return true
                },
                _isVisible: function() {
                    return true
                },
                _getTextCloudOptions: function() {
                    var type, that = this,
                        x = that._actualPosition,
                        y = that._actualPosition;
                    if (that.vertical) {
                        x = that._options.x;
                        type = that._inverted ? "top-left" : "top-right"
                    } else {
                        y = that._options.y;
                        type = that._inverted ? "right-top" : "right-bottom"
                    }
                    return {
                        x: x,
                        y: y,
                        type: type
                    }
                },
                measure: function(layout) {
                    var minbound, maxbound, indent, that = this,
                        arrowLength = _Number(that._options.arrowLength) || 0;
                    that._measureText();
                    if (that.vertical) {
                        indent = that._textFullHeight;
                        if (that._inverted) {
                            minbound = layout.x;
                            maxbound = layout.x + arrowLength + that._textFullWidth
                        } else {
                            minbound = layout.x - arrowLength - that._textFullWidth;
                            maxbound = layout.x
                        }
                    } else {
                        indent = that._textFullWidth;
                        if (that._inverted) {
                            minbound = layout.y;
                            maxbound = layout.y + arrowLength + that._textFullHeight
                        } else {
                            minbound = layout.y - arrowLength - that._textFullHeight;
                            maxbound = layout.y
                        }
                    }
                    return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
                }
            });
            var rangebar = BaseRangeBar.inherit({
                _isEnabled: function() {
                    var that = this;
                    that.vertical = that._options.vertical;
                    that._inverted = that.vertical ? "right" === _normalizeEnum(that._options.horizontalOrientation) : "bottom" === _normalizeEnum(that._options.verticalOrientation);
                    return that._options.size > 0
                },
                _isVisible: function() {
                    return true
                },
                _createBarItem: function() {
                    return this._renderer.path([], "area").append(this._rootElement)
                },
                _createTracker: function() {
                    return this._renderer.path([], "area")
                },
                _setBarSides: function() {
                    var minSide, maxSide, that = this,
                        options = that._options,
                        size = _Number(options.size);
                    if (that.vertical) {
                        if (that._inverted) {
                            minSide = options.x;
                            maxSide = options.x + size
                        } else {
                            minSide = options.x - size;
                            maxSide = options.x
                        }
                    } else {
                        if (that._inverted) {
                            minSide = options.y;
                            maxSide = options.y + size
                        } else {
                            minSide = options.y - size;
                            maxSide = options.y
                        }
                    }
                    that._minSide = minSide;
                    that._maxSide = maxSide;
                    that._minBound = minSide;
                    that._maxBound = maxSide
                },
                _getSpace: function() {
                    var options = this._options;
                    return options.space > 0 ? _Number(options.space) : 0
                },
                _isTextVisible: function() {
                    var textOptions = this._options.text || {};
                    return textOptions.indent > 0 || textOptions.indent < 0
                },
                _getTextAlign: function() {
                    return this.vertical ? this._options.text.indent > 0 ? "left" : "right" : "center"
                },
                _setTextItemsSides: function() {
                    var that = this,
                        indent = _Number(that._options.text.indent);
                    if (indent > 0) {
                        that._lineStart = that._maxSide;
                        that._lineEnd = that._maxSide + indent;
                        that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
                        that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2)
                    } else {
                        if (indent < 0) {
                            that._lineStart = that._minSide;
                            that._lineEnd = that._minSide + indent;
                            that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
                            that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2)
                        }
                    }
                },
                _getPositions: function() {
                    var mainPosition1, mainPosition2, backPosition1, backPosition2, that = this,
                        startPosition = that._startPosition,
                        endPosition = that._endPosition,
                        space = that._space,
                        basePosition = that._basePosition,
                        actualPosition = that._actualPosition;
                    if (startPosition < endPosition) {
                        if (basePosition < actualPosition) {
                            mainPosition1 = basePosition;
                            mainPosition2 = actualPosition
                        } else {
                            mainPosition1 = actualPosition;
                            mainPosition2 = basePosition
                        }
                        backPosition1 = mainPosition1 - space;
                        backPosition2 = mainPosition2 + space
                    } else {
                        if (basePosition > actualPosition) {
                            mainPosition1 = basePosition;
                            mainPosition2 = actualPosition
                        } else {
                            mainPosition1 = actualPosition;
                            mainPosition2 = basePosition
                        }
                        backPosition1 = mainPosition1 + space;
                        backPosition2 = mainPosition2 - space
                    }
                    return {
                        start: startPosition,
                        end: endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: backPosition1,
                        back2: backPosition2
                    }
                },
                _buildItemSettings: function(from, to) {
                    var that = this,
                        side1 = that._minSide,
                        side2 = that._maxSide,
                        points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
                    return {
                        points: points
                    }
                },
                _updateTextPosition: function() {
                    var that = this;
                    that._text.attr(that.vertical ? {
                        x: that._textPosition,
                        y: that._actualPosition + that._textVerticalOffset
                    } : {
                        x: that._actualPosition,
                        y: that._textPosition + that._textVerticalOffset
                    })
                },
                _updateLinePosition: function() {
                    var side1, side2, points, that = this,
                        actualPosition = that._actualPosition;
                    if (that.vertical) {
                        if (that._basePosition >= actualPosition) {
                            side1 = actualPosition;
                            side2 = actualPosition + 2
                        } else {
                            side1 = actualPosition - 2;
                            side2 = actualPosition
                        }
                        points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1]
                    } else {
                        if (that._basePosition <= actualPosition) {
                            side1 = actualPosition - 2;
                            side2 = actualPosition
                        } else {
                            side1 = actualPosition;
                            side2 = actualPosition + 2
                        }
                        points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart]
                    }
                    that._line.attr({
                        points: points
                    }).sharp()
                },
                _getTooltipPosition: function() {
                    var that = this,
                        crossCenter = (that._minSide + that._maxSide) / 2,
                        alongCenter = (that._basePosition + that._actualPosition) / 2;
                    return that.vertical ? {
                        x: crossCenter,
                        y: alongCenter
                    } : {
                        x: alongCenter,
                        y: crossCenter
                    }
                },
                measure: function(layout) {
                    var minbound, maxbound, indent, that = this,
                        size = _Number(that._options.size),
                        textIndent = _Number(that._options.text.indent);
                    that._measureText();
                    if (that.vertical) {
                        minbound = maxbound = layout.x;
                        if (that._inverted) {
                            maxbound += size
                        } else {
                            minbound -= size
                        }
                        if (that._hasText) {
                            indent = that._textHeight / 2;
                            if (textIndent > 0) {
                                maxbound += textIndent + that._textWidth
                            }
                            if (textIndent < 0) {
                                minbound += textIndent - that._textWidth
                            }
                        }
                    } else {
                        minbound = maxbound = layout.y;
                        if (that._inverted) {
                            maxbound += size
                        } else {
                            minbound -= size
                        }
                        if (that._hasText) {
                            indent = that._textWidth / 2;
                            if (textIndent > 0) {
                                maxbound += textIndent + that._textHeight
                            }
                            if (textIndent < 0) {
                                minbound += textIndent - that._textHeight
                            }
                        }
                    }
                    return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
                }
            });
            exports._default = rangebar;
            exports.rectangle = rectangle;
            exports.rhombus = rhombus;
            exports.circle = circle;
            exports.trianglemarker = trianglemarker;
            exports.textcloud = textcloud;
            exports.rangebar = rangebar
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/gauges/linear_range_container.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BaseRangeContainer = __webpack_require__( /*! ./base_range_container */ 332),
                _Number = Number,
                _max = Math.max,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum;
            var LinearRangeContainer = BaseRangeContainer.inherit({
                _processOptions: function() {
                    var that = this;
                    that.vertical = that._options.vertical;
                    that._inner = that._outer = 0;
                    if (that.vertical) {
                        switch (_normalizeEnum(that._options.horizontalOrientation)) {
                            case "left":
                                that._inner = 1;
                                break;
                            case "center":
                                that._inner = that._outer = .5;
                                break;
                            default:
                                that._outer = 1
                        }
                    } else {
                        switch (_normalizeEnum(that._options.verticalOrientation)) {
                            case "top":
                                that._inner = 1;
                                break;
                            case "center":
                            case "middle":
                                that._inner = that._outer = .5;
                                break;
                            default:
                                that._outer = 1
                        }
                    }
                },
                _isVisible: function() {
                    return true
                },
                _createRange: function(range, layout) {
                    var points, that = this,
                        inner = that._inner,
                        outer = that._outer,
                        startPosition = that._translator.translate(range.start),
                        endPosition = that._translator.translate(range.end),
                        x = layout.x,
                        y = layout.y,
                        startWidth = range.startWidth,
                        endWidth = range.endWidth;
                    if (that.vertical) {
                        points = [x - startWidth * inner, startPosition, x - endWidth * inner, endPosition, x + endWidth * outer, endPosition, x + startWidth * outer, startPosition]
                    } else {
                        points = [startPosition, y + startWidth * outer, startPosition, y - startWidth * inner, endPosition, y - endWidth * inner, endPosition, y + endWidth * outer]
                    }
                    return that._renderer.path(points, "area")
                },
                measure: function(layout) {
                    var width, result = {};
                    result.min = result.max = layout[this.vertical ? "x" : "y"];
                    width = this._options.width;
                    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                    result.min -= this._inner * width;
                    result.max += this._outer * width;
                    return result
                }
            });
            module.exports = LinearRangeContainer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/viz/gauges/tracker.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _abs = Math.abs,
                Class = __webpack_require__( /*! ../../core/class */ 5),
                wheelEvent = __webpack_require__( /*! ../../events/core/wheel */ 78),
                TOOLTIP_SHOW_DELAY = 300,
                TOOLTIP_HIDE_DELAY = 300,
                TOOLTIP_TOUCH_SHOW_DELAY = 400,
                TOOLTIP_TOUCH_HIDE_DELAY = 300;
            var Tracker = Class.inherit({
                ctor: function(parameters) {
                    var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                    debug.assertParam(parameters, "parameters");
                    debug.assertParam(parameters.renderer, "parameters.renderer");
                    debug.assertParam(parameters.container, "parameters.container");
                    var that = this;
                    that._element = parameters.renderer.g().attr({
                        "class": "dxg-tracker",
                        stroke: "none",
                        "stroke-width": 0,
                        fill: "#000000",
                        opacity: 1e-4
                    }).linkOn(parameters.container, {
                        name: "tracker",
                        after: "peripheral"
                    });
                    that._showTooltipCallback = function() {
                        that._showTooltipTimeout = null;
                        var target = that._tooltipEvent.target,
                            data_target = target["gauge-data-target"],
                            data_info = target["gauge-data-info"];
                        that._targetEvent = null;
                        if (that._tooltipTarget !== target && that._callbacks["tooltip-show"](data_target, data_info)) {
                            that._tooltipTarget = target
                        }
                    };
                    that._hideTooltipCallback = function() {
                        that._hideTooltipTimeout = null;
                        that._targetEvent = null;
                        if (that._tooltipTarget) {
                            that._callbacks["tooltip-hide"]();
                            that._tooltipTarget = null
                        }
                    };
                    that._dispose = function() {
                        clearTimeout(that._showTooltipTimeout);
                        clearTimeout(that._hideTooltipTimeout);
                        that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null
                    };
                    that._DEBUG_showTooltipTimeoutSet = that._DEBUG_showTooltipTimeoutCleared = that._DEBUG_hideTooltipTimeoutSet = that._DEBUG_hideTooltipTimeoutCleared = 0;
                    that.TOOLTIP_SHOW_DELAY = TOOLTIP_SHOW_DELAY;
                    that.TOOLTIP_HIDE_DELAY = TOOLTIP_HIDE_DELAY;
                    that.TOOLTIP_TOUCH_SHOW_DELAY = TOOLTIP_TOUCH_SHOW_DELAY;
                    that.TOOLTIP_TOUCH_HIDE_DELAY = TOOLTIP_TOUCH_HIDE_DELAY
                },
                dispose: function() {
                    var that = this;
                    that._dispose();
                    that.deactivate();
                    that._element.linkOff();
                    that._element = that._context = that._callbacks = null;
                    return that
                },
                activate: function() {
                    this._element.linkAppend();
                    return this
                },
                deactivate: function() {
                    this._element.linkRemove().clear();
                    return this
                },
                attach: function(element, target, info) {
                    element.data({
                        "gauge-data-target": target,
                        "gauge-data-info": info
                    }).append(this._element);
                    return this
                },
                detach: function(element) {
                    element.remove();
                    return this
                },
                setTooltipState: function(state) {
                    var data, that = this;
                    that._element.off(tooltipMouseEvents).off(tooltipTouchEvents).off(tooltipMouseWheelEvents);
                    if (state) {
                        data = {
                            tracker: that
                        };
                        that._element.on(tooltipMouseEvents, data).on(tooltipTouchEvents, data).on(tooltipMouseWheelEvents, data)
                    }
                    return that
                },
                setCallbacks: function(callbacks) {
                    this._callbacks = callbacks;
                    return this
                },
                _showTooltip: function(event, delay) {
                    var that = this;
                    that._hideTooltipTimeout && ++that._DEBUG_hideTooltipTimeoutCleared;
                    clearTimeout(that._hideTooltipTimeout);
                    that._hideTooltipTimeout = null;
                    if (that._tooltipTarget === event.target) {
                        return
                    }
                    clearTimeout(that._showTooltipTimeout);
                    that._tooltipEvent = event;
                    ++that._DEBUG_showTooltipTimeoutSet;
                    that._showTooltipTimeout = setTimeout(that._showTooltipCallback, delay)
                },
                _hideTooltip: function(delay) {
                    var that = this;
                    that._showTooltipTimeout && ++that._DEBUG_showTooltipTimeoutCleared;
                    clearTimeout(that._showTooltipTimeout);
                    that._showTooltipTimeout = null;
                    clearTimeout(that._hideTooltipTimeout);
                    if (delay) {
                        ++that._DEBUG_hideTooltipTimeoutSet;
                        that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay)
                    } else {
                        that._hideTooltipCallback()
                    }
                }
            });
            var tooltipMouseEvents = {
                "mouseover.gauge-tooltip": handleTooltipMouseOver,
                "mouseout.gauge-tooltip": handleTooltipMouseOut
            };
            var tooltipMouseMoveEvents = {
                "mousemove.gauge-tooltip": handleTooltipMouseMove
            };
            var tooltipMouseWheelEvents = {};
            tooltipMouseWheelEvents[wheelEvent.name + ".gauge-tooltip"] = handleTooltipMouseWheel;
            var tooltipTouchEvents = {
                "touchstart.gauge-tooltip": handleTooltipTouchStart
            };

            function handleTooltipMouseOver(event) {
                var tracker = event.data.tracker;
                tracker._x = event.pageX;
                tracker._y = event.pageY;
                tracker._element.off(tooltipMouseMoveEvents).on(tooltipMouseMoveEvents, event.data);
                tracker._showTooltip(event, TOOLTIP_SHOW_DELAY)
            }

            function handleTooltipMouseMove(event) {
                var tracker = event.data.tracker;
                if (tracker._showTooltipTimeout && _abs(event.pageX - tracker._x) > 4 || _abs(event.pageY - tracker._y) > 4) {
                    tracker._x = event.pageX;
                    tracker._y = event.pageY;
                    tracker._showTooltip(event, TOOLTIP_SHOW_DELAY)
                }
            }

            function handleTooltipMouseOut(event) {
                var tracker = event.data.tracker;
                tracker._element.off(tooltipMouseMoveEvents);
                tracker._hideTooltip(TOOLTIP_HIDE_DELAY)
            }

            function handleTooltipMouseWheel(event) {
                event.data.tracker._hideTooltip()
            }
            var active_touch_tooltip_tracker = null;
            Tracker._DEBUG_reset = function() {
                active_touch_tooltip_tracker = null
            };

            function handleTooltipTouchStart(event) {
                event.preventDefault();
                var tracker = active_touch_tooltip_tracker;
                if (tracker && tracker !== event.data.tracker) {
                    tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY)
                }
                tracker = active_touch_tooltip_tracker = event.data.tracker;
                tracker._showTooltip(event, TOOLTIP_TOUCH_SHOW_DELAY);
                tracker._touch = true
            }

            function handleTooltipDocumentTouchStart() {
                var tracker = active_touch_tooltip_tracker;
                if (tracker) {
                    if (!tracker._touch) {
                        tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY);
                        active_touch_tooltip_tracker = null
                    }
                    tracker._touch = null
                }
            }

            function handleTooltipDocumentTouchEnd() {
                var tracker = active_touch_tooltip_tracker;
                if (tracker) {
                    if (tracker._showTooltipTimeout) {
                        tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY);
                        active_touch_tooltip_tracker = null
                    }
                }
            }
            $(window.document).on({
                "touchstart.gauge-tooltip": handleTooltipDocumentTouchStart,
                "touchend.gauge-tooltip": handleTooltipDocumentTouchEnd
            });
            module.exports = Tracker
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************!*\
      !*** ./Scripts/viz/linear_gauge.js ***!
      \*************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./gauges/linear_gauge */ 525)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************!*\
      !*** ./Scripts/viz/pie_chart.js ***!
      \**********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                errors = __webpack_require__( /*! ../core/errors */ 10),
                seriesConsts = __webpack_require__( /*! ./components/consts */ 126),
                vizUtils = __webpack_require__( /*! ./core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../core/utils/common */ 2),
                rangeModule = __webpack_require__( /*! ./translators/range */ 89),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                baseChartModule = __webpack_require__( /*! ./chart_components/base_chart */ 232),
                BaseChart = baseChartModule.BaseChart,
                overlapping = baseChartModule.overlapping,
                seriesSpacing = seriesConsts.pieSeriesSpacing,
                translator1DModule = __webpack_require__( /*! ./translators/translator1d */ 341),
                OPTIONS_FOR_REFRESH_SERIES = ["startAngle", "innerRadius", "segmentsDirection", "type"],
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop,
                _getVerticallyShiftedAngularCoords = __webpack_require__( /*! ./core/utils */ 6).getVerticallyShiftedAngularCoords,
                states = seriesConsts.states,
                SELECTED_STATE = states.selectedMark,
                HOVER_STATE = states.hoverMark,
                HOVER = states.hover,
                NORMAL = states.normal,
                SELECTION = states.selection,
                APPLY_HOVER = states.applyHover,
                RESET_ITEM = states.resetItem;

            function AbstractSeries(index, points) {
                var that = this;
                that.index = index;
                that.fullState = 0;
                that._points = points;
                that._selectedPointsCount = 0;
                return that
            }
            AbstractSeries.prototype = {
                isHovered: function() {
                    return !!(1 & this.fullState)
                },
                setHoverState: function(state, _, legendCallback) {
                    var that = this;
                    if (state && !that.isHovered()) {
                        that._changeStyle(legendCallback, APPLY_HOVER, HOVER);
                        that.fullState |= HOVER_STATE
                    } else {
                        if (!state && that.isHovered()) {
                            that._changeStyle(legendCallback, RESET_ITEM, NORMAL);
                            that.fullState &= ~HOVER_STATE
                        }
                    }
                },
                _changeStyle: function(legendCallback, legendAction, pointAction) {
                    var that = this;
                    !that._selectedPointsCount && legendCallback(legendAction);
                    _each(that._points || [], function(_, p) {
                        !p.isSelected() && p.applyStyle(pointAction)
                    })
                },
                setPointHoverState: function(data) {
                    var point = data.point;
                    point.fullState |= HOVER_STATE;
                    if (!point.isSelected()) {
                        point.applyStyle(HOVER);
                        if (!this._selectedPointsCount) {
                            data.legendCallback(APPLY_HOVER)
                        }
                    }
                },
                releasePointHoverState: function(data) {
                    var point = data.point;
                    point.fullState &= ~HOVER_STATE;
                    if (!point.isSelected()) {
                        point.applyStyle(NORMAL);
                        if (!this._selectedPointsCount) {
                            data.legendCallback(RESET_ITEM)
                        }
                    }
                },
                setPointSelectedState: function(data) {
                    var that = this,
                        point = data.point;
                    point.fullState |= SELECTED_STATE;
                    point.applyStyle(SELECTION);
                    !that._selectedPointsCount && data.legendCallback(states.applySelected);
                    that._selectedPointsCount++
                },
                releasePointSelectedState: function(data) {
                    var action, that = this,
                        point = data.point;
                    point.fullState &= ~SELECTED_STATE;
                    if (point.isHovered() || that.isHovered()) {
                        point.applyStyle(HOVER);
                        action = APPLY_HOVER
                    } else {
                        point.applyStyle(NORMAL);
                        action = RESET_ITEM
                    }
                    that._selectedPointsCount--;
                    !that._selectedPointsCount && data.legendCallback(action)
                }
            };
            var dxPieChart = BaseChart.inherit({
                _setDeprecatedOptions: function() {
                    this.callBase.apply(this, arguments);
                    _extend(this._deprecatedOptions, {
                        "series.innerRadius": {
                            since: "15.2",
                            message: "Use the 'innerRadius' option instead"
                        },
                        "series.startAngle": {
                            since: "15.2",
                            message: "Use the 'startAngle' option instead"
                        },
                        "series.segmentsDirection": {
                            since: "15.2",
                            message: "Use the 'segmentsDirection' option instead"
                        },
                        "series.type": {
                            since: "15.2",
                            message: "Use the 'type' option instead"
                        }
                    })
                },
                _chartType: "pie",
                _layoutManagerOptions: function() {
                    var diameter = this._themeManager.getOptions("diameter");
                    if (commonUtils.isNumber(diameter)) {
                        if (diameter > 1) {
                            diameter = 1
                        } else {
                            if (diameter < 0) {
                                diameter = 0
                            }
                        }
                    } else {
                        diameter = void 0
                    }
                    return _extend(true, {}, this.callBase(), {
                        piePercentage: diameter
                    })
                },
                _optionChangesMap: {
                    diameter: "REINIT"
                },
                _groupSeries: function() {
                    var series = this.series;
                    this._groupsData = {
                        groups: [{
                            series: series,
                            valueOptions: {
                                valueType: "numeric"
                            }
                        }],
                        argumentOptions: series[0] && series[0].getOptions()
                    }
                },
                _populateBusinessRange: function() {
                    var singleSeriesRange, businessRanges = [],
                        series = this.series;
                    this.businessRanges = null;
                    _each(series, function(_, singleSeries) {
                        var range = new rangeModule.Range;
                        singleSeriesRange = singleSeries.getRangeData();
                        range.addRange(singleSeriesRange.val);
                        if (!range.isDefined()) {
                            range.setStubData()
                        }
                        businessRanges.push(range)
                    });
                    this.businessRanges = businessRanges
                },
                _specialProcessSeries: function() {
                    _each(this.series, function(_, singleSeries) {
                        singleSeries.arrangePoints()
                    })
                },
                _createTranslator: function(range) {
                    return (new translator1DModule.Translator1D).setDomain(range.min, range.max).setCodomain(360, 0)
                },
                _checkPaneName: function() {
                    return true
                },
                _processSingleSeries: function(singleSeries) {
                    singleSeries.arrangePoints()
                },
                _collectPointsByArg: function() {
                    var itemIndex, that = this,
                        points = {},
                        args = {},
                        index = 0;
                    _each(that.series, function(_, singleSeries) {
                        var count, arrayArguments = {};
                        _each(singleSeries.getPoints(), function(_, point) {
                            var argument = point.argument;
                            arrayArguments[argument] = ++arrayArguments[argument] || 0;
                            count = arrayArguments[argument];
                            itemIndex = args[argument + count];
                            if (void 0 === itemIndex) {
                                point.index = args[argument + count] = index;
                                points[index] = [point];
                                index++
                            } else {
                                point.index = itemIndex;
                                points[itemIndex].push(point)
                            }
                        })
                    });
                    that._collectionPointsArg = points
                },
                _getLegendTargets: function() {
                    var that = this,
                        points = [];
                    _each(that._collectionPointsArg, function(_, id) {
                        _each(id, function(i, point) {
                            if (0 === i) {
                                points.push(that._getLegendOptions(point))
                            } else {
                                if (!points[points.length - 1].visible) {
                                    points[points.length - 1].visible = point.isVisible()
                                }
                            }
                        })
                    });
                    return points
                },
                _getAxisDrawingMethods: _noop,
                _getLayoutTargets: function() {
                    return [{
                        canvas: this._canvas
                    }]
                },
                _getAxesForTransform: function() {
                    return {
                        verticalAxes: [],
                        horizontalAxes: []
                    }
                },
                _getLayoutSeries: function(series, drawOptions) {
                    var layout, that = this,
                        canvas = that._canvas,
                        drawnLabels = false;
                    layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
                    _each(series, function(i, singleSeries) {
                        singleSeries.correctPosition(layout);
                        drawnLabels = singleSeries.drawLabelsWOPoints(that._createTranslator(that.businessRanges[i])) || drawnLabels
                    });
                    if (drawnLabels) {
                        layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels)
                    }
                    return layout
                },
                _updateSeriesDimensions: function(drawOptions) {
                    var innerRad, delta, layout, that = this,
                        visibleSeries = that._getVisibleSeries(),
                        lengthVisibleSeries = visibleSeries.length;
                    if (lengthVisibleSeries) {
                        layout = that._getLayoutSeries(visibleSeries, drawOptions);
                        delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
                        innerRad = layout.radiusInner;
                        that._setCenter({
                            x: layout.centerX,
                            y: layout.centerY
                        });
                        _each(visibleSeries, function(_, singleSeries) {
                            singleSeries.correctRadius({
                                radiusInner: innerRad,
                                radiusOuter: innerRad + delta
                            });
                            innerRad += delta + seriesSpacing
                        })
                    }
                },
                _prepareTranslators: function(_, i) {
                    return this._createTranslator(this.businessRanges[i])
                },
                _getLegendCallBack: function() {
                    var legend = this._legend;
                    return function(point) {
                        return legend.getActionCallback(point)
                    }
                },
                _adjustSeries: function() {
                    _each(this.series, function(_, singleSeries) {
                        singleSeries.adjustLabels()
                    })
                },
                _prepareStackPoints: _noop,
                _resetStackPoints: _noop,
                _applyExtraSettings: _noop,
                _resolveLabelOverlappingShift: function() {
                    var that = this,
                        series = that.series,
                        center = that._center;
                    _each(series, function(_, singleSeries) {
                        if ("inside" === singleSeries.getOptions().label.position) {
                            return
                        }
                        var points = singleSeries.getVisiblePoints(),
                            lPoints = [],
                            rPoints = [];
                        $.each(points, function(_, point) {
                            var angle = vizUtils.normalizeAngle(point.middleAngle);
                            (angle <= 90 || angle >= 270 ? rPoints : lPoints).push(point)
                        });
                        overlapping.resolveLabelOverlappingInOneDirection(lPoints, that._canvas, false, shiftFunction);
                        overlapping.resolveLabelOverlappingInOneDirection(rPoints, that._canvas, false, shiftFunction)
                    });

                    function shiftFunction(box, length) {
                        return _getVerticallyShiftedAngularCoords(box, -length, center)
                    }
                },
                _setCenter: function(center) {
                    this._center = center
                },
                _getStoredSeries: function() {
                    if (this._abstractSeries && 0 === this._abstractSeries.length) {
                        this._abstractSeries = null
                    }
                    this._abstractSeries = this._abstractSeries || $.map(this._collectionPointsArg, function(points, i) {
                        return new AbstractSeries(i, points)
                    });
                    return this._abstractSeries
                },
                _disposeSeries: function() {
                    this.callBase.apply(this, arguments);
                    this._abstractSeries = null
                },
                getSeries: function() {
                    errors.log("W0002", "dxPieChart", "getSeries", "15.2", "Use the 'getAllSeries' method instead");
                    return this.series[0]
                },
                _legendDataField: "point",
                _legendItemTextField: "argument",
                _updateLegendPosition: _noop,
                _renderTrackers: _noop,
                _trackerType: "PieTracker",
                _createScrollBar: _noop,
                _updateAxesLayout: _noop,
                _applyClipRects: _noop,
                _appendAdditionalSeriesGroups: _noop,
                _prepareToRender: _noop,
                _isLegendInside: _noop,
                _renderAxes: _noop,
                _isRotated: _noop,
                _seriesPopulatedHandlerCore: _noop,
                _reinitAxes: _noop,
                _correctAxes: _noop,
                _getExtraOptions: function() {
                    var that = this;
                    return {
                        startAngle: that.option("startAngle"),
                        innerRadius: that.option("innerRadius"),
                        segmentsDirection: that.option("segmentsDirection"),
                        type: that.option("type")
                    }
                }
            });
            _each(OPTIONS_FOR_REFRESH_SERIES, function(_, name) {
                dxPieChart.prototype._optionChangesMap[name] = "REFRESH_SERIES_DATA_INIT"
            });
            registerComponent("dxPieChart", dxPieChart);
            module.exports = dxPieChart
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************!*\
      !*** ./Scripts/viz/polar_chart.js ***!
      \************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                registerComponent = __webpack_require__( /*! ../core/component_registrator */ 3),
                vizUtils = __webpack_require__( /*! ./core/utils */ 6),
                polarTranslatorModule = __webpack_require__( /*! ./translators/polar_translator */ 340),
                rangeModule = __webpack_require__( /*! ./translators/range */ 89),
                AdvancedChart = __webpack_require__( /*! ./chart_components/advanced_chart */ 327).AdvancedChart,
                _noop = $.noop,
                DEFAULT_PANE_NAME = "default";
            var dxPolarChart = AdvancedChart.inherit({
                _chartType: "polar",
                _createPanes: function() {
                    return [{
                        name: DEFAULT_PANE_NAME
                    }]
                },
                _checkPaneName: function() {
                    return true
                },
                _getAxisRenderingOptions: function(typeSelector) {
                    var isArgumentAxis = "argumentAxis" === typeSelector,
                        type = isArgumentAxis ? "circular" : "linear",
                        useSpiderWeb = this.option("useSpiderWeb");
                    if (useSpiderWeb) {
                        type += "Spider"
                    }
                    return {
                        axisType: "polarAxes",
                        drawingType: type
                    }
                },
                _prepareAxisOptions: function(typeSelector, axisOptions) {
                    var isArgumentAxis = "argumentAxis" === typeSelector;
                    return {
                        type: this.option("useSpiderWeb") && isArgumentAxis ? "discrete" : axisOptions.type,
                        isHorizontal: true,
                        showCustomBoundaryTicks: isArgumentAxis
                    }
                },
                _optionChangesMap: {
                    useSpiderWeb: "REINIT"
                },
                _getExtraOptions: function() {
                    return {
                        spiderWidget: this.option("useSpiderWeb")
                    }
                },
                _groupSeries: function() {
                    var that = this;
                    that._groupsData = {
                        groups: [{
                            series: that.series,
                            valueAxis: that._valueAxes[0],
                            valueOptions: that._valueAxes[0].getOptions()
                        }],
                        argumentAxes: that._argumentAxes,
                        argumentOptions: that._argumentAxes[0].getOptions()
                    }
                },
                _prepareToRender: function() {
                    this._appendAxesGroups();
                    return {}
                },
                _renderAxes: function(drawOptions, _, __, adjustUnits) {
                    this._drawAxes({}, drawOptions, adjustUnits)
                },
                _getAxisDrawingMethods: function(drawOptions, preparedOptions, isRotated, adjustUnits) {
                    var that = this;
                    return function() {
                        that._renderAxes(drawOptions, preparedOptions, isRotated, adjustUnits)
                    }
                },
                _reinitTranslators: function() {
                    var that = this,
                        valueAxes = that._valueAxes,
                        argumentAxes = that._argumentAxes,
                        translator = that._createTranslator({
                            arg: new rangeModule.Range(that.businessRanges[0].arg),
                            val: new rangeModule.Range(that.businessRanges[0].val)
                        }),
                        argTranslator = translator.getComponent("arg"),
                        valTranslator = translator.getComponent("val"),
                        i = 0;
                    that.translator = translator;
                    argumentAxes[0].setTranslator(argTranslator, valTranslator);
                    for (i; i < valueAxes.length; i++) {
                        valueAxes[i].setTranslator(valTranslator, argTranslator)
                    }
                },
                _prepareAxesAndDraw: function(drawAxes, drawStaticAxisElements) {
                    var that = this,
                        valueAxes = that._valueAxes,
                        argAxes = that._argumentAxes,
                        argumentAxis = argAxes[0];
                    that._calcCanvas(argumentAxis.measureLabels(true));
                    that.translator.reinit();
                    drawAxes(argAxes);
                    $.each(valueAxes, function(_, valAxis) {
                        valAxis.setSpiderTicks(argumentAxis.getSpiderTicks())
                    });
                    drawAxes(valueAxes);
                    drawStaticAxisElements(argAxes);
                    drawStaticAxisElements(valueAxes)
                },
                _calcCanvas: function(measure) {
                    var canvas = this.translator.canvas;
                    canvas.left += measure.width;
                    canvas.right += measure.width;
                    canvas.top += measure.height;
                    canvas.bottom += measure.height
                },
                _getLayoutTargets: function() {
                    return [{
                        canvas: this._canvas
                    }]
                },
                _getAxesForTransform: function() {
                    var argAxes = this._getArgumentAxes();
                    return {
                        verticalAxes: argAxes,
                        horizontalAxes: argAxes
                    }
                },
                _getTranslator: function() {
                    var translator = this.translator;
                    return {
                        val: translator,
                        arg: translator
                    }
                },
                _prepareTranslators: function() {
                    return this.translator
                },
                _createTranslator: function(br) {
                    var themeManager = this._themeManager,
                        axisUserOptions = this.option("argumentAxis"),
                        axisOptions = themeManager.getOptions("argumentAxis", axisUserOptions) || {},
                        startAngle = isFinite(axisOptions.startAngle) ? vizUtils.normalizeAngle(axisOptions.startAngle) : 0;
                    return new polarTranslatorModule.PolarTranslator(br, $.extend(true, {}, this._canvas), {
                        startAngle: startAngle,
                        endAngle: startAngle + 360
                    })
                },
                _getSeriesForPane: function() {
                    return this.series
                },
                _applyExtraSettings: _noop,
                _updateLegendPosition: _noop,
                _createScrollBar: _noop,
                _applyClipRects: _noop,
                _isRotated: _noop,
                _getCrosshairOptions: _noop,
                _isLegendInside: _noop,
                _processSingleSeries: _noop
            });
            registerComponent("dxPolarChart", dxPolarChart);
            module.exports = dxPolarChart
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************!*\
      !*** ./Scripts/viz/range_selector.js ***!
      \***************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./range_selector/range_selector */ 533)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/range_selector/range_selector.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                registerComponent = __webpack_require__( /*! ../../core/component_registrator */ 3),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                adjustValue = vizUtils.adjustValue,
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                correctDate = dateUtils.correctDateWithUnitBeginning,
                addInterval = dateUtils.addInterval,
                dateToMilliseconds = dateUtils.dateToMilliseconds,
                rangeModule = __webpack_require__( /*! ../translators/range */ 89),
                translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 105),
                axisModule = __webpack_require__( /*! ../axes/base_axis */ 231),
                patchFontOptions = vizUtils.patchFontOptions,
                parseUtils = __webpack_require__( /*! ../components/parse_utils */ 234),
                _normalizeEnum = vizUtils.normalizeEnum,
                formatHelper = __webpack_require__( /*! ../../format_helper */ 68),
                commonModule = __webpack_require__( /*! ./common */ 192),
                slidersControllerModule = __webpack_require__( /*! ./sliders_controller */ 538),
                trackerModule = __webpack_require__( /*! ./tracker */ 540),
                rangeViewModule = __webpack_require__( /*! ./range_view */ 534),
                seriesDataSourceModule = __webpack_require__( /*! ./series_data_source */ 535),
                themeManagerModule = __webpack_require__( /*! ./theme_manager */ 539),
                tickManagerModule = __webpack_require__( /*! ../axes/base_tick_manager */ 325),
                _isDefined = commonUtils.isDefined,
                _isNumber = commonUtils.isNumber,
                _isDate = commonUtils.isDate,
                _max = Math.max,
                _ceil = Math.ceil,
                _floor = Math.floor,
                START_VALUE = "startValue",
                END_VALUE = "endValue",
                DATETIME = "datetime",
                SELECTED_RANGE = "selectedRange",
                DISCRETE = "discrete",
                SEMIDISCRETE = "semidiscrete",
                STRING = "string",
                SELECTED_RANGE_CHANGED = SELECTED_RANGE + "Changed",
                CONTAINER_BACKGROUND_COLOR = "containerBackgroundColor",
                SLIDER_MARKER = "sliderMarker",
                OPTION_BACKGROUND = "background",
                LOGARITHMIC = "logarithmic",
                INVISIBLE_POS = -1e3,
                SEMIDISCRETE_GRID_SPACING_FACTOR = 50,
                logarithmBase = 10;

            function createTranslator() {
                return new translator2DModule.Translator2D({}, {})
            }

            function updateTranslator(translator, valueRange, screenRange, interval) {
                translator.update(valueRange, {
                    left: screenRange[0],
                    width: screenRange[1]
                }, {
                    isHorizontal: true,
                    interval: interval
                })
            }

            function calculateMarkerHeight(renderer, value, sliderMarkerOptions) {
                var formattedText = void 0 === value ? commonModule.consts.emptySliderMarkerText : commonModule.formatValue(value, sliderMarkerOptions),
                    textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
                return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + commonModule.consts.pointerSize
            }

            function calculateScaleLabelHalfWidth(renderer, value, scaleOptions) {
                var formattedText = commonModule.formatValue(value, scaleOptions.label),
                    textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);
                return _ceil(textBBox.width / 2)
            }

            function parseSliderMarkersPlaceholderSize(placeholderSize) {
                var placeholderWidthLeft, placeholderWidthRight, placeholderHeight;
                if (_isNumber(placeholderSize)) {
                    placeholderWidthLeft = placeholderWidthRight = placeholderHeight = placeholderSize
                } else {
                    if (placeholderSize) {
                        if (_isNumber(placeholderSize.height)) {
                            placeholderHeight = placeholderSize.height
                        }
                        if (_isNumber(placeholderSize.width)) {
                            placeholderWidthLeft = placeholderWidthRight = placeholderSize.width
                        } else {
                            if (placeholderSize.width) {
                                if (_isNumber(placeholderSize.width.left)) {
                                    placeholderWidthLeft = placeholderSize.width.left
                                }
                                if (_isNumber(placeholderSize.width.right)) {
                                    placeholderWidthRight = placeholderSize.width.right
                                }
                            }
                        }
                    } else {
                        return null
                    }
                }
                return {
                    widthLeft: placeholderWidthLeft,
                    widthRight: placeholderWidthRight,
                    height: placeholderHeight
                }
            }

            function calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions) {
                var leftMarkerHeight, rightMarkerHeight, placeholderHeight, parsedPlaceholderSize, leftScaleLabelWidth = 0,
                    rightScaleLabelWidth = 0,
                    placeholderWidthLeft = 0,
                    placeholderWidthRight = 0;
                indentOptions = indentOptions || {};
                parsedPlaceholderSize = parseSliderMarkersPlaceholderSize(sliderMarkerOptions.placeholderSize);
                if (parsedPlaceholderSize && void 0 === indentOptions.left && void 0 === indentOptions.right) {
                    placeholderWidthLeft = parsedPlaceholderSize.widthLeft;
                    placeholderWidthRight = parsedPlaceholderSize.widthRight
                } else {
                    placeholderWidthLeft = indentOptions.left;
                    placeholderWidthRight = indentOptions.right
                }
                if (parsedPlaceholderSize && void 0 === sliderMarkerOptions.placeholderHeight) {
                    placeholderHeight = parsedPlaceholderSize.height
                } else {
                    placeholderHeight = sliderMarkerOptions.placeholderHeight
                }
                if (sliderMarkerOptions.visible) {
                    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);
                    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);
                    if (void 0 === placeholderHeight) {
                        placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight)
                    }
                }
                if (scale.label.visible) {
                    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.startValue, scale);
                    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.endValue, scale)
                }
                placeholderWidthLeft = void 0 !== placeholderWidthLeft ? placeholderWidthLeft : leftScaleLabelWidth;
                placeholderWidthRight = (void 0 !== placeholderWidthRight ? placeholderWidthRight : rightScaleLabelWidth) || 1;
                return {
                    left: placeholderWidthLeft,
                    right: placeholderWidthRight,
                    top: placeholderHeight || 0,
                    bottom: 0
                }
            }

            function calculateValueType(firstValue, secondValue) {
                var typeFirstValue = $.type(firstValue),
                    typeSecondValue = $.type(secondValue),
                    validType = function(type) {
                        return typeFirstValue === type || typeSecondValue === type
                    };
                return validType("date") ? DATETIME : validType("number") ? "numeric" : validType(STRING) ? STRING : ""
            }

            function showScaleMarkers(scaleOptions) {
                return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible
            }

            function updateTranslatorRangeInterval(translatorRange, scaleOptions) {
                var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;
                if ("datetime" === scaleOptions.valueType) {
                    intervalX = dateUtils.dateToMilliseconds(intervalX)
                }
                translatorRange.addRange({
                    interval: intervalX
                })
            }

            function checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {
                var logarithmBase;
                if (!options) {
                    return
                }
                logarithmBase = options.logarithmBase;
                if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !_isNumber(logarithmBase)) {
                    options.logarithmBase = defaultLogarithmBase;
                    incidentOccurred("E2104")
                } else {
                    if (options.type !== LOGARITHMIC) {
                        options.logarithmBase = void 0
                    }
                }
            }

            function calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers) {
                var textBBox, value = "0",
                    formatObject = {
                        value: 0,
                        valueText: value
                    },
                    labelScaleOptions = scaleOptions.label,
                    markerScaleOptions = scaleOptions.marker,
                    customizeText = labelScaleOptions.customizeText,
                    placeholderHeight = scaleOptions.placeholderHeight,
                    text = commonUtils.isFunction(customizeText) ? customizeText.call(formatObject, formatObject) : value,
                    visibleLabels = labelScaleOptions.visible;
                if (placeholderHeight) {
                    return placeholderHeight
                } else {
                    textBBox = getTextBBox(renderer, text, labelScaleOptions.font);
                    return (visibleLabels ? labelScaleOptions.topIndent + textBBox.height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0)
                }
            }

            function getNextTickInterval(tickInterval, minorTickInterval, isDateType) {
                if (!tickInterval) {
                    tickInterval = minorTickInterval
                } else {
                    if (isDateType) {
                        tickInterval = dateUtils.getNextDateUnit(tickInterval)
                    } else {
                        tickInterval += minorTickInterval
                    }
                }
                return tickInterval
            }

            function calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {
                var interval, delta, minorTickInterval = scaleOptions.minorTickInterval,
                    tickInterval = scaleOptions.tickInterval,
                    isDateType = "datetime" === scaleOptions.valueType,
                    gridSpacingFactor = scaleOptions.axisDivisionFactor || {};
                if (!tickInterval) {
                    do {
                        interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);
                        if (tickInterval !== interval) {
                            tickInterval = interval
                        } else {
                            break
                        }
                        if (isDateType) {
                            interval = dateToMilliseconds(tickInterval)
                        }
                        delta = screenDelta / (_ceil((max - min) / interval) + 1)
                    } while (interval && delta < (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR))
                }
                return {
                    tickInterval: tickInterval,
                    minorTickInterval: minorTickInterval,
                    bounds: {
                        minVisible: min,
                        maxVisible: max
                    },
                    ticks: []
                }
            }

            function updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {
                var result, tickManager, ticks, min = _isDefined(range.minVisible) ? range.minVisible : range.min,
                    max = _isDefined(range.maxVisible) ? range.maxVisible : range.max,
                    categoriesInfo = scaleOptions._categoriesInfo;
                if (scaleOptions.type === SEMIDISCRETE) {
                    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta)
                } else {
                    tickManager = new tickManagerModule.TickManager({
                        axisType: scaleOptions.type,
                        dataType: scaleOptions.valueType
                    }, {
                        min: min,
                        max: max,
                        screenDelta: screenDelta,
                        customTicks: categoriesInfo && categoriesInfo.categories
                    }, {
                        labelOptions: {},
                        boundCoef: 1,
                        minorTickInterval: scaleOptions.minorTickInterval,
                        tickInterval: scaleOptions.tickInterval,
                        incidentOccurred: incidentOccurred,
                        base: scaleOptions.logarithmBase,
                        showMinorTicks: true,
                        withMinorCorrection: true,
                        stick: false !== range.stick
                    });
                    ticks = tickManager.getTicks(true);
                    result = {
                        tickInterval: tickManager.getTickInterval(),
                        minorTickInterval: tickManager.getMinorTickInterval(),
                        bounds: tickManager.getTickBounds(),
                        ticks: ticks
                    }
                }
                return result
            }

            function calculateTranslatorRange(seriesDataSource, scaleOptions) {
                var minValue, maxValue, isEqualDates, categories, categoriesInfo, rangeForCategories, inverted = false,
                    startValue = scaleOptions.startValue,
                    endValue = scaleOptions.endValue,
                    translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new rangeModule.Range,
                    isDate = "datetime" === scaleOptions.valueType,
                    minRange = scaleOptions.minRange;
                if (scaleOptions.type === DISCRETE) {
                    rangeForCategories = new rangeModule.Range({
                        minVisible: startValue,
                        maxVisible: endValue
                    });
                    rangeForCategories.addRange(translatorRange);
                    translatorRange = rangeForCategories;
                    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || !seriesDataSource && startValue && endValue && [startValue, endValue];
                    categories = categories || [];
                    scaleOptions._categoriesInfo = categoriesInfo = vizUtils.getCategoriesInfo(categories, startValue || categories[0], endValue || categories[categories.length - 1])
                }
                if (scaleOptions.type === SEMIDISCRETE) {
                    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange);
                    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange);
                    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange);
                    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange);
                    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange);
                    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange)
                }
                if (_isDefined(startValue) && _isDefined(endValue)) {
                    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
                    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
                    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue
                } else {
                    if (_isDefined(startValue) || _isDefined(endValue)) {
                        minValue = startValue;
                        maxValue = endValue
                    } else {
                        if (categoriesInfo) {
                            minValue = categoriesInfo.start;
                            maxValue = categoriesInfo.end
                        }
                    }
                }
                isEqualDates = _isDate(minValue) && _isDate(maxValue) && minValue.getTime() === maxValue.getTime();
                if (scaleOptions.type === SEMIDISCRETE || minValue !== maxValue && !isEqualDates) {
                    translatorRange.addRange({
                        invert: inverted,
                        min: minValue,
                        max: maxValue,
                        minVisible: minValue,
                        maxVisible: maxValue,
                        dataType: scaleOptions.valueType
                    })
                }
                translatorRange.addRange({
                    categories: categories,
                    base: scaleOptions.logarithmBase,
                    axisType: scaleOptions.type
                });
                if (!translatorRange.isDefined()) {
                    if (isEqualDates) {
                        scaleOptions.valueType = "numeric"
                    }
                    translatorRange.setStubData(scaleOptions.valueType)
                }
                return translatorRange
            }

            function startEndNotDefined(start, end) {
                return !_isDefined(start) || !_isDefined(end)
            }

            function getTextBBox(renderer, text, fontOptions) {
                var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css(patchFontOptions(fontOptions)).append(renderer.root);
                var textBBox = textElement.getBBox();
                textElement.remove();
                return textBBox
            }

            function updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo) {
                var bounds, isEmptyInterval, intervals, categoriesInfo = scaleOptions._categoriesInfo;
                if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.stubData) {
                    bounds = tickIntervalsInfo.bounds;
                    translatorRange.addRange(bounds);
                    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;
                    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible
                }
                if (categoriesInfo) {
                    scaleOptions.startValue = categoriesInfo.start;
                    scaleOptions.endValue = categoriesInfo.end
                }
                if (-1 === scaleOptions.type.indexOf(DISCRETE)) {
                    isEmptyInterval = _isDate(scaleOptions.startValue) && _isDate(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue
                }
                scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;
                if (scaleOptions.isEmpty) {
                    scaleOptions.startValue = scaleOptions.endValue = void 0
                } else {
                    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
                    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;
                    if (scaleOptions.valueType === DATETIME && (!_isDefined(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {
                        if (scaleOptions.type === DISCRETE) {
                            scaleOptions.label.format = formatHelper.getDateFormatByTicks(tickIntervalsInfo.ticks)
                        } else {
                            if (!scaleOptions.marker.visible) {
                                scaleOptions.label.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval)
                            } else {
                                scaleOptions.label.format = dateUtils.getDateFormatByTickInterval(scaleOptions.tickInterval)
                            }
                        }
                    }
                }
                if (scaleOptions.type === SEMIDISCRETE) {
                    intervals = getIntervalCustomTicks(scaleOptions);
                    scaleOptions.customMinorTicks = intervals.altIntervals;
                    scaleOptions.customTicks = intervals.intervals;
                    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]]
                }
            }

            function prepareScaleOptions(scaleOption, seriesDataSource, incidentOccurred) {
                var parser, parsedValue = 0,
                    valueType = parseUtils.correctValueType(_normalizeEnum(scaleOption.valueType)),
                    validateStartEndValues = function(field, parser) {
                        var messageToIncidentOccurred = field === START_VALUE ? "start" : "end";
                        if (_isDefined(scaleOption[field])) {
                            parsedValue = parser(scaleOption[field]);
                            if (_isDefined(parsedValue)) {
                                scaleOption[field] = parsedValue
                            } else {
                                scaleOption[field] = void 0;
                                incidentOccurred("E2202", [messageToIncidentOccurred])
                            }
                        }
                    };
                if (seriesDataSource) {
                    valueType = seriesDataSource.getCalculatedValueType() || valueType
                }
                if (!valueType) {
                    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || "numeric"
                }
                if (valueType === STRING || scaleOption.categories) {
                    scaleOption.type = DISCRETE;
                    valueType = STRING
                }
                scaleOption.valueType = valueType;
                parser = parseUtils.getParser(valueType);
                validateStartEndValues(START_VALUE, parser);
                validateStartEndValues(END_VALUE, parser);
                checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);
                if (!scaleOption.type) {
                    scaleOption.type = "continuous"
                }
                void 0 === scaleOption.tickInterval && (scaleOption.tickInterval = scaleOption.majorTickInterval);
                scaleOption.minorTick.visible && (scaleOption.minorTick.visible = scaleOption.showMinorTicks);
                scaleOption.parser = parser;
                if (scaleOption.type === SEMIDISCRETE) {
                    scaleOption.minorTick.visible = false;
                    scaleOption.minorTickInterval = scaleOption.minRange;
                    scaleOption.marker.visible = false;
                    scaleOption.maxRange = void 0
                }
                return scaleOption
            }

            function correctValueByInterval(value, isDate, interval) {
                if (_isDefined(value)) {
                    if (isDate) {
                        value = new Date(value);
                        correctDate(value, interval)
                    } else {
                        value = adjustValue(_floor(value / interval) * interval)
                    }
                }
                return value
            }

            function getIntervalCustomTicks(options) {
                var min = options.startValue,
                    max = options.endValue,
                    isDate = "datetime" === options.valueType,
                    tickInterval = options.tickInterval,
                    res = {
                        intervals: []
                    };
                if (!_isDefined(min) || !_isDefined(max)) {
                    return res
                }
                res.intervals = calculateIntervals(min, max, options.minorTickInterval);
                if (tickInterval !== options.minorTickInterval) {
                    res.altIntervals = res.intervals;
                    min = correctValueByInterval(min, isDate, tickInterval);
                    max = correctValueByInterval(max, isDate, tickInterval);
                    res.intervals = calculateIntervals(min, max, tickInterval)
                }
                return res
            }

            function calculateIntervals(min, max, interval) {
                var cur, intervals = [];
                intervals.push(min);
                cur = min;
                while (cur < max) {
                    cur = addInterval(cur, interval);
                    intervals.push(cur)
                }
                return intervals
            }
            var dxRangeSelector = __webpack_require__( /*! ../core/base_widget */ 109).inherit({
                _eventsMap: {
                    onSelectedRangeChanged: {
                        name: SELECTED_RANGE_CHANGED
                    }
                },
                _setDeprecatedOptions: function() {
                    this.callBase.apply(this, arguments);
                    $.extend(this._deprecatedOptions, {
                        "sliderMarker.padding": {
                            since: "15.1",
                            message: "Use the 'paddingTopBottom' and 'paddingLeftRight' options instead"
                        },
                        "sliderMarker.placeholderSize": {
                            since: "15.1",
                            message: "Use the 'placeholderHeight' and 'indent' options instead"
                        },
                        "scale.majorTickInterval": {
                            since: "15.2",
                            message: "Use the 'tickInterval' options instead"
                        },
                        "scale.showMinorTicks": {
                            since: "15.2",
                            message: "Use the 'minorTick.visible' options instead"
                        }
                    })
                },
                _rootClassPrefix: "dxrs",
                _rootClass: "dxrs-range-selector",
                _dataIsReady: function() {
                    return this._dataSource.isLoaded()
                },
                _initialChanges: ["DATA_SOURCE", "SELECTED_RANGE"],
                _themeDependentChanges: ["MOSTLY_TOTAL"],
                _initCore: function() {
                    var rangeViewGroup, slidersGroup, scaleGroup, trackersGroup, that = this,
                        renderer = that._renderer,
                        root = renderer.root;
                    root.css({
                        "touch-action": "pan-y",
                        "-ms-touch-action": "pan-y"
                    });
                    that._clipRect = renderer.clipRect();
                    rangeViewGroup = renderer.g().attr({
                        "class": "dxrs-view"
                    }).append(root);
                    slidersGroup = renderer.g().attr({
                        "class": "dxrs-slidersContainer",
                        clipId: that._clipRect.id
                    }).append(root);
                    scaleGroup = renderer.g().attr({
                        "class": "dxrs-scale",
                        clipId: that._clipRect.id
                    }).append(root);
                    trackersGroup = renderer.g().attr({
                        "class": "dxrs-trackers"
                    }).append(root);
                    that._translator = createTranslator();
                    that._rangeView = new rangeViewModule.RangeView({
                        renderer: renderer,
                        root: rangeViewGroup,
                        translator: that._translator
                    });
                    that._slidersController = new slidersControllerModule.SlidersController({
                        renderer: renderer,
                        root: slidersGroup,
                        trackersGroup: trackersGroup,
                        updateSelectedRange: function(range) {
                            if (!that._selectedRangeOption) {
                                that.option(SELECTED_RANGE, range)
                            }
                            that._eventTrigger(SELECTED_RANGE_CHANGED, {
                                startValue: range.startValue,
                                endValue: range.endValue
                            })
                        },
                        translator: that._translator
                    });
                    that._axis = new AxisWrapper({
                        renderer: renderer,
                        root: scaleGroup,
                        updateSelectedRange: function(range) {
                            that.setSelectedRange(range)
                        },
                        translator: that._translator
                    });
                    that._tracker = new trackerModule.Tracker({
                        renderer: renderer,
                        controller: that._slidersController
                    })
                },
                _getDefaultSize: function() {
                    return {
                        width: 400,
                        height: 160
                    }
                },
                _disposeCore: function() {
                    this._axis.dispose();
                    this._slidersController.dispose();
                    this._tracker.dispose()
                },
                _createThemeManager: function() {
                    return new themeManagerModule.ThemeManager
                },
                _applySize: function(rect) {
                    this._clientRect = rect.slice();
                    this._change(["MOSTLY_TOTAL"])
                },
                _optionChangesMap: {
                    scale: "SCALE",
                    selectedRange: "SELECTED_RANGE",
                    dataSource: "DATA_SOURCE"
                },
                _optionChangesOrder: ["SCALE", "DATA_SOURCE"],
                _change_SCALE: function() {
                    this._change(["MOSTLY_TOTAL"])
                },
                _change_DATA_SOURCE: function() {
                    if (this._initialized || this._options.dataSource) {
                        this._options[SELECTED_RANGE] = null;
                        this._updateDataSource()
                    }
                },
                _customChangesOrder: ["MOSTLY_TOTAL", "SELECTED_RANGE"],
                _change_MOSTLY_TOTAL: function() {
                    this._applyMostlyTotalChange()
                },
                _change_SELECTED_RANGE: function() {
                    var that = this;
                    if (that._selectedRangeOption) {
                        that._options[SELECTED_RANGE] = that._selectedRangeOption
                    }
                    that.setSelectedRange(that._options[SELECTED_RANGE])
                },
                _applyChanges: function() {
                    var that = this;
                    if (that._changes.has("SELECTED_RANGE") && that._options[SELECTED_RANGE]) {
                        that._selectedRangeOption = $.extend({}, that._options[SELECTED_RANGE])
                    }
                    that.callBase.apply(that, arguments);
                    that._selectedRangeOption = null;
                    that.__isResizing = false
                },
                _applyMostlyTotalChange: function() {
                    var currentAnimationEnabled, that = this,
                        renderer = that._renderer,
                        rect = that._clientRect;
                    if (that.__isResizing) {
                        currentAnimationEnabled = renderer.animationEnabled();
                        renderer.updateAnimationOptions({
                            enabled: false
                        })
                    }
                    that._clipRect.attr({
                        x: rect[0],
                        y: rect[1],
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1]
                    });
                    that._updateContent({
                        left: rect[0],
                        top: rect[1],
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1]
                    });
                    if (that.__isResizing) {
                        renderer.updateAnimationOptions({
                            enabled: currentAnimationEnabled
                        })
                    }
                    that._drawn()
                },
                _dataSourceChangedHandler: function() {
                    this._requestChange(["MOSTLY_TOTAL"])
                },
                _updateContent: function(canvas) {
                    var sliderMarkerOptions, indents, scaleLabelsAreaHeight, rangeContainerCanvas, that = this,
                        chartOptions = that.option("chart"),
                        seriesDataSource = that._createSeriesDataSource(chartOptions),
                        isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option("background.image.url")),
                        scaleOptions = prepareScaleOptions(that._getOption("scale"), seriesDataSource, that._incidentOccurred),
                        argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions),
                        tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange),
                        chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();
                    if (chartThemeManager) {
                        checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions("valueAxis").logarithmBase, that._incidentOccurred)
                    }
                    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo);
                    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);
                    sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo);
                    indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option("indent"));
                    scaleLabelsAreaHeight = calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions));
                    rangeContainerCanvas = {
                        left: canvas.left + indents.left,
                        top: canvas.top + indents.top,
                        width: _max(canvas.width - indents.left - indents.right, 1),
                        height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - scaleLabelsAreaHeight : commonModule.HEIGHT_COMPACT_MODE, 0)
                    };
                    updateTranslator(that._translator, argTranslatorRange, [rangeContainerCanvas.left, rangeContainerCanvas.left + rangeContainerCanvas.width], scaleOptions.minRange);
                    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;
                    that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);
                    if (chartThemeManager) {
                        chartThemeManager.dispose()
                    }
                },
                _updateElements: function(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {
                    var that = this,
                        behavior = that._getOption("behavior"),
                        selectedRange = that.option(SELECTED_RANGE),
                        shutterOptions = that._getOption("shutter"),
                        isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;
                    if (selectedRange) {
                        if (!that._translator.isValid(selectedRange[START_VALUE])) {
                            that._incidentOccurred("E2203", [START_VALUE])
                        }
                        if (!that._translator.isValid(selectedRange[END_VALUE])) {
                            that._incidentOccurred("E2203", [END_VALUE])
                        }
                    }
                    shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);
                    that._rangeView.update(that.option("background"), that._themeManager.theme("background"), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource);
                    that._axis.update(scaleOptions, isCompactMode, canvas);
                    that._isUpdating = true;
                    that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption("sliderHandle"), sliderMarkerOptions, shutterOptions, {
                        minRange: isNotSemiDiscrete ? that.option("scale.minRange") : void 0,
                        maxRange: isNotSemiDiscrete ? that.option("scale.maxRange") : void 0
                    }, that._axis.getFullTicks(), that._getOption("selectedRangeColor", true));
                    that._slidersController.setSelectedRange(selectedRange);
                    that._isUpdating = false;
                    that._tracker.update(!that._translator.isEmptyValueRange(), behavior)
                },
                _createSeriesDataSource: function(chartOptions) {
                    var seriesDataSource, that = this,
                        dataSource = that._dataSource.items(),
                        scaleOptions = that._getOption("scale"),
                        valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
                    if (dataSource || chartOptions && chartOptions.series) {
                        chartOptions = $.extend({}, chartOptions, {
                            theme: that.option("theme")
                        });
                        seriesDataSource = new seriesDataSourceModule.SeriesDataSource({
                            renderer: that._renderer,
                            dataSource: dataSource,
                            valueType: _normalizeEnum(valueType),
                            axisType: scaleOptions.type,
                            chart: chartOptions,
                            dataSourceField: that.option("dataSourceField"),
                            incidentOccurred: that._incidentOccurred,
                            categories: scaleOptions.categories
                        })
                    }
                    return seriesDataSource
                },
                _prepareSliderMarkersOptions: function(scaleOptions, screenDelta, tickIntervalsInfo) {
                    var businessInterval, that = this,
                        minorTickInterval = tickIntervalsInfo.minorTickInterval,
                        tickInterval = tickIntervalsInfo.tickInterval,
                        endValue = scaleOptions.endValue,
                        startValue = scaleOptions.startValue,
                        sliderMarkerOptions = that._getOption(SLIDER_MARKER),
                        sliderMarkerUserOption = that.option(SLIDER_MARKER) || {},
                        isTypeDiscrete = scaleOptions.type === DISCRETE,
                        isValueTypeDatetime = scaleOptions.valueType === DATETIME;
                    sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);
                    if (!sliderMarkerOptions.format) {
                        if (!that._getOption("behavior").snapToTicks && _isNumber(scaleOptions.startValue)) {
                            businessInterval = Math.abs(endValue - startValue);
                            sliderMarkerOptions.format = {
                                type: "fixedPoint",
                                precision: vizUtils.getSignificantDigitPosition(businessInterval / screenDelta)
                            }
                        }
                        if (isValueTypeDatetime && !isTypeDiscrete) {
                            if (!scaleOptions.marker.visible) {
                                if (_isDefined(startValue) && _isDefined(endValue)) {
                                    sliderMarkerOptions.format = formatHelper.getDateFormatByTickInterval(startValue, endValue, _isDefined(minorTickInterval) && 0 !== minorTickInterval ? minorTickInterval : tickInterval)
                                }
                            } else {
                                sliderMarkerOptions.format = dateUtils.getDateFormatByTickInterval(_isDefined(minorTickInterval) && 0 !== minorTickInterval ? minorTickInterval : tickInterval)
                            }
                        }
                        if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {
                            sliderMarkerOptions.format = formatHelper.getDateFormatByTicks(tickIntervalsInfo.ticks)
                        }
                    }
                    if (void 0 !== sliderMarkerUserOption.padding && void 0 === sliderMarkerUserOption.paddingLeftRight && void 0 === sliderMarkerUserOption.paddingTopBottom) {
                        sliderMarkerOptions.paddingLeftRight = sliderMarkerOptions.paddingTopBottom = sliderMarkerUserOption.padding
                    }
                    return sliderMarkerOptions
                },
                getSelectedRange: function() {
                    return this._slidersController.getSelectedRange()
                },
                setSelectedRange: function(range) {
                    var current;
                    if (!this._isUpdating && range) {
                        current = this._slidersController.getSelectedRange();
                        if (!current || current.startValue !== range.startValue || current.endValue !== range.endValue) {
                            this._slidersController.setSelectedRange(range)
                        }
                    }
                },
                resetSelectedRange: function() {
                    this.setSelectedRange({})
                },
                _setContentSize: function() {
                    this.__isResizing = 2 === this._changes.count();
                    this.callBase.apply(this, arguments)
                },
                render: function(isResizing) {
                    this.__isResizing = isResizing;
                    this.callBase.apply(this, arguments);
                    this._requestChange(["MOSTLY_TOTAL"])
                }
            });
            $.each(["selectedRangeColor", "containerBackgroundColor", "sliderMarker", "sliderHandle", "shutter", OPTION_BACKGROUND, "behavior", "chart", "indent"], function(_, name) {
                dxRangeSelector.prototype._optionChangesMap[name] = "MOSTLY_TOTAL"
            });

            function prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {
                scaleOptions.label.overlappingBehavior = {
                    mode: scaleOptions.useTicksAutoArrangement ? "enlargeTickInterval" : "ignore"
                };
                scaleOptions.marker.label.font = scaleOptions.label.font;
                scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;
                scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;
                scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;
                scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;
                scaleOptions.argumentType = scaleOptions.valueType;
                scaleOptions.visible = isCompactMode;
                scaleOptions.minorTick.showCalculatedTicks = scaleOptions.isHorizontal = scaleOptions.withoutOverlappingBehavior = scaleOptions.stick = true;
                if (!isCompactMode) {
                    scaleOptions.minorTick.length = scaleOptions.tick.length = height
                }
                scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;
                return scaleOptions
            }

            function createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {
                $.each(markerTrackers, function(_, value) {
                    value.on("dxpointerdown", onPointerDown)
                });

                function onPointerDown(e) {
                    var range = e.target.range,
                        minRange = scaleOptions.minRange ? dateUtils.addInterval(range.startValue, scaleOptions.minRange) : void 0,
                        maxRange = scaleOptions.maxRange ? dateUtils.addInterval(range.startValue, scaleOptions.maxRange) : void 0;
                    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {
                        setSelectedRange(range)
                    }
                }
            }

            function AxisWrapper(params) {
                this._axis = new axisModule.Axis({
                    renderer: params.renderer,
                    axesContainerGroup: params.root,
                    axisType: "xyAxes",
                    drawingType: "linear",
                    widgetClass: "dxrs",
                    axisClass: "range-selector"
                });
                this._updateSelectedRangeCallback = params.updateSelectedRange;
                this._translator = params.translator
            }
            AxisWrapper.prototype = {
                constructor: AxisWrapper,
                dispose: function() {
                    this._axis.dispose()
                },
                update: function(options, isCompactMode, canvas) {
                    var axis = this._axis;
                    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - Math.ceil(options.width / 2)));
                    axis.delta = {
                        bottom: -canvas.height / 2
                    };
                    axis.setTranslator(this._translator, {
                        translateSpecialCase: function() {
                            return canvas.top + canvas.height
                        }
                    });
                    axis.draw();
                    if (axis.getMarkerTrackers()) {
                        createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback)
                    }
                },
                getFullTicks: function() {
                    return this._axis.getFullTicks()
                }
            };
            registerComponent("dxRangeSelector", dxRangeSelector);
            module.exports = dxRangeSelector;
            dxRangeSelector.addPlugin(__webpack_require__( /*! ../core/data_source */ 161).plugin);
            dxRangeSelector.addPlugin(__webpack_require__( /*! ../core/export */ 127).plugin);
            dxRangeSelector.addPlugin(__webpack_require__( /*! ../core/title */ 164).plugin);
            dxRangeSelector.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 163).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/range_selector/range_view.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var translator2DModule = __webpack_require__( /*! ../translators/translator2d */ 105);

            function createTranslator(valueRange, screenRange) {
                return new translator2DModule.Translator2D(valueRange, {
                    top: screenRange[0],
                    height: screenRange[1]
                })
            }

            function drawSeriesView(root, seriesDataSource, translator, screenRange, isAnimationEnabled) {
                var series, i, seriesList = seriesDataSource.getSeries(),
                    ii = seriesList.length,
                    translators = {
                        x: translator,
                        y: createTranslator(seriesDataSource.getBoundRange().val, screenRange)
                    };
                seriesDataSource.adjustSeriesDimensions(translators);
                for (i = 0; i < ii; ++i) {
                    series = seriesList[i];
                    series._extGroups.seriesGroup = series._extGroups.labelsGroup = root;
                    series.draw(translators, isAnimationEnabled)
                }
            }

            function merge(a, b) {
                return void 0 !== a ? a : b
            }

            function RangeView(params) {
                this._params = params;
                this._clipRect = params.renderer.clipRect();
                params.root.attr({
                    clipId: this._clipRect.id
                })
            }
            RangeView.prototype = {
                constructor: RangeView,
                update: function(backgroundOption, backgroundTheme, canvas, isCompactMode, isAnimationEnabled, seriesDataSource) {
                    var renderer = this._params.renderer,
                        root = this._params.root;
                    backgroundOption = backgroundOption || {};
                    root.clear();
                    this._clipRect.attr({
                        x: canvas.left,
                        y: canvas.top,
                        width: canvas.width,
                        height: canvas.height
                    });
                    if (!isCompactMode) {
                        if (merge(backgroundOption.visible, backgroundTheme.visible)) {
                            if (backgroundOption.color) {
                                renderer.rect(canvas.left, canvas.top, canvas.width + 1, canvas.height).attr({
                                    fill: merge(backgroundOption.color, backgroundTheme.color),
                                    "class": "dx-range-selector-background"
                                }).append(root)
                            }
                            if (backgroundOption.image && backgroundOption.image.url) {
                                renderer.image(canvas.left, canvas.top, canvas.width + 1, canvas.height, backgroundOption.image.url, merge(backgroundOption.image.location, backgroundTheme.image.location)).append(root)
                            }
                        }
                        if (seriesDataSource && seriesDataSource.isShowChart()) {
                            drawSeriesView(root, seriesDataSource, this._params.translator, [canvas.top, canvas.top + canvas.height], isAnimationEnabled)
                        }
                    }
                }
            };
            exports.RangeView = RangeView
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/viz/range_selector/series_data_source.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var SeriesDataSource, $ = __webpack_require__( /*! jquery */ 1),
                seriesModule = __webpack_require__( /*! ../series/base_series */ 236),
                seriesFamilyModule = __webpack_require__( /*! ../core/series_family */ 331),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                rangeModule = __webpack_require__( /*! ../translators/range */ 89),
                dataValidatorModule = __webpack_require__( /*! ../components/data_validator */ 233),
                ChartThemeManager = __webpack_require__( /*! ../components/chart_theme_manager */ 329).ThemeManager;
            var createThemeManager = function(chartOptions) {
                return new ChartThemeManager(chartOptions, "rangeSelector.chart")
            };
            var processSeriesFamilies = function(series, equalBarWidth, minBubbleSize, maxBubbleSize, barWidth, negativesAsZeroes) {
                var families = [],
                    types = [];
                $.each(series, function(i, item) {
                    if (-1 === $.inArray(item.type, types)) {
                        types.push(item.type)
                    }
                });
                $.each(types, function(_, type) {
                    var family = new seriesFamilyModule.SeriesFamily({
                        type: type,
                        equalBarWidth: equalBarWidth,
                        minBubbleSize: minBubbleSize,
                        maxBubbleSize: maxBubbleSize,
                        barWidth: barWidth,
                        negativesAsZeroes: negativesAsZeroes
                    });
                    family.add(series);
                    family.adjustSeriesValues();
                    families.push(family)
                });
                return families
            };
            var isStickType = function(type) {
                var nonStickTypes = ["bar", "candlestick", "stock", "bubble"],
                    stickType = true;
                type = vizUtils.normalizeEnum(type);
                $.each(nonStickTypes, function(_, item) {
                    if (-1 !== type.indexOf(item)) {
                        stickType = false;
                        return false
                    }
                });
                return stickType
            };

            function setTemplateFields(data, templateData, series) {
                $.each(data, function(_, data) {
                    $.each(series.getTemplateFields(), function(_, field) {
                        data[field.templateField] = data[field.originalField]
                    });
                    templateData.push(data)
                });
                series.updateTemplateFieldNames()
            }
            SeriesDataSource = function(options) {
                var templatedSeries, seriesTemplate, topIndent, bottomIndent, negativesAsZeroes, negativesAsZeros, that = this,
                    themeManager = that._themeManager = createThemeManager(options.chart);
                themeManager._fontFields = ["commonSeriesSettings.label.font"];
                themeManager.setTheme(options.chart.theme);
                topIndent = themeManager.getOptions("topIndent");
                bottomIndent = themeManager.getOptions("bottomIndent");
                that._indent = {
                    top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
                    bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
                };
                that._valueAxis = themeManager.getOptions("valueAxisRangeSelector") || {};
                that._hideChart = false;
                seriesTemplate = themeManager.getOptions("seriesTemplate");
                if (options.dataSource && seriesTemplate) {
                    templatedSeries = vizUtils.processSeriesTemplate(seriesTemplate, options.dataSource)
                }
                that._useAggregation = options.chart.useAggregation;
                that._series = that._calculateSeries(options, templatedSeries);
                negativesAsZeroes = themeManager.getOptions("negativesAsZeroes");
                negativesAsZeros = themeManager.getOptions("negativesAsZeros");
                that._seriesFamilies = processSeriesFamilies(that._series, themeManager.getOptions("equalBarWidth"), themeManager.getOptions("minBubbleSize"), themeManager.getOptions("maxBubbleSize"), themeManager.getOptions("barWidth"), commonUtils.isDefined(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros)
            };
            SeriesDataSource.prototype = {
                constructor: SeriesDataSource,
                _calculateSeries: function(options, templatedSeries) {
                    var particularSeriesOptions, seriesTheme, data, parsedData, dataSourceField, i, newSeries, groupsData, that = this,
                        series = [],
                        chartThemeManager = that._themeManager,
                        hasSeriesTemplate = !!chartThemeManager.getOptions("seriesTemplate"),
                        allSeriesOptions = hasSeriesTemplate ? templatedSeries : options.chart.series,
                        seriesValueType = options.chart.valueAxis && options.chart.valueAxis.valueType;
                    that.templateData = [];
                    if (options.dataSource && !allSeriesOptions) {
                        dataSourceField = options.dataSourceField || "arg";
                        allSeriesOptions = {
                            argumentField: dataSourceField,
                            valueField: dataSourceField
                        };
                        that._hideChart = true
                    }
                    allSeriesOptions = $.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
                    for (i = 0; i < allSeriesOptions.length; i++) {
                        particularSeriesOptions = $.extend(true, {
                            incidentOccurred: options.incidentOccurred
                        }, allSeriesOptions[i]);
                        particularSeriesOptions.rotated = false;
                        data = particularSeriesOptions.data || options.dataSource;
                        seriesTheme = chartThemeManager.getOptions("series", particularSeriesOptions);
                        seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField;
                        if (data && data.length > 0) {
                            newSeries = new seriesModule.Series({
                                renderer: options.renderer
                            }, seriesTheme);
                            series.push(newSeries)
                        }
                        if (hasSeriesTemplate) {
                            setTemplateFields(data, that.templateData, newSeries)
                        }
                    }
                    data = hasSeriesTemplate ? that.templateData : data;
                    if (series.length) {
                        groupsData = {
                            groups: [{
                                series: series,
                                valueOptions: {
                                    valueType: dataSourceField ? options.valueType : seriesValueType
                                }
                            }],
                            argumentOptions: {
                                categories: options.categories,
                                argumentType: options.valueType,
                                type: options.axisType
                            }
                        };
                        parsedData = dataValidatorModule.validateData(data, groupsData, options.incidentOccurred, chartThemeManager.getOptions("dataPrepareSettings"));
                        that.argCategories = groupsData.categories;
                        for (i = 0; i < series.length; i++) {
                            series[i].updateData(parsedData[series[i].getArgumentField()])
                        }
                    }
                    return series
                },
                adjustSeriesDimensions: function(translators) {
                    if (this._useAggregation) {
                        $.each(this._series, function(_, s) {
                            s.resamplePoints(translators.x)
                        })
                    }
                    $.each(this._seriesFamilies, function(_, family) {
                        family.adjustSeriesDimensions({
                            arg: translators.x,
                            val: translators.y
                        })
                    })
                },
                getBoundRange: function() {
                    var rangeData, rangeYSize, rangeVisibleSizeY, minIndent, maxIndent, that = this,
                        valueAxisMin = that._valueAxis.min,
                        valueAxisMax = that._valueAxis.max,
                        valRange = new rangeModule.Range({
                            min: valueAxisMin,
                            minVisible: valueAxisMin,
                            max: valueAxisMax,
                            maxVisible: valueAxisMax,
                            axisType: that._valueAxis.type,
                            base: that._valueAxis.logarithmBase
                        }),
                        argRange = new rangeModule.Range({});
                    $.each(that._series, function(_, series) {
                        rangeData = series.getRangeData();
                        valRange.addRange(rangeData.val);
                        argRange.addRange(rangeData.arg);
                        if (!isStickType(series.type)) {
                            argRange.addRange({
                                stick: false
                            })
                        }
                    });
                    if (valRange.isDefined() && argRange.isDefined()) {
                        minIndent = that._valueAxis.inverted ? that._indent.top : that._indent.bottom;
                        maxIndent = that._valueAxis.inverted ? that._indent.bottom : that._indent.top;
                        rangeYSize = valRange.max - valRange.min;
                        rangeVisibleSizeY = ($.isNumeric(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ($.isNumeric(valRange.minVisible) ? valRange.minVisible : valRange.min);
                        if (commonUtils.isDate(valRange.min)) {
                            valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent)
                        } else {
                            valRange.min -= rangeYSize * minIndent
                        }
                        if (commonUtils.isDate(valRange.max)) {
                            valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent)
                        } else {
                            valRange.max += rangeYSize * maxIndent
                        }
                        if ($.isNumeric(rangeVisibleSizeY)) {
                            valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : void 0;
                            valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : void 0
                        }
                        valRange.invert = that._valueAxis.inverted
                    }
                    return {
                        arg: argRange,
                        val: valRange
                    }
                },
                getSeries: function() {
                    return this._series
                },
                isEmpty: function() {
                    return 0 === this.getSeries().length
                },
                isShowChart: function() {
                    return !this._hideChart
                },
                getCalculatedValueType: function() {
                    var series = this._series[0];
                    return series && series.argumentType
                },
                getThemeManager: function() {
                    return this._themeManager
                }
            };
            exports.SeriesDataSource = SeriesDataSource
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/range_selector/slider.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var commonModule = __webpack_require__( /*! ./common */ 192),
                animationSettings = commonModule.utils.animationSettings,
                formatValue = commonModule.formatValue,
                SliderMarker = __webpack_require__( /*! ./slider_marker */ 537),
                support = __webpack_require__( /*! ../../core/utils/support */ 18),
                SPLITTER_WIDTH = 8,
                TOUCH_SPLITTER_WIDTH = 20;

            function getSliderTrackerWidth(sliderHandleWidth) {
                return support.touchEvents || support.pointer ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH
            }

            function Slider(params, index) {
                var that = this;
                that._translator = params.translator;
                that._sliderGroup = params.renderer.g().attr({
                    "class": "slider"
                }).append(params.root);
                that._line = params.renderer.path(null, "line").append(that._sliderGroup);
                that._marker = new SliderMarker(params.renderer, that._sliderGroup, 1 === index);
                that._tracker = params.renderer.rect().attr({
                    "class": "slider-tracker",
                    fill: "#000000",
                    opacity: 1e-4
                }).css({
                    cursor: "w-resize"
                }).append(params.trackersGroup)
            }
            Slider.prototype = {
                constructor: Slider,
                cancelAnimation: function() {
                    this._sliderGroup.stopAnimation();
                    this._tracker.stopAnimation()
                },
                applyPosition: function(isAnimated) {
                    var that = this,
                        slider = that._sliderGroup,
                        tracker = that._tracker,
                        attrs = {
                            translateX: that._position
                        };
                    that._marker.setPosition(that._position);
                    if (isAnimated) {
                        slider.animate(attrs, animationSettings);
                        tracker.animate(attrs, animationSettings)
                    } else {
                        slider.attr(attrs);
                        tracker.attr(attrs)
                    }
                },
                _setValid: function(isValid) {
                    this._marker.setValid(isValid);
                    this._line.attr({
                        stroke: this._colors[Number(isValid)]
                    })
                },
                _setText: function(text) {
                    this._marker.setText(text)
                },
                update: function(verticalRange, sliderHandleOptions, sliderMarkerOptions) {
                    var that = this;
                    that._formatOptions = {
                        format: sliderMarkerOptions.format,
                        precision: sliderMarkerOptions.precision,
                        customizeText: sliderMarkerOptions.customizeText
                    };
                    that._marker.applyOptions(sliderMarkerOptions, that._translator.getScreenRange());
                    that._colors = [sliderMarkerOptions.invalidRangeColor, sliderHandleOptions.color];
                    that._sliderGroup.attr({
                        translateY: verticalRange[0]
                    });
                    that._line.attr({
                        "stroke-width": sliderHandleOptions.width,
                        stroke: sliderHandleOptions.color,
                        "stroke-opacity": sliderHandleOptions.opacity,
                        sharp: "h",
                        points: [0, 0, 0, verticalRange[1] - verticalRange[0]]
                    });
                    var trackerWidth = getSliderTrackerWidth(sliderHandleOptions.width);
                    that._tracker.attr({
                        x: -trackerWidth / 2,
                        y: 0,
                        width: trackerWidth,
                        height: verticalRange[1] - verticalRange[0],
                        translateY: verticalRange[0]
                    })
                },
                toForeground: function() {
                    this._sliderGroup.toForeground()
                },
                getSliderTracker: function() {
                    return this._tracker
                },
                getPosition: function() {
                    return this._position
                },
                setDisplayValue: function(value) {
                    this._value = value;
                    this._setText(formatValue(value, this._formatOptions))
                },
                setOverlapped: function(isOverlapped) {
                    this._marker.setOverlapped(isOverlapped)
                },
                getValue: function() {
                    return this._value
                },
                on: function(event, handler) {
                    this._tracker.on(event, handler);
                    this._marker.getTracker().on(event, handler)
                },
                getCloudBorder: function() {
                    return this._marker.getBorderPosition()
                },
                dispose: function() {
                    this._marker.dispose()
                }
            };
            module.exports = Slider
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/viz/range_selector/slider_marker.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var patchFontOptions = __webpack_require__( /*! ../core/utils */ 6).patchFontOptions,
                SLIDER_MARKER_UPDATE_DELAY = 75,
                POINTER_SIZE = __webpack_require__( /*! ./common */ 192).consts.pointerSize;

            function SliderMarker(renderer, root, isLeftPointer) {
                var that = this;
                that._isLeftPointer = isLeftPointer;
                that._isOverlapped = false;
                that._group = renderer.g().attr({
                    "class": "slider-marker"
                }).append(root);
                that._area = renderer.path(null, "area").append(that._group);
                that._label = renderer.text().attr({
                    align: "left"
                }).append(that._group);
                that._tracker = renderer.rect().attr({
                    "class": "slider-marker-tracker",
                    fill: "#000000",
                    opacity: 1e-4
                }).css({
                    cursor: "pointer"
                }).append(that._group);
                that._border = renderer.rect(0, 0, 1, 0)
            }
            SliderMarker.prototype = {
                constructor: SliderMarker,
                _getRectSize: function(textSize) {
                    return {
                        width: Math.round(2 * this._paddingLeftRight + textSize.width),
                        height: Math.round(2 * this._paddingTopBottom + textSize.height)
                    }
                },
                _getTextSize: function() {
                    var textSize = this._label.getBBox();
                    if (!this._textHeight && isFinite(textSize.height)) {
                        this._textHeight = textSize.height
                    }
                    return {
                        width: textSize.width,
                        height: this._textHeight,
                        y: textSize.y
                    }
                },
                _getAreaPointsInfo: function(textSize) {
                    var that = this,
                        rectSize = that._getRectSize(textSize),
                        rectWidth = rectSize.width,
                        rectHeight = rectSize.height,
                        rectLeftBorder = -rectWidth,
                        rectRightBorder = 0,
                        pointerRightPoint = POINTER_SIZE,
                        pointerCenterPoint = 0,
                        pointerLeftPoint = -POINTER_SIZE,
                        position = that._position,
                        isLeft = that._isLeftPointer,
                        correctCloudBorders = function() {
                            rectLeftBorder++;
                            rectRightBorder++;
                            pointerRightPoint++;
                            pointerCenterPoint++;
                            pointerLeftPoint++
                        },
                        checkPointerBorders = function() {
                            if (pointerRightPoint > rectRightBorder) {
                                pointerRightPoint = rectRightBorder
                            } else {
                                if (pointerLeftPoint < rectLeftBorder) {
                                    pointerLeftPoint = rectLeftBorder
                                }
                            }
                            isLeft && correctCloudBorders()
                        },
                        borderPosition = position;
                    if (isLeft) {
                        if (position > that._range[1] - rectWidth) {
                            rectRightBorder = -position + that._range[1];
                            rectLeftBorder = rectRightBorder - rectWidth;
                            checkPointerBorders();
                            borderPosition += rectLeftBorder
                        } else {
                            rectLeftBorder = pointerLeftPoint = 0;
                            rectRightBorder = rectWidth
                        }
                    } else {
                        if (position - that._range[0] < rectWidth) {
                            rectLeftBorder = -(position - that._range[0]);
                            rectRightBorder = rectLeftBorder + rectWidth;
                            checkPointerBorders();
                            borderPosition += rectRightBorder
                        } else {
                            pointerRightPoint = 0;
                            correctCloudBorders()
                        }
                    }
                    that._borderPosition = borderPosition;
                    return {
                        offset: rectLeftBorder,
                        isCutted: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),
                        points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]
                    }
                },
                _update: function() {
                    var textSize, currentTextSize, rectSize, that = this;
                    clearTimeout(that._timeout);
                    that._label.attr({
                        text: that._text || ""
                    });
                    currentTextSize = that._getTextSize();
                    rectSize = that._getRectSize(currentTextSize);
                    textSize = that._textSize || currentTextSize;
                    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;
                    that._timeout = setTimeout(function() {
                        updateSliderMarker(currentTextSize, rectSize);
                        that._textSize = currentTextSize
                    }, SLIDER_MARKER_UPDATE_DELAY);

                    function updateSliderMarker(size, rectSize) {
                        var points, pointsData, offset;
                        rectSize = rectSize || that._getRectSize(size);
                        that._group.attr({
                            translateY: -(rectSize.height + POINTER_SIZE)
                        });
                        pointsData = that._getAreaPointsInfo(size);
                        points = pointsData.points;
                        offset = pointsData.offset;
                        that._area.attr({
                            points: points
                        });
                        that._border.attr({
                            x: that._isLeftPointer ? points[0] - 1 : points[2],
                            height: pointsData.isCutted ? rectSize.height : rectSize.height + POINTER_SIZE
                        });
                        that._tracker.attr({
                            translateX: offset,
                            width: rectSize.width,
                            height: rectSize.height + POINTER_SIZE
                        });
                        that._label.attr({
                            translateX: that._paddingLeftRight + offset,
                            translateY: rectSize.height / 2 - (size.y + size.height / 2)
                        })
                    }
                    updateSliderMarker(textSize)
                },
                setText: function(value) {
                    this._text = value
                },
                setPosition: function(position) {
                    this._position = position;
                    this._update()
                },
                applyOptions: function(options, screenRange) {
                    var that = this;
                    that._range = screenRange;
                    that._paddingLeftRight = options.paddingLeftRight;
                    that._paddingTopBottom = options.paddingTopBottom;
                    that._textHeight = null;
                    that._colors = [options.invalidRangeColor, options.color];
                    that._area.attr({
                        fill: options.color
                    });
                    that._border.attr({
                        fill: options.borderColor
                    });
                    that._label.css(patchFontOptions(options.font));
                    that._update()
                },
                getTracker: function() {
                    return this._tracker
                },
                setValid: function(isValid) {
                    this._area.attr({
                        fill: this._colors[Number(isValid)]
                    })
                },
                setColor: function(color) {
                    this._area.attr({
                        fill: color
                    })
                },
                dispose: function() {
                    clearTimeout(this._timeout)
                },
                setOverlapped: function(isOverlapped) {
                    var that = this;
                    if (that._isOverlapped !== isOverlapped) {
                        if (isOverlapped) {
                            that._border.append(that._group)
                        } else {
                            that._isOverlapped && that._border.remove()
                        }
                        that._isOverlapped = isOverlapped
                    }
                },
                getBorderPosition: function() {
                    return this._borderPosition
                }
            };
            module.exports = SliderMarker
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************************!*\
      !*** ./Scripts/viz/range_selector/sliders_controller.js ***!
      \**********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonModule = __webpack_require__( /*! ./common */ 192),
                animationSettings = commonModule.utils.animationSettings,
                emptySliderMarkerText = commonModule.consts.emptySliderMarkerText,
                Slider = __webpack_require__( /*! ./slider */ 536),
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum;

            function buildRectPoints(left, top, right, bottom) {
                return [left, top, right, top, right, bottom, left, bottom]
            }

            function valueOf(value) {
                return value && value.valueOf()
            }

            function isLess(a, b) {
                return a < b
            }

            function isGreater(a, b) {
                return a > b
            }

            function selectClosestValue(target, values) {
                var middle, start = 0,
                    end = values ? values.length - 1 : 0,
                    val = target;
                while (end - start > 1) {
                    middle = start + end >> 1;
                    val = values[middle];
                    if (val === target) {
                        return target
                    } else {
                        if (target < val) {
                            end = middle
                        } else {
                            start = middle
                        }
                    }
                }
                if (values) {
                    val = values[target - values[start] <= values[end] - target ? start : end]
                }
                return val
            }

            function dummyProcessSelectionChanged() {
                this._lastSelectedRange = this.getSelectedRange();
                delete this._processSelectionChanged
            }

            function suppressSetSelectedRange(controller) {
                controller.setSelectedRange = $.noop;
                if (controller._processSelectionChanged === dummyProcessSelectionChanged) {
                    controller._processSelectionChanged()
                }
            }

            function restoreSetSelectedRange(controller) {
                delete controller.setSelectedRange
            }

            function SlidersController(params) {
                var that = this,
                    sliderParams = {
                        renderer: params.renderer,
                        root: params.root,
                        trackersGroup: params.trackersGroup,
                        translator: params.translator
                    };
                that._params = params;
                that._areaTracker = params.renderer.path(null, "area").attr({
                    "class": "area-tracker",
                    fill: "#000000",
                    opacity: 1e-4
                }).append(params.trackersGroup);
                that._selectedAreaTracker = params.renderer.path(null, "area").attr({
                    "class": "selected-area-tracker",
                    fill: "#000000",
                    opacity: 1e-4
                }).append(params.trackersGroup);
                that._shutter = params.renderer.path(null, "area").append(params.root);
                that._sliders = [new Slider(sliderParams, 0), new Slider(sliderParams, 1)];
                that._processSelectionChanged = dummyProcessSelectionChanged
            }
            SlidersController.prototype = {
                constructor: SlidersController,
                dispose: function() {
                    this._sliders[0].dispose();
                    this._sliders[1].dispose()
                },
                getTrackerTargets: function() {
                    return {
                        area: this._areaTracker,
                        selectedArea: this._selectedAreaTracker,
                        sliders: this._sliders
                    }
                },
                _processSelectionChanged: function() {
                    var that = this,
                        selectedRange = that.getSelectedRange();
                    if (valueOf(selectedRange.startValue) !== valueOf(that._lastSelectedRange.startValue) || valueOf(selectedRange.endValue) !== valueOf(that._lastSelectedRange.endValue)) {
                        that._lastSelectedRange = selectedRange;
                        that._params.updateSelectedRange(selectedRange)
                    }
                },
                update: function(verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {
                    var that = this,
                        screenRange = that._params.translator.getScreenRange();
                    that._verticalRange = verticalRange;
                    that._minRange = rangeBounds.minRange;
                    that._maxRange = rangeBounds.maxRange;
                    that._animationEnabled = behavior.animationEnabled && that._params.renderer.animationEnabled();
                    that._allowSlidersSwap = behavior.allowSlidersSwap;
                    that._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
                    that._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
                    that._sliders[0]._position = that._sliders[1]._position = screenRange[0];
                    that._values = !that._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;
                    that._areaTracker.attr({
                        points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])
                    });
                    that._isCompactMode = isCompactMode;
                    that._shutterOffset = sliderHandleOptions.width / 2;
                    that._updateSelectedView(shutterOptions, selectedRangeColor);
                    that._isOnMoving = "onmoving" === _normalizeEnum(behavior.callSelectedRangeChanged);
                    that._updateSelectedRange();
                    that._applyTotalPosition(false)
                },
                _updateSelectedView: function(shutterOptions, selectedRangeColor) {
                    var settings = {
                        fill: null,
                        "fill-opacity": null,
                        stroke: null,
                        "stroke-width": null
                    };
                    if (this._isCompactMode) {
                        settings.stroke = selectedRangeColor;
                        settings["stroke-width"] = 3;
                        settings.sharp = "v"
                    } else {
                        settings.fill = shutterOptions.color;
                        settings["fill-opacity"] = shutterOptions.opacity
                    }
                    this._shutter.attr(settings)
                },
                _updateSelectedRange: function() {
                    var that = this,
                        sliders = that._sliders;
                    sliders[0].cancelAnimation();
                    sliders[1].cancelAnimation();
                    that._shutter.stopAnimation();
                    if (that._params.translator.isEmptyValueRange()) {
                        sliders[0]._setText(emptySliderMarkerText);
                        sliders[1]._setText(emptySliderMarkerText);
                        sliders[0]._value = sliders[1]._value = void 0;
                        sliders[0]._position = that._params.translator.getScreenRange()[0];
                        sliders[1]._position = that._params.translator.getScreenRange()[1];
                        that._applyTotalPosition(false);
                        suppressSetSelectedRange(that)
                    } else {
                        restoreSetSelectedRange(that)
                    }
                },
                _applyTotalPosition: function(isAnimated) {
                    var areOverlapped, sliders = this._sliders;
                    isAnimated = this._animationEnabled && isAnimated;
                    sliders[0].applyPosition(isAnimated);
                    sliders[1].applyPosition(isAnimated);
                    areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();
                    sliders[0].setOverlapped(areOverlapped);
                    sliders[1].setOverlapped(areOverlapped);
                    this._applyAreaTrackersPosition();
                    this._applySelectedRangePosition(isAnimated)
                },
                _applyAreaTrackersPosition: function() {
                    var that = this,
                        position1 = that._sliders[0].getPosition(),
                        position2 = that._sliders[1].getPosition();
                    that._selectedAreaTracker.attr({
                        points: buildRectPoints(position1, that._verticalRange[0], position2, that._verticalRange[1])
                    }).css({
                        cursor: Math.abs(that._params.translator.getScreenRange()[1] - that._params.translator.getScreenRange()[0] - position2 + position1) < .001 ? "default" : "pointer"
                    })
                },
                _applySelectedRangePosition: function(isAnimated) {
                    var screenRange, points, that = this,
                        verticalRange = that._verticalRange,
                        pos1 = that._sliders[0].getPosition(),
                        pos2 = that._sliders[1].getPosition();
                    if (that._isCompactMode) {
                        points = [pos1 + Math.ceil(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2]
                    } else {
                        screenRange = that._params.translator.getScreenRange();
                        points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(that._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(that._shutterOffset), screenRange[1]), verticalRange[1])]
                    }
                    if (isAnimated) {
                        that._shutter.animate({
                            points: points
                        }, animationSettings)
                    } else {
                        that._shutter.attr({
                            points: points
                        })
                    }
                },
                getSelectedRange: function() {
                    return {
                        startValue: this._sliders[0].getValue(),
                        endValue: this._sliders[1].getValue()
                    }
                },
                setSelectedRange: function(arg) {
                    arg = arg || {};
                    var that = this,
                        translator = that._params.translator,
                        startValue = translator.isValid(arg.startValue) ? translator.parse(arg.startValue) : translator.getRange()[0],
                        endValue = translator.isValid(arg.endValue) ? translator.parse(arg.endValue) : translator.getRange()[1],
                        values = translator.to(startValue, -1) < translator.to(endValue, 1) ? [startValue, endValue] : [endValue, startValue];
                    that._sliders[0].setDisplayValue(values[0]);
                    that._sliders[1].setDisplayValue(values[1]);
                    that._sliders[0]._position = translator.to(values[0], -1);
                    that._sliders[1]._position = translator.to(values[1], 1);
                    that._applyTotalPosition(true);
                    that._processSelectionChanged()
                },
                beginSelectedAreaMoving: function(initialPosition) {
                    var that = this,
                        sliders = that._sliders,
                        offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition,
                        currentPosition = initialPosition;
                    move.complete = function() {
                        that._dockSelectedArea()
                    };
                    return move;

                    function move(position) {
                        if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {
                            that._moveSelectedArea(position + offset, false)
                        }
                        currentPosition = position
                    }
                },
                _dockSelectedArea: function() {
                    var translator = this._params.translator,
                        sliders = this._sliders;
                    sliders[0]._position = translator.to(sliders[0].getValue(), -1);
                    sliders[1]._position = translator.to(sliders[1].getValue(), 1);
                    this._applyTotalPosition(true);
                    this._processSelectionChanged()
                },
                moveSelectedArea: function(screenPosition) {
                    this._moveSelectedArea(screenPosition, true);
                    this._dockSelectedArea()
                },
                _moveSelectedArea: function(screenPosition, isAnimated) {
                    var startValue, endValue, that = this,
                        translator = that._params.translator,
                        sliders = that._sliders,
                        interval = sliders[1].getPosition() - sliders[0].getPosition(),
                        startPosition = screenPosition - interval / 2,
                        endPosition = screenPosition + interval / 2;
                    if (startPosition < translator.getScreenRange()[0]) {
                        startPosition = translator.getScreenRange()[0];
                        endPosition = startPosition + interval
                    }
                    if (endPosition > translator.getScreenRange()[1]) {
                        endPosition = translator.getScreenRange()[1];
                        startPosition = endPosition - interval
                    }
                    startValue = translator.from(startPosition, -1);
                    endValue = translator.from(endPosition, 1);
                    sliders[0].setDisplayValue(selectClosestValue(startValue, that._values));
                    sliders[1].setDisplayValue(selectClosestValue(endValue, that._values));
                    sliders[0]._position = startPosition;
                    sliders[1]._position = endPosition;
                    that._applyTotalPosition(isAnimated);
                    if (that._isOnMoving) {
                        that._processSelectionChanged()
                    }
                },
                placeSliderAndBeginMoving: function(firstPosition, secondPosition) {
                    var thresholdPosition, handler, that = this,
                        translator = that._params.translator,
                        sliders = that._sliders,
                        index = firstPosition < secondPosition ? 0 : 1,
                        dir = index > 0 ? 1 : -1,
                        compare = index > 0 ? isGreater : isLess,
                        antiCompare = index > 0 ? isLess : isGreater,
                        positions = [],
                        values = [];
                    values[index] = translator.from(firstPosition, dir);
                    values[1 - index] = translator.from(secondPosition, -dir);
                    positions[1 - index] = secondPosition;
                    if (translator.isValueProlonged) {
                        if (compare(firstPosition, translator.to(values[index], dir))) {
                            values[index] = translator.from(firstPosition, -dir)
                        }
                        if (compare(secondPosition, translator.to(values[index], -dir))) {
                            values[1 - index] = values[index]
                        }
                    }
                    if (that._minRange) {
                        thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], that._values), that._minRange, -dir), -dir);
                        if (compare(secondPosition, thresholdPosition)) {
                            values[1 - index] = translator.add(values[index], that._minRange, -dir)
                        }
                        thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], that._minRange, dir), -dir);
                        if (antiCompare(firstPosition, thresholdPosition)) {
                            values[1 - index] = translator.getRange()[1 - index];
                            values[index] = translator.add(values[1 - index], that._minRange, dir);
                            positions[1 - index] = firstPosition
                        }
                    }
                    values[0] = selectClosestValue(values[0], that._values);
                    values[1] = selectClosestValue(values[1], that._values);
                    positions[index] = translator.to(values[index], dir);
                    sliders[0].setDisplayValue(values[0]);
                    sliders[1].setDisplayValue(values[1]);
                    sliders[0]._position = positions[0];
                    sliders[1]._position = positions[1];
                    that._applyTotalPosition(true);
                    if (that._isOnMoving) {
                        that._processSelectionChanged()
                    }
                    handler = that.beginSliderMoving(1 - index, secondPosition);
                    sliders[1 - index]._sliderGroup.stopAnimation();
                    that._shutter.stopAnimation();
                    handler(secondPosition);
                    return handler
                },
                beginSliderMoving: function(initialIndex, initialPosition) {
                    var that = this,
                        translator = that._params.translator,
                        sliders = that._sliders,
                        minPosition = translator.getScreenRange()[0],
                        maxPosition = translator.getScreenRange()[1],
                        index = initialIndex,
                        staticPosition = sliders[1 - index].getPosition(),
                        currentPosition = initialPosition,
                        dir = index > 0 ? 1 : -1,
                        compareMin = index > 0 ? isLess : isGreater,
                        compareMax = index > 0 ? isGreater : isLess,
                        moveOffset = sliders[index].getPosition() - initialPosition,
                        swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;
                    move.complete = function() {
                        sliders[index]._setValid(true);
                        that._dockSelectedArea()
                    };
                    return move;

                    function move(position) {
                        var isValid, temp, pos, slider, value;
                        if (position !== currentPosition) {
                            if (compareMin(position + swapOffset, staticPosition)) {
                                isValid = that._allowSlidersSwap;
                                if (isValid && !translator.isValueProlonged && that._minRange) {
                                    isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir))
                                }
                                if (isValid) {
                                    that._changeMovingSlider(index);
                                    index = 1 - index;
                                    dir = -dir;
                                    temp = compareMin;
                                    compareMin = compareMax;
                                    compareMax = temp;
                                    moveOffset = -dir * Math.abs(moveOffset);
                                    swapOffset = -moveOffset
                                }
                            }
                            if (compareMax(position + moveOffset, staticPosition)) {
                                isValid = true;
                                slider = sliders[index];
                                value = sliders[1 - index].getValue();
                                pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition);
                                if (isValid && translator.isValueProlonged) {
                                    isValid = !compareMin(pos, translator.to(value, dir))
                                }
                                if (isValid && that._minRange) {
                                    isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir))
                                }
                                if (isValid && that._maxRange) {
                                    isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir))
                                }
                                slider._setValid(isValid);
                                slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : slider.getValue());
                                slider._position = pos;
                                that._applyTotalPosition(false);
                                slider.toForeground();
                                if (that._isOnMoving) {
                                    that._processSelectionChanged()
                                }
                            }
                        }
                        currentPosition = position
                    }
                },
                _changeMovingSlider: function(index) {
                    var newValue, that = this,
                        translator = that._params.translator,
                        sliders = that._sliders,
                        position = sliders[1 - index].getPosition(),
                        dir = index > 0 ? 1 : -1;
                    sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), that._values));
                    newValue = translator.from(position, -dir);
                    if (translator.isValueProlonged) {
                        newValue = translator.from(position, dir)
                    } else {
                        if (that._minRange) {
                            newValue = translator.add(newValue, that._minRange, -dir)
                        }
                    }
                    sliders[1 - index].setDisplayValue(selectClosestValue(newValue, that._values));
                    sliders[index]._setValid(true);
                    sliders[index]._marker._update();
                    sliders[0]._position = sliders[1]._position = position
                },
                foregroundSlider: function(index) {
                    this._sliders[index].toForeground()
                }
            };
            exports.SlidersController = SlidersController
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/viz/range_selector/theme_manager.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager;
            exports.ThemeManager = BaseThemeManager.inherit({
                _themeSection: "rangeSelector",
                _fontFields: ["scale.label.font", "sliderMarker.font", "loadingIndicator.font", "export.font", "title.font", "title.subtitle.font"]
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/range_selector/tracker.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                pointerEvents = __webpack_require__( /*! ../../events/pointer */ 13),
                msPointerEnabled = __webpack_require__( /*! ../../core/utils/support */ 18).pointer,
                MIN_MANUAL_SELECTING_WIDTH = 10;

            function isLeftButtonPressed(event) {
                var e = event || window.event,
                    originalEvent = e.originalEvent,
                    touches = e.touches,
                    pointerType = originalEvent ? originalEvent.pointerType : false,
                    eventTouches = originalEvent ? originalEvent.touches : false,
                    isIE8LeftClick = void 0 === e.which && 1 === e.button,
                    isMSPointerLeftClick = originalEvent && void 0 !== pointerType && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || "touch") || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || "mouse") && 1 === originalEvent.buttons),
                    isLeftClick = isIE8LeftClick || 1 === e.which,
                    isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
                return isLeftClick || isMSPointerLeftClick || isTouches
            }

            function isMultiTouches(event) {
                var originalEvent = event.originalEvent,
                    touches = event.touches,
                    eventTouches = originalEvent && originalEvent.touches;
                return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null
            }

            function preventDefault(e) {
                if (!isMultiTouches(e)) {
                    e.preventDefault()
                }
            }

            function stopPropagationAndPreventDefault(e) {
                if (!isMultiTouches(e)) {
                    e.stopPropagation();
                    e.preventDefault()
                }
            }

            function isTouchEventArgs(e) {
                return e && e.type && 0 === e.type.indexOf("touch")
            }

            function getEventPageX(event) {
                var originalEvent = event.originalEvent,
                    result = 0;
                if (event.pageX) {
                    result = event.pageX
                } else {
                    if (originalEvent && originalEvent.pageX) {
                        result = originalEvent.pageX
                    }
                }
                if (originalEvent && originalEvent.touches) {
                    if (originalEvent.touches.length > 0) {
                        result = originalEvent.touches[0].pageX
                    } else {
                        if (originalEvent.changedTouches.length > 0) {
                            result = originalEvent.changedTouches[0].pageX
                        }
                    }
                }
                return result
            }

            function initializeAreaEvents(controller, area, state, getRootOffsetLeft) {
                var isTouchEvent, initialPosition, isActive = false,
                    movingHandler = null,
                    docEvents = {};
                docEvents[pointerEvents.move] = function(e) {
                    var position, offset;
                    if (isTouchEvent !== isTouchEventArgs(e)) {
                        return
                    }
                    if (!isLeftButtonPressed(e)) {
                        cancel()
                    }
                    if (isActive) {
                        position = getEventPageX(e);
                        offset = getRootOffsetLeft();
                        if (movingHandler) {
                            movingHandler(position - offset)
                        } else {
                            if (state.manualRangeSelectionEnabled && Math.abs(initialPosition - position) >= MIN_MANUAL_SELECTING_WIDTH) {
                                movingHandler = controller.placeSliderAndBeginMoving(initialPosition - offset, position - offset)
                            }
                        }
                    }
                };
                docEvents[pointerEvents.up] = function(e) {
                    var position;
                    if (isActive) {
                        position = getEventPageX(e);
                        if (!movingHandler && state.moveSelectedRangeByClick && Math.abs(initialPosition - position) < MIN_MANUAL_SELECTING_WIDTH) {
                            controller.moveSelectedArea(position - getRootOffsetLeft())
                        }
                        cancel()
                    }
                };

                function cancel() {
                    if (isActive) {
                        isActive = false;
                        if (movingHandler) {
                            movingHandler.complete();
                            movingHandler = null
                        }
                    }
                }
                area.on(pointerEvents.down, function(e) {
                    if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                        return
                    }
                    isActive = true;
                    isTouchEvent = isTouchEventArgs(e);
                    initialPosition = getEventPageX(e)
                });
                return docEvents
            }

            function initializeSelectedAreaEvents(controller, area, state, getRootOffsetLeft) {
                var isTouchEvent, isActive = false,
                    movingHandler = null,
                    docEvents = {};
                docEvents[pointerEvents.move] = function(e) {
                    if (isTouchEvent !== isTouchEventArgs(e)) {
                        return
                    }
                    if (!isLeftButtonPressed(e)) {
                        cancel()
                    }
                    if (isActive) {
                        preventDefault(e);
                        movingHandler(getEventPageX(e) - getRootOffsetLeft())
                    }
                };
                docEvents[pointerEvents.up] = cancel;

                function cancel() {
                    if (isActive) {
                        isActive = false;
                        movingHandler.complete();
                        movingHandler = null
                    }
                }
                area.on(pointerEvents.down, function(e) {
                    if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                        return
                    }
                    isActive = true;
                    isTouchEvent = isTouchEventArgs(e);
                    movingHandler = controller.beginSelectedAreaMoving(getEventPageX(e) - getRootOffsetLeft());
                    stopPropagationAndPreventDefault(e)
                });
                return docEvents
            }

            function initializeSliderEvents(controller, sliders, state, getRootOffsetLeft) {
                var isTouchEvent, isActive = false,
                    movingHandler = null,
                    docEvents = {};
                docEvents[pointerEvents.move] = function(e) {
                    if (isTouchEvent !== isTouchEventArgs(e)) {
                        return
                    }
                    if (!isLeftButtonPressed(e)) {
                        cancel()
                    }
                    if (isActive) {
                        preventDefault(e);
                        movingHandler(getEventPageX(e) - getRootOffsetLeft())
                    }
                };
                docEvents[pointerEvents.up] = cancel;
                $.each(sliders, function(i, slider) {
                    var events = {};
                    events[pointerEvents.down] = function(e) {
                        if (!state.enabled || !isLeftButtonPressed(e) || isActive) {
                            return
                        }
                        isActive = true;
                        isTouchEvent = isTouchEventArgs(e);
                        movingHandler = controller.beginSliderMoving(i, getEventPageX(e) - getRootOffsetLeft());
                        stopPropagationAndPreventDefault(e)
                    };
                    events[pointerEvents.move] = function() {
                        if (!movingHandler) {
                            controller.foregroundSlider(i)
                        }
                    };
                    slider.on(events)
                });

                function cancel() {
                    if (isActive) {
                        isActive = false;
                        movingHandler.complete();
                        movingHandler = null
                    }
                }
                return docEvents
            }

            function Tracker(params) {
                var state = this._state = {},
                    targets = params.controller.getTrackerTargets();
                if (msPointerEnabled) {
                    params.renderer.root.css({
                        msTouchAction: "pinch-zoom"
                    })
                }
                this._docEvents = [initializeSelectedAreaEvents(params.controller, targets.selectedArea, state, getRootOffsetLeft), initializeAreaEvents(params.controller, targets.area, state, getRootOffsetLeft), initializeSliderEvents(params.controller, targets.sliders, state, getRootOffsetLeft)];
                $.each(this._docEvents, function(_, events) {
                    $(document).on(events)
                });

                function getRootOffsetLeft() {
                    return params.renderer.getRootOffset().left
                }
            }
            Tracker.prototype = {
                constructor: Tracker,
                dispose: function() {
                    $.each(this._docEvents, function(_, events) {
                        $(document).off(events)
                    })
                },
                update: function(enabled, behavior) {
                    var state = this._state;
                    state.enabled = enabled;
                    state.moveSelectedRangeByClick = behavior.moveSelectedRangeByClick;
                    state.manualRangeSelectionEnabled = behavior.manualRangeSelectionEnabled
                }
            };
            exports.Tracker = Tracker
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/viz/series/bubble_series.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                lineSeries = __webpack_require__( /*! ./line_series */ 193).chart.line,
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88).chart,
                areaSeries = __webpack_require__( /*! ./area_series */ 166).chart.area,
                barSeries = __webpack_require__( /*! ./bar_series */ 129),
                chartBarSeries = barSeries.chart.bar,
                polarBarSeries = barSeries.polar.bar,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop;
            exports.chart = {};
            exports.chart.bubble = _extend({}, scatterSeries, {
                _fillErrorBars: _noop,
                getErrorBarRangeCorrector: _noop,
                _calculateErrorBars: _noop,
                _getMainColor: chartBarSeries._getMainColor,
                _createPointStyles: chartBarSeries._createPointStyles,
                _createPattern: chartBarSeries._createPattern,
                _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
                _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
                _getSpecialColor: chartBarSeries._getSpecialColor,
                _applyMarkerClipRect: lineSeries._applyElementsClipRect,
                _parsePointStyle: polarBarSeries._parsePointStyle,
                _createLegendState: areaSeries._createLegendState,
                _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
                areErrorBarsVisible: _noop,
                _createErrorBarGroup: _noop,
                _checkData: function(data) {
                    return _isDefined(data.argument) && _isDefined(data.size) && void 0 !== data.value
                },
                _getPointData: function(data, options) {
                    var pointData = scatterSeries._getPointData.call(this, data, options);
                    pointData.size = data[options.sizeField || "size"];
                    return pointData
                },
                _fusionPoints: function(fusionPoints, tick) {
                    var calcMedianValue = scatterSeries._calcMedianValue;
                    return {
                        size: calcMedianValue.call(this, fusionPoints, "size"),
                        value: calcMedianValue.call(this, fusionPoints, "value"),
                        argument: tick,
                        tag: null
                    }
                },
                getValueFields: function() {
                    return [this._options.valueField || "val"]
                },
                getSizeField: function() {
                    return this._options.sizeField || "size"
                },
                updateTemplateFieldNames: function() {
                    var that = this,
                        options = that._options,
                        name = that.name;
                    options.valueField = that.getValueFields()[0] + name;
                    options.sizeField = that.getSizeField() + name;
                    options.tagField = that.getTagField() + name
                },
                _clearingAnimation: function(translators, drawComplete) {
                    var that = this,
                        partitionDuration = .5,
                        lastPointIndex = that._drawnPoints.length - 1,
                        labelsGroup = that._labelsGroup;
                    labelsGroup && labelsGroup.animate({
                        opacity: .001
                    }, {
                        duration: that._defaultDuration,
                        partitionDuration: partitionDuration
                    }, function() {
                        _each(that._drawnPoints || [], function(i, p) {
                            p.animate(i === lastPointIndex ? drawComplete : void 0, {
                                r: 0
                            }, partitionDuration)
                        })
                    })
                },
                _animate: function() {
                    var that = this,
                        lastPointIndex = that._drawnPoints.length - 1,
                        labelsGroup = that._labelsGroup,
                        labelAnimFunc = function() {
                            labelsGroup && labelsGroup.animate({
                                opacity: 1
                            }, {
                                duration: that._defaultDuration
                            })
                        };
                    _each(that._drawnPoints || [], function(i, p) {
                        p.animate(i === lastPointIndex ? labelAnimFunc : void 0, {
                            r: p.bubbleSize,
                            translateX: p.x,
                            translateY: p.y
                        })
                    })
                },
                _beginUpdateData: chartBarSeries._beginUpdateData
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!************************************************!*\
      !*** ./Scripts/viz/series/financial_series.js ***!
      \************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88).chart,
                barSeries = __webpack_require__( /*! ./bar_series */ 129).chart.bar,
                rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 167),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop,
                DEFAULT_FINANCIAL_POINT_SIZE = 10;
            exports.stock = _extend({}, scatterSeries, {
                _animate: _noop,
                _applyMarkerClipRect: function(settings) {
                    settings.clipId = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID
                },
                _updatePointsVisibility: barSeries._updatePointsVisibility,
                _getOptionsForPoint: barSeries._getOptionsForPoint,
                getErrorBarRangeCorrector: _noop,
                _createErrorBarGroup: _noop,
                areErrorBarsVisible: _noop,
                _createGroups: scatterSeries._createGroups,
                _setMarkerGroupSettings: function() {
                    var that = this,
                        markersGroup = that._markersGroup,
                        styles = that._createPointStyles(that._getMarkerGroupOptions()),
                        defaultStyle = _extend(styles.normal, {
                            "class": "default-markers"
                        }),
                        defaultPositiveStyle = _extend(styles.positive.normal, {
                            "class": "default-positive-markers"
                        }),
                        reductionStyle = _extend(styles.reduction.normal, {
                            "class": "reduction-markers"
                        }),
                        reductionPositiveStyle = _extend(styles.reductionPositive.normal, {
                            "class": "reduction-positive-markers"
                        }),
                        markerSettings = {
                            "class": "dxc-markers"
                        };
                    that._applyMarkerClipRect(markerSettings);
                    markersGroup.attr(markerSettings);
                    that._createGroup("defaultMarkersGroup", markersGroup, markersGroup, defaultStyle);
                    that._createGroup("reductionMarkersGroup", markersGroup, markersGroup, reductionStyle);
                    that._createGroup("defaultPositiveMarkersGroup", markersGroup, markersGroup, defaultPositiveStyle);
                    that._createGroup("reductionPositiveMarkersGroup", markersGroup, markersGroup, reductionPositiveStyle)
                },
                _setGroupsSettings: function() {
                    scatterSeries._setGroupsSettings.call(this, false)
                },
                _clearingAnimation: function(translators, drawComplete) {
                    drawComplete()
                },
                _getCreatingPointOptions: function() {
                    var defaultPointOptions, that = this,
                        creatingPointOptions = that._predefinedPointOptions;
                    if (!creatingPointOptions) {
                        defaultPointOptions = this._getPointOptions();
                        that._predefinedPointOptions = creatingPointOptions = _extend(true, {
                            styles: {}
                        }, defaultPointOptions);
                        creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
                            "stroke-width": defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal["stroke-width"]
                        }
                    }
                    return creatingPointOptions
                },
                _checkData: function(data) {
                    return _isDefined(data.argument) && void 0 !== data.highValue && void 0 !== data.lowValue && void 0 !== data.openValue && void 0 !== data.closeValue
                },
                _processRange: function(point, prevPoint) {
                    rangeCalculator.processTwoValues(this, point, prevPoint, "highValue", "lowValue")
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "highValue", "lowValue");
                    rangeCalculator.addRangeSeriesLabelPaddings(this);
                    return this._rangeData
                },
                _getPointData: function(data, options) {
                    var level, reductionValue, that = this,
                        openValueField = options.openValueField || "open",
                        closeValueField = options.closeValueField || "close",
                        highValueField = options.highValueField || "high",
                        lowValueField = options.lowValueField || "low";
                    that.level = options.reduction.level;
                    switch (_normalizeEnum(that.level)) {
                        case "open":
                            level = openValueField;
                            break;
                        case "high":
                            level = highValueField;
                            break;
                        case "low":
                            level = lowValueField;
                            break;
                        default:
                            level = closeValueField;
                            that.level = "close"
                    }
                    reductionValue = data[level];
                    return {
                        argument: data[options.argumentField || "date"],
                        highValue: data[highValueField],
                        lowValue: data[lowValueField],
                        closeValue: data[closeValueField],
                        openValue: data[openValueField],
                        reductionValue: reductionValue,
                        tag: data[options.tagField || "tag"],
                        isReduction: that._checkReduction(reductionValue)
                    }
                },
                _parsePointStyle: function(style, defaultColor, innerColor) {
                    return {
                        stroke: style.color || defaultColor,
                        "stroke-width": style.width,
                        fill: style.color || innerColor
                    }
                },
                updateTemplateFieldNames: function() {
                    var that = this,
                        options = that._options,
                        valueFields = that.getValueFields(),
                        name = that.name;
                    options.openValueField = valueFields[0] + name;
                    options.highValueField = valueFields[1] + name;
                    options.lowValueField = valueFields[2] + name;
                    options.closeValueField = valueFields[3] + name;
                    options.tagField = that.getTagField() + name
                },
                _getDefaultStyle: function(options) {
                    var that = this,
                        mainPointColor = options.color || that._options.mainSeriesColor;
                    return {
                        normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
                        hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
                        selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
                    }
                },
                _getReductionStyle: function(options) {
                    var that = this,
                        reductionColor = options.reduction.color;
                    return {
                        normal: that._parsePointStyle({
                            color: reductionColor,
                            width: options.width,
                            hatching: options.hatching
                        }, reductionColor, reductionColor),
                        hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
                        selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
                    }
                },
                _createPointStyles: function(pointOptions) {
                    var positiveStyle, reductionStyle, reductionPositiveStyle, that = this,
                        innerColor = that._options.innerColor,
                        styles = that._getDefaultStyle(pointOptions);
                    positiveStyle = _extend(true, {}, styles);
                    reductionStyle = that._getReductionStyle(pointOptions);
                    reductionPositiveStyle = _extend(true, {}, reductionStyle);
                    positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
                    reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
                    styles.positive = positiveStyle;
                    styles.reduction = reductionStyle;
                    styles.reductionPositive = reductionPositiveStyle;
                    return styles
                },
                _endUpdateData: function() {
                    delete this.prevLevelValue;
                    delete this._predefinedPointOptions
                },
                _checkReduction: function(value) {
                    var that = this,
                        result = false;
                    if (null !== value) {
                        if (_isDefined(that.prevLevelValue)) {
                            result = value < that.prevLevelValue
                        }
                        that.prevLevelValue = value
                    }
                    return result
                },
                _fusionPoints: function(fusionPoints, tick) {
                    var reductionLevel, openValue, closeValue, fusedPointData = {},
                        highValue = -(1 / 0),
                        lowValue = +(1 / 0);
                    if (!fusionPoints.length) {
                        return {}
                    }
                    _each(fusionPoints, function(_, point) {
                        if (!point.hasValue()) {
                            return
                        }
                        highValue = Math.max(highValue, point.highValue);
                        lowValue = Math.min(lowValue, point.lowValue);
                        openValue = void 0 !== openValue ? openValue : point.openValue;
                        closeValue = void 0 !== point.closeValue ? point.closeValue : closeValue
                    });
                    fusedPointData.argument = tick;
                    fusedPointData.openValue = openValue;
                    fusedPointData.closeValue = closeValue;
                    fusedPointData.highValue = highValue;
                    fusedPointData.lowValue = lowValue;
                    fusedPointData.tag = null;
                    switch (_normalizeEnum(this.level)) {
                        case "open":
                            reductionLevel = openValue;
                            break;
                        case "high":
                            reductionLevel = highValue;
                            break;
                        case "low":
                            reductionLevel = lowValue;
                            break;
                        default:
                            reductionLevel = closeValue
                    }
                    fusedPointData.reductionValue = reductionLevel;
                    fusedPointData.isReduction = this._checkReduction(reductionLevel);
                    return fusedPointData
                },
                _getPointSize: function() {
                    return DEFAULT_FINANCIAL_POINT_SIZE
                },
                getValueFields: function() {
                    var options = this._options;
                    return [options.openValueField || "open", options.highValueField || "high", options.lowValueField || "low", options.closeValueField || "close"]
                },
                getArgumentField: function() {
                    return this._options.argumentField || "date"
                },
                _beginUpdateData: _noop
            });
            exports.candlestick = _extend({}, exports.stock, {
                _createPattern: barSeries._createPattern,
                _beginUpdateData: barSeries._beginUpdateData,
                _parsePointStyle: function(style, defaultColor, innerColor) {
                    var color = this._createPattern(style.color || innerColor, style.hatching),
                        base = exports.stock._parsePointStyle.call(this, style, defaultColor, color);
                    base.fill = color;
                    return base
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/series/pie_series.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                chartScatterSeries = scatterSeries.chart,
                barSeries = __webpack_require__( /*! ./bar_series */ 129).chart.bar,
                _extend = $.extend,
                _each = $.each,
                _noop = $.noop,
                _map = vizUtils.map,
                _isFinite = isFinite,
                _max = Math.max,
                INSIDE = "inside";
            exports.pie = _extend({}, barSeries, {
                _setGroupsSettings: chartScatterSeries._setGroupsSettings,
                _createErrorBarGroup: _noop,
                _drawPoint: function(options) {
                    var point = options.point,
                        legendCallback = options.legendCallback;
                    chartScatterSeries._drawPoint.call(this, options);
                    !point.isVisible() && point.setInvisibility();
                    legendCallback && point.isSelected() && legendCallback(point)("applySelected")
                },
                adjustLabels: function() {
                    var maxLabelLength, that = this,
                        points = that._points || [],
                        labelsBBoxes = [];
                    _each(points, function(_, point) {
                        if (point._label.isVisible()) {
                            point.setLabelTrackerData();
                            if (point._label.getLayoutOptions().position !== INSIDE) {
                                point.setLabelEllipsis();
                                labelsBBoxes.push(point._label.getBoundingRect().width)
                            }
                        }
                    });
                    if (labelsBBoxes.length) {
                        maxLabelLength = _max.apply(null, labelsBBoxes)
                    }
                    _each(points, function(_, point) {
                        if (point._label.isVisible() && point._label.getLayoutOptions().position !== INSIDE) {
                            point.setMaxLabelLength(maxLabelLength);
                            point.updateLabelCoord()
                        }
                    })
                },
                _processRange: _noop,
                _applyElementsClipRect: _noop,
                getColor: _noop,
                areErrorBarsVisible: _noop,
                _prepareSeriesToDrawing: _noop,
                _endUpdateData: function() {
                    this._arrayArguments = {};
                    chartScatterSeries._prepareSeriesToDrawing.call(this)
                },
                drawLabelsWOPoints: function(translators) {
                    var that = this,
                        options = that._options,
                        points = that._points || [];
                    if (options.label.position === INSIDE) {
                        return false
                    }
                    that._labelsGroup.append(that._extGroups.labelsGroup);
                    _each(points, function(_, point) {
                        point.drawLabel(translators)
                    });
                    return true
                },
                _getCreatingPointOptions: function(data) {
                    return this._getPointOptions(data)
                },
                _updateOptions: function(options) {
                    this.labelSpace = 0;
                    this.innerRadius = "pie" === this.type ? 0 : options.innerRadius
                },
                _checkData: function(data) {
                    var base = barSeries._checkData(data);
                    return this._options.paintNullPoints ? base : base && null !== data.value
                },
                _createGroups: chartScatterSeries._createGroups,
                _setMarkerGroupSettings: function() {
                    var that = this;
                    that._markersGroup.attr({
                        "class": "dxc-markers"
                    })
                },
                _getMainColor: function(data) {
                    var that = this,
                        arr = that._arrayArguments || {},
                        argument = data.argument;
                    arr[argument] = ++arr[argument] || 0;
                    that._arrayArguments = arr;
                    return that._options.mainSeriesColor(argument, arr[argument])
                },
                _getPointOptions: function(data) {
                    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data)
                },
                _getRangeData: function() {
                    return this._rangeData
                },
                _getArrangeTotal: function(points) {
                    var total = 0;
                    _each(points, function(_, point) {
                        if (point.isVisible()) {
                            total += point.initialValue
                        }
                    });
                    return total
                },
                _createPointStyles: function(pointOptions, data) {
                    var that = this,
                        mainColor = pointOptions.color || that._getMainColor(data),
                        specialMainColor = that._getSpecialColor(mainColor);
                    return {
                        normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                        hover: that._parsePointStyle(pointOptions.hoverStyle, specialMainColor, mainColor),
                        selection: that._parsePointStyle(pointOptions.selectionStyle, specialMainColor, mainColor),
                        legendStyles: {
                            normal: that._createLegendState(pointOptions, mainColor),
                            hover: that._createLegendState(pointOptions.hoverStyle, specialMainColor),
                            selection: that._createLegendState(pointOptions.selectionStyle, specialMainColor)
                        }
                    }
                },
                _getArrangeMinShownValue: function(points, total) {
                    var minSegmentSize = this._options.minSegmentSize,
                        totalMinSegmentSize = 0,
                        totalNotMinValues = 0;
                    total = total || points.length;
                    _each(points, function(_, point) {
                        if (point.isVisible()) {
                            if (point.initialValue < minSegmentSize * total / 360) {
                                totalMinSegmentSize += minSegmentSize
                            } else {
                                totalNotMinValues += point.initialValue
                            }
                        }
                    });
                    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0
                },
                _applyArrangeCorrection: function(points, minShownValue, total) {
                    var percent, options = this._options,
                        isClockWise = "anticlockwise" !== options.segmentsDirection,
                        shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0,
                        minSegmentSize = options.minSegmentSize,
                        correction = 0,
                        zeroTotalCorrection = 0;
                    if (0 === total) {
                        total = points.filter(function(el) {
                            return el.isVisible()
                        }).length;
                        zeroTotalCorrection = 1
                    }
                    _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {
                        var updatedZeroValue, val = point.isVisible() ? zeroTotalCorrection || point.initialValue : 0;
                        if (minSegmentSize && point.isVisible() && val < minShownValue) {
                            updatedZeroValue = minShownValue
                        }
                        percent = val / total;
                        point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
                        point.shiftedAngle = shiftedAngle;
                        correction += updatedZeroValue || val
                    });
                    this._rangeData = {
                        val: {
                            min: 0,
                            max: correction
                        }
                    }
                },
                arrangePoints: function() {
                    var minShownValue, total, points, that = this,
                        originalPoints = that._originalPoints || [],
                        minSegmentSize = that._options.minSegmentSize,
                        isAllPointsNegative = true,
                        i = 0,
                        len = originalPoints.length;
                    while (i < len && isAllPointsNegative) {
                        isAllPointsNegative = originalPoints[i].value <= 0;
                        i++
                    }
                    points = that._originalPoints = that._points = _map(originalPoints, function(point) {
                        if (null === point.value || !isAllPointsNegative && point.value < 0) {
                            point.dispose();
                            return null
                        } else {
                            return point
                        }
                    });
                    total = that._getArrangeTotal(points);
                    if (minSegmentSize) {
                        minShownValue = this._getArrangeMinShownValue(points, total)
                    }
                    that._applyArrangeCorrection(points, minShownValue, total)
                },
                correctPosition: function(correction) {
                    var debug = __webpack_require__( /*! ../../core/utils/console */ 36).debug;
                    debug.assert(correction, "correction was not passed");
                    debug.assertParam(correction.centerX, "correction.centerX was not passed");
                    debug.assertParam(correction.centerY, "correction.centerY was not passed");
                    debug.assertParam(correction.radiusInner, "correction.radiusInner was not passed");
                    debug.assertParam(correction.radiusOuter, "correction.radiusOuter was not passed");
                    debug.assertParam(correction.canvas, "correction.canvas was not passed");
                    _each(this._points, function(_, point) {
                        point.correctPosition(correction)
                    });
                    this.setVisibleArea(correction.canvas)
                },
                correctRadius: function(correction) {
                    _each(this._points, function(_, point) {
                        point.correctRadius(correction)
                    })
                },
                correctLabelRadius: function(labelRadius) {
                    _each(this._points, function(_, point) {
                        point.correctLabelRadius(labelRadius)
                    })
                },
                setVisibleArea: function(canvas) {
                    this._visibleArea = {
                        minX: canvas.left,
                        maxX: canvas.width - canvas.right,
                        minY: canvas.top,
                        maxY: canvas.height - canvas.bottom
                    }
                },
                _applyVisibleArea: _noop,
                _animate: function(firstDrawing) {
                    var that = this,
                        index = 0,
                        timeThreshold = .2,
                        points = that._points,
                        pointsCount = points && points.length,
                        duration = 1 / (timeThreshold * (pointsCount - 1) + 1),
                        completeFunc = function() {
                            that._animateComplete()
                        },
                        animateP = function() {
                            points[index] && points[index].animate(index === pointsCount - 1 ? completeFunc : void 0, duration, stepFunc);
                            index++
                        },
                        stepFunc = function(_, progress) {
                            if (progress >= timeThreshold) {
                                this.step = null;
                                animateP()
                            }
                        };
                    if (firstDrawing) {
                        animateP()
                    } else {
                        $.each(points, function(i, p) {
                            p.animate(i === pointsCount - 1 ? completeFunc : void 0)
                        })
                    }
                },
                getVisiblePoints: function() {
                    return _map(this._points, function(p) {
                        return p.isVisible() ? p : null
                    })
                },
                _beginUpdateData: function() {
                    this._deletePatterns()
                }
            });
            exports.doughnut = exports.donut = exports.pie
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/series/points/base_point.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                mixins = {},
                statesConsts = __webpack_require__( /*! ../../components/consts */ 126).states,
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                barPoint = __webpack_require__( /*! ./bar_point */ 194),
                bubblePoint = __webpack_require__( /*! ./bubble_point */ 545),
                piePoint = __webpack_require__( /*! ./pie_point */ 337),
                rangeSymbolPoint = __webpack_require__( /*! ./range_symbol_point */ 338),
                rangeBarPoint = __webpack_require__( /*! ./range_bar_point */ 547),
                candlestickPoint = __webpack_require__( /*! ./candlestick_point */ 335),
                stockPoint = __webpack_require__( /*! ./stock_point */ 548),
                polarPoints = __webpack_require__( /*! ./polar_point */ 546),
                _each = $.each,
                _extend = $.extend,
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                _isDefined = commonUtils.isDefined,
                _noop = $.noop,
                SYMBOL_POINT = "symbolPoint",
                POLAR_SYMBOL_POINT = "polarSymbolPoint",
                BAR_POINT = "barPoint",
                POLAR_BAR_POINT = "polarBarPoint",
                PIE_POINT = "piePoint",
                pointTypes = {
                    chart: {
                        scatter: SYMBOL_POINT,
                        line: SYMBOL_POINT,
                        spline: SYMBOL_POINT,
                        stepline: SYMBOL_POINT,
                        stackedline: SYMBOL_POINT,
                        fullstackedline: SYMBOL_POINT,
                        stackedspline: SYMBOL_POINT,
                        fullstackedspline: SYMBOL_POINT,
                        stackedsplinearea: SYMBOL_POINT,
                        fullstackedsplinearea: SYMBOL_POINT,
                        area: SYMBOL_POINT,
                        splinearea: SYMBOL_POINT,
                        steparea: SYMBOL_POINT,
                        stackedarea: SYMBOL_POINT,
                        fullstackedarea: SYMBOL_POINT,
                        rangearea: "rangeSymbolPoint",
                        bar: BAR_POINT,
                        stackedbar: BAR_POINT,
                        fullstackedbar: BAR_POINT,
                        rangebar: "rangeBarPoint",
                        bubble: "bubblePoint",
                        stock: "stockPoint",
                        candlestick: "candlestickPoint"
                    },
                    pie: {
                        pie: PIE_POINT,
                        doughnut: PIE_POINT,
                        donut: PIE_POINT
                    },
                    polar: {
                        scatter: POLAR_SYMBOL_POINT,
                        line: POLAR_SYMBOL_POINT,
                        area: POLAR_SYMBOL_POINT,
                        bar: POLAR_BAR_POINT,
                        stackedbar: POLAR_BAR_POINT
                    }
                };

            function Point(series, dataItem, options) {
                this.fullState = statesConsts.normalMark;
                this.series = series;
                this.update(dataItem, options);
                this._emptySettings = {
                    fill: null,
                    stroke: null,
                    dashStyle: null
                }
            }
            exports.Point = Point;
            mixins.symbolPoint = symbolPoint;
            mixins.barPoint = barPoint;
            mixins.bubblePoint = bubblePoint;
            mixins.piePoint = piePoint;
            mixins.rangeSymbolPoint = rangeSymbolPoint;
            mixins.rangeBarPoint = rangeBarPoint;
            mixins.candlestickPoint = candlestickPoint;
            mixins.stockPoint = stockPoint;
            mixins.polarSymbolPoint = polarPoints.polarSymbolPoint;
            mixins.polarBarPoint = polarPoints.polarBarPoint;
            Point.prototype = {
                constructor: Point,
                getColor: function() {
                    return this._styles.normal.fill || this.series.getColor()
                },
                _getStyle: function() {
                    return this._styles[this._currentStyle || "normal"]
                },
                update: function(dataItem, options) {
                    this.updateOptions(options);
                    this.updateData(dataItem)
                },
                updateData: function(dataItem) {
                    var that = this;
                    that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
                    that.tag = dataItem.tag;
                    that.index = dataItem.index;
                    that.lowError = dataItem.lowError;
                    that.highError = dataItem.highError;
                    that._updateData(dataItem);
                    !that.hasValue() && that.setInvisibility();
                    that._fillStyle();
                    that._updateLabelData()
                },
                deleteMarker: function() {
                    var that = this;
                    if (that.graphic) {
                        that.graphic.dispose()
                    }
                    that.graphic = null
                },
                _drawErrorBar: _noop,
                draw: function(renderer, groups, animationEnabled, firstDrawing) {
                    var that = this;
                    if (that._needDeletingOnDraw) {
                        that.deleteMarker();
                        that._needDeletingOnDraw = false
                    }
                    if (that._needClearingOnDraw) {
                        that.clearMarker();
                        that._needClearingOnDraw = false
                    }
                    if (!that._hasGraphic()) {
                        that._getMarkerVisibility() && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing)
                    } else {
                        that._updateMarker(animationEnabled, void 0, groups.markers)
                    }
                    that._drawLabel();
                    that._drawErrorBar(renderer, groups.errorBars, animationEnabled);
                    return that
                },
                applyStyle: function(style) {
                    var that = this;
                    that._currentStyle = style;
                    if (that.graphic) {
                        if ("normal" === style) {
                            if (that.isHovered()) {
                                that.applyStyle("hover");
                                return
                            }
                            that.clearMarker()
                        } else {
                            that.graphic.toForeground()
                        }
                        that._updateMarker(true, that._styles[style])
                    }
                    return that
                },
                releaseHoverState: function() {
                    var that = this;
                    if (that.graphic && !that.isSelected()) {
                        that.graphic.toBackground()
                    }
                },
                select: function() {
                    this.series.selectPoint(this)
                },
                clearSelection: function() {
                    this.series.deselectPoint(this)
                },
                showTooltip: function() {
                    this.series.showPointTooltip(this)
                },
                hideTooltip: function() {
                    this.series.hidePointTooltip(this)
                },
                _checkLabelsChanging: function(oldType, newType) {
                    var isNewRange = ~newType.indexOf("range"),
                        isOldRange = ~oldType.indexOf("range");
                    return isOldRange && !isNewRange || !isOldRange && isNewRange
                },
                updateOptions: function(newOptions) {
                    if (!newOptions) {
                        return
                    }
                    var that = this,
                        oldOptions = that._options,
                        widgetType = newOptions.widgetType,
                        oldType = oldOptions && oldOptions.type,
                        newType = newOptions.type,
                        newPointTypeMixin = pointTypes[widgetType][newType];
                    if (oldType !== newType) {
                        that._needDeletingOnDraw = true;
                        that._needClearingOnDraw = false;
                        if (oldType) {
                            that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
                            that._resetType(mixins[pointTypes[oldType]])
                        }
                        that._setType(mixins[newPointTypeMixin])
                    } else {
                        that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
                        that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions)
                    }
                    that._options = newOptions;
                    that._fillStyle();
                    that._updateLabelOptions(newPointTypeMixin)
                },
                translate: function(translators) {
                    var that = this;
                    that.translators = translators || that.translators;
                    that.translators && that.hasValue() && that._translate(that.translators)
                },
                _checkCustomize: function(oldOptions, newOptions) {
                    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions
                },
                _getCustomLabelVisibility: function() {
                    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null
                },
                getBoundingRect: function() {
                    return this._getGraphicBbox()
                },
                _resetType: function(methods) {
                    for (var methodName in methods) {
                        delete this[methodName]
                    }
                },
                _setType: function(methods) {
                    for (var methodName in methods) {
                        this[methodName] = methods[methodName]
                    }
                },
                isInVisibleArea: function() {
                    return this.inVisibleArea
                },
                isSelected: function() {
                    return !!(this.fullState & statesConsts.selectedMark)
                },
                isHovered: function() {
                    return !!(this.fullState & statesConsts.hoverMark)
                },
                getOptions: function() {
                    return this._options
                },
                animate: function(complete, settings, partitionDuration) {
                    if (!this.graphic) {
                        complete && complete();
                        return
                    }
                    this.graphic.animate(settings, {
                        partitionDuration: partitionDuration
                    }, complete)
                },
                getCoords: function(min) {
                    var that = this;
                    if (!min) {
                        return {
                            x: that.x,
                            y: that.y
                        }
                    }
                    if (!that._options.rotated) {
                        return {
                            x: that.x,
                            y: that.minY
                        }
                    }
                    return {
                        x: that.minX,
                        y: that.y
                    }
                },
                getDefaultCoords: function() {
                    var that = this;
                    return !that._options.rotated ? {
                        x: that.x,
                        y: that.defaultY
                    } : {
                        x: that.defaultX,
                        y: that.y
                    }
                },
                _getVisibleArea: function() {
                    return this.series._visibleArea
                },
                _calculateVisibility: function(x, y, width, height) {
                    var visibleAreaX, visibleAreaY, that = this,
                        rotated = that._options.rotated;
                    if (that.translators) {
                        visibleAreaX = that.translators.x.getCanvasVisibleArea();
                        visibleAreaY = that.translators.y.getCanvasVisibleArea();
                        if (visibleAreaX.min > x + (width || 0) || visibleAreaX.max < x || visibleAreaY.min > y + (height || 0) || visibleAreaY.max < y || rotated && _isDefined(width) && 0 !== width && (visibleAreaX.min === x + width || visibleAreaX.max === x) || !rotated && _isDefined(height) && 0 !== height && (visibleAreaY.min === y + height || visibleAreaY.max === y)) {
                            that.inVisibleArea = false
                        } else {
                            that.inVisibleArea = true
                        }
                    }
                },
                hasValue: function() {
                    return null !== this.value && null !== this.minValue
                },
                getBoundaryCoords: function() {
                    return this.getBoundingRect()
                },
                correctPosition: _noop,
                correctRadius: _noop,
                correctLabelRadius: _noop,
                getCrosshairData: _noop,
                getPointRadius: _noop,
                _populatePointShape: _noop,
                _checkSymbol: _noop,
                getMarkerCoords: _noop,
                hide: _noop,
                show: _noop,
                hideMarker: _noop,
                setInvisibility: _noop,
                clearVisibility: _noop,
                isVisible: _noop,
                resetCorrection: _noop,
                correctValue: _noop,
                resetValue: _noop,
                setPercentValue: _noop,
                correctCoordinates: _noop,
                coordsIn: _noop,
                getTooltipParams: _noop,
                setLabelEllipsis: _noop,
                setLabelTrackerData: _noop,
                updateLabelCoord: _noop,
                drawLabel: _noop,
                correctLabelPosition: _noop,
                setMaxLabelLength: _noop,
                dispose: function() {
                    var that = this;
                    that.deleteMarker();
                    that.deleteLabel();
                    that._errorBar && this._errorBar.dispose();
                    that._options = that._styles = that.series = that.translators = that._errorBar = null
                },
                getTooltipFormatObject: function(tooltip) {
                    var that = this,
                        tooltipFormatObject = that._getFormatObject(tooltip),
                        sharedTooltipValuesArray = [],
                        tooltipStackPointsFormatObject = [];
                    if (that.stackPoints) {
                        _each(that.stackPoints, function(_, point) {
                            if (!point.isVisible()) {
                                return
                            }
                            var formatObject = point._getFormatObject(tooltip);
                            tooltipStackPointsFormatObject.push(formatObject);
                            sharedTooltipValuesArray.push(formatObject.seriesName + ": " + formatObject.valueText)
                        });
                        _extend(tooltipFormatObject, {
                            points: tooltipStackPointsFormatObject,
                            valueText: sharedTooltipValuesArray.join("\n"),
                            stackName: that.stackPoints.stackName
                        })
                    }
                    return tooltipFormatObject
                },
                setHole: function(holeValue, position) {
                    var that = this,
                        minValue = isFinite(that.minValue) ? that.minValue : 0;
                    if (_isDefined(holeValue)) {
                        if ("left" === position) {
                            that.leftHole = that.value - holeValue;
                            that.minLeftHole = minValue - holeValue
                        } else {
                            that.rightHole = that.value - holeValue;
                            that.minRightHole = minValue - holeValue
                        }
                    }
                },
                resetHoles: function() {
                    this.leftHole = null;
                    this.minLeftHole = null;
                    this.rightHole = null;
                    this.minRightHole = null
                },
                getLabel: function() {
                    return this._label
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/series/points/bubble_point.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                _extend = $.extend,
                MIN_BUBBLE_HEIGHT = 20;
            module.exports = _extend({}, symbolPoint, {
                correctCoordinates: function(diameter) {
                    this.bubbleSize = diameter / 2
                },
                _drawMarker: function(renderer, group, animationEnabled) {
                    var that = this,
                        attr = _extend({
                            translateX: that.x,
                            translateY: that.y
                        }, that._getStyle());
                    that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).attr(attr).data({
                        "chart-data-point": that
                    }).append(group)
                },
                getTooltipParams: function(location) {
                    var height, that = this,
                        graphic = that.graphic;
                    if (!graphic) {
                        return
                    }
                    height = graphic.getBBox().height;
                    return {
                        x: that.x,
                        y: height < MIN_BUBBLE_HEIGHT || "edge" === location ? this.y - height / 2 : this.y,
                        offset: 0
                    }
                },
                _getLabelFormatObject: function() {
                    var formatObject = symbolPoint._getLabelFormatObject.call(this);
                    formatObject.size = this.initialSize;
                    return formatObject
                },
                _updateData: function(data) {
                    symbolPoint._updateData.call(this, data);
                    this.size = this.initialSize = data.size
                },
                _getGraphicBbox: function() {
                    var that = this;
                    return that._getSymbolBbox(that.x, that.y, that.bubbleSize)
                },
                _updateMarker: function(animationEnabled, style) {
                    var that = this;
                    style = style || that._getStyle();
                    if (!animationEnabled) {
                        style = $.extend({
                            r: that.bubbleSize,
                            translateX: that.x,
                            translateY: that.y
                        }, style)
                    }
                    that.graphic.attr(style)
                },
                _getFormatObject: function(tooltip) {
                    var formatObject = symbolPoint._getFormatObject.call(this, tooltip);
                    formatObject.sizeText = tooltip.formatValue(this.initialSize);
                    return formatObject
                },
                _storeTrackerR: function() {
                    return this.bubbleSize
                },
                _getLabelCoords: function(label) {
                    var coords;
                    if ("inside" === label.getLayoutOptions().position) {
                        coords = this._getLabelCoordOfPosition(label, "inside")
                    } else {
                        coords = symbolPoint._getLabelCoords.call(this, label)
                    }
                    return coords
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/series/points/polar_point.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _extend = $.extend,
                commonUtils = __webpack_require__( /*! ../../../core/utils/common */ 2),
                symbolPoint = __webpack_require__( /*! ./symbol_point */ 104),
                barPoint = __webpack_require__( /*! ./bar_point */ 194),
                piePoint = __webpack_require__( /*! ./pie_point */ 337),
                isDefined = commonUtils.isDefined,
                vizUtils = __webpack_require__( /*! ../../core/utils */ 6),
                normalizeAngle = vizUtils.normalizeAngle,
                _math = Math,
                _max = _math.max,
                ERROR_BARS_ANGLE_OFFSET = 90,
                CANVAS_POSITION_START = "canvas_position_start",
                CANVAS_POSITION_TOP = "canvas_position_top",
                CANVAS_POSITION_END = "canvas_position_end",
                CANVAS_POSITION_DEFAULT = "canvas_position_default";
            exports.polarSymbolPoint = _extend({}, symbolPoint, {
                _getLabelCoords: piePoint._getLabelCoords,
                _moveLabelOnCanvas: barPoint._moveLabelOnCanvas,
                _getLabelPosition: function() {
                    return "outside"
                },
                _translate: function(translator) {
                    var that = this,
                        coord = translator.translate(that.argument, that.value),
                        center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                    that.vx = normalizeAngle(coord.angle);
                    that.vy = that.radiusOuter = that.radiusLabels = coord.radius;
                    that.radius = coord.radius;
                    that.middleAngle = -coord.angle;
                    that.angle = -coord.angle;
                    that.x = coord.x;
                    that.y = coord.y;
                    that.defaultX = that.centerX = center.x;
                    that.defaultY = that.centerY = center.y;
                    that._translateErrorBars(translator);
                    that.inVisibleArea = true
                },
                _translateErrorBars: function(translator) {
                    var that = this,
                        errorBars = that._options.errorBars;
                    if (!errorBars) {
                        return
                    }
                    isDefined(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.argument, that.lowError).radius);
                    isDefined(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.argument, that.highError).radius);
                    that._errorBarPos = that.centerX;
                    that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius
                },
                _getTranslates: function(animationEnabled) {
                    return animationEnabled ? this.getDefaultCoords() : {
                        x: this.x,
                        y: this.y
                    }
                },
                getDefaultCoords: function() {
                    var cossin = vizUtils.getCosAndSin(-this.angle),
                        radius = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_DEFAULT).radius,
                        x = this.defaultX + radius * cossin.cos,
                        y = this.defaultY + radius * cossin.sin;
                    return {
                        x: x,
                        y: y
                    }
                },
                _addLabelAlignmentAndOffset: function(label, coord) {
                    return coord
                },
                _checkLabelPosition: function(label, coord) {
                    var that = this,
                        visibleArea = that._getVisibleArea(),
                        graphicBbox = that._getGraphicBbox();
                    if (that._isPointInVisibleArea(visibleArea, graphicBbox)) {
                        coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
                    }
                    return coord
                },
                _getErrorBarSettings: function(errorBarOptions, animationEnabled) {
                    var settings = symbolPoint._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
                    settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
                    settings.rotateX = this.centerX;
                    settings.rotateY = this.centerY;
                    return settings
                },
                getCoords: function(min) {
                    return min ? this.getDefaultCoords() : {
                        x: this.x,
                        y: this.y
                    }
                }
            });
            exports.polarBarPoint = _extend({}, barPoint, {
                _translateErrorBars: exports.polarSymbolPoint._translateErrorBars,
                _getErrorBarSettings: exports.polarSymbolPoint._getErrorBarSettings,
                _moveLabelOnCanvas: barPoint._moveLabelOnCanvas,
                _getLabelCoords: piePoint._getLabelCoords,
                _getLabelConnector: piePoint._getLabelConnector,
                getBoundaryCoords: piePoint.getBoundaryCoords,
                getTooltipParams: piePoint.getTooltipParams,
                _getLabelPosition: piePoint._getLabelPosition,
                _translate: function(translator) {
                    var that = this,
                        maxRadius = translator.translate(CANVAS_POSITION_TOP, CANVAS_POSITION_END).radius;
                    that.radiusInner = translator.translate(that.argument, that.minValue).radius;
                    exports.polarSymbolPoint._translate.call(that, translator);
                    if (null === that.radiusInner) {
                        that.radiusInner = that.radius = maxRadius
                    } else {
                        if (null === that.radius) {
                            this.radius = this.value >= 0 ? maxRadius : 0
                        }
                    }
                    that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
                    that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
                    that.middleAngle = that.angle = -normalizeAngle(that.middleAngleCorrection - that.angle)
                },
                _checkVisibility: function(translator) {
                    return translator.checkVisibility(this.radius, this.radiusInner)
                },
                getMarkerCoords: function() {
                    return {
                        x: this.centerX,
                        y: this.centerY,
                        outerRadius: this.radiusOuter,
                        innerRadius: this.defaultRadius,
                        startAngle: this.middleAngle - this.interval / 2,
                        endAngle: this.middleAngle + this.interval / 2
                    }
                },
                _drawMarker: function(renderer, group, animationEnabled) {
                    var that = this,
                        styles = that._getStyle(),
                        coords = that.getMarkerCoords(),
                        innerRadius = coords.innerRadius,
                        outerRadius = coords.outerRadius,
                        start = that.translators.translate(that.argument, CANVAS_POSITION_DEFAULT),
                        x = coords.x,
                        y = coords.y;
                    if (animationEnabled) {
                        innerRadius = 0;
                        outerRadius = 0;
                        x = start.x;
                        y = start.y
                    }
                    that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
                        "chart-data-point": that
                    }).append(group)
                },
                _checkLabelPosition: function(label, coord) {
                    var that = this,
                        visibleArea = that._getVisibleArea(),
                        angleFunctions = vizUtils.getCosAndSin(that.middleAngle),
                        x = that.centerX + that.defaultRadius * angleFunctions.cos,
                        y = that.centerY - that.defaultRadius * angleFunctions.sin;
                    if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
                        coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
                    }
                    return coord
                },
                _addLabelAlignmentAndOffset: function(label, coord) {
                    return coord
                },
                correctCoordinates: function(correctOptions) {
                    this.middleAngleCorrection = correctOptions.offset;
                    this.interval = correctOptions.width
                },
                coordsIn: function(x, y) {
                    var val = this.translators.untranslate(x, y),
                        coords = this.getMarkerCoords(),
                        isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
                    return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************************!*\
      !*** ./Scripts/viz/series/points/range_bar_point.js ***!
      \******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                barPoint = __webpack_require__( /*! ./bar_point */ 194),
                rangeSymbolPointMethods = __webpack_require__( /*! ./range_symbol_point */ 338),
                _extend = $.extend;
            module.exports = _extend({}, barPoint, {
                deleteLabel: rangeSymbolPointMethods.deleteLabel,
                _getFormatObject: rangeSymbolPointMethods._getFormatObject,
                clearVisibility: function() {
                    var graphic = this.graphic;
                    if (graphic && graphic.attr("visibility")) {
                        graphic.attr({
                            visibility: null
                        })
                    }
                    this._topLabel.clearVisibility();
                    this._bottomLabel.clearVisibility()
                },
                setInvisibility: function() {
                    var graphic = this.graphic;
                    if (graphic && "hidden" !== graphic.attr("visibility")) {
                        graphic.attr({
                            visibility: "hidden"
                        })
                    }
                    this._topLabel.hide();
                    this._bottomLabel.hide()
                },
                getTooltipParams: function(location) {
                    var x, y, that = this,
                        edgeLocation = "edge" === location;
                    if (that._options.rotated) {
                        x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
                        y = that.y + that.height / 2
                    } else {
                        x = that.x + that.width / 2;
                        y = edgeLocation ? that.y : that.y + that.height / 2
                    }
                    return {
                        x: x,
                        y: y,
                        offset: 0
                    }
                },
                _translate: function(translator) {
                    var that = this,
                        barMethods = barPoint;
                    barMethods._translate.call(that, translator);
                    if (that._options.rotated) {
                        that.width = that.width || 1
                    } else {
                        that.height = that.height || 1
                    }
                },
                _updateData: rangeSymbolPointMethods._updateData,
                _getLabelPosition: rangeSymbolPointMethods._getLabelPosition,
                _getLabelMinFormatObject: rangeSymbolPointMethods._getLabelMinFormatObject,
                _updateLabelData: rangeSymbolPointMethods._updateLabelData,
                _updateLabelOptions: rangeSymbolPointMethods._updateLabelOptions,
                getCrosshairData: rangeSymbolPointMethods.getCrosshairData,
                _createLabel: rangeSymbolPointMethods._createLabel,
                _checkOverlay: rangeSymbolPointMethods._checkOverlay,
                _checkLabelsOverlay: rangeSymbolPointMethods._checkLabelsOverlay,
                _getOverlayCorrections: rangeSymbolPointMethods._getOverlayCorrections,
                _drawLabel: rangeSymbolPointMethods._drawLabel,
                _getLabelCoords: rangeSymbolPointMethods._getLabelCoords,
                _getGraphicBbox: function(location) {
                    var isTop = "top" === location,
                        bbox = barPoint._getGraphicBbox.call(this);
                    if (!this._options.rotated) {
                        bbox.y = isTop ? bbox.y : bbox.y + bbox.height;
                        bbox.height = 0
                    } else {
                        bbox.x = isTop ? bbox.x + bbox.width : bbox.x;
                        bbox.width = 0
                    }
                    return bbox
                },
                getLabel: rangeSymbolPointMethods.getLabel,
                getBoundingRect: $.noop
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/series/points/stock_point.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                candlestickPoint = __webpack_require__( /*! ./candlestick_point */ 335),
                _extend = $.extend,
                _isNumeric = $.isNumeric;
            module.exports = _extend({}, candlestickPoint, {
                _getPoints: function() {
                    var points, that = this,
                        createPoint = that._options.rotated ? function(x, y) {
                            return [y, x]
                        } : function(x, y) {
                            return [x, y]
                        },
                        openYExist = _isNumeric(that.openY),
                        closeYExist = _isNumeric(that.closeY),
                        x = that.x,
                        width = that.width;
                    points = [].concat(createPoint(x, that.highY));
                    openYExist && (points = points.concat(createPoint(x, that.openY)));
                    openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
                    openYExist && (points = points.concat(createPoint(x, that.openY)));
                    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                    closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
                    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                    points = points.concat(createPoint(x, that.lowY));
                    return points
                },
                _drawMarkerInGroup: function(group, attributes, renderer) {
                    this.graphic = renderer.path(this._getPoints(), "line").attr({
                        "stroke-linecap": "square"
                    }).attr(attributes).data({
                        "chart-data-point": this
                    }).sharp().append(group)
                },
                _getMinTrackerWidth: function() {
                    var width = 2 + this._styles.normal["stroke-width"];
                    return width + width % 2
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************!*\
      !*** ./Scripts/viz/series/range_series.js ***!
      \********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                _extend = $.extend,
                _isDefined = commonUtils.isDefined,
                _map = __webpack_require__( /*! ../core/utils */ 6).map,
                _noop = $.noop,
                rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 167),
                scatterSeries = __webpack_require__( /*! ./scatter_series */ 88).chart,
                barSeries = __webpack_require__( /*! ./bar_series */ 129).chart.bar,
                areaSeries = __webpack_require__( /*! ./area_series */ 166).chart.area;
            exports.chart = {};
            var baseRangeSeries = {
                _beginUpdateData: _noop,
                areErrorBarsVisible: _noop,
                _createErrorBarGroup: _noop,
                _checkData: function(data) {
                    return _isDefined(data.argument) && void 0 !== data.value && void 0 !== data.minValue
                },
                updateTemplateFieldNames: function() {
                    var that = this,
                        options = that._options,
                        valueFields = that.getValueFields(),
                        name = that.name;
                    options.rangeValue1Field = valueFields[0] + name;
                    options.rangeValue2Field = valueFields[1] + name;
                    options.tagField = that.getTagField() + name
                },
                _processRange: function(point, prevPoint) {
                    rangeCalculator.processTwoValues(this, point, prevPoint, "value", "minValue")
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "value", "minValue");
                    rangeCalculator.addRangeSeriesLabelPaddings(this);
                    return this._rangeData
                },
                _getPointData: function(data, options) {
                    return {
                        tag: data[options.tagField || "tag"],
                        minValue: data[options.rangeValue1Field || "val1"],
                        value: data[options.rangeValue2Field || "val2"],
                        argument: data[options.argumentField || "arg"]
                    }
                },
                _fusionPoints: function(fusionPoints, tick) {
                    var calcMedianValue = scatterSeries._calcMedianValue,
                        value = calcMedianValue.call(this, fusionPoints, "value"),
                        minValue = calcMedianValue.call(this, fusionPoints, "minValue");
                    if (null === value || null === minValue) {
                        value = minValue = null
                    }
                    return {
                        minValue: minValue,
                        value: value,
                        argument: tick,
                        tag: null
                    }
                },
                getValueFields: function() {
                    return [this._options.rangeValue1Field || "val1", this._options.rangeValue2Field || "val2"]
                }
            };
            exports.chart.rangebar = _extend({}, barSeries, baseRangeSeries);
            exports.chart.rangearea = _extend({}, areaSeries, {
                _drawPoint: function(options) {
                    var point = options.point;
                    if (point.isInVisibleArea()) {
                        point.clearVisibility();
                        point.draw(this._renderer, options.groups);
                        this._drawnPoints.push(point);
                        if (!point.visibleTopMarker) {
                            point.hideMarker("top")
                        }
                        if (!point.visibleBottomMarker) {
                            point.hideMarker("bottom")
                        }
                    } else {
                        point.setInvisibility()
                    }
                },
                _prepareSegment: function(points, rotated) {
                    var processedPoints = this._processSinglePointsAreaSegment(points, rotated),
                        processedMinPointsCoords = _map(processedPoints, function(pt) {
                            return pt.getCoords(true)
                        });
                    return {
                        line: processedPoints,
                        bottomLine: processedMinPointsCoords,
                        area: _map(processedPoints, function(pt) {
                            return pt.getCoords()
                        }).concat(processedMinPointsCoords.slice().reverse()),
                        singlePointSegment: processedPoints !== points
                    }
                },
                _getDefaultSegment: function(segment) {
                    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
                    defaultSegment.bottomLine = defaultSegment.line;
                    return defaultSegment
                },
                _removeElement: function(element) {
                    areaSeries._removeElement.call(this, element);
                    element.bottomLine && element.bottomLine.remove()
                },
                _drawElement: function(segment, group) {
                    var that = this,
                        drawnElement = areaSeries._drawElement.call(that, segment, group);
                    drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
                        "stroke-width": that._styles.normal.border["stroke-width"]
                    }).append(that._bordersGroup);
                    return drawnElement
                },
                _applyStyle: function(style) {
                    var that = this,
                        elementsGroup = that._elementsGroup,
                        bordersGroup = that._bordersGroup;
                    elementsGroup && elementsGroup.attr(style.elements);
                    bordersGroup && bordersGroup.attr(style.border);
                    $.each(that._graphics || [], function(_, graphic) {
                        graphic.line && graphic.line.attr({
                            "stroke-width": style.border["stroke-width"]
                        });
                        graphic.bottomLine && graphic.bottomLine.attr({
                            "stroke-width": style.border["stroke-width"]
                        })
                    })
                },
                _updateElement: function(element, segment, animate, animateParams, complete) {
                    areaSeries._updateElement.call(this, element, segment, animate, animateParams, complete);
                    var bottomLineParams = {
                            points: segment.bottomLine
                        },
                        bottomBorderElement = element.bottomLine;
                    if (bottomBorderElement) {
                        animate ? bottomBorderElement.animate(bottomLineParams, animateParams) : bottomBorderElement.attr(bottomLineParams)
                    }
                }
            }, baseRangeSeries)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/series/stacked_series.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                areaSeries = __webpack_require__( /*! ./area_series */ 166).chart,
                chartAreaSeries = areaSeries.area,
                barSeries = __webpack_require__( /*! ./bar_series */ 129),
                chartBarSeries = barSeries.chart.bar,
                lineSeries = __webpack_require__( /*! ./line_series */ 193).chart,
                rangeCalculator = __webpack_require__( /*! ./helpers/range_data_calculator */ 167),
                _extend = $.extend,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                objectUtils = __webpack_require__( /*! ../../core/utils/object */ 30),
                _noop = $.noop,
                baseStackedSeries = {
                    _processRange: _noop,
                    getErrorBarRangeCorrector: _noop,
                    _fillErrorBars: _noop,
                    _calculateErrorBars: _noop,
                    _processStackedRange: function() {
                        var prevPoint, that = this;
                        that._resetRangeData();
                        $.each(that.getAllPoints(), function(i, p) {
                            rangeCalculator.processRange(that, p, prevPoint);
                            prevPoint = p
                        })
                    },
                    _getRangeData: function() {
                        this._processStackedRange();
                        return chartAreaSeries._getRangeData.apply(this, arguments)
                    }
                },
                baseFullStackedSeries = _extend({}, baseStackedSeries, {
                    _getRangeData: function(zoomArgs, calcIntervalFunction) {
                        var that = this;
                        that._processStackedRange();
                        rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
                        rangeCalculator.addLabelPaddings(that);
                        rangeCalculator.processFullStackedRange(that);
                        rangeCalculator.calculateRangeMinValue(that, zoomArgs);
                        return that._rangeData
                    },
                    isFullStackedSeries: function() {
                        return true
                    }
                });
            exports.chart = {};
            exports.polar = {};
            exports.chart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {
                _getRangeData: function() {
                    this._processStackedRange();
                    return lineSeries.line._getRangeData.apply(this, arguments)
                }
            });
            exports.chart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {
                _getRangeData: exports.chart.stackedline._getRangeData
            });
            exports.chart.fullstackedline = _extend({}, lineSeries.line, baseFullStackedSeries, {
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    var that = this;
                    that._processStackedRange();
                    rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(that);
                    rangeCalculator.processFullStackedRange(that);
                    return that._rangeData
                }
            });
            exports.chart.fullstackedspline = _extend({}, lineSeries.spline, baseFullStackedSeries, {
                _getRangeData: exports.chart.fullstackedline._getRangeData
            });
            exports.chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {
                _getRangeData: function() {
                    this._processStackedRange();
                    return chartBarSeries._getRangeData.apply(this, arguments)
                }
            });
            exports.chart.fullstackedbar = _extend({}, chartBarSeries, baseFullStackedSeries, {
                _getRangeData: function() {
                    var rangeData = baseFullStackedSeries._getRangeData.apply(this, arguments);
                    rangeData.arg.stick = false;
                    return rangeData
                }
            });

            function clonePoint(point, value, minValue, position) {
                point = objectUtils.clone(point);
                point.value = value;
                point.minValue = minValue;
                point.translate();
                point.argument = point.argument + position;
                return point
            }

            function preparePointsForStackedAreaSegment(points) {
                var p, array, i = 0,
                    result = [],
                    len = points.length;
                while (i < len) {
                    p = points[i];
                    array = [p];
                    if (p.leftHole) {
                        array = [clonePoint(p, p.leftHole, p.minLeftHole, "left"), p]
                    }
                    if (p.rightHole) {
                        array.push(clonePoint(p, p.rightHole, p.minRightHole, "right"))
                    }
                    result.push(array);
                    i++
                }
                return [].concat.apply([], result)
            }
            exports.chart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {
                _prepareSegment: function(points, rotated) {
                    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points, this._prevSeries), rotated)
                },
                _appendInGroup: function() {
                    this._group.append(this._extGroups.seriesGroup).toBackground()
                }
            });

            function getPointsByArgFromPrevSeries(prevSeries, argument) {
                var result;
                while (!result && prevSeries) {
                    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];
                    prevSeries = prevSeries._prevSeries
                }
                return result
            }
            exports.chart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {
                _prepareSegment: function(points, rotated) {
                    var areaSegment, that = this;
                    points = preparePointsForStackedAreaSegment(points, that._prevSeries);
                    if (!this._prevSeries || 1 === points.length) {
                        areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated)
                    } else {
                        var fwPoints = lineSeries.spline._calculateBezierPoints(points, rotated),
                            bwPoints = vizUtils.map(points, function(p) {
                                var point = p.getCoords(true);
                                point.argument = p.argument;
                                return point
                            }),
                            prevSeriesFwPoints = [],
                            pointByArg = {},
                            i = 0,
                            len = that._prevSeries._segments.length;
                        while (i < len) {
                            prevSeriesFwPoints = prevSeriesFwPoints.concat(that._prevSeries._segments[i].line);
                            i++
                        }
                        $.each(prevSeriesFwPoints, function(_, p) {
                            if (null !== p.argument) {
                                var argument = p.argument.valueOf();
                                if (!pointByArg[argument]) {
                                    pointByArg[argument] = [p]
                                } else {
                                    pointByArg[argument].push(p)
                                }
                            }
                        });
                        that._prevSeries._segmentByArg = pointByArg;
                        bwPoints = lineSeries.spline._calculateBezierPoints(bwPoints, rotated);
                        $.each(bwPoints, function(i, p) {
                            var prevSeriesPoints, argument = p.argument.valueOf();
                            if (i % 3 === 0) {
                                prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
                                if (prevSeriesPoints) {
                                    bwPoints[i - 1] && prevSeriesPoints[0] && (bwPoints[i - 1] = prevSeriesPoints[0]);
                                    bwPoints[i + 1] && (bwPoints[i + 1] = prevSeriesPoints[2] || p)
                                }
                            }
                        });
                        areaSegment = {
                            line: fwPoints,
                            area: fwPoints.concat(bwPoints.reverse())
                        };
                        that._areaPointsToSplineAreaPoints(areaSegment.area)
                    }
                    return areaSegment
                }
            });
            exports.chart.fullstackedarea = _extend({}, chartAreaSeries, baseFullStackedSeries, {
                _prepareSegment: exports.chart.stackedarea._prepareSegment,
                _appendInGroup: exports.chart.stackedarea._appendInGroup
            });
            exports.chart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseFullStackedSeries, {
                _prepareSegment: exports.chart.stackedsplinearea._prepareSegment
            });
            exports.polar.stackedbar = _extend({}, barSeries.polar.bar, baseStackedSeries, {
                _getRangeData: function() {
                    this._processStackedRange();
                    return barSeries.polar.bar._getRangeData.apply(this, arguments)
                }
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************!*\
      !*** ./Scripts/viz/sparkline.js ***!
      \**********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./sparklines/sparkline */ 553)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/sparklines/bullet.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                BaseSparkline = __webpack_require__( /*! ./base_sparkline */ 339),
                TARGET_MIN_Y = .02,
                TARGET_MAX_Y = .98,
                BAR_VALUE_MIN_Y = .1,
                BAR_VALUE_MAX_Y = .9,
                DEFAULT_CANVAS_WIDTH = 300,
                DEFAULT_CANVAS_HEIGHT = 30,
                DEFAULT_HORIZONTAL_MARGIN = 1,
                DEFAULT_VERTICAL_MARGIN = 2,
                _Number = Number,
                _isFinite = isFinite;
            var dxBullet = BaseSparkline.inherit({
                _rootClassPrefix: "dxb",
                _rootClass: "dxb-bullet",
                _widgetType: "bullet",
                _defaultSize: {
                    width: DEFAULT_CANVAS_WIDTH,
                    height: DEFAULT_CANVAS_HEIGHT,
                    left: DEFAULT_HORIZONTAL_MARGIN,
                    right: DEFAULT_HORIZONTAL_MARGIN,
                    top: DEFAULT_VERTICAL_MARGIN,
                    bottom: DEFAULT_VERTICAL_MARGIN
                },
                _disposeWidgetElements: function() {
                    delete this._zeroLevelPath;
                    delete this._targetPath;
                    delete this._barValuePath
                },
                _cleanWidgetElements: function() {
                    this._zeroLevelPath.remove();
                    this._targetPath.remove();
                    this._barValuePath.remove()
                },
                _drawWidgetElements: function() {
                    this._drawBullet();
                    this._drawn()
                },
                _createHtmlElements: function() {
                    var renderer = this._renderer;
                    this._zeroLevelPath = renderer.path(void 0, "line").attr({
                        "class": "dxb-zero-level",
                        "stroke-linecap": "square"
                    });
                    this._targetPath = renderer.path(void 0, "line").attr({
                        "class": "dxb-target",
                        "stroke-linecap": "square"
                    });
                    this._barValuePath = renderer.path(void 0, "line").attr({
                        "class": "dxb-bar-value",
                        "stroke-linecap": "square"
                    })
                },
                _prepareOptions: function() {
                    var options, startScaleValue, endScaleValue, level, value, target, isValueUndefined, isTargetUndefined, that = this;
                    that._allOptions = options = that.callBase();
                    isValueUndefined = void 0 === that._allOptions.value;
                    isTargetUndefined = void 0 === that._allOptions.target;
                    that._tooltipEnabled = !(isValueUndefined && isTargetUndefined);
                    if (isValueUndefined) {
                        that._allOptions.value = 0
                    }
                    if (isTargetUndefined) {
                        that._allOptions.target = 0
                    }
                    options.value = value = _Number(options.value);
                    options.target = target = _Number(options.target);
                    if (void 0 === that._allOptions.startScaleValue) {
                        that._allOptions.startScaleValue = target < value ? target : value;
                        that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0
                    }
                    if (void 0 === that._allOptions.endScaleValue) {
                        that._allOptions.endScaleValue = target > value ? target : value
                    }
                    options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
                    options.endScaleValue = endScaleValue = _Number(options.endScaleValue);
                    if (endScaleValue < startScaleValue) {
                        level = endScaleValue;
                        that._allOptions.endScaleValue = startScaleValue;
                        that._allOptions.startScaleValue = level;
                        that._allOptions.inverted = true
                    }
                },
                _updateRange: function() {
                    var that = this,
                        options = that._allOptions;
                    that._ranges = {
                        arg: {
                            invert: options.inverted,
                            min: options.startScaleValue,
                            max: options.endScaleValue,
                            axisType: "continuous",
                            dataType: "numeric"
                        },
                        val: {
                            min: 0,
                            max: 1,
                            axisType: "continuous",
                            dataType: "numeric"
                        }
                    }
                },
                _drawBullet: function() {
                    var that = this,
                        options = that._allOptions,
                        isValidBounds = options.startScaleValue !== options.endScaleValue,
                        isValidMin = _isFinite(options.startScaleValue),
                        isValidMax = _isFinite(options.endScaleValue),
                        isValidValue = _isFinite(options.value),
                        isValidTarget = _isFinite(options.target);
                    if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
                        this._drawBarValue();
                        this._drawTarget();
                        this._drawZeroLevel()
                    }
                },
                _getTargetParams: function() {
                    var that = this,
                        options = that._allOptions,
                        translatorY = that._translatorY,
                        x = that._translatorX.translate(options.target);
                    return {
                        points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                        stroke: options.targetColor,
                        "stroke-width": options.targetWidth
                    }
                },
                _getBarValueParams: function() {
                    var x1, x2, that = this,
                        options = that._allOptions,
                        translatorX = that._translatorX,
                        translatorY = that._translatorY,
                        startLevel = options.startScaleValue,
                        endLevel = options.endScaleValue,
                        value = options.value,
                        y2 = translatorY.translate(BAR_VALUE_MIN_Y),
                        y1 = translatorY.translate(BAR_VALUE_MAX_Y);
                    if (value > 0) {
                        x1 = startLevel <= 0 ? 0 : startLevel;
                        x2 = value >= endLevel ? endLevel : value < x1 ? x1 : value
                    } else {
                        x1 = endLevel >= 0 ? 0 : endLevel;
                        x2 = value < startLevel ? startLevel : value > x1 ? x1 : value
                    }
                    x1 = translatorX.translate(x1);
                    x2 = translatorX.translate(x2);
                    return {
                        points: [x1, y1, x2, y1, x2, y2, x1, y2],
                        fill: options.color
                    }
                },
                _getZeroLevelParams: function() {
                    var that = this,
                        translatorY = that._translatorY,
                        x = that._translatorX.translate(0);
                    return {
                        points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                        stroke: that._allOptions.targetColor,
                        "stroke-width": 1
                    }
                },
                _drawZeroLevel: function() {
                    var that = this,
                        options = that._allOptions;
                    if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel) {
                        return
                    }
                    that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root)
                },
                _drawTarget: function() {
                    var that = this,
                        options = that._allOptions,
                        target = options.target;
                    if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget) {
                        return
                    }
                    that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root)
                },
                _drawBarValue: function() {
                    this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root)
                },
                _getTooltipCoords: function() {
                    var canvas = this._canvas,
                        rootOffset = this._renderer.getRootOffset(),
                        bbox = this._barValuePath.getBBox();
                    return {
                        x: bbox.x + bbox.width / 2 + rootOffset.left,
                        y: canvas.height / 2 + rootOffset.top
                    }
                },
                _getTooltipData: function() {
                    var that = this,
                        tooltip = that._tooltip,
                        options = that._allOptions,
                        value = options.value,
                        target = options.target,
                        valueText = tooltip.formatValue(value),
                        targetText = tooltip.formatValue(target);
                    return {
                        originalValue: value,
                        originalTarget: target,
                        value: valueText,
                        target: targetText,
                        valueText: ["Actual Value:", valueText, "Target Value:", targetText]
                    }
                },
                _isTooltipEnabled: function() {
                    return this._tooltipEnabled
                }
            });
            $.each(["color", "targetColor", "targetWidth", "showTarget", "showZeroLevel", "value", "target", "startScaleValue", "endScaleValue"], function(_, name) {
                dxBullet.prototype._optionChangesMap[name] = "OPTIONS"
            });
            __webpack_require__( /*! ../../core/component_registrator */ 3)("dxBullet", dxBullet);
            module.exports = dxBullet
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/viz/sparklines/sparkline.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BaseSparkline = __webpack_require__( /*! ./base_sparkline */ 339),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                dataValidatorModule = __webpack_require__( /*! ../components/data_validator */ 233),
                seriesModule = __webpack_require__( /*! ../series/base_series */ 236),
                MIN_BAR_WIDTH = 1,
                MAX_BAR_WIDTH = 50,
                DEFAULT_BAR_INTERVAL = 4,
                DEFAULT_CANVAS_WIDTH = 250,
                DEFAULT_CANVAS_HEIGHT = 30,
                DEFAULT_HORIZONTAL_MARGIN = 5,
                DEFAULT_VERTICAL_MARGIN = 3,
                ALLOWED_TYPES = {
                    line: true,
                    spline: true,
                    stepline: true,
                    area: true,
                    steparea: true,
                    splinearea: true,
                    bar: true,
                    winloss: true
                },
                _math = Math,
                _abs = _math.abs,
                _round = _math.round,
                _max = _math.max,
                _min = _math.min,
                _isFinite = isFinite,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _map = vizUtils.map,
                _normalizeEnum = vizUtils.normalizeEnum,
                _isDefined = commonUtils.isDefined,
                _Number = Number,
                _String = String;
            var dxSparkline = BaseSparkline.inherit({
                _rootClassPrefix: "dxsl",
                _rootClass: "dxsl-sparkline",
                _widgetType: "sparkline",
                _defaultSize: {
                    width: DEFAULT_CANVAS_WIDTH,
                    height: DEFAULT_CANVAS_HEIGHT,
                    left: DEFAULT_HORIZONTAL_MARGIN,
                    right: DEFAULT_HORIZONTAL_MARGIN,
                    top: DEFAULT_VERTICAL_MARGIN,
                    bottom: DEFAULT_VERTICAL_MARGIN
                },
                _initCore: function() {
                    this.callBase();
                    this._createSeries()
                },
                _initialChanges: ["DATA_SOURCE"],
                _dataSourceChangedHandler: function() {
                    this._requestChange(["UPDATE"])
                },
                _updateWidgetElements: function() {
                    this._updateSeries();
                    this.callBase()
                },
                _disposeWidgetElements: function() {
                    var that = this;
                    that._series && that._series.dispose();
                    that._series = that._seriesGroup = that._seriesLabelGroup = null
                },
                _cleanWidgetElements: function() {
                    this._seriesGroup.remove();
                    this._seriesLabelGroup.remove();
                    this._seriesGroup.clear();
                    this._seriesLabelGroup.clear()
                },
                _drawWidgetElements: function() {
                    if (this._dataSource.isLoaded()) {
                        this._drawSeries();
                        this._drawn()
                    }
                },
                _prepareOptions: function() {
                    var that = this;
                    that._allOptions = that.callBase();
                    that._allOptions.type = _normalizeEnum(that._allOptions.type);
                    if (!ALLOWED_TYPES[that._allOptions.type]) {
                        that._allOptions.type = "line"
                    }
                },
                _createHtmlElements: function() {
                    this._seriesGroup = this._renderer.g().attr({
                        "class": "dxsl-series"
                    });
                    this._seriesLabelGroup = this._renderer.g().attr({
                        "class": "dxsl-series-labels"
                    })
                },
                _createSeries: function() {
                    this._series = new seriesModule.Series({
                        renderer: this._renderer,
                        seriesGroup: this._seriesGroup,
                        labelsGroup: this._seriesLabelGroup
                    }, {
                        widgetType: "chart",
                        type: "line"
                    })
                },
                getSeriesOptions: function() {
                    return this._series.getOptions()
                },
                _updateSeries: function() {
                    var groupsData, seriesOptions, that = this,
                        singleSeries = that._series;
                    that._prepareDataSource();
                    seriesOptions = that._prepareSeriesOptions();
                    singleSeries.updateOptions(seriesOptions);
                    groupsData = {
                        groups: [{
                            series: [singleSeries]
                        }]
                    };
                    groupsData.argumentOptions = {
                        type: "bar" === seriesOptions.type ? "discrete" : void 0
                    };
                    that._simpleDataSource = dataValidatorModule.validateData(that._simpleDataSource, groupsData, that._incidentOccurred, {
                        checkTypeForAllData: false,
                        convertToAxisDataType: true,
                        sortingMethod: true
                    })[singleSeries.getArgumentField()];
                    singleSeries.updateData(that._simpleDataSource);
                    that._groupsDataCategories = groupsData.categories
                },
                _optionChangesMap: {
                    dataSource: "DATA_SOURCE"
                },
                _optionChangesOrder: ["DATA_SOURCE"],
                _change_DATA_SOURCE: function() {
                    this._updateDataSource()
                },
                _parseNumericDataSource: function(data, argField, valField) {
                    var ignoreEmptyPoints = this.option("ignoreEmptyPoints");
                    return _map(data, function(dataItem, index) {
                        var isDataNumber, value, item = null;
                        if (void 0 !== dataItem) {
                            item = {};
                            isDataNumber = _isFinite(dataItem);
                            item[argField] = isDataNumber ? _String(index) : dataItem[argField];
                            value = isDataNumber ? dataItem : dataItem[valField];
                            item[valField] = null === value ? ignoreEmptyPoints ? void 0 : value : _Number(value);
                            item = void 0 !== item[argField] && void 0 !== item[valField] ? item : null
                        }
                        return item
                    })
                },
                _parseWinlossDataSource: function(data, argField, valField) {
                    var lowBarValue = -1,
                        zeroBarValue = 0,
                        highBarValue = 1,
                        delta = 1e-4,
                        target = this._allOptions.winlossThreshold;
                    return _map(data, function(dataItem) {
                        var item = {};
                        item[argField] = dataItem[argField];
                        if (_abs(dataItem[valField] - target) < delta) {
                            item[valField] = zeroBarValue
                        } else {
                            if (dataItem[valField] > target) {
                                item[valField] = highBarValue
                            } else {
                                item[valField] = lowBarValue
                            }
                        }
                        return item
                    })
                },
                _prepareDataSource: function() {
                    var that = this,
                        options = that._allOptions,
                        argField = options.argumentField,
                        valField = options.valueField,
                        dataSource = that._dataSource.items() || [],
                        data = that._parseNumericDataSource(dataSource, argField, valField);
                    if ("winloss" === options.type) {
                        that._winlossDataSource = data;
                        that._simpleDataSource = that._parseWinlossDataSource(data, argField, valField)
                    } else {
                        that._simpleDataSource = data
                    }
                },
                _prepareSeriesOptions: function() {
                    var that = this,
                        options = that._allOptions,
                        type = "winloss" === options.type ? "bar" : options.type;
                    return {
                        visible: true,
                        argumentField: options.argumentField,
                        valueField: options.valueField,
                        color: options.lineColor,
                        width: options.lineWidth,
                        widgetType: "chart",
                        type: type,
                        opacity: -1 !== type.indexOf("area") ? that._allOptions.areaOpacity : void 0,
                        customizePoint: that._getCustomizeFunction(),
                        point: {
                            size: options.pointSize,
                            symbol: options.pointSymbol,
                            border: {
                                visible: true,
                                width: 2
                            },
                            color: options.pointColor,
                            visible: false,
                            hoverStyle: {
                                border: {}
                            },
                            selectionStyle: {
                                border: {}
                            }
                        },
                        border: {
                            color: options.lineColor,
                            width: options.lineWidth,
                            visible: "bar" !== type
                        }
                    }
                },
                _createBarCustomizeFunction: function(pointIndexes) {
                    var that = this,
                        options = that._allOptions,
                        winlossData = that._winlossDataSource;
                    return function() {
                        var color, index = this.index,
                            isWinloss = "winloss" === options.type,
                            target = isWinloss ? options.winlossThreshold : 0,
                            value = isWinloss ? winlossData[index][options.valueField] : this.value,
                            positiveColor = isWinloss ? options.winColor : options.barPositiveColor,
                            negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;
                        if (value >= target) {
                            color = positiveColor
                        } else {
                            color = negativeColor
                        }
                        if (index === pointIndexes.first || index === pointIndexes.last) {
                            color = options.firstLastColor
                        }
                        if (index === pointIndexes.min) {
                            color = options.minColor
                        }
                        if (index === pointIndexes.max) {
                            color = options.maxColor
                        }
                        return {
                            color: color
                        }
                    }
                },
                _createLineCustomizeFunction: function(pointIndexes) {
                    var that = this,
                        options = that._allOptions;
                    return function() {
                        var color, index = this.index;
                        if (index === pointIndexes.first || index === pointIndexes.last) {
                            color = options.firstLastColor
                        }
                        if (index === pointIndexes.min) {
                            color = options.minColor
                        }
                        if (index === pointIndexes.max) {
                            color = options.maxColor
                        }
                        return color ? {
                            visible: true,
                            border: {
                                color: color
                            }
                        } : {}
                    }
                },
                _getCustomizeFunction: function() {
                    var customizeFunction, that = this,
                        options = that._allOptions,
                        dataSource = that._winlossDataSource || that._simpleDataSource,
                        drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);
                    if ("winloss" === options.type || "bar" === options.type) {
                        customizeFunction = that._createBarCustomizeFunction(drawnPointIndexes)
                    } else {
                        customizeFunction = that._createLineCustomizeFunction(drawnPointIndexes)
                    }
                    return customizeFunction
                },
                _getExtremumPointsIndexes: function(data) {
                    var that = this,
                        options = that._allOptions,
                        lastIndex = data.length - 1,
                        indexes = {};
                    that._minMaxIndexes = that._findMinMax(data);
                    if (options.showFirstLast) {
                        indexes.first = 0;
                        indexes.last = lastIndex
                    }
                    if (options.showMinMax) {
                        indexes.min = that._minMaxIndexes.minIndex;
                        indexes.max = that._minMaxIndexes.maxIndex
                    }
                    return indexes
                },
                _findMinMax: function(data) {
                    var value, i, that = this,
                        valField = that._allOptions.valueField,
                        firstItem = data[0] || {},
                        firstValue = firstItem[valField] || 0,
                        min = firstValue,
                        max = firstValue,
                        minIndex = 0,
                        maxIndex = 0,
                        dataLength = data.length;
                    for (i = 1; i < dataLength; i++) {
                        value = data[i][valField];
                        if (value < min) {
                            min = value;
                            minIndex = i
                        }
                        if (value > max) {
                            max = value;
                            maxIndex = i
                        }
                    }
                    return {
                        minIndex: minIndex,
                        maxIndex: maxIndex
                    }
                },
                _updateRange: function() {
                    var valCoef, argCoef, that = this,
                        series = that._series,
                        type = series.type,
                        isBarType = "bar" === type,
                        isWinlossType = "winloss" === type,
                        DEFAULT_VALUE_RANGE_MARGIN = .15,
                        DEFAULT_ARGUMENT_RANGE_MARGIN = .1,
                        WINLOSS_MAX_RANGE = 1,
                        WINLOSS_MIN_RANGE = -1,
                        rangeData = series.getRangeData(),
                        minValue = that._allOptions.minValue,
                        hasMinY = _isDefined(minValue) && _isFinite(minValue),
                        maxValue = that._allOptions.maxValue,
                        hasMaxY = _isDefined(maxValue) && _isFinite(maxValue);
                    valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;
                    if (isBarType || isWinlossType || "area" === type) {
                        if (0 !== rangeData.val.min) {
                            rangeData.val.min -= valCoef
                        }
                        if (0 !== rangeData.val.max) {
                            rangeData.val.max += valCoef
                        }
                    } else {
                        rangeData.val.min -= valCoef;
                        rangeData.val.max += valCoef
                    }
                    if (hasMinY || hasMaxY) {
                        if (hasMinY && hasMaxY) {
                            rangeData.val.minVisible = _min(minValue, maxValue);
                            rangeData.val.maxVisible = _max(minValue, maxValue)
                        } else {
                            rangeData.val.minVisible = hasMinY ? _Number(minValue) : void 0;
                            rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : void 0
                        }
                        if (isWinlossType) {
                            rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : void 0;
                            rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : void 0
                        }
                    }
                    if (series.getPoints().length > 1) {
                        if (isBarType) {
                            argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
                            rangeData.arg.min = rangeData.arg.min - argCoef;
                            rangeData.arg.max = rangeData.arg.max + argCoef
                        } else {
                            rangeData.arg.stick = true
                        }
                    }
                    rangeData.arg.categories = that._groupsDataCategories;
                    that._ranges = rangeData
                },
                _getBarWidth: function(pointsCount) {
                    var that = this,
                        canvas = that._canvas,
                        intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL,
                        rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth,
                        width = _round(rangeWidth / pointsCount);
                    if (width < MIN_BAR_WIDTH) {
                        width = MIN_BAR_WIDTH
                    }
                    if (width > MAX_BAR_WIDTH) {
                        width = MAX_BAR_WIDTH
                    }
                    return width
                },
                _correctPoints: function() {
                    var barWidth, i, that = this,
                        seriesType = that._allOptions.type,
                        seriesPoints = that._series.getPoints(),
                        pointsLength = seriesPoints.length;
                    if ("bar" === seriesType || "winloss" === seriesType) {
                        barWidth = that._getBarWidth(pointsLength);
                        for (i = 0; i < pointsLength; i++) {
                            seriesPoints[i].correctCoordinates({
                                width: barWidth,
                                offset: 0
                            })
                        }
                    }
                },
                _drawSeries: function() {
                    var that = this;
                    if (that._simpleDataSource.length > 0) {
                        that._correctPoints();
                        that._series.draw({
                            x: that._translatorX,
                            y: that._translatorY
                        });
                        that._seriesGroup.append(that._renderer.root)
                    }
                },
                _isTooltipEnabled: function() {
                    return !!this._simpleDataSource.length
                },
                _getTooltipData: function() {
                    var that = this,
                        options = that._allOptions,
                        dataSource = that._winlossDataSource || that._simpleDataSource,
                        tooltip = that._tooltip;
                    if (0 === dataSource.length) {
                        return {}
                    }
                    var minMax = that._minMaxIndexes,
                        valueField = options.valueField,
                        first = dataSource[0][valueField],
                        last = dataSource[dataSource.length - 1][valueField],
                        min = dataSource[minMax.minIndex][valueField],
                        max = dataSource[minMax.maxIndex][valueField],
                        formattedFirst = tooltip.formatValue(first),
                        formattedLast = tooltip.formatValue(last),
                        formattedMin = tooltip.formatValue(min),
                        formattedMax = tooltip.formatValue(max),
                        customizeObject = {
                            firstValue: formattedFirst,
                            lastValue: formattedLast,
                            minValue: formattedMin,
                            maxValue: formattedMax,
                            originalFirstValue: first,
                            originalLastValue: last,
                            originalMinValue: min,
                            originalMaxValue: max,
                            valueText: ["Start:", formattedFirst, "End:", formattedLast, "Min:", formattedMin, "Max:", formattedMax]
                        };
                    if ("winloss" === options.type) {
                        customizeObject.originalThresholdValue = options.winlossThreshold;
                        customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold)
                    }
                    return customizeObject
                }
            });
            _map(["lineColor", "lineWidth", "areaOpacity", "minColor", "maxColor", "barPositiveColor", "barNegativeColor", "winColor", "lessColor", "firstLastColor", "pointSymbol", "pointColor", "pointSize", "type", "argumentField", "valueField", "winlossThreshold", "showFirstLast", "showMinMax", "ignoreEmptyPoints", "minValue", "maxValue"], function(name) {
                dxSparkline.prototype._optionChangesMap[name] = "OPTIONS"
            });
            __webpack_require__( /*! ../../core/component_registrator */ 3)("dxSparkline", dxSparkline);
            module.exports = dxSparkline;
            dxSparkline.addPlugin(__webpack_require__( /*! ../core/data_source */ 161).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/translators/category_translator.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                isDefined = commonUtils.isDefined,
                round = Math.round;
            module.exports = {
                translate: function(category, directionOffset) {
                    var stickDelta, that = this,
                        canvasOptions = that._canvasOptions,
                        categoryIndex = that._categoriesToPoints[category],
                        specialValue = that.translateSpecialCase(category),
                        startPointIndex = canvasOptions.startPointIndex || 0,
                        stickInterval = that._businessRange.stick ? 0 : .5;
                    if (isDefined(specialValue)) {
                        return specialValue
                    }
                    if (!categoryIndex && 0 !== categoryIndex) {
                        return null
                    }
                    directionOffset = directionOffset || 0;
                    stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;
                    return round(that._calculateProjection(canvasOptions.interval * stickDelta))
                },
                untranslate: function(pos, directionOffset, enableOutOfCanvas) {
                    var that = this,
                        canvasOptions = that._canvasOptions,
                        startPoint = canvasOptions.startPoint,
                        categories = that.visibleCategories || that._categories,
                        categoriesLength = categories.length,
                        result = 0,
                        stickInterval = that._businessRange.stick ? .5 : 0;
                    if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint)) {
                        return null
                    }
                    directionOffset = directionOffset || 0;
                    result = round((pos - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * directionOffset);
                    if (categoriesLength === result) {
                        result--
                    }
                    if (-1 === result) {
                        result = 0
                    }
                    if (canvasOptions.invert) {
                        result = categoriesLength - result - 1
                    }
                    return categories[result]
                },
                getInterval: function() {
                    return this._canvasOptions.interval
                },
                zoom: function(translate, scale) {
                    var endCategoryIndex, newVisibleCategories, newInterval, that = this,
                        canvasOptions = that._canvasOptions,
                        stick = that._businessRange.stick,
                        invert = canvasOptions.invert,
                        interval = canvasOptions.interval * scale,
                        translateCategories = translate / interval,
                        startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5),
                        categoriesLength = parseInt(canvasOptions.canvasLength / interval + (stick ? 1 : 0)) || 1,
                        categories = that._categories;
                    if (invert) {
                        startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + (that.visibleCategories || []).length - translateCategories + .5) - categoriesLength
                    }
                    if (startCategoryIndex < 0) {
                        startCategoryIndex = 0
                    }
                    endCategoryIndex = startCategoryIndex + categoriesLength;
                    if (endCategoryIndex > categories.length) {
                        endCategoryIndex = categories.length;
                        startCategoryIndex = endCategoryIndex - categoriesLength;
                        if (startCategoryIndex < 0) {
                            startCategoryIndex = 0
                        }
                    }
                    newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
                    newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
                    scale = newInterval / canvasOptions.interval;
                    translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
                    return {
                        min: newVisibleCategories[0],
                        max: newVisibleCategories[newVisibleCategories.length - 1],
                        translate: translate,
                        scale: scale
                    }
                },
                getMinScale: function(zoom) {
                    var that = this,
                        canvasOptions = that._canvasOptions,
                        categoriesLength = (that.visibleCategories || that._categories).length;
                    categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);
                    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)
                },
                getScale: function(min, max) {
                    var that = this,
                        canvasOptions = that._canvasOptions,
                        visibleArea = that.getCanvasVisibleArea(),
                        stickOffset = !that._businessRange.stick && 1,
                        minPoint = that.translate(min, -stickOffset),
                        maxPoint = that.translate(max, +stickOffset);
                    if (!isDefined(minPoint)) {
                        minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min
                    }
                    if (!isDefined(maxPoint)) {
                        maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max
                    }
                    return that.canvasLength / Math.abs(maxPoint - minPoint)
                },
                isValid: function(value) {
                    return this._categoriesToPoints[value] >= 0
                },
                parse: function(value) {
                    return value
                },
                to: function(value, direction) {
                    var canvasOptions = this._canvasOptions,
                        businessRange = this._businessRange,
                        categoryIndex = this._categoriesToPoints[value],
                        startPointIndex = canvasOptions.startPointIndex || 0,
                        stickInterval = businessRange.stick ? 0 : .5,
                        stickDelta = categoryIndex + stickInterval - startPointIndex + (businessRange.invert ? -1 : 1) * direction * .5;
                    return round(this._calculateProjection(canvasOptions.interval * stickDelta))
                },
                from: function(position, direction) {
                    var canvasOptions = this._canvasOptions,
                        businessRange = this._businessRange,
                        startPoint = canvasOptions.startPoint,
                        categories = this._categories,
                        categoriesLength = categories.length,
                        stickInterval = businessRange.stick ? .5 : 0,
                        result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);
                    if (categoriesLength === result) {
                        result--
                    }
                    if (-1 === result) {
                        result = 0
                    }
                    if (canvasOptions.invert) {
                        result = categoriesLength - result - 1
                    }
                    return categories[result]
                },
                _add: function(value, diff, coeff) {
                    return NaN
                },
                isValueProlonged: true
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/translators/datetime_translator.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var numericTranslator = __webpack_require__( /*! ./numeric_translator */ 237);
            module.exports = {
                translate: numericTranslator.translate,
                untranslate: function() {
                    var result = numericTranslator.untranslate.apply(this, arguments);
                    return null === result ? result : new Date(result)
                },
                _getValue: numericTranslator._getValue,
                getInterval: numericTranslator.getInterval,
                zoom: numericTranslator.zoom,
                getMinScale: numericTranslator.getMinScale,
                getScale: numericTranslator.getScale,
                isValid: function(value) {
                    return numericTranslator.isValid.call(this, new Date(value))
                },
                parse: function(value) {
                    return new Date(value)
                },
                to: numericTranslator.to,
                from: function(position) {
                    return new Date(numericTranslator.from.call(this, position))
                },
                _add: __webpack_require__( /*! ../../core/utils/date */ 12).addDateInterval,
                isValueProlonged: numericTranslator.isValueProlonged
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!********************************************************!*\
      !*** ./Scripts/viz/translators/interval_translator.js ***!
      \********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var adjustValue = __webpack_require__( /*! ../core/utils */ 6).adjustValue,
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                isNumber = commonUtils.isNumber,
                isDefined = commonUtils.isDefined,
                dateUtils = __webpack_require__( /*! ../../core/utils/date */ 12),
                correctDate = dateUtils.correctDateWithUnitBeginning,
                addInterval = dateUtils.addInterval,
                dateToMilliseconds = dateUtils.dateToMilliseconds,
                floor = Math.floor;
            module.exports = {
                _intervalize: function(value, interval) {
                    if (!isDefined(value)) {
                        return
                    }
                    if ("datetime" === this._businessRange.dataType) {
                        if (isNumber(value)) {
                            value = new Date(value)
                        } else {
                            value = new Date(value.getTime())
                        }
                        correctDate(value, interval)
                    } else {
                        value = adjustValue(floor(value / interval) * interval)
                    }
                    return value
                },
                translate: function(bp, direction, interval) {
                    var that = this,
                        specialValue = that.translateSpecialCase(bp);
                    if (isDefined(specialValue)) {
                        return specialValue
                    }
                    interval = interval || that._options.interval;
                    if (!that.isValid(bp, interval)) {
                        return null
                    }
                    return that.to(bp, direction, interval)
                },
                untranslate: function(pos, direction, enableOutOfCanvas) {
                    var canvasOptions = this._canvasOptions,
                        startPoint = canvasOptions.startPoint;
                    if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint) || !isDefined(canvasOptions.rangeMin) || !isDefined(canvasOptions.rangeMax)) {
                        return null
                    }
                    return this.from(pos, direction)
                },
                getInterval: function() {
                    return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
                },
                _getValue: function() {},
                zoom: function() {},
                getMinScale: function() {},
                getScale: function() {},
                isValid: function(value, interval) {
                    var that = this,
                        co = that._canvasOptions,
                        rangeMin = co.rangeMin,
                        rangeMax = co.rangeMax;
                    interval = interval || that._options.interval;
                    if (null === value || isNaN(value)) {
                        return false
                    }
                    value = "datetime" === that._businessRange.dataType && isNumber(value) ? new Date(value) : value;
                    if (interval !== that._options.interval) {
                        rangeMin = that._intervalize(rangeMin, interval);
                        rangeMax = that._intervalize(rangeMax, interval)
                    }
                    if (value.valueOf() < rangeMin || value.valueOf() >= addInterval(rangeMax, interval)) {
                        return false
                    }
                    return true
                },
                parse: function(value) {
                    return "datetime" === this._businessRange.dataType ? isNumber(value) ? new Date(value) : value : Number(value)
                },
                to: function(bp, direction, interval) {
                    var that = this;
                    interval = interval || that._options.interval;
                    var v1 = that._intervalize(bp, interval),
                        v2 = addInterval(v1, interval),
                        res = that._to(v1),
                        p2 = that._to(v2);
                    if (!direction) {
                        res = floor((res + p2) / 2)
                    } else {
                        if (direction > 0) {
                            res = p2
                        }
                    }
                    return res
                },
                _to: function(value) {
                    var co = this._canvasOptions,
                        rMin = co.rangeMinVisible,
                        rMax = co.rangeMaxVisible,
                        offset = value - rMin;
                    if (value < rMin) {
                        offset = 0
                    } else {
                        if (value > rMax) {
                            offset = addInterval(rMax, this._options.interval) - rMin
                        }
                    }
                    return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange))
                },
                from: function(position, direction) {
                    var value, that = this,
                        origInterval = that._options.interval,
                        interval = origInterval,
                        co = that._canvasOptions,
                        rMin = co.rangeMinVisible,
                        rMax = co.rangeMaxVisible;
                    if ("datetime" === that._businessRange.dataType) {
                        interval = dateToMilliseconds(origInterval)
                    }
                    value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
                    value = that._intervalize(addInterval(value, interval / 2, direction > 0), origInterval);
                    if (value < rMin) {
                        value = rMin
                    } else {
                        if (value > rMax) {
                            value = rMax
                        }
                    }
                    return value
                },
                _add: function(value, diff, coeff) {
                    return NaN
                },
                isValueProlonged: true
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************************!*\
      !*** ./Scripts/viz/translators/logarithmic_translator.js ***!
      \***********************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var numericTranslator = __webpack_require__( /*! ./numeric_translator */ 237),
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                commonUtils = __webpack_require__( /*! ../../core/utils/common */ 2),
                raiseTo = vizUtils.raiseTo,
                getLog = vizUtils.getLog;
            module.exports = {
                translate: function(bp) {
                    var that = this,
                        specialValue = that.translateSpecialCase(bp);
                    if (commonUtils.isDefined(specialValue)) {
                        return specialValue
                    }
                    return numericTranslator.translate.call(that, getLog(bp, that._businessRange.base))
                },
                untranslate: function() {
                    var result = numericTranslator.untranslate.apply(this, arguments);
                    return null === result ? result : raiseTo(result, this._businessRange.base)
                },
                getInterval: numericTranslator.getInterval,
                _getValue: function(value) {
                    return Math.pow(this._canvasOptions.base, value)
                },
                zoom: numericTranslator.zoom,
                getMinScale: numericTranslator.getMinScale,
                getScale: function(val1, val2) {
                    var base = this._businessRange.base;
                    val1 = commonUtils.isDefined(val1) ? getLog(val1, base) : void 0;
                    val2 = commonUtils.isDefined(val2) ? getLog(val2, base) : void 0;
                    return numericTranslator.getScale.call(this, val1, val2)
                },
                isValid: function(value) {
                    return numericTranslator.isValid.call(this, getLog(value, this._businessRange.base))
                },
                parse: numericTranslator.parse,
                to: function(value) {
                    return numericTranslator.to.call(this, getLog(value, this._businessRange.base))
                },
                from: function(position) {
                    return raiseTo(numericTranslator.from.call(this, position), this._businessRange.base)
                },
                _add: function(value, diff, dir) {
                    var b = this._businessRange.base;
                    return raiseTo(numericTranslator._add(getLog(value, b), diff, dir), b)
                },
                isValueProlonged: numericTranslator.isValueProlonged
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************!*\
      !*** ./Scripts/viz/tree_map.js ***!
      \*********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./tree_map/tree_map */ 567)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************************!*\
      !*** ./Scripts/viz/tree_map/colorizing.gradient.js ***!
      \*****************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _createColorCodeGetter = __webpack_require__( /*! ./colorizing */ 106).createColorCodeGetter,
                _min = Math.min,
                _max = Math.max;

            function createSimpleColorizer(getColor, range) {
                return function(node) {
                    return getColor(node, range)
                }
            }

            function getRangeData(range) {
                return [Number(range[0]) || 0, range[1] - range[0] || 1]
            }

            function calculateRange(nodes, getValue) {
                var i, code, ii = nodes.length,
                    codes = [];
                for (i = 0; i < ii; ++i) {
                    code = getValue(nodes[i]);
                    if (isFinite(code)) {
                        codes.push(code)
                    }
                }
                return getRangeData([_min.apply(null, codes), _max.apply(null, codes)])
            }

            function createGuessingColorizer(getColor, getValue) {
                var ranges = {};
                return function(node) {
                    var parent = node.parent;
                    return getColor(node, ranges[parent._id] || (ranges[parent._id] = calculateRange(parent.nodes, getValue)))
                }
            }

            function gradientColorizer(options, themeManager) {
                var palette = themeManager.createGradientPalette(options.palette),
                    getValue = _createColorCodeGetter(options);
                return "range" in options ? createSimpleColorizer(getColor, getRangeData(options.range || [])) : createGuessingColorizer(getColor, getValue);

                function getColor(node, arg) {
                    return palette.getColor((getValue(node) - arg[0]) / arg[1])
                }
            }
            __webpack_require__( /*! ./colorizing */ 106).addColorizer("gradient", gradientColorizer);
            module.exports = gradientColorizer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/tree_map/colorizing.range.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _createColorCodeGetter = __webpack_require__( /*! ./colorizing */ 106).createColorCodeGetter;

            function getPaletteIndex(value, items) {
                var middle, start = 0,
                    end = items.length - 1,
                    index = -1;
                if (items[start] <= value && value <= items[end]) {
                    if (value === items[end]) {
                        index = end - 1
                    } else {
                        while (end - start > 1) {
                            middle = start + end >> 1;
                            if (value < items[middle]) {
                                end = middle
                            } else {
                                start = middle
                            }
                        }
                        index = start
                    }
                }
                return index
            }

            function rangeColorizer(options, themeManager) {
                var range = options.range || [],
                    palette = themeManager.createDiscretePalette(options.palette, range.length - 1),
                    getValue = _createColorCodeGetter(options);
                return function(node) {
                    return palette.getColor(getPaletteIndex(getValue(node), range))
                }
            }
            __webpack_require__( /*! ./colorizing */ 106).addColorizer("range", rangeColorizer);
            module.exports = rangeColorizer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/tree_map/drilldown.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                _expand = __webpack_require__( /*! ./common */ 90).expand;
            __webpack_require__( /*! ./api */ 130);
            proto._eventsMap.onDrill = {
                name: "drill"
            };
            _expand(proto, "_extendProxyType", function(proto) {
                var that = this;
                proto.drillDown = function() {
                    that._drillToNode(this._id)
                }
            });
            _expand(proto, "_onNodesCreated", function() {
                this._drilldownIndex = -1
            });
            proto._drillToNode = function(index) {
                var node, that = this;
                if (that._drilldownIndex !== index) {
                    node = that._nodes[index] || that._root;
                    if (node.nodes) {
                        that._drilldownIndex = index;
                        that._topNode = node;
                        that._context.suspend();
                        that._context.change(["MAX_DEPTH", "NODES_RESET"]);
                        that._context.resume();
                        that._eventTrigger("drill", {
                            node: node.proxy
                        })
                    }
                }
            };
            proto.resetDrillDown = function() {
                this._drillToNode(-1);
                return this
            };
            proto.drillUp = function() {
                this._drillToNode(this._topNode.parent._id || -1);
                return this
            };
            proto.getCurrentNode = function() {
                return this._topNode.proxy
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/tree_map/plain_data_source.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype;
            proto._optionChangesMap.idField = proto._optionChangesMap.parentField = "NODES_CREATE";
            proto._processDataSourceItems = function(items) {
                var i, currentItem, parentId, tmpItems, item, struct = {},
                    idField = this._getOption("idField", true),
                    parentField = this._getOption("parentField", true),
                    rootNodes = [];
                if (!idField || !parentField || 0 === items.length) {
                    return {
                        items: items,
                        isPlain: true
                    }
                }
                for (i = 0; i < items.length; i++) {
                    currentItem = items[i];
                    parentId = currentItem[parentField];
                    if (!!parentId) {
                        struct[parentId] = struct[parentId] || {
                            items: []
                        };
                        tmpItems = struct[parentId].items
                    } else {
                        tmpItems = rootNodes
                    }
                    tmpItems.push(currentItem)
                }
                treeFiller({
                    struct: struct,
                    idField: idField
                }, rootNodes);
                for (item in struct) {
                    struct[item] && rootNodes.push(struct[item])
                }
                return {
                    items: rootNodes,
                    isPlain: true
                }
            };

            function treeFiller(context, items) {
                var currentItem, i, id, struct = context.struct;
                for (i = 0; i < items.length; i++) {
                    currentItem = items[i];
                    id = currentItem[context.idField];
                    if (struct[id]) {
                        currentItem.items = struct[id].items;
                        struct[id] = null;
                        treeFiller(context, currentItem.items)
                    }
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/tree_map/selection.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                nodeProto = __webpack_require__( /*! ./node */ 168).prototype,
                common = __webpack_require__( /*! ./common */ 90),
                _buildRectAppearance = common.buildRectAppearance,
                _normalizeEnum = __webpack_require__( /*! ../core/utils */ 6).normalizeEnum,
                _inArray = __webpack_require__( /*! jquery */ 1).inArray,
                MODE_NONE = 0,
                MODE_SINGLE = 1,
                MODE_MULTIPLE = 2,
                STATE_CODE = 2;
            __webpack_require__( /*! ./api */ 130);
            __webpack_require__( /*! ./states */ 344);
            proto._eventsMap.onSelectionChanged = {
                name: "selectionChanged"
            };
            common.expand(proto._handlers, "calculateAdditionalStates", function(states, options) {
                states[2] = options.selectionStyle ? _buildRectAppearance(options.selectionStyle) : {}
            });
            nodeProto.statesMap[2] = nodeProto.statesMap[3] = STATE_CODE;
            nodeProto.additionalStates.push(2);
            common.expand(proto, "_onNodesCreated", function() {
                this._selectionList.length = 0
            });
            common.expand(proto, "_extendProxyType", function(proto) {
                var that = this;
                proto.select = function(state) {
                    that._selectNode(this._id, !!state)
                };
                proto.isSelected = function() {
                    return _inArray(this._id, that._selectionList) >= 0
                };
                that._selectionList = []
            });
            __webpack_require__( /*! ./tree_map.base */ 51).addChange({
                code: "SELECTION_MODE",
                handler: function() {
                    var mode, tmp, that = this,
                        option = _normalizeEnum(that._getOption("selectionMode", true)),
                        selectionList = that._selectionList;
                    mode = "none" === option ? MODE_NONE : "multiple" === option ? MODE_MULTIPLE : MODE_SINGLE;
                    if (mode === MODE_SINGLE && selectionList.length > 1) {
                        tmp = selectionList.pop();
                        that.clearSelection();
                        selectionList.push(tmp)
                    } else {
                        if (mode === MODE_NONE) {
                            that.clearSelection()
                        }
                    }
                    that._selectionMode = mode
                },
                isThemeDependent: true,
                isOptionChange: true,
                option: "selectionMode"
            });
            common.expand(proto, "_applyTilesAppearance", function() {
                if (this._selectionList.length) {
                    bringSelectedTilesToForeground(this._nodes, this._selectionList)
                }
            });

            function bringSelectedTilesToForeground(nodes, selectionList) {
                var i, node, ii = selectionList.length;
                for (i = 0; i < ii; ++i) {
                    node = nodes[selectionList[i]];
                    tileToFront[Number(node.isNode())](node.tile)
                }
            }
            var tileToFront = [leafToFront, groupToFront];

            function leafToFront(content) {
                content.toForeground()
            }

            function groupToFront(content) {
                content.outer.toForeground();
                content.inner.toForeground()
            }
            proto._applySelectionState = function(index, state) {
                var node = this._nodes[index];
                node.setState(STATE_CODE, state);
                this._eventTrigger("selectionChanged", {
                    node: node.proxy
                })
            };
            proto._selectNode = function(index, state) {
                var selectionList, k, tmp, that = this;
                if (that._selectionMode !== MODE_NONE) {
                    that._context.suspend();
                    selectionList = that._selectionList;
                    k = _inArray(index, selectionList);
                    if (state && -1 === k) {
                        if (that._selectionMode === MODE_SINGLE) {
                            if (selectionList.length) {
                                tmp = selectionList.pop();
                                that._applySelectionState(tmp, false)
                            }
                        }
                        selectionList.push(index);
                        that._applySelectionState(index, true)
                    } else {
                        if (!state && k >= 0) {
                            selectionList.splice(k, 1);
                            that._applySelectionState(index, false)
                        }
                    }
                    that._context.resume()
                }
            };
            proto.clearSelection = function() {
                var i, that = this,
                    selectionList = that._selectionList,
                    ii = selectionList.length;
                if (that._selectionMode !== MODE_NONE) {
                    that._context.suspend();
                    for (i = 0; i < ii; ++i) {
                        that._applySelectionState(selectionList[i], false)
                    }
                    selectionList.length = 0;
                    that._context.resume()
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************************!*\
      !*** ./Scripts/viz/tree_map/tiling.slice_and_dice.js ***!
      \*******************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var tiling = __webpack_require__( /*! ./tiling */ 107);

            function sliceAndDice(data) {
                var items = data.items,
                    sidesData = tiling.buildSidesData(data.rect, data.directions, data.isRotated ? 1 : 0);
                tiling.calculateRectangles(items, 0, data.rect, sidesData, {
                    sum: data.sum,
                    count: items.length,
                    side: sidesData.variedSide
                })
            }
            tiling.addAlgorithm("sliceanddice", sliceAndDice);
            module.exports = sliceAndDice
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/tree_map/tiling.strip.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _squarify = __webpack_require__( /*! ./tiling.squarified.base */ 345);

            function accumulate(total, current, count) {
                return ((count - 1) * total + current) / count
            }

            function strip(data) {
                return _squarify(data, accumulate, true)
            }
            __webpack_require__( /*! ./tiling */ 107).addAlgorithm("strip", strip);
            module.exports = strip
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*****************************************!*\
      !*** ./Scripts/viz/tree_map/tracker.js ***!
      \*****************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var proto = __webpack_require__( /*! ./tree_map.base */ 51).prototype,
                common = __webpack_require__( /*! ./common */ 90),
                _eventData = __webpack_require__( /*! ../../events/utils */ 4).eventData,
                _parseScalar = __webpack_require__( /*! ../core/utils */ 6).parseScalar,
                clickEventName = __webpack_require__( /*! ../../events/click */ 9).name,
                downPointerEventName = __webpack_require__( /*! ../../events/pointer */ 13).down,
                movePointerEventName = __webpack_require__( /*! ../../events/pointer */ 13).move,
                $ = __webpack_require__( /*! jquery */ 1),
                $doc = $(document),
                DATA_KEY_BASE = "__treemap_data_",
                dataKeyModifier = 0;
            __webpack_require__( /*! ./api */ 130);
            __webpack_require__( /*! ./hover */ 343);
            __webpack_require__( /*! ./tooltip */ 347);
            proto._eventsMap.onClick = {
                name: "click"
            };
            common.expand(proto, "_initCore", function() {
                var that = this,
                    dataKey = DATA_KEY_BASE + dataKeyModifier++;
                that._tracker = new Tracker({
                    widget: that,
                    root: that._renderer.root,
                    eventTrigger: that._eventTrigger,
                    getData: function(e) {
                        var target = e.target;
                        return ("tspan" === target.tagName ? target.parentNode : target)[dataKey]
                    },
                    getProxy: function(index) {
                        return that._nodes[index].proxy
                    },
                    getCoords: function(e) {
                        var data = _eventData(e),
                            offset = that._renderer.getRootOffset();
                        return [data.x - offset.left, data.y - offset.top]
                    }
                });
                proto._handlers.setTrackerData = function(node, element) {
                    element.data(dataKey, node._id)
                };
                exports._TESTS_dataKey = dataKey
            });
            common.expand(proto, "_disposeCore", function() {
                this._tracker.dispose()
            });
            __webpack_require__( /*! ./tree_map.base */ 51).addChange({
                code: "INTERACT_WITH_GROUP",
                handler: function() {
                    this._tracker.setOptions({
                        interactWithGroup: _parseScalar(this._getOption("interactWithGroup", true), false)
                    })
                },
                isThemeDependent: true,
                isOptionChange: true,
                option: "interactWithGroup"
            });

            function Tracker(parameters) {
                this._options = {};
                this._initHandlers(parameters, this._options)
            }
            Tracker.prototype = {
                constructor: Tracker,
                _initHandlers: function(parameters, options) {
                    parameters.getNode = function(id) {
                        var proxy = parameters.getProxy(id);
                        return options.interactWithGroup && proxy.isLeaf() && proxy.getParent().isActive() ? proxy.getParent() : proxy
                    };
                    parameters.root.on(clickEventName, clickHandler);
                    parameters.root.on(downPointerEventName, downHandler);
                    $doc.on(downPointerEventName, downHandler);
                    $doc.on(movePointerEventName, moveHandler);
                    this._disposeHandlers = function() {
                        parameters.root.off(clickEventName, clickHandler);
                        parameters.root.off(downPointerEventName, downHandler);
                        $doc.off(downPointerEventName, downHandler);
                        $doc.off(movePointerEventName, moveHandler)
                    };

                    function clickHandler(e) {
                        processClick(e, parameters)
                    }
                    var isRootDown = false;

                    function downHandler(e) {
                        if (isRootDown) {
                            isRootDown = false
                        } else {
                            if (void 0 !== parameters.getData(e)) {
                                e.preventDefault();
                                isRootDown = true
                            }
                            moveHandler(e)
                        }
                    }

                    function moveHandler(e) {
                        processHover(e, parameters);
                        processTooltip(e, parameters)
                    }
                },
                dispose: function() {
                    this._disposeHandlers()
                },
                setOptions: function(options) {
                    $.extend(this._options, options)
                }
            };

            function processClick(e, params) {
                var id = params.getData(e);
                if (id >= 0) {
                    params.eventTrigger("click", {
                        node: params.getNode(id),
                        coords: params.getCoords(e),
                        jQueryEvent: e
                    })
                }
            }

            function processHover(e, params) {
                var id = params.getData(e);
                if (id >= 0) {
                    params.getNode(id).setHover()
                } else {
                    params.widget.clearHover()
                }
            }

            function processTooltip(e, params) {
                var coords, id = params.getData(e);
                if (id >= 0) {
                    coords = _eventData(e);
                    params.getNode(id).showTooltip([coords.x, coords.y])
                } else {
                    params.widget.hideTooltip()
                }
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/tree_map/tree_map.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var dxTreeMap = module.exports = __webpack_require__( /*! ./tree_map.base */ 51);
            __webpack_require__( /*! ./tiling.squarified */ 346);
            __webpack_require__( /*! ./tiling.strip */ 565);
            __webpack_require__( /*! ./tiling.slice_and_dice */ 564);
            __webpack_require__( /*! ./colorizing.discrete */ 342);
            __webpack_require__( /*! ./colorizing.gradient */ 559);
            __webpack_require__( /*! ./colorizing.range */ 560);
            __webpack_require__( /*! ./api */ 130);
            __webpack_require__( /*! ./hover */ 343);
            __webpack_require__( /*! ./selection */ 563);
            __webpack_require__( /*! ./tooltip */ 347);
            __webpack_require__( /*! ./tracker */ 566);
            __webpack_require__( /*! ./drilldown */ 561);
            __webpack_require__( /*! ./plain_data_source */ 562);
            dxTreeMap.addPlugin(__webpack_require__( /*! ../core/export */ 127).plugin);
            dxTreeMap.addPlugin(__webpack_require__( /*! ../core/title */ 164).plugin);
            dxTreeMap.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 163).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************!*\
      !*** ./Scripts/viz/vector_map.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            module.exports = __webpack_require__( /*! ./vector_map/vector_map */ 578)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***********************************************!*\
      !*** ./Scripts/viz/vector_map/control_bar.js ***!
      \***********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _math = Math,
                _min = _math.min,
                _max = _math.max,
                _round = _math.round,
                _floor = _math.floor,
                _sqrt = _math.sqrt,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _parseScalar = vizUtils.parseScalar,
                parseHorizontalAlignment = vizUtils.enumParser(["left", "center", "right"]),
                parseVerticalAlignment = vizUtils.enumParser(["top", "bottom"]),
                COMMAND_RESET = "command-reset",
                COMMAND_MOVE_UP = "command-move-up",
                COMMAND_MOVE_RIGHT = "command-move-right",
                COMMAND_MOVE_DOWN = "command-move-down",
                COMMAND_MOVE_LEFT = "command-move-left",
                COMMAND_ZOOM_IN = "command-zoom-in",
                COMMAND_ZOOM_OUT = "command-zoom-out",
                COMMAND_ZOOM_DRAG_LINE = "command-zoom-drag-line",
                COMMAND_ZOOM_DRAG = "command-zoom-drag",
                EVENT_TARGET_TYPE = "control-bar",
                FLAG_CENTERING = 1,
                FLAG_ZOOMING = 2,
                SIZE_OPTIONS = {
                    bigCircleSize: 58,
                    smallCircleSize: 28,
                    buttonSize: 10,
                    arrowButtonOffset: 20,
                    incdecButtonSize: 11,
                    incButtonOffset: 66,
                    decButtonOffset: 227,
                    sliderLineStartOffset: 88.5,
                    sliderLineEndOffset: 205.5,
                    sliderLength: 20,
                    sliderWidth: 8,
                    trackerGap: 4
                },
                OFFSET_X = 30.5,
                OFFSET_Y = 30.5,
                TOTAL_WIDTH = 61,
                TOTAL_HEIGHT = 274,
                COMMAND_TO_TYPE_MAP = {};
            COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
            COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
            COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
            COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;

            function ControlBar(parameters) {
                var that = this;
                that._params = parameters;
                that._createElements(parameters.renderer, parameters.container, parameters.dataKey);
                parameters.layoutControl.addItem(that);
                that._subscribeToProjection(parameters.projection);
                that._subscribeToTracker(parameters.tracker);
                that._createCallbacks(parameters.projection, parameters.renderer)
            }
            ControlBar.prototype = {
                constructor: ControlBar,
                _flags: 0,
                dispose: function() {
                    var that = this;
                    that._params.layoutControl.removeItem(that);
                    that._root.linkRemove().linkOff();
                    that._offProjection();
                    that._offTracker();
                    that._params = that._root = that._offProjection = that._offTracker = that._callbacks = null
                },
                _subscribeToProjection: function(projection) {
                    var that = this;
                    that._offProjection = projection.on({
                        engine: function() {
                            that._update()
                        },
                        zoom: updateZoom,
                        "max-zoom": function() {
                            that._zoomPartition = projection.getZoomScalePartition();
                            that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
                            updateZoom()
                        }
                    });

                    function updateZoom() {
                        that._adjustZoom(projection.getScaledZoom())
                    }
                },
                _subscribeToTracker: function(tracker) {
                    var that = this,
                        isActive = false;
                    that._offTracker = tracker.on({
                        start: function(arg) {
                            isActive = arg.data.name === EVENT_TARGET_TYPE;
                            if (isActive) {
                                that._processStart(arg.data.index, arg)
                            }
                        },
                        move: function(arg) {
                            if (isActive) {
                                that._processMove(arg.data.index, arg)
                            }
                        },
                        end: function(arg) {
                            if (isActive) {
                                that._processEnd();
                                isActive = false
                            }
                        }
                    })
                },
                _createCallbacks: function(projection, renderer) {
                    var that = this;
                    that._callbacks = {
                        reset: function(isCenter, isZoom) {
                            if (isCenter) {
                                projection.setCenter(null)
                            }
                            if (isZoom) {
                                projection.setZoom(null)
                            }
                        },
                        beginMove: function() {
                            projection.beginMoveCenter()
                        },
                        endMove: function() {
                            projection.endMoveCenter()
                        },
                        move: function(shift) {
                            projection.moveCenter(shift)
                        },
                        zoom: function(zoom) {
                            projection.setScaledZoom(zoom)
                        }
                    }
                },
                _createElements: function(renderer, container, dataKey) {
                    var buttonsGroups, trackersGroup, that = this;
                    that._root = renderer.g().attr({
                        "class": "dxm-control-bar"
                    }).linkOn(container, "control-bar");
                    buttonsGroups = that._buttonsGroup = renderer.g().attr({
                        "class": "dxm-control-buttons"
                    }).append(that._root);
                    trackersGroup = renderer.g().attr({
                        stroke: "none",
                        "stroke-width": 0,
                        fill: "#000000",
                        opacity: 1e-4
                    }).css({
                        cursor: "pointer"
                    }).append(that._root);
                    that._createButtons(renderer, dataKey, buttonsGroups);
                    that._createTrackers(renderer, dataKey, trackersGroup)
                },
                _createButtons: function(renderer, dataKey, group) {
                    var that = this,
                        options = SIZE_OPTIONS,
                        size = options.buttonSize / 2,
                        offset1 = options.arrowButtonOffset - size,
                        offset2 = options.arrowButtonOffset,
                        incdecButtonSize = options.incdecButtonSize / 2,
                        directionOptions = {
                            "stroke-linecap": "square",
                            fill: "none"
                        },
                        line = "line";
                    renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
                    renderer.circle(0, 0, size).attr({
                        fill: "none"
                    }).append(group);
                    renderer.path([-size, -offset1, 0, -offset2, size, -offset1], line).attr(directionOptions).append(group);
                    renderer.path([offset1, -size, offset2, 0, offset1, size], line).attr(directionOptions).append(group);
                    renderer.path([size, offset1, 0, offset2, -size, offset1], line).attr(directionOptions).append(group);
                    renderer.path([-offset1, size, -offset2, 0, -offset1, -size], line).attr(directionOptions).append(group);
                    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
                    renderer.path([
                        [-incdecButtonSize, options.incButtonOffset, incdecButtonSize, options.incButtonOffset],
                        [0, options.incButtonOffset - incdecButtonSize, 0, options.incButtonOffset + incdecButtonSize]
                    ], "area").append(group);
                    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
                    renderer.path([-incdecButtonSize, options.decButtonOffset, incdecButtonSize, options.decButtonOffset], "area").append(group);
                    that._zoomLine = renderer.path([], "line").append(group);
                    that._zoomDrag = renderer.rect(_floor(-options.sliderLength / 2), _floor(options.sliderLineEndOffset - options.sliderWidth / 2), options.sliderLength, options.sliderWidth).append(group);
                    that._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset
                },
                _createTrackers: function(renderer, dataKey, group) {
                    var options = SIZE_OPTIONS,
                        size = _round((options.arrowButtonOffset - options.trackerGap) / 2),
                        offset1 = options.arrowButtonOffset - size,
                        offset2 = _round(_sqrt(options.bigCircleSize * options.bigCircleSize / 4 - size * size)),
                        size2 = offset2 - offset1;
                    renderer.rect(-size, -size, 2 * size, 2 * size).data(dataKey, {
                        index: COMMAND_RESET,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.rect(-size, -offset2, 2 * size, size2).data(dataKey, {
                        index: COMMAND_MOVE_UP,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.rect(offset1, -size, size2, 2 * size).data(dataKey, {
                        index: COMMAND_MOVE_RIGHT,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.rect(-size, offset1, 2 * size, size2).data(dataKey, {
                        index: COMMAND_MOVE_DOWN,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.rect(-offset2, -size, size2, 2 * size).data(dataKey, {
                        index: COMMAND_MOVE_LEFT,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).data(dataKey, {
                        index: COMMAND_ZOOM_IN,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).data(dataKey, {
                        index: COMMAND_ZOOM_OUT,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).css({
                        cursor: "default"
                    }).data(dataKey, {
                        index: COMMAND_ZOOM_DRAG_LINE,
                        name: EVENT_TARGET_TYPE
                    }).append(group);
                    this._zoomDragTracker = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).data(dataKey, {
                        index: COMMAND_ZOOM_DRAG,
                        name: EVENT_TARGET_TYPE
                    }).append(group)
                },
                resize: function(size) {
                    if (this._isActive) {
                        this._root.attr({
                            visibility: null !== size ? null : "hidden"
                        })
                    }
                },
                getLayoutOptions: function() {
                    return this._isActive ? this._layoutOptions : null
                },
                locate: function(x, y) {
                    this._root.attr({
                        translateX: x + this._margin + OFFSET_X,
                        translateY: y + this._margin + OFFSET_Y
                    })
                },
                _update: function() {
                    var that = this;
                    that._isActive = that._isEnabled && that._flags && that._params.projection.isInvertible();
                    if (that._isActive) {
                        that._root.linkAppend()
                    } else {
                        that._root.linkRemove()
                    }
                    that._processEnd();
                    that.updateLayout()
                },
                setInteraction: function(interaction) {
                    var that = this;
                    if (_parseScalar(interaction.centeringEnabled, true)) {
                        that._flags |= FLAG_CENTERING
                    } else {
                        that._flags &= ~FLAG_CENTERING
                    }
                    if (_parseScalar(interaction.zoomingEnabled, true)) {
                        that._flags |= FLAG_ZOOMING
                    } else {
                        that._flags &= ~FLAG_ZOOMING
                    }
                    that._update()
                },
                setOptions: function(options) {
                    var that = this;
                    that._isEnabled = !!_parseScalar(options.enabled, true);
                    that._margin = options.margin || 0;
                    that._layoutOptions = {
                        width: 2 * that._margin + TOTAL_WIDTH,
                        height: 2 * that._margin + TOTAL_HEIGHT,
                        horizontalAlignment: parseHorizontalAlignment(options.horizontalAlignment, "left"),
                        verticalAlignment: parseVerticalAlignment(options.verticalAlignment, "top")
                    };
                    that._buttonsGroup.attr({
                        "stroke-width": options.borderWidth,
                        stroke: options.borderColor,
                        fill: options.color,
                        "fill-opacity": options.opacity
                    });
                    that._update()
                },
                _adjustZoom: function(zoom) {
                    var transform, y, that = this,
                        start = SIZE_OPTIONS.sliderLineStartOffset,
                        end = SIZE_OPTIONS.sliderLineEndOffset,
                        h = SIZE_OPTIONS.sliderWidth;
                    that._zoomFactor = _max(_min(_round(zoom), that._zoomPartition), 0);
                    transform = {
                        translateY: -_round(that._zoomFactor * that._sliderUnitLength)
                    };
                    y = end - h / 2 + transform.translateY;
                    that._zoomLine.attr({
                        points: [
                            [0, start, 0, _max(start, y)],
                            [0, _min(end, y + h), 0, end]
                        ]
                    });
                    that._zoomDrag.attr(transform);
                    that._zoomDragTracker.attr(transform)
                },
                _applyZoom: function() {
                    this._callbacks.zoom(this._zoomFactor)
                },
                _processStart: function(command, arg) {
                    var commandType;
                    if (this._isActive) {
                        commandType = COMMAND_TO_TYPE_MAP[command];
                        this._command = commandType && commandType.flags & this._flags ? new commandType(this, command, arg) : null
                    }
                },
                _processMove: function(command, arg) {
                    this._command && this._command.update(command, arg)
                },
                _processEnd: function() {
                    this._command && this._command.finish();
                    this._command = null
                }
            };

            function disposeCommand(command) {
                delete command._owner;
                command.update = function() {};
                command.finish = function() {}
            }

            function ResetCommand(owner, command) {
                this._owner = owner;
                this._command = command
            }
            ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;
            ResetCommand.prototype.update = function(command) {
                command !== this._command && disposeCommand(this)
            };
            ResetCommand.prototype.finish = function() {
                var flags = this._owner._flags;
                this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));
                disposeCommand(this)
            };

            function MoveCommand(owner, command, arg) {
                this._command = command;
                var timeout = null,
                    interval = 100,
                    dx = 0,
                    dy = 0;
                switch (this._command) {
                    case COMMAND_MOVE_UP:
                        dy = -10;
                        break;
                    case COMMAND_MOVE_RIGHT:
                        dx = 10;
                        break;
                    case COMMAND_MOVE_DOWN:
                        dy = 10;
                        break;
                    case COMMAND_MOVE_LEFT:
                        dx = -10
                }

                function callback() {
                    owner._callbacks.move([dx, dy]);
                    timeout = setTimeout(callback, interval)
                }
                this._stop = function() {
                    clearTimeout(timeout);
                    owner._callbacks.endMove();
                    this._stop = owner = null;
                    return this
                };
                arg = null;
                owner._callbacks.beginMove();
                callback()
            }
            MoveCommand.flags = FLAG_CENTERING;
            MoveCommand.prototype.update = function(command) {
                this._command !== command && this.finish()
            };
            MoveCommand.prototype.finish = function() {
                disposeCommand(this._stop())
            };

            function ZoomCommand(owner, command) {
                this._owner = owner;
                this._command = command;
                var timeout = null,
                    interval = 150,
                    dzoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;

                function callback() {
                    owner._adjustZoom(owner._zoomFactor + dzoom);
                    timeout = setTimeout(callback, interval)
                }
                this._stop = function() {
                    clearTimeout(timeout);
                    this._stop = owner = null;
                    return this
                };
                callback()
            }
            ZoomCommand.flags = FLAG_ZOOMING;
            ZoomCommand.prototype.update = function(command) {
                this._command !== command && this.finish()
            };
            ZoomCommand.prototype.finish = function() {
                this._owner._applyZoom();
                disposeCommand(this._stop())
            };

            function ZoomDragCommand(owner, command, arg) {
                this._owner = owner;
                this._zoomFactor = owner._zoomFactor;
                this._pos = arg.y
            }
            ZoomDragCommand.flags = FLAG_ZOOMING;
            ZoomDragCommand.prototype.update = function(command, arg) {
                var owner = this._owner;
                owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength)
            };
            ZoomDragCommand.prototype.finish = function() {
                this._owner._applyZoom();
                disposeCommand(this)
            };
            exports.ControlBar = ControlBar;
            var COMMAND_TO_TYPE_MAP__ORIGINAL = COMMAND_TO_TYPE_MAP;
            exports._TESTS_stubCommandToTypeMap = function(map) {
                COMMAND_TO_TYPE_MAP = map
            };
            exports._TESTS_restoreCommandToTypeMap = function() {
                COMMAND_TO_TYPE_MAP = COMMAND_TO_TYPE_MAP__ORIGINAL
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/vector_map/data_exchanger.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _Callbacks = __webpack_require__( /*! jquery */ 1).Callbacks;

            function DataExchanger() {
                this._store = {}
            }
            DataExchanger.prototype = {
                constructor: DataExchanger,
                dispose: function() {
                    this._store = null;
                    return this
                },
                _get: function(category, name) {
                    var store = this._store[category] || (this._store[category] = {});
                    return store[name] || (store[name] = {
                        callbacks: _Callbacks()
                    })
                },
                set: function(category, name, data) {
                    var item = this._get(category, name);
                    item.data = data;
                    item.callbacks.fire(data);
                    return this
                },
                bind: function(category, name, callback) {
                    var item = this._get(category, name);
                    item.callbacks.add(callback);
                    item.data && callback(item.data);
                    return this
                },
                unbind: function(category, name, callback) {
                    var item = this._get(category, name);
                    item.callbacks.remove(callback);
                    return this
                }
            };
            exports.DataExchanger = DataExchanger
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!***************************************************!*\
      !*** ./Scripts/viz/vector_map/gesture_handler.js ***!
      \***************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var _ln = Math.log,
                _LN2 = Math.LN2;

            function GestureHandler(params) {
                var that = this;
                that._projection = params.projection;
                that._renderer = params.renderer;
                that._x = that._y = 0;
                that._subscribeToTracker(params.tracker)
            }
            GestureHandler.prototype = {
                constructor: GestureHandler,
                dispose: function() {
                    this._offTracker();
                    this._offTracker = null
                },
                _subscribeToTracker: function(tracker) {
                    var that = this,
                        isActive = false;
                    that._offTracker = tracker.on({
                        start: function(arg) {
                            isActive = "control-bar" !== arg.data.name;
                            if (isActive) {
                                that._processStart(arg)
                            }
                        },
                        move: function(arg) {
                            if (isActive) {
                                that._processMove(arg)
                            }
                        },
                        end: function(arg) {
                            if (isActive) {
                                that._processEnd()
                            }
                        },
                        zoom: function(arg) {
                            that._processZoom(arg)
                        }
                    })
                },
                setInteraction: function(options) {
                    this._processEnd();
                    this._centeringEnabled = options.centeringEnabled;
                    this._zoomingEnabled = options.zoomingEnabled
                },
                _processStart: function(arg) {
                    if (this._centeringEnabled) {
                        this._x = arg.x;
                        this._y = arg.y;
                        this._projection.beginMoveCenter()
                    }
                },
                _processMove: function(arg) {
                    var that = this;
                    if (that._centeringEnabled) {
                        that._renderer.root.attr({
                            cursor: "move"
                        });
                        that._projection.moveCenter([that._x - arg.x, that._y - arg.y]);
                        that._x = arg.x;
                        that._y = arg.y
                    }
                },
                _processEnd: function() {
                    if (this._centeringEnabled) {
                        this._renderer.root.attr({
                            cursor: "default"
                        });
                        this._projection.endMoveCenter()
                    }
                },
                _processZoom: function(arg) {
                    var delta, screenPosition, coords, that = this;
                    if (that._zoomingEnabled) {
                        if (arg.delta) {
                            delta = arg.delta
                        } else {
                            if (arg.ratio) {
                                delta = _ln(arg.ratio) / _LN2
                            }
                        }
                        if (that._centeringEnabled) {
                            screenPosition = that._renderer.getRootOffset();
                            screenPosition = [arg.x - screenPosition.left, arg.y - screenPosition.top];
                            coords = that._projection.fromScreenPoint(screenPosition)
                        }
                        that._projection.changeScaledZoom(delta);
                        if (that._centeringEnabled) {
                            that._projection.setCenterByPoint(coords, screenPosition)
                        }
                    }
                }
            };
            exports.GestureHandler = GestureHandler
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/vector_map/layout.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _round = Math.round,
                _min = Math.min,
                _max = Math.max,
                _each = $.each,
                _inArray = $.inArray,
                horizontalAlignmentMap = {
                    left: 0,
                    center: 1,
                    right: 2
                },
                verticalAlignmentMap = {
                    top: 0,
                    bottom: 1
                };

            function getCellIndex(options) {
                return 3 * verticalAlignmentMap[options.verticalAlignment] + horizontalAlignmentMap[options.horizontalAlignment]
            }

            function createCells(canvas, items) {
                var hstep = (canvas.right - canvas.left) / 3,
                    vstep = (canvas.bottom - canvas.top) / 2,
                    h1 = canvas.left,
                    h2 = _round(h1 + hstep),
                    h3 = _round(h1 + hstep + hstep),
                    h4 = canvas.right,
                    v1 = canvas.top,
                    v2 = _round(v1 + vstep),
                    v3 = canvas.bottom,
                    cells = [{
                        rect: [h1, v1, h2, v2]
                    }, {
                        rect: [h2, v1, h3, v2],
                        center: true
                    }, {
                        rect: [h3, v1, h4, v2],
                        horInv: true
                    }, {
                        rect: [h1, v2, h2, v3],
                        verInv: true
                    }, {
                        rect: [h2, v2, h3, v3],
                        center: true,
                        verInv: true
                    }, {
                        rect: [h3, v2, h4, v3],
                        horInv: true,
                        verInv: true
                    }],
                    itemsList = [
                        [],
                        [],
                        [],
                        [],
                        [],
                        []
                    ];
                _each(items, function(_, item) {
                    var options = item.getLayoutOptions();
                    if (options) {
                        itemsList[getCellIndex(options)].push({
                            item: item,
                            width: options.width,
                            height: options.height
                        })
                    }
                });
                _each(cells, function(i, cell) {
                    if (itemsList[i].length) {
                        cell.items = itemsList[i]
                    } else {
                        if (cell.center) {
                            cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2
                        } else {
                            cell.rect[cell.horInv ? 0 : 2] = cell.rect[cell.horInv ? 2 : 0]
                        }
                        cell.rect[cell.verInv ? 1 : 3] = cell.rect[cell.verInv ? 3 : 1]
                    }
                });
                return cells
            }

            function adjustCellSizes(cells) {
                _each([0, 1, 2, 3, 4, 5], function(_, index) {
                    var cell = cells[index],
                        otherCell = cells[(index + 3) % 6];
                    if (cell.items) {
                        if (!otherCell.items) {
                            cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
                            cell.rect[3] = _max(cell.rect[3], otherCell.rect[1])
                        }
                    }
                });
                _each([1, 4], function(_, index) {
                    var size1, size2, cell = cells[index],
                        otherCell1 = cells[index - 1],
                        otherCell2 = cells[index + 1];
                    if (cell.items) {
                        if (!otherCell1.items && !otherCell2.items) {
                            size1 = cell.rect[0] - otherCell1.rect[2];
                            size2 = otherCell2.rect[0] - cell.rect[2];
                            if (size1 > size2) {
                                if (size1 / size2 >= 2) {
                                    cell.rect[0] -= size1;
                                    cell.right = true
                                } else {
                                    cell.rect[0] -= size2;
                                    cell.rect[2] += size2
                                }
                            } else {
                                if (size2 / size1 >= 2) {
                                    cell.rect[2] += size2;
                                    cell.center = null
                                } else {
                                    cell.rect[0] -= size1;
                                    cell.rect[2] += size1
                                }
                            }
                        }
                    } else {
                        if (otherCell1.items) {
                            otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2
                        }
                        if (otherCell2.items) {
                            otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2
                        }
                    }
                })
            }

            function adjustCellsAndApplyLayout(cells, forceMode) {
                var hasHiddenItems = false;
                adjustCellSizes(cells);
                _each(cells, function(_, cell) {
                    if (cell.items) {
                        hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems
                    }
                });
                return hasHiddenItems
            }

            function applyCellLayout(cell, forceMode) {
                var cellRect = cell.rect,
                    cellWidth = cellRect[2] - cellRect[0],
                    cellHeight = cellRect[3] - cellRect[1],
                    xoffset = 0,
                    yoffset = 0,
                    currentHeight = 0,
                    totalL = cellRect[2],
                    totalT = cellRect[3],
                    totalR = cellRect[0],
                    totalB = cellRect[1],
                    moves = [],
                    hasHiddenItems = false;
                _each(cell.items, function(_, item) {
                    if (item.width > cellWidth || item.height > cellHeight) {
                        moves.push(null);
                        hasHiddenItems = true;
                        return forceMode || false
                    }
                    if (xoffset + item.width > cellWidth) {
                        yoffset += currentHeight;
                        xoffset = currentHeight = 0
                    }
                    if (yoffset + item.height > cellHeight) {
                        moves.push(null);
                        hasHiddenItems = true;
                        return forceMode || false
                    }
                    currentHeight = _max(currentHeight, item.height);
                    var dx = cell.horInv ? cellRect[2] - item.width - xoffset : cellRect[0] + xoffset,
                        dy = cell.verInv ? cellRect[3] - item.height - yoffset : cellRect[1] + yoffset;
                    xoffset += item.width;
                    totalL = _min(totalL, dx);
                    totalT = _min(totalT, dy);
                    totalR = _max(totalR, dx + item.width);
                    totalB = _max(totalB, dy + item.height);
                    moves.push([dx, dy])
                });
                if (forceMode || !hasHiddenItems) {
                    xoffset = 0;
                    if (cell.right) {
                        xoffset = cellRect[2] - cellRect[0] - totalR + totalL
                    } else {
                        if (cell.center) {
                            xoffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2)
                        }
                    }
                    _each(cell.items, function(i, item) {
                        var move = moves[i];
                        if (move) {
                            item.item.locate(move[0] + xoffset, move[1])
                        } else {
                            item.item.resize(null)
                        }
                    });
                    cell.rect = [totalL, totalT, totalR, totalB];
                    cell.items = null
                }
                return hasHiddenItems
            }

            function applyLayout(canvas, items) {
                var cells = createCells(canvas, items);
                if (adjustCellsAndApplyLayout(cells)) {
                    adjustCellsAndApplyLayout(cells, true)
                }
            }

            function LayoutControl() {
                var that = this;
                that._items = [];
                that._suspended = 0;
                that._updateLayout = function() {
                    that._update()
                }
            }
            LayoutControl.prototype = {
                constructor: LayoutControl,
                dispose: function() {
                    this._items = this._updateLayout = null
                },
                setSize: function(canvas) {
                    this._canvas = canvas;
                    this._update()
                },
                suspend: function() {
                    ++this._suspended
                },
                resume: function() {
                    if (0 === --this._suspended) {
                        this._update()
                    }
                },
                addItem: function(item) {
                    this._items.push(item);
                    item.updateLayout = this._updateLayout
                },
                removeItem: function(item) {
                    this._items.splice(_inArray(item, this._items), 1);
                    item.updateLayout = null
                },
                _update: function() {
                    var canvas;
                    if (0 === this._suspended) {
                        canvas = this._canvas;
                        _each(this._items, function(_, item) {
                            item.resize(canvas)
                        });
                        applyLayout({
                            left: canvas.left,
                            top: canvas.top,
                            right: canvas.width + canvas.left,
                            bottom: canvas.height + canvas.top
                        }, this._items)
                    }
                }
            };
            exports.LayoutControl = LayoutControl
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!******************************************!*\
      !*** ./Scripts/viz/vector_map/legend.js ***!
      \******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _extend = $.extend,
                _each = $.each,
                legendModule = __webpack_require__( /*! ../components/legend */ 330),
                _BaseLegend = legendModule.Legend;
            var sourceMap = {
                areacolorgroups: {
                    category: "areas",
                    name: "color"
                },
                markercolorgroups: {
                    category: "markers",
                    name: "color"
                },
                markersizegroups: {
                    category: "markers",
                    name: "size"
                }
            };
            var unknownSource = {
                category: "UNKNOWN",
                name: "UNKNOWN"
            };

            function parseSource(source) {
                var ret;
                if ("string" === typeof source) {
                    ret = sourceMap[source.toLowerCase()] || unknownSource
                } else {
                    ret = {
                        category: source.layer,
                        name: source.grouping
                    }
                }
                return ret
            }

            function Legend(parameters) {
                var that = this;
                that._params = parameters;
                that._root = parameters.renderer.g().attr({
                    "class": "dxm-legend"
                }).linkOn(parameters.container, {
                    name: "legend",
                    after: "legend-base"
                }).linkAppend();
                parameters.layoutControl.addItem(that);
                _BaseLegend.call(that, {
                    renderer: parameters.renderer,
                    group: that._root,
                    backgroundClass: null,
                    itemsGroupClass: null,
                    textField: "text",
                    getFormatObject: function(data) {
                        return data
                    }
                });
                that._onDataChanged = function(data) {
                    that._updateData(data)
                }
            }

            function buildData(partition, values, field) {
                var i, item, ii = values.length,
                    list = [];
                for (i = 0; i < ii; ++i) {
                    list[i] = item = {
                        start: partition[i],
                        end: partition[i + 1],
                        index: i
                    };
                    item[field] = values[i];
                    item.states = {
                        normal: {
                            fill: item.color
                        }
                    }
                }
                return list
            }
            Legend.prototype = _extend(__webpack_require__( /*! ../../core/utils/object */ 30).clone(_BaseLegend.prototype), {
                constructor: Legend,
                dispose: function() {
                    var that = this;
                    that._params.layoutControl.removeItem(that);
                    that._unbindData();
                    that._root.linkRemove().linkOff();
                    that._params = that._root = that._onDataChanged = null;
                    return _BaseLegend.prototype.dispose.apply(that, arguments)
                },
                resize: function(size) {
                    this._params.notifyDirty();
                    if (null === size) {
                        this.erase()
                    } else {
                        this.draw(size.width, size.height)
                    }
                    this._params.notifyReady()
                },
                locate: _BaseLegend.prototype.shift,
                _updateData: function(data) {
                    this.update(data ? buildData(data.partition, data.values, this._dataName) : [], this._options);
                    this.updateLayout()
                },
                _unbindData: function() {
                    if (this._dataCategory) {
                        this._params.dataExchanger.unbind(this._dataCategory, this._dataName, this._onDataChanged)
                    }
                },
                _bindData: function(arg) {
                    this._params.dataExchanger.bind(this._dataCategory = arg.category, this._dataName = arg.name, this._onDataChanged)
                },
                setOptions: function(options) {
                    var that = this;
                    that.update(that._data, options);
                    that._unbindData();
                    that._bindData(options.source && parseSource(options.source) || unknownSource);
                    that.updateLayout();
                    return that
                }
            });

            function LegendsControl(parameters) {
                this._params = parameters;
                this._items = [];
                parameters.container.virtualLink("legend-base")
            }
            LegendsControl.prototype = {
                constructor: LegendsControl,
                dispose: function() {
                    _each(this._items, function(_, item) {
                        item.dispose()
                    });
                    this._params = this._items = null
                },
                setOptions: function(options) {
                    var i, optionList = options && options.length ? options : [],
                        items = this._items,
                        ii = optionList.length,
                        params = this._params,
                        theme = params.themeManager.theme("legend");
                    for (i = items.length; i < ii; ++i) {
                        items[i] = new Legend(params)
                    }
                    for (i = items.length - 1; i >= ii; --i) {
                        items[i].dispose();
                        items.splice(i, 1)
                    }
                    params.layoutControl.suspend();
                    for (i = 0; i < ii; ++i) {
                        items[i].setOptions(_extend(true, {}, theme, optionList[i]))
                    }
                    params.layoutControl.resume()
                }
            };
            exports.LegendsControl = LegendsControl;
            var originalLegend = Legend;
            exports._TESTS_Legend = Legend;
            exports._TESTS_stubLegendType = function(stub) {
                Legend = stub
            };
            exports._TESTS_restoreLegendType = function() {
                Legend = originalLegend
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*********************************************!*\
      !*** ./Scripts/viz/vector_map/map_layer.js ***!
      \*********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _Number = Number,
                _String = String,
                _abs = Math.abs,
                _round = Math.round,
                _min = Math.min,
                _max = Math.max,
                _sqrt = Math.sqrt,
                _utils = __webpack_require__( /*! ../../core/utils/common */ 2),
                dataSourceModule = __webpack_require__( /*! ../core/data_source */ 161),
                _isFunction = _utils.isFunction,
                _isArray = _utils.isArray,
                vizUtils = __webpack_require__( /*! ../core/utils */ 6),
                _parseScalar = vizUtils.parseScalar,
                _patchFontOptions = vizUtils.patchFontOptions,
                _normalizeEnum = vizUtils.normalizeEnum,
                _noop = $.noop,
                _extend = $.extend,
                _each = $.each,
                _concat = Array.prototype.concat,
                TYPE_AREA = "area",
                TYPE_LINE = "line",
                TYPE_MARKER = "marker",
                STATE_DEFAULT = 0,
                STATE_HOVERED = 1,
                STATE_SELECTED = 2,
                STATE_TO_INDEX = [0, 1, 2, 2],
                TOLERANCE = 1,
                SELECTIONS = {
                    none: null,
                    single: -1,
                    multiple: NaN
                };

            function getSelection(selectionMode) {
                var selection = _normalizeEnum(selectionMode);
                selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;
                if (null !== selection) {
                    selection = {
                        state: {},
                        single: selection
                    }
                }
                return selection
            }

            function EmptySource() {}
            EmptySource.prototype.count = function() {
                return 0
            };

            function ArraySource(raw) {
                this.raw = raw
            }
            ArraySource.prototype = {
                constructor: ArraySource,
                count: function() {
                    return this.raw.length
                },
                item: function(index) {
                    return this.raw[index]
                },
                geometry: function(item) {
                    return {
                        coordinates: item.coordinates
                    }
                },
                attributes: function(item) {
                    return item.attributes
                }
            };

            function GeoJsonSource(raw) {
                this.raw = raw
            }
            GeoJsonSource.prototype = {
                constructor: GeoJsonSource,
                count: function() {
                    return this.raw.features.length
                },
                item: function(index) {
                    return this.raw.features[index]
                },
                geometry: function(item) {
                    return item.geometry
                },
                attributes: function(item) {
                    return item.properties
                }
            };

            function isGeoJsonObject(obj) {
                return _isArray(obj.features)
            }

            function unwrapFromDataSource(source) {
                var sourceType;
                if (source) {
                    if (isGeoJsonObject(source)) {
                        sourceType = GeoJsonSource
                    } else {
                        if (1 === source.length && source[0] && isGeoJsonObject(source[0])) {
                            sourceType = GeoJsonSource;
                            source = source[0]
                        } else {
                            if (_isArray(source)) {
                                sourceType = ArraySource
                            }
                        }
                    }
                }
                sourceType = sourceType || EmptySource;
                return new sourceType(source)
            }

            function wrapToDataSource(option) {
                return option ? isGeoJsonObject(option) ? [option] : option : []
            }

            function customizeHandles(proxies, callback, widget) {
                callback.call(widget, proxies)
            }

            function customizeHandles_deprecated(proxies, callback) {
                var i, proxy, settings, ii = proxies.length;
                for (i = 0; i < ii; ++i) {
                    proxy = proxies[i];
                    settings = callback.call(proxy, proxy) || {};
                    proxy.applySettings(settings);
                    if (settings.isSelected) {
                        proxy.selected(true)
                    }
                }
            }

            function patchProxies(handles, name, data) {
                var i, dataItem, type = {
                        areas: "area",
                        markers: "marker"
                    }[name],
                    ii = handles.length;
                for (i = 0; i < ii; ++i) {
                    handles[i].proxy.type = type
                }
                if ("marker" === type) {
                    for (i = 0; i < ii; ++i) {
                        dataItem = data.item(i);
                        _extend(handles[i].proxy, {
                            text: dataItem.text,
                            value: dataItem.value,
                            values: dataItem.values,
                            url: dataItem.url
                        })
                    }
                }
            }

            function setAreaLabelVisibility(label) {
                label.text.attr({
                    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : "hidden"
                })
            }

            function setLineLabelVisibility(label) {
                label.text.attr({
                    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : "hidden"
                })
            }

            function getDataValue(proxy, dataField, deprecatedField) {
                return proxy.attribute(dataField) || proxy[deprecatedField]
            }
            var TYPE_TO_TYPE_MAP = {
                Point: TYPE_MARKER,
                MultiPoint: TYPE_LINE,
                LineString: TYPE_LINE,
                MultiLineString: TYPE_LINE,
                Polygon: TYPE_AREA,
                MultiPolygon: TYPE_AREA
            };

            function guessTypeByData(sample) {
                var type = TYPE_TO_TYPE_MAP[sample.type],
                    coordinates = sample.coordinates;
                if (!type) {
                    if ("number" === typeof coordinates[0]) {
                        type = TYPE_MARKER
                    } else {
                        if ("number" === typeof coordinates[0][0]) {
                            type = TYPE_LINE
                        } else {
                            type = TYPE_AREA
                        }
                    }
                }
                return type
            }
            var selectStrategy = function(options, data) {
                var sample, type = _normalizeEnum(options.type),
                    elementType = _normalizeEnum(options.elementType),
                    strategy = _extend({}, emptyStrategy);
                if (data.count() > 0) {
                    sample = data.geometry(data.item(0));
                    type = strategiesByType[type] ? type : guessTypeByData(sample);
                    _extend(strategy, strategiesByType[type]);
                    strategy.fullType = strategy.type = type;
                    if (strategiesByGeometry[type]) {
                        _extend(strategy, strategiesByGeometry[type](sample))
                    }
                    if (strategiesByElementType[type]) {
                        elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;
                        _extend(strategy, strategiesByElementType[type][elementType]);
                        strategy.elementType = elementType;
                        strategy.fullType += ":" + elementType
                    }
                }
                return strategy
            };

            function applyElementState(figure, styles, state, field) {
                figure[field].attr(styles[field][state])
            }
            var emptyStrategy = {
                setup: _noop,
                reset: _noop,
                arrange: _noop,
                updateGrouping: _noop
            };
            var strategiesByType = {};
            strategiesByType[TYPE_AREA] = {
                projectLabel: projectAreaLabel,
                transform: transformPointList,
                transformLabel: transformAreaLabel,
                draw: function(context, figure, data) {
                    figure.root = context.renderer.path([], "area").data(context.dataKey, data)
                },
                refresh: _noop,
                getLabelOffset: function(label) {
                    setAreaLabelVisibility(label);
                    return [0, 0]
                },
                getStyles: function(settings) {
                    var color = settings.color || null,
                        borderColor = settings.borderColor || null,
                        borderWidth = settings.borderWidth || null,
                        opacity = settings.opacity || null;
                    return {
                        root: [{
                            "class": "dxm-area",
                            stroke: borderColor,
                            "stroke-width": borderWidth,
                            fill: color,
                            opacity: opacity
                        }, {
                            "class": "dxm-area dxm-area-hovered",
                            stroke: settings.hoveredBorderColor || borderColor,
                            "stroke-width": settings.hoveredBorderWidth || borderWidth,
                            fill: settings.hoveredColor || color,
                            opacity: settings.hoveredOpacity || opacity
                        }, {
                            "class": "dxm-area dxm-area-selected",
                            stroke: settings.selectedBorderColor || borderColor,
                            "stroke-width": settings.selectedBorderWidth || borderWidth,
                            fill: settings.selectedColor || color,
                            opacity: settings.selectedOpacity || opacity
                        }]
                    }
                },
                setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "root")
                },
                hasLabelsGroup: true,
                updateGrouping: function(context) {
                    groupByColor(context)
                }
            };
            strategiesByType[TYPE_LINE] = {
                projectLabel: projectLineLabel,
                transform: transformPointList,
                transformLabel: transformLineLabel,
                draw: function(context, figure, data) {
                    figure.root = context.renderer.path([], "line").data(context.dataKey, data)
                },
                refresh: _noop,
                getLabelOffset: function(label) {
                    setLineLabelVisibility(label);
                    return [0, 0]
                },
                getStyles: function(settings) {
                    var color = settings.color || settings.borderColor || null,
                        width = settings.borderWidth || null,
                        opacity = settings.opacity || null;
                    return {
                        root: [{
                            "class": "dxm-line",
                            stroke: color,
                            "stroke-width": width,
                            opacity: opacity
                        }, {
                            "class": "dxm-line dxm-line-hovered",
                            stroke: settings.hoveredColor || settings.hoveredBorderColor || color,
                            "stroke-width": settings.hoveredBorderWidth || width,
                            opacity: settings.hoveredOpacity || opacity
                        }, {
                            "class": "dxm-line dxm-line-selected",
                            stroke: settings.selectedColor || settings.selectedBorderColor || color,
                            "stroke-width": settings.selectedBorderWidth || width,
                            opacity: settings.selectedOpacity || opacity
                        }]
                    }
                },
                setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "root")
                },
                hasLabelsGroup: true,
                updateGrouping: function(context) {
                    groupByColor(context)
                }
            };
            strategiesByType[TYPE_MARKER] = {
                project: projectPoint,
                transform: transformPoint,
                draw: function(context, figure, data) {
                    figure.root = context.renderer.g();
                    this._draw(context, figure, data)
                },
                refresh: _noop,
                hasLabelsGroup: false,
                getLabelOffset: function(label, settings) {
                    return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0]
                },
                getStyles: function(settings) {
                    var styles = {
                        root: [{
                            "class": "dxm-marker"
                        }, {
                            "class": "dxm-marker dxm-marker-hovered"
                        }, {
                            "class": "dxm-marker dxm-marker-selected"
                        }]
                    };
                    this._getStyles(styles, settings);
                    return styles
                },
                setState: function(figure, styles, state) {
                    applyElementState(figure, styles, state, "root");
                    this._setState(figure, styles, state)
                },
                updateGrouping: function(context) {
                    groupByColor(context);
                    groupBySize(context)
                }
            };
            var strategiesByGeometry = {};
            strategiesByGeometry[TYPE_AREA] = function(sample) {
                var coordinates = sample.coordinates;
                return {
                    project: coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && "number" === typeof coordinates[0][0][0][0] ? projectMultiPolygon : projectPolygon
                }
            };
            strategiesByGeometry[TYPE_LINE] = function(sample) {
                var coordinates = sample.coordinates;
                return {
                    project: coordinates[0] && coordinates[0][0] && "number" === typeof coordinates[0][0][0] ? projectPolygon : projectLineString
                }
            };
            var strategiesByElementType = {};
            strategiesByElementType[TYPE_MARKER] = {
                _default: "dot",
                dot: {
                    setup: function(context) {
                        context.filter = context.renderer.shadowFilter("-40%", "-40%", "180%", "200%", 0, 1, 1, "#000000", .2)
                    },
                    reset: function(context) {
                        context.filter.dispose();
                        context.filter = null
                    },
                    _draw: function(ctx, figure, data) {
                        figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
                        figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                    },
                    refresh: function(ctx, figure, data, proxy, settings) {
                        figure.dot.attr({
                            filter: settings.shadow ? ctx.filter.ref : null
                        })
                    },
                    _getStyles: function(styles, style) {
                        var size = style.size > 0 ? _Number(style.size) : 0,
                            hoveredSize = size,
                            selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0),
                            hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0),
                            selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0),
                            color = style.color || null,
                            borderColor = style.borderColor || null,
                            borderWidth = style.borderWidth || null,
                            opacity = style.opacity || null,
                            backColor = style.backColor || null,
                            backOpacity = style.backOpacity || null;
                        styles.dot = [{
                            r: size / 2,
                            stroke: borderColor,
                            "stroke-width": borderWidth,
                            fill: color,
                            opacity: opacity
                        }, {
                            r: hoveredSize / 2,
                            stroke: style.hoveredBorderColor || borderColor,
                            "stroke-width": style.hoveredBorderWidth || borderWidth,
                            fill: style.hoveredColor || color,
                            opacity: style.hoveredOpacity || opacity
                        }, {
                            r: selectedSize / 2,
                            stroke: style.selectedBorderColor || borderColor,
                            "stroke-width": style.selectedBorderWidth || borderWidth,
                            fill: style.selectedColor || color,
                            opacity: style.selectedOpacity || opacity
                        }];
                        styles.back = [{
                            r: size / 2,
                            stroke: "none",
                            "stroke-width": 0,
                            fill: backColor,
                            opacity: backOpacity
                        }, {
                            r: hoveredBackSize / 2,
                            stroke: "none",
                            "stroke-width": 0,
                            fill: backColor,
                            opacity: backOpacity
                        }, {
                            r: selectedBackSize / 2,
                            stroke: "none",
                            "stroke-width": 0,
                            fill: backColor,
                            opacity: backOpacity
                        }]
                    },
                    _setState: function(figure, styles, state) {
                        applyElementState(figure, styles, state, "dot");
                        applyElementState(figure, styles, state, "back")
                    }
                },
                bubble: {
                    _draw: function(ctx, figure, data) {
                        figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                    },
                    refresh: function(ctx, figure, data, proxy, settings) {
                        figure.bubble.attr({
                            r: settings.size / 2
                        })
                    },
                    _getStyles: function(styles, style) {
                        var color = style.color || null,
                            borderColor = style.borderColor || null,
                            borderWidth = style.borderWidth || null,
                            opacity = style.opacity || null;
                        styles.bubble = [{
                            stroke: borderColor,
                            "stroke-width": borderWidth,
                            fill: color,
                            opacity: opacity
                        }, {
                            stroke: style.hoveredBorderColor || borderColor,
                            "stroke-width": style.hoveredBorderWidth || borderWidth,
                            fill: style.hoveredColor || style.color,
                            opacity: style.hoveredOpacity || opacity
                        }, {
                            stroke: style.selectedBorderColor || borderColor,
                            "stroke-width": style.selectedBorderWidth || borderWidth,
                            fill: style.selectedColor || style.color,
                            opacity: style.selectedOpacity || opacity
                        }]
                    },
                    _setState: function(figure, styles, state) {
                        applyElementState(figure, styles, state, "bubble")
                    },
                    arrange: function(context, handles) {
                        var i, minValue, maxValue, deltaValue, deltaSize, values = [],
                            ii = values.length = handles.length,
                            settings = context.settings,
                            dataField = settings.dataField,
                            minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0,
                            maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;
                        if (settings.sizeGroups) {
                            return
                        }
                        for (i = 0; i < ii; ++i) {
                            values[i] = _max(getDataValue(handles[i].proxy, dataField, "value") || 0, 0)
                        }
                        minValue = _min.apply(null, values);
                        maxValue = _max.apply(null, values);
                        deltaValue = maxValue - minValue || 1;
                        deltaSize = maxSize - minSize;
                        for (i = 0; i < ii; ++i) {
                            handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue
                        }
                    },
                    updateGrouping: function(context) {
                        var dataField = context.settings.dataField;
                        strategiesByType[TYPE_MARKER].updateGrouping(context);
                        groupBySize(context, function(proxy) {
                            return getDataValue(proxy, dataField, "value")
                        })
                    }
                },
                pie: {
                    _draw: function(ctx, figure, data) {
                        figure.pie = ctx.renderer.g().append(figure.root);
                        figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root)
                    },
                    refresh: function(ctx, figure, data, proxy, settings) {
                        var i, values = getDataValue(proxy, ctx.settings.dataField, "values") || [],
                            ii = values.length || 0,
                            colors = settings._colors,
                            sum = 0,
                            pie = figure.pie,
                            renderer = ctx.renderer,
                            dataKey = ctx.dataKey,
                            r = (settings.size > 0 ? _Number(settings.size) : 0) / 2,
                            start = 90,
                            end = start;
                        for (i = 0; i < ii; ++i) {
                            sum += values[i] || 0
                        }
                        for (i = 0; i < ii; ++i) {
                            start = end;
                            end += (values[i] || 0) / sum * 360;
                            renderer.arc(0, 0, 0, r, start, end).attr({
                                "stroke-linejoin": "round",
                                fill: colors[i]
                            }).data(dataKey, data).append(pie)
                        }
                        figure.border.attr({
                            r: r
                        })
                    },
                    _getStyles: function(styles, style) {
                        var opacity = style.opacity || null,
                            borderColor = style.borderColor || null,
                            borderWidth = style.borderWidth || null;
                        styles.pie = [{
                            opacity: opacity
                        }, {
                            opacity: style.hoveredOpacity || opacity
                        }, {
                            opacity: style.selectedOpacity || opacity
                        }];
                        styles.border = [{
                            stroke: borderColor,
                            "stroke-width": borderWidth
                        }, {
                            stroke: style.hoveredBorderColor || borderColor,
                            "stroke-width": style.hoveredBorderWidth || borderWidth
                        }, {
                            stroke: style.selectedBorderColor || borderColor,
                            "stroke-width": style.selectedBorderWidth || borderWidth
                        }]
                    },
                    _setState: function(figure, styles, state) {
                        applyElementState(figure, styles, state, "pie");
                        applyElementState(figure, styles, state, "border")
                    },
                    arrange: function(context, handles) {
                        var i, values, palette, ii = handles.length,
                            dataField = context.settings.dataField,
                            count = 0;
                        for (i = 0; i < ii; ++i) {
                            values = getDataValue(handles[i].proxy, dataField, "values");
                            if (values && values.length > count) {
                                count = values.length
                            }
                        }
                        if (count > 0) {
                            values = [];
                            palette = context.params.themeManager.createPalette(context.settings.palette, {
                                useHighlight: true
                            });
                            for (i = 0; i < count; ++i) {
                                values.push(palette.getNextColor())
                            }
                            context.settings._colors = values;
                            context.grouping.color = {
                                callback: _noop,
                                field: "",
                                partition: [],
                                values: []
                            };
                            context.params.dataExchanger.set(context.name, "color", {
                                partition: [],
                                values: values
                            })
                        }
                    }
                },
                image: {
                    _draw: function(ctx, figure, data) {
                        figure.image = ctx.renderer.image().attr({
                            location: "center"
                        }).data(ctx.dataKey, data).append(figure.root)
                    },
                    refresh: function(ctx, figure, data, proxy, settings) {
                        figure.image.attr({
                            href: getDataValue(proxy, ctx.settings.dataField, "url")
                        })
                    },
                    _getStyles: function(styles, style) {
                        var size = style.size > 0 ? _Number(style.size) : 0,
                            hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0),
                            selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0),
                            opacity = style.opacity || null;
                        styles.image = [{
                            x: -size / 2,
                            y: -size / 2,
                            width: size,
                            height: size,
                            opacity: opacity
                        }, {
                            x: -hoveredSize / 2,
                            y: -hoveredSize / 2,
                            width: hoveredSize,
                            height: hoveredSize,
                            opacity: style.hoveredOpacity || opacity
                        }, {
                            x: -selectedSize / 2,
                            y: -selectedSize / 2,
                            width: selectedSize,
                            height: selectedSize,
                            opacity: style.selectedOpacity || opacity
                        }]
                    },
                    _setState: function(figure, styles, state) {
                        applyElementState(figure, styles, state, "image")
                    }
                }
            };

            function projectPoint(projection, coordinates) {
                return projection.project(coordinates)
            }

            function projectPointList(projection, coordinates) {
                var i, output = [],
                    ii = output.length = coordinates.length;
                for (i = 0; i < ii; ++i) {
                    output[i] = projection.project(coordinates[i])
                }
                return output
            }

            function projectLineString(projection, coordinates) {
                return [projectPointList(projection, coordinates)]
            }

            function projectPolygon(projection, coordinates) {
                var i, output = [],
                    ii = output.length = coordinates.length;
                for (i = 0; i < ii; ++i) {
                    output[i] = projectPointList(projection, coordinates[i])
                }
                return output
            }

            function projectMultiPolygon(projection, coordinates) {
                var i, output = [],
                    ii = output.length = coordinates.length;
                for (i = 0; i < ii; ++i) {
                    output[i] = projectPolygon(projection, coordinates[i])
                }
                return _concat.apply([], output)
            }

            function transformPoint(content, projection, coordinates) {
                var data = projection.transform(coordinates);
                content.root.attr({
                    translateX: data[0],
                    translateY: data[1]
                })
            }

            function transformList(projection, coordinates) {
                var i, item, output = [],
                    ii = coordinates.length,
                    k = 0;
                output.length = 2 * ii;
                for (i = 0; i < ii; ++i) {
                    item = projection.transform(coordinates[i]);
                    output[k++] = item[0];
                    output[k++] = item[1]
                }
                return output
            }

            function transformPointList(content, projection, coordinates) {
                var i, output = [],
                    ii = output.length = coordinates.length;
                for (i = 0; i < ii; ++i) {
                    output[i] = transformList(projection, coordinates[i])
                }
                content.root.attr({
                    points: output
                })
            }

            function transformAreaLabel(label, projection, coordinates) {
                var data = projection.transform(coordinates[0]);
                label.spaceSize = projection.getSquareSize(coordinates[1]);
                label.text.attr({
                    translateX: data[0],
                    translateY: data[1]
                });
                setAreaLabelVisibility(label)
            }

            function transformLineLabel(label, projection, coordinates) {
                var data = projection.transform(coordinates[0]);
                label.spaceSize = projection.getSquareSize(coordinates[1]);
                label.text.attr({
                    translateX: data[0],
                    translateY: data[1]
                });
                setLineLabelVisibility(label)
            }

            function getItemSettings(context, proxy, settings) {
                var result = combineSettings(context.settings, settings);
                proxy.text = proxy.text || settings.text;
                applyGrouping(context.grouping, proxy, result);
                if (void 0 === settings.color && settings.paletteIndex >= 0) {
                    result.color = result._colors[settings.paletteIndex]
                }
                return result
            }

            function applyGrouping(grouping, proxy, settings) {
                _each(grouping, function(name, data) {
                    var index = findGroupingIndex(data.callback(proxy, data.field), data.partition);
                    if (index >= 0) {
                        settings[name] = data.values[index]
                    }
                })
            }

            function findGroupingIndex(value, partition) {
                var middle, start = 0,
                    end = partition.length - 1,
                    index = -1;
                if (partition[start] <= value && value <= partition[end]) {
                    if (value === partition[end]) {
                        index = end - 1
                    } else {
                        while (end - start > 1) {
                            middle = start + end >> 1;
                            if (value < partition[middle]) {
                                end = middle
                            } else {
                                start = middle
                            }
                        }
                        index = start
                    }
                }
                return index
            }

            function raiseChanged(context, handle, state, name) {
                context.params.eventTrigger(name, {
                    target: handle.proxy,
                    state: state
                })
            }

            function combineSettings(common, partial) {
                var obj = _extend({}, common, partial);
                obj.label = _extend({}, common.label, obj.label);
                obj.label.font = _extend({}, common.label.font, obj.label.font);
                return obj
            }

            function processCommonSettings(type, options, themeManager) {
                var colors, i, palette, settings = combineSettings(themeManager.theme("layer:" + type) || {
                    label: {}
                }, options);
                if (settings.paletteSize > 0) {
                    palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);
                    for (i = 0, colors = []; i < settings.paletteSize; ++i) {
                        colors.push(palette.getColor(i))
                    }
                    settings._colors = colors
                }
                return settings
            }

            function valueCallback(proxy, dataField) {
                return proxy.attribute(dataField)
            }
            var performGrouping = function(context, partition, settingField, dataField, valuesCallback) {
                var values;
                if (dataField && partition && partition.length > 1) {
                    values = valuesCallback(partition.length - 1);
                    context.grouping[settingField] = {
                        callback: _isFunction(dataField) ? dataField : valueCallback,
                        field: dataField,
                        partition: partition,
                        values: values
                    };
                    context.params.dataExchanger.set(context.name, settingField, {
                        partition: partition,
                        values: values
                    })
                }
            };

            function dropGrouping(context) {
                var name = context.name,
                    dataExchanger = context.params.dataExchanger;
                _each(context.grouping, function(field) {
                    dataExchanger.set(name, field, null)
                });
                context.grouping = {}
            }
            var groupByColor = function(context) {
                performGrouping(context, context.settings.colorGroups, "color", context.settings.colorGroupingField, function(count) {
                    var i, _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count),
                        list = [];
                    for (i = 0; i < count; ++i) {
                        list.push(_palette.getColor(i))
                    }
                    return list
                })
            };
            var groupBySize = function(context, valueCallback) {
                var settings = context.settings;
                performGrouping(context, settings.sizeGroups, "size", valueCallback || settings.sizeGroupingField, function(count) {
                    var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0,
                        maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0,
                        i = 0,
                        sizes = [];
                    if (count > 1) {
                        for (i = 0; i < count; ++i) {
                            sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1))
                        }
                    } else {
                        if (1 === count) {
                            sizes.push((minSize + maxSize) / 2)
                        }
                    }
                    return sizes
                })
            };

            function setFlag(flags, flag, state) {
                if (state) {
                    flags |= flag
                } else {
                    flags &= ~flag
                }
                return flags
            }

            function hasFlag(flags, flag) {
                return !!(flags & flag)
            }

            function createLayerProxy(layer, name, index) {
                var proxy = {
                    index: index,
                    name: name,
                    getElements: function() {
                        return layer.getProxies()
                    },
                    clearSelection: function(_noEvent) {
                        layer.clearSelection(_noEvent);
                        return proxy
                    }
                };
                return proxy
            }
            var MapLayer = function(params, container, name, index) {
                var that = this;
                that._params = params;
                that._onProjection();
                that.proxy = createLayerProxy(that, name, index);
                that._context = {
                    name: name,
                    layer: that.proxy,
                    renderer: params.renderer,
                    projection: params.projection,
                    params: params,
                    dataKey: params.dataKey,
                    str: emptyStrategy,
                    hover: false,
                    selection: null,
                    grouping: {},
                    root: params.renderer.g().attr({
                        "class": "dxm-layer"
                    }).linkOn(container, name).linkAppend()
                };
                that._container = container;
                that._dataSource = new dataSourceModule.DataSource(function() {
                    that._data = unwrapFromDataSource(that._dataSource.items());
                    that._update(true)
                });
                that._options = {};
                that._handles = [];
                that._data = new EmptySource
            };
            MapLayer.prototype = {
                constructor: MapLayer,
                _onProjection: function() {
                    var that = this;
                    that._removeHandlers = that._params.projection.on({
                        engine: function() {
                            that._project()
                        },
                        screen: function() {
                            that._transform()
                        },
                        center: function() {
                            that._transformCore()
                        },
                        zoom: function() {
                            that._transform()
                        }
                    })
                },
                _offProjection: function() {
                    this._removeHandlers();
                    this._removeHandlers = null
                },
                dispose: function() {
                    var that = this;
                    that._dataSource.dispose();
                    that._destroyHandles();
                    dropGrouping(that._context);
                    that._context.root.linkRemove().linkOff();
                    that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();
                    that._context.str.reset(that._context);
                    that._offProjection();
                    that._params = that._container = that._context = that._dataSource = that.proxy = null;
                    return that
                },
                TESTS_getContext: function() {
                    return this._context
                },
                setOptions: function(options) {
                    var name, that = this;
                    options = that._options = options || {};
                    name = !("dataSource" in options) && "data" in options ? "data" : "dataSource";
                    if (name in options && options[name] !== that._options_dataSource) {
                        that._options_dataSource = options[name];
                        that._params.notifyDirty();
                        that._dataSource.update(wrapToDataSource(options[name]))
                    } else {
                        if (that._data.count() > 0) {
                            that._params.notifyDirty();
                            that._update(void 0 !== options.type && options.type !== that._context.str.type || void 0 !== options.elementType && options.elementType !== that._context.str.elementType)
                        }
                    }
                },
                _update: function(isContextChanged) {
                    var that = this,
                        context = that._context;
                    if (isContextChanged) {
                        context.str.reset(context);
                        context.root.clear();
                        context.labelRoot && context.labelRoot.clear();
                        that._params.tracker.reset();
                        that._destroyHandles();
                        context.str = selectStrategy(that._options, that._data);
                        context.str.setup(context);
                        that.proxy.type = context.str.type;
                        that.proxy.elementType = context.str.elementType
                    }
                    context.settings = processCommonSettings(context.str.fullType, that._options, that._params.themeManager);
                    context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);
                    context.hover = !!_parseScalar(context.settings.hoverEnabled, true);
                    if (context.selection) {
                        _each(context.selection.state, function(_, handle) {
                            handle && handle.resetSelected()
                        })
                    }
                    context.selection = getSelection(context.settings.selectionMode);
                    if (context.hasSeparateLabel) {
                        if (!context.labelRoot) {
                            context.labelRoot = context.renderer.g().attr({
                                "class": "dxm-layer-labels"
                            }).linkOn(that._container, {
                                name: context.name + "-labels",
                                after: context.name
                            }).linkAppend();
                            that._transformCore()
                        }
                    } else {
                        if (context.labelRoot) {
                            context.labelRoot.linkRemove().linkOff();
                            context.labelRoot = null
                        }
                    }
                    if (isContextChanged) {
                        that._createHandles()
                    }
                    dropGrouping(context);
                    context.str.arrange(context, that._handles);
                    context.str.updateGrouping(context);
                    that._updateHandles();
                    that._params.notifyReady()
                },
                _destroyHandles: function() {
                    var i, handles = this._handles,
                        ii = handles.length;
                    for (i = 0; i < ii; ++i) {
                        handles[i].dispose()
                    }
                    if (this._context.selection) {
                        this._context.selection.state = {}
                    }
                    this._handles = []
                },
                _createHandles: function() {
                    var i, handle, dataItem, that = this,
                        handles = that._handles = [],
                        data = that._data,
                        ii = handles.length = data.count(),
                        context = that._context,
                        geometry = data.geometry,
                        attributes = data.attributes;
                    for (i = 0; i < ii; ++i) {
                        dataItem = data.item(i);
                        handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem))
                    }
                    if (_isFunction(that._options.customize)) {
                        (that._options._deprecated ? customizeHandles_deprecated : customizeHandles)(that.getProxies(), that._options.customize, that._params.widget)
                    }
                    if (that._options._deprecated) {
                        patchProxies(handles, context.name, data)
                    }
                    for (i = 0; i < ii; ++i) {
                        handle = handles[i];
                        handle.project();
                        handle.draw();
                        handle.transform()
                    }
                    if (context.selection) {
                        _each(context.selection.state, function(_, handle) {
                            handle && handle.restoreSelected()
                        })
                    }
                },
                _updateHandles: function() {
                    var i, handles = this._handles,
                        ii = handles.length;
                    for (i = 0; i < ii; ++i) {
                        handles[i].refresh()
                    }
                    if (this._context.settings.label.enabled) {
                        for (i = 0; i < ii; ++i) {
                            handles[i].measureLabel()
                        }
                        for (i = 0; i < ii; ++i) {
                            handles[i].adjustLabel()
                        }
                    }
                },
                _transformCore: function() {
                    var transform = this._params.projection.getTransform();
                    this._context.root.attr(transform);
                    this._context.labelRoot && this._context.labelRoot.attr(transform)
                },
                _project: function() {
                    var i, handles = this._handles,
                        ii = handles.length;
                    for (i = 0; i < ii; ++i) {
                        handles[i].project()
                    }
                },
                _transform: function() {
                    var i, handles = this._handles,
                        ii = handles.length;
                    this._transformCore();
                    for (i = 0; i < ii; ++i) {
                        handles[i].transform()
                    }
                },
                getProxies: function() {
                    var i, handles = this._handles,
                        proxies = [],
                        ii = proxies.length = handles.length;
                    for (i = 0; i < ii; ++i) {
                        proxies[i] = handles[i].proxy
                    }
                    return proxies
                },
                getProxy: function(index) {
                    return this._handles[index].proxy
                },
                raiseClick: function(i, jQueryEvent) {
                    this._params.eventTrigger("click", {
                        target: this._handles[i].proxy,
                        jQueryEvent: jQueryEvent
                    })
                },
                hoverItem: function(i, state) {
                    this._handles[i].setHovered(state)
                },
                selectItem: function(i, state, _noEvent) {
                    this._handles[i].setSelected(state, _noEvent)
                },
                clearSelection: function() {
                    var selection = this._context.selection;
                    if (selection) {
                        _each(selection.state, function(_, handle) {
                            handle && handle.setSelected(false)
                        });
                        selection.state = {}
                    }
                }
            };

            function createProxy(handle, coords, attrs) {
                var proxy = {
                    coordinates: function() {
                        return coords
                    },
                    attribute: function(name, value) {
                        if (arguments.length > 1) {
                            attrs[name] = value;
                            return proxy
                        } else {
                            return arguments.length > 0 ? attrs[name] : attrs
                        }
                    },
                    selected: function(state, _noEvent) {
                        if (arguments.length > 0) {
                            handle.setSelected(state, _noEvent);
                            return proxy
                        } else {
                            return handle.isSelected()
                        }
                    },
                    applySettings: function(settings) {
                        handle.update(settings);
                        return proxy
                    }
                };
                return proxy
            }
            var MapLayerElement = function(context, index, geometry, attributes) {
                var that = this,
                    proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));
                that._ctx = context;
                that._idx = index;
                that._fig = that._lbl = null;
                that._state = STATE_DEFAULT;
                that._coordinates = geometry.coordinates;
                that._settings = {
                    label: {}
                };
                proxy.index = index;
                proxy.layer = context.layer;
                that._data = {
                    name: context.name,
                    index: index
                }
            };
            MapLayerElement.prototype = {
                constructor: MapLayerElement,
                dispose: function() {
                    var that = this;
                    that._ctx = that.proxy = that._settings = that._fig = that._lbl = that.data = null;
                    return that
                },
                project: function() {
                    var context = this._ctx;
                    this._prj = context.str.project(context.projection, this._coordinates);
                    if (context.hasSeparateLabel && this._lbl) {
                        this._projectLabel()
                    }
                },
                _projectLabel: function() {
                    this._labelPrj = this._ctx.str.projectLabel(this._prj)
                },
                draw: function() {
                    var that = this,
                        context = this._ctx;
                    context.str.draw(context, that._fig = {}, that._data);
                    that._fig.root.append(context.root)
                },
                transform: function() {
                    var that = this,
                        context = that._ctx;
                    context.str.transform(that._fig, context.projection, that._prj);
                    if (context.hasSeparateLabel && that._lbl) {
                        that._transformLabel()
                    }
                },
                _transformLabel: function() {
                    this._ctx.str.transformLabel(this._lbl, this._ctx.projection, this._labelPrj)
                },
                refresh: function() {
                    var that = this,
                        strategy = that._ctx.str,
                        settings = getItemSettings(that._ctx, that.proxy, that._settings);
                    that._styles = strategy.getStyles(settings);
                    strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);
                    that._refreshLabel(settings);
                    that._setState()
                },
                _refreshLabel: function(settings) {
                    var that = this,
                        context = that._ctx,
                        labelSettings = settings.label,
                        label = that._lbl;
                    if (context.settings.label.enabled) {
                        if (!label) {
                            label = that._lbl = {
                                root: context.labelRoot || that._fig.root,
                                text: context.renderer.text().attr({
                                    "class": "dxm-label"
                                }),
                                size: [0, 0]
                            };
                            if (context.hasSeparateLabel) {
                                that._projectLabel();
                                that._transformLabel()
                            }
                        }
                        label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || "");
                        if (label.value) {
                            label.text.attr({
                                text: label.value,
                                x: 0,
                                y: 0
                            }).css(_patchFontOptions(labelSettings.font)).attr({
                                align: "center",
                                stroke: labelSettings.stroke,
                                "stroke-width": labelSettings["stroke-width"],
                                "stroke-opacity": labelSettings["stroke-opacity"]
                            }).data(context.dataKey, that._data).append(label.root);
                            label.settings = settings
                        }
                    } else {
                        if (label) {
                            label.text.remove();
                            that._lbl = null
                        }
                    }
                },
                measureLabel: function() {
                    var bbox, label = this._lbl;
                    if (label.value) {
                        bbox = label.text.getBBox();
                        label.size = [bbox.width, bbox.height, -bbox.y - bbox.height / 2]
                    }
                },
                adjustLabel: function() {
                    var offset, label = this._lbl;
                    if (label.value) {
                        offset = this._ctx.str.getLabelOffset(label, label.settings);
                        label.settings = null;
                        label.text.attr({
                            x: offset[0],
                            y: offset[1] + label.size[2]
                        })
                    }
                },
                update: function(settings) {
                    var that = this;
                    that._settings = combineSettings(that._settings, settings);
                    if (that._fig) {
                        that.refresh();
                        if (that._lbl && that._lbl.value) {
                            that.measureLabel();
                            that.adjustLabel()
                        }
                    }
                },
                _setState: function() {
                    this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state])
                },
                _setForeground: function() {
                    var root = this._fig.root;
                    this._state ? root.toForeground() : root.toBackground()
                },
                setHovered: function(state) {
                    var that = this,
                        currentState = hasFlag(that._state, STATE_HOVERED),
                        newState = !!state;
                    if (that._ctx.hover && currentState !== newState) {
                        that._state = setFlag(that._state, STATE_HOVERED, newState);
                        that._setState();
                        that._setForeground();
                        raiseChanged(that._ctx, that, newState, "hoverChanged")
                    }
                    return that
                },
                setSelected: function(state, _noEvent) {
                    var tmp, that = this,
                        currentState = hasFlag(that._state, STATE_SELECTED),
                        newState = !!state,
                        selection = that._ctx.selection;
                    if (selection && currentState !== newState) {
                        that._state = setFlag(that._state, STATE_SELECTED, newState);
                        tmp = selection.state[selection.single];
                        selection.state[selection.single] = null;
                        if (tmp) {
                            tmp.setSelected(false)
                        }
                        selection.state[selection.single || that._idx] = state ? that : null;
                        if (that._fig) {
                            that._setState();
                            that._setForeground();
                            if (!_noEvent) {
                                raiseChanged(that._ctx, that, newState, "selectionChanged")
                            }
                        }
                    }
                },
                isSelected: function() {
                    return hasFlag(this._state, STATE_SELECTED)
                },
                resetSelected: function() {
                    this._state = setFlag(this._state, STATE_SELECTED, false)
                },
                restoreSelected: function() {
                    this._fig.root.toForeground()
                }
            };

            function calculatePolygonCentroid(coordinates) {
                var i, v1, cross, length = coordinates.length,
                    v2 = coordinates[length - 1],
                    cx = 0,
                    cy = 0,
                    area = 0,
                    minX = 1 / 0,
                    maxX = -(1 / 0),
                    minY = 1 / 0,
                    maxY = -(1 / 0);
                for (i = 0; i < length; ++i) {
                    v1 = v2;
                    v2 = coordinates[i];
                    cross = v1[0] * v2[1] - v2[0] * v1[1];
                    area += cross;
                    cx += (v1[0] + v2[0]) * cross;
                    cy += (v1[1] + v2[1]) * cross;
                    minX = _min(minX, v2[0]);
                    maxX = _max(maxX, v2[0]);
                    minY = _min(minY, v2[1]);
                    maxY = _max(maxY, v2[1])
                }
                return {
                    area: _abs(area) / 2,
                    center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]
                }
            }

            function calculateLineStringData(coordinates) {
                var i, v1, t, ii = coordinates.length,
                    v2 = coordinates[0] || [],
                    totalLength = 0,
                    items = [0],
                    min0 = v2[0],
                    max0 = v2[0],
                    min1 = v2[1],
                    max1 = v2[1];
                for (i = 1; i < ii; ++i) {
                    v1 = v2;
                    v2 = coordinates[i];
                    totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
                    items[i] = totalLength;
                    min0 = _min(min0, v2[0]);
                    max0 = _max(max0, v2[0]);
                    min1 = _min(min1, v2[1]);
                    max1 = _max(max1, v2[1])
                }
                i = findGroupingIndex(totalLength / 2, items);
                v1 = coordinates[i];
                v2 = coordinates[i + 1];
                t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);
                return ii ? [
                    [v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t],
                    [max0 - min0, max1 - min1], totalLength
                ] : []
            }

            function projectAreaLabel(coordinates) {
                var i, centroid, resultCentroid, ii = coordinates.length,
                    maxArea = 0;
                for (i = 0; i < ii; ++i) {
                    centroid = calculatePolygonCentroid(coordinates[i]);
                    if (centroid.area > maxArea) {
                        maxArea = centroid.area;
                        resultCentroid = centroid
                    }
                }
                return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [
                    [],
                    []
                ]
            }

            function projectLineLabel(coordinates) {
                var i, data, resultData, ii = coordinates.length,
                    maxLength = 0;
                for (i = 0; i < ii; ++i) {
                    data = calculateLineStringData(coordinates[i]);
                    if (data[2] > maxLength) {
                        maxLength = data[2];
                        resultData = data
                    }
                }
                return resultData || [
                    [],
                    []
                ]
            }

            function MapLayerCollection(params) {
                var that = this,
                    renderer = params.renderer;
                that._params = params;
                that._layers = [];
                that._layerByName = {};
                that._rect = [0, 0, 0, 0];
                that._clip = renderer.clipRect();
                that._background = renderer.rect().attr({
                    "class": "dxm-background"
                }).data(params.dataKey, {
                    name: "background"
                }).append(renderer.root);
                that._container = renderer.g().attr({
                    "class": "dxm-layers",
                    clipId: that._clip.id
                }).append(renderer.root).enableLinks();
                that._subscribeToTracker(params.tracker, renderer, params.eventTrigger)
            }
            MapLayerCollection.prototype = {
                constructor: MapLayerCollection,
                dispose: function() {
                    var that = this;
                    that._clip.dispose();
                    that._offTracker();
                    that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null
                },
                _subscribeToTracker: function(tracker, renderer, eventTrigger) {
                    var that = this;
                    that._offTracker = tracker.on({
                        click: function(arg) {
                            var offset = renderer.getRootOffset(),
                                layer = that.byName(arg.data.name);
                            arg.$event.x = arg.x - offset.left;
                            arg.$event.y = arg.y - offset.top;
                            if (layer) {
                                layer.raiseClick(arg.data.index, arg.$event)
                            } else {
                                if ("background" === arg.data.name) {
                                    eventTrigger("click", {
                                        jQueryEvent: arg.$event
                                    })
                                }
                            }
                        },
                        "hover-on": function(arg) {
                            var layer = that.byName(arg.data.name);
                            if (layer) {
                                layer.hoverItem(arg.data.index, true)
                            }
                        },
                        "hover-off": function(arg) {
                            var layer = that.byName(arg.data.name);
                            if (layer) {
                                layer.hoverItem(arg.data.index, false)
                            }
                        }
                    })
                },
                setOptions: function(options) {
                    var name, layer, i, ii, optionList = options ? options.length ? options : [options] : [],
                        layers = this._layers,
                        layerByName = this._layerByName,
                        params = this._params,
                        container = this._container;
                    for (i = optionList.length, ii = layers.length; i < ii; ++i) {
                        layer = layers[i];
                        delete layerByName[layer.proxy.name];
                        layer.dispose()
                    }
                    layers.splice(optionList.length, layers.length - optionList.length);
                    for (i = layers.length, ii = optionList.length; i < ii; ++i) {
                        name = (optionList[i] || {}).name || "map-layer-" + i;
                        layer = layers[i] = new MapLayer(params, container, name, i);
                        layerByName[name] = layer
                    }
                    for (i = 0, ii = optionList.length; i < ii; ++i) {
                        name = optionList[i] && optionList[i].name;
                        layer = layers[i];
                        if (name && name !== layer.proxy.name) {
                            delete layerByName[layer.proxy.name];
                            layer.dispose();
                            layer = layers[i] = new MapLayer(params, container, name, i);
                            layerByName[name] = layer
                        }
                        layer.setOptions(optionList[i])
                    }
                },
                _updateClip: function() {
                    var rect = this._rect,
                        bw = this._bw;
                    this._clip.attr({
                        x: rect[0] + bw,
                        y: rect[1] + bw,
                        width: _max(rect[2] - 2 * bw, 0),
                        height: _max(rect[3] - 2 * bw, 0)
                    })
                },
                setBackgroundOptions: function(options) {
                    this._background.attr({
                        stroke: options.borderColor,
                        "stroke-width": options.borderWidth,
                        fill: options.color
                    });
                    this._bw = _max(options.borderWidth, 0);
                    this._updateClip()
                },
                setRect: function(rect) {
                    this._rect = rect;
                    this._background.attr({
                        x: rect[0],
                        y: rect[1],
                        width: rect[2],
                        height: rect[3]
                    });
                    this._updateClip()
                },
                byIndex: function(index) {
                    return this._layers[index]
                },
                byName: function(name) {
                    return this._layerByName[name]
                },
                items: function() {
                    return this._layers
                }
            };
            exports.MapLayerCollection = MapLayerCollection;
            exports._TESTS_MapLayer = MapLayer;
            exports._TESTS_stub_MapLayer = function(stub) {
                MapLayer = stub
            };
            exports._TESTS_selectStrategy = selectStrategy;
            exports._TESTS_stub_selectStrategy = function(stub) {
                selectStrategy = stub
            };
            exports._TESTS_MapLayerElement = MapLayerElement;
            exports._TESTS_stub_MapLayerElement = function(stub) {
                MapLayerElement = stub
            };
            exports._TESTS_createProxy = createProxy;
            exports._TESTS_stub_performGrouping = function(stub) {
                performGrouping = stub
            };
            exports._TESTS_performGrouping = performGrouping;
            exports._TESTS_stub_groupByColor = function(stub) {
                groupByColor = stub
            };
            exports._TESTS_groupByColor = groupByColor;
            exports._TESTS_stub_groupBySize = function(stub) {
                groupBySize = stub
            };
            exports._TESTS_groupBySize = groupBySize;
            exports._TESTS_findGroupingIndex = findGroupingIndex
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*************************************************!*\
      !*** ./Scripts/viz/vector_map/theme_manager.js ***!
      \*************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var BaseThemeManager = __webpack_require__( /*! ../core/base_theme_manager */ 103).BaseThemeManager;
            exports.ThemeManager = BaseThemeManager.inherit({
                _themeSection: "map",
                _fontFields: ["layer:area.label.font", "layer:marker:dot.label.font", "layer:marker:bubble.label.font", "layer:marker:pie.label.font", "layer:marker:image.label.font", "tooltip.font", "legend.font", "title.font", "title.subtitle.font", "loadingIndicator.font", "export.font"]
            })
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**************************************************!*\
      !*** ./Scripts/viz/vector_map/tooltip_viewer.js ***!
      \**************************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var TOOLTIP_OFFSET = 12;

            function TooltipViewer(params) {
                this._subscribeToTracker(params.tracker, params.tooltip, params.layerCollection)
            }
            TooltipViewer.prototype = {
                constructor: TooltipViewer,
                dispose: function() {
                    this._offTracker();
                    this._offTracker = null
                },
                _subscribeToTracker: function(tracker, tooltip, layerCollection) {
                    this._offTracker = tracker.on({
                        "focus-on": function(arg) {
                            var layer, proxy, result = false;
                            if (tooltip.isEnabled()) {
                                layer = layerCollection.byName(arg.data.name);
                                proxy = layer && layer.getProxy(arg.data.index);
                                if (proxy && tooltip.show(proxy, {
                                        x: 0,
                                        y: 0,
                                        offset: 0
                                    }, {
                                        target: proxy
                                    })) {
                                    tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET);
                                    result = true
                                }
                            }
                            arg.done(result)
                        },
                        "focus-move": function(arg) {
                            tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET)
                        },
                        "focus-off": function() {
                            tooltip.hide()
                        }
                    })
                }
            };
            exports.TooltipViewer = TooltipViewer
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!*******************************************!*\
      !*** ./Scripts/viz/vector_map/tracker.js ***!
      \*******************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _math = Math,
                _abs = _math.abs,
                _sqrt = _math.sqrt,
                _round = _math.round,
                eventEmitterModule = __webpack_require__( /*! ./event_emitter */ 348),
                eventUtils = __webpack_require__( /*! ../../events/utils */ 4),
                wheelEventName = __webpack_require__( /*! ../../events/core/wheel */ 78).name,
                _addNamespace = eventUtils.addNamespace,
                _parseScalar = __webpack_require__( /*! ../core/utils */ 6).parseScalar,
                _now = $.now,
                _NAME = "dxVectorMap",
                EVENTS = {};
            setupEvents();
            var EVENT_START = "start",
                EVENT_MOVE = "move",
                EVENT_END = "end",
                EVENT_ZOOM = "zoom",
                EVENT_HOVER_ON = "hover-on",
                EVENT_HOVER_OFF = "hover-off",
                EVENT_CLICK = "click",
                EVENT_FOCUS_ON = "focus-on",
                EVENT_FOCUS_MOVE = "focus-move",
                EVENT_FOCUS_OFF = "focus-off",
                CLICK_TIME_THRESHOLD = 500,
                CLICK_COORD_THRESHOLD_MOUSE = 5,
                CLICK_COORD_THRESHOLD_TOUCH = 20,
                DRAG_COORD_THRESHOLD_MOUSE = 5,
                DRAG_COORD_THRESHOLD_TOUCH = 10,
                FOCUS_ON_DELAY_MOUSE = 300,
                FOCUS_OFF_DELAY_MOUSE = 300,
                FOCUS_ON_DELAY_TOUCH = 300,
                FOCUS_OFF_DELAY_TOUCH = 400,
                FOCUS_COORD_THRESHOLD_MOUSE = 5,
                WHEEL_COOLDOWN = 50,
                WHEEL_DIRECTION_COOLDOWN = 300;

            function Tracker(parameters) {
                var that = this;
                that._root = parameters.root;
                that._createEventHandlers(parameters.dataKey);
                that._createProjectionHandlers(parameters.projection);
                that._initEvents();
                that._focus = new Focus(function(name, arg) {
                    that._fire(name, arg)
                });
                that._attachHandlers()
            }
            Tracker.prototype = {
                constructor: Tracker,
                dispose: function() {
                    var that = this;
                    that._detachHandlers();
                    that._disposeEvents();
                    that._focus.dispose();
                    that._root = that._focus = that._docHandlers = that._rootHandlers = null
                },
                _eventNames: [EVENT_START, EVENT_MOVE, EVENT_END, EVENT_ZOOM, EVENT_CLICK, EVENT_HOVER_ON, EVENT_HOVER_OFF, EVENT_FOCUS_ON, EVENT_FOCUS_OFF, EVENT_FOCUS_MOVE],
                _startClick: function(event, data) {
                    if (!data) {
                        return
                    }
                    var coords = getEventCoords(event);
                    this._clickState = {
                        x: coords.x,
                        y: coords.y,
                        threshold: isTouchEvent(event) ? CLICK_COORD_THRESHOLD_TOUCH : CLICK_COORD_THRESHOLD_MOUSE,
                        time: _now()
                    }
                },
                _endClick: function(event, data) {
                    var threshold, coords, state = this._clickState;
                    if (!state) {
                        return
                    }
                    if (_now() - state.time <= CLICK_TIME_THRESHOLD) {
                        threshold = state.threshold;
                        coords = getEventCoords(event);
                        if (_abs(coords.x - state.x) <= threshold && _abs(coords.y - state.y) <= threshold) {
                            this._fire(EVENT_CLICK, {
                                data: data,
                                x: coords.x,
                                y: coords.y,
                                $event: event
                            })
                        }
                    }
                    this._clickState = null
                },
                _startDrag: function(event, data) {
                    if (!data) {
                        return
                    }
                    var coords = getEventCoords(event),
                        state = this._dragState = {
                            x: coords.x,
                            y: coords.y,
                            data: data
                        };
                    this._fire(EVENT_START, {
                        x: state.x,
                        y: state.y,
                        data: state.data
                    })
                },
                _moveDrag: function(event, data) {
                    var coords, threshold, state = this._dragState;
                    if (!state) {
                        return
                    }
                    coords = getEventCoords(event);
                    threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;
                    if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
                        state.x = coords.x;
                        state.y = coords.y;
                        state.active = true;
                        state.data = data || {};
                        this._fire(EVENT_MOVE, {
                            x: state.x,
                            y: state.y,
                            data: state.data
                        })
                    }
                },
                _endDrag: function() {
                    var state = this._dragState;
                    if (!state) {
                        return
                    }
                    this._dragState = null;
                    this._fire(EVENT_END, {
                        x: state.x,
                        y: state.y,
                        data: state.data
                    })
                },
                _wheelZoom: function(event, data) {
                    if (!data) {
                        return
                    }
                    var delta, coords, that = this,
                        lock = that._wheelLock,
                        time = _now();
                    if (time - lock.time <= WHEEL_COOLDOWN) {
                        return
                    }
                    if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN) {
                        lock.dir = 0
                    }
                    delta = adjustWheelDelta(event.delta / 120 || 0, lock);
                    if (0 === delta) {
                        return
                    }
                    coords = getEventCoords(event);
                    that._fire(EVENT_ZOOM, {
                        delta: delta,
                        x: coords.x,
                        y: coords.y
                    });
                    lock.time = lock.dirTime = time
                },
                _startZoom: function(event, data) {
                    if (!isTouchEvent(event) || !data) {
                        return
                    }
                    var coords, pointer2, state = this._zoomState = this._zoomState || {};
                    if (state.pointer1 && state.pointer2) {
                        return
                    }
                    if (void 0 === state.pointer1) {
                        state.pointer1 = getPointerId(event) || 0;
                        coords = getMultitouchEventCoords(event, state.pointer1);
                        state.x1 = state.x1_0 = coords.x;
                        state.y1 = state.y1_0 = coords.y
                    }
                    if (void 0 === state.pointer2) {
                        pointer2 = getPointerId(event) || 1;
                        if (pointer2 !== state.pointer1) {
                            coords = getMultitouchEventCoords(event, pointer2);
                            if (coords) {
                                state.x2 = state.x2_0 = coords.x;
                                state.y2 = state.y2_0 = coords.y;
                                state.pointer2 = pointer2;
                                state.ready = true;
                                this._endDrag()
                            }
                        }
                    }
                },
                _moveZoom: function(event) {
                    var coords, state = this._zoomState;
                    if (!state || !isTouchEvent(event)) {
                        return
                    }
                    if (void 0 !== state.pointer1) {
                        coords = getMultitouchEventCoords(event, state.pointer1);
                        if (coords) {
                            state.x1 = coords.x;
                            state.y1 = coords.y
                        }
                    }
                    if (void 0 !== state.pointer2) {
                        coords = getMultitouchEventCoords(event, state.pointer2);
                        if (coords) {
                            state.x2 = coords.x;
                            state.y2 = coords.y
                        }
                    }
                },
                _endZoom: function(event) {
                    var startDistance, currentDistance, state = this._zoomState;
                    if (!state || !isTouchEvent(event)) {
                        return
                    }
                    if (state.ready) {
                        startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0);
                        currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);
                        this._fire(EVENT_ZOOM, {
                            ratio: currentDistance / startDistance,
                            x: (state.x1_0 + state.x2_0) / 2,
                            y: (state.y1_0 + state.y2_0) / 2
                        })
                    }
                    this._zoomState = null
                },
                _startHover: function(event, data) {
                    this._doHover(event, data, true)
                },
                _moveHover: function(event, data) {
                    this._doHover(event, data, false)
                },
                _doHover: function(event, data, isTouch) {
                    var that = this;
                    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                        that._cancelHover();
                        return
                    }
                    if (isTouchEvent(event) !== isTouch || that._hoverTarget === event.target || that._hoverState && that._hoverState.data === data) {
                        return
                    }
                    that._cancelHover();
                    if (data) {
                        that._hoverState = {
                            data: data
                        };
                        that._fire(EVENT_HOVER_ON, {
                            data: data
                        })
                    }
                    that._hoverTarget = event.target
                },
                _cancelHover: function() {
                    var state = this._hoverState;
                    this._hoverState = this._hoverTarget = null;
                    if (state) {
                        this._fire(EVENT_HOVER_OFF, {
                            data: state.data
                        })
                    }
                },
                _startFocus: function(event, data) {
                    this._doFocus(event, data, true)
                },
                _moveFocus: function(event, data) {
                    this._doFocus(event, data, false)
                },
                _doFocus: function(event, data, isTouch) {
                    var that = this;
                    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                        that._cancelFocus();
                        return
                    }
                    if (isTouchEvent(event) !== isTouch) {
                        return
                    }
                    that._focus.turnOff(isTouch ? FOCUS_OFF_DELAY_TOUCH : FOCUS_OFF_DELAY_MOUSE);
                    data && that._focus.turnOn(data, getEventCoords(event), isTouch ? FOCUS_ON_DELAY_TOUCH : FOCUS_ON_DELAY_MOUSE, isTouch)
                },
                _endFocus: function(event) {
                    if (!isTouchEvent(event)) {
                        return
                    }
                    this._focus.cancelOn()
                },
                _cancelFocus: function() {
                    this._focus.cancel()
                },
                _createEventHandlers: function(DATA_KEY) {
                    var that = this;
                    that._docHandlers = {};
                    that._rootHandlers = {};
                    that._rootHandlers[EVENTS.start] = that._docHandlers[EVENTS.start] = function(event) {
                        var isTouch = isTouchEvent(event),
                            data = getData(event);
                        if (isTouch && !that._isTouchEnabled) {
                            return
                        }
                        if (data) {
                            event.preventDefault();
                            event.stopPropagation()
                        }
                        that._startClick(event, data);
                        that._startDrag(event, data);
                        that._startZoom(event, data);
                        that._startHover(event, data);
                        that._startFocus(event, data)
                    };
                    that._docHandlers[EVENTS.move] = function(event) {
                        var isTouch = isTouchEvent(event),
                            data = getData(event);
                        if (isTouch && !that._isTouchEnabled) {
                            return
                        }
                        that._moveDrag(event, data);
                        that._moveZoom(event, data);
                        that._moveHover(event, data);
                        that._moveFocus(event, data)
                    };
                    that._docHandlers[EVENTS.end] = function(event) {
                        var isTouch = isTouchEvent(event),
                            data = getData(event);
                        if (isTouch && !that._isTouchEnabled) {
                            return
                        }
                        that._endClick(event, data);
                        that._endDrag(event, data);
                        that._endZoom(event, data);
                        that._endFocus(event, data)
                    };
                    that._rootHandlers[EVENTS.wheel] = function(event) {
                        that._cancelFocus();
                        if (!that._isWheelEnabled) {
                            return
                        }
                        var data = getData(event);
                        if (data) {
                            event.preventDefault();
                            event.stopPropagation();
                            that._wheelZoom(event, data)
                        }
                    };
                    that._wheelLock = {
                        dir: 0
                    };

                    function getData(event) {
                        var target = event.target;
                        return ("tspan" === target.tagName ? target.parentNode : target)[DATA_KEY]
                    }
                },
                _createProjectionHandlers: function(projection) {
                    var that = this;
                    projection.on({
                        center: handler,
                        zoom: handler
                    });

                    function handler() {
                        that._cancelFocus()
                    }
                },
                reset: function() {
                    var that = this;
                    that._clickState = null;
                    that._endDrag();
                    that._cancelHover();
                    that._cancelFocus()
                },
                setOptions: function(options) {
                    var that = this;
                    that.reset();
                    that._detachHandlers();
                    that._isTouchEnabled = !!_parseScalar(options.touchEnabled, true);
                    that._isWheelEnabled = !!_parseScalar(options.wheelEnabled, true);
                    that._attachHandlers()
                },
                _detachHandlers: function() {
                    var that = this;
                    if (that._isTouchEnabled) {
                        that._root.css({
                            "touch-action": "",
                            "-ms-touch-action": "",
                            "-webkit-user-select": ""
                        }).off(_addNamespace("MSHoldVisual", _NAME)).off(_addNamespace("contextmenu", _NAME))
                    }
                    $(document).off(that._docHandlers);
                    that._root.off(that._rootHandlers)
                },
                _attachHandlers: function() {
                    var that = this;
                    if (that._isTouchEnabled) {
                        that._root.css({
                            "touch-action": "none",
                            "-ms-touch-action": "none",
                            "-webkit-user-select": "none"
                        }).on(_addNamespace("MSHoldVisual", _NAME), function(event) {
                            event.preventDefault()
                        }).on(_addNamespace("contextmenu", _NAME), function(event) {
                            isTouchEvent(event) && event.preventDefault()
                        })
                    }
                    $(document).on(that._docHandlers);
                    that._root.on(that._rootHandlers)
                }
            };
            var Focus = function(fire) {
                var _x, _y, that = this,
                    _activeData = null,
                    _data = null,
                    _disabled = false,
                    _onTimer = null,
                    _offTimer = null;
                that.dispose = function() {
                    clearTimeout(_onTimer);
                    clearTimeout(_offTimer);
                    that.turnOn = that.turnOff = that.cancel = that.cancelOn = that.dispose = that = fire = _activeData = _data = _onTimer = _offTimer = null
                };
                that.turnOn = function(data, coords, timeout, forceTimeout) {
                    if (data === _data && _disabled) {
                        return
                    }
                    _disabled = false;
                    _data = data;
                    if (_activeData) {
                        _x = coords.x;
                        _y = coords.y;
                        clearTimeout(_onTimer);
                        _onTimer = setTimeout(function() {
                            _onTimer = null;
                            if (_data === _activeData) {
                                fire(EVENT_FOCUS_MOVE, {
                                    data: _data,
                                    x: _x,
                                    y: _y
                                });
                                onCheck(true)
                            } else {
                                fire(EVENT_FOCUS_ON, {
                                    data: _data,
                                    x: _x,
                                    y: _y,
                                    done: onCheck
                                })
                            }
                        }, forceTimeout ? timeout : 0)
                    } else {
                        if (!_onTimer || _abs(coords.x - _x) > FOCUS_COORD_THRESHOLD_MOUSE || _abs(coords.y - _y) > FOCUS_COORD_THRESHOLD_MOUSE || forceTimeout) {
                            _x = coords.x;
                            _y = coords.y;
                            clearTimeout(_onTimer);
                            _onTimer = setTimeout(function() {
                                _onTimer = null;
                                fire(EVENT_FOCUS_ON, {
                                    data: _data,
                                    x: _x,
                                    y: _y,
                                    done: onCheck
                                })
                            }, timeout)
                        }
                    }

                    function onCheck(result) {
                        _disabled = !result;
                        if (result) {
                            _activeData = _data;
                            clearTimeout(_offTimer);
                            _offTimer = null
                        }
                    }
                };
                that.turnOff = function(timeout) {
                    clearTimeout(_onTimer);
                    _onTimer = null;
                    _data = null;
                    if (_activeData && !_disabled) {
                        _offTimer = _offTimer || setTimeout(function() {
                            _offTimer = null;
                            fire(EVENT_FOCUS_OFF, {
                                data: _activeData
                            });
                            _activeData = null
                        }, timeout)
                    }
                };
                that.cancel = function() {
                    clearTimeout(_onTimer);
                    clearTimeout(_offTimer);
                    if (_activeData) {
                        fire(EVENT_FOCUS_OFF, {
                            data: _activeData
                        })
                    }
                    _activeData = _data = _onTimer = _offTimer = null
                };
                that.cancelOn = function() {
                    clearTimeout(_onTimer);
                    _onTimer = null
                }
            };
            eventEmitterModule.makeEventEmitter(Tracker);
            exports.Tracker = Tracker;
            var originFocus = Focus;
            exports._DEBUG_forceEventMode = function(mode) {
                setupEvents(mode)
            };
            exports.Focus = Focus;
            exports._DEBUG_stubFocusType = function(focusType) {
                Focus = focusType
            };
            exports._DEBUG_restoreFocusType = function() {
                Focus = originFocus
            };

            function getDistance(x1, y1, x2, y2) {
                return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
            }

            function isTouchEvent(event) {
                var type = event.originalEvent.type,
                    pointerType = event.originalEvent.pointerType;
                return /^touch/.test(type) || /^MSPointer/.test(type) && 4 !== pointerType || /^pointer/.test(type) && "mouse" !== pointerType
            }

            function selectItem(flags, items) {
                var item, i = 0,
                    ii = flags.length;
                for (; i < ii; ++i) {
                    if (flags[i]) {
                        item = items[i];
                        break
                    }
                }
                return _addNamespace(item || items[i], _NAME)
            }

            function setupEvents() {
                var flags = [navigator.pointerEnabled, navigator.msPointerEnabled, "ontouchstart" in window];
                if (arguments.length) {
                    flags = ["pointer" === arguments[0], "MSPointer" === arguments[0], "touch" === arguments[0]]
                }
                EVENTS = {
                    start: selectItem(flags, ["pointerdown", "MSPointerDown", "touchstart mousedown", "mousedown"]),
                    move: selectItem(flags, ["pointermove", "MSPointerMove", "touchmove mousemove", "mousemove"]),
                    end: selectItem(flags, ["pointerup", "MSPointerUp", "touchend mouseup", "mouseup"]),
                    wheel: _addNamespace(wheelEventName, _NAME)
                }
            }

            function getEventCoords(event) {
                var originalEvent = event.originalEvent,
                    touch = originalEvent.touches && originalEvent.touches[0] || {};
                return {
                    x: touch.pageX || originalEvent.pageX || event.pageX,
                    y: touch.pageY || originalEvent.pageY || event.pageY
                }
            }

            function getPointerId(event) {
                return event.originalEvent.pointerId
            }

            function getMultitouchEventCoords(event, pointerId) {
                var originalEvent = event.originalEvent;
                if (void 0 !== originalEvent.pointerId) {
                    originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null
                } else {
                    originalEvent = originalEvent.touches[pointerId]
                }
                return originalEvent ? {
                    x: originalEvent.pageX || event.pageX,
                    y: originalEvent.pageY || event.pageY
                } : null
            }

            function adjustWheelDelta(delta, lock) {
                if (0 === delta) {
                    return 0
                }
                var _delta = _abs(delta),
                    sign = _round(delta / _delta);
                if (lock.dir && sign !== lock.dir) {
                    return 0
                }
                lock.dir = sign;
                if (_delta < .1) {
                    _delta = 0
                } else {
                    if (_delta < 1) {
                        _delta = 1
                    } else {
                        if (_delta > 4) {
                            _delta = 4
                        } else {
                            _delta = _round(_delta)
                        }
                    }
                }
                return sign * _delta
            }
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/viz/vector_map/vector_map.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var $ = __webpack_require__( /*! jquery */ 1),
                _parseScalar = __webpack_require__( /*! ../core/utils */ 6).parseScalar,
                projectionModule = __webpack_require__( /*! ./projection.main */ 350),
                controlBarModule = __webpack_require__( /*! ./control_bar */ 569),
                gestureHandlerModule = __webpack_require__( /*! ./gesture_handler */ 571),
                trackerModule = __webpack_require__( /*! ./tracker */ 577),
                themeManagerModule = __webpack_require__( /*! ./theme_manager */ 575),
                dataExchangerModule = __webpack_require__( /*! ./data_exchanger */ 570),
                legendModule = __webpack_require__( /*! ./legend */ 573),
                layoutModule = __webpack_require__( /*! ./layout */ 572),
                mapLayerModule = __webpack_require__( /*! ./map_layer */ 574),
                tooltipViewerModule = __webpack_require__( /*! ./tooltip_viewer */ 576),
                _noop = $.noop,
                _extend = $.extend,
                DEFAULT_WIDTH = 800,
                DEFAULT_HEIGHT = 400,
                nextDataKey = 1,
                RE_STARTS_LAYERS = /^layers/,
                RE_ENDS_DATA_SOURCE = /\.(dataSource|data)$/;
            __webpack_require__( /*! ./projection */ 349);

            function generateDataKey() {
                return "vectormap-data-" + nextDataKey++
            }
            var dxVectorMap = __webpack_require__( /*! ../core/base_widget */ 109).inherit({
                _eventsMap: {
                    onClick: {
                        name: "click"
                    },
                    onCenterChanged: {
                        name: "centerChanged"
                    },
                    onZoomFactorChanged: {
                        name: "zoomFactorChanged"
                    },
                    onAreaClick: {
                        name: "areaClick"
                    },
                    onAreaHoverChanged: {
                        name: "areaHoverChanged"
                    },
                    onAreaSelectionChanged: {
                        name: "areaSelectionChanged"
                    },
                    onMarkerClick: {
                        name: "markerClick"
                    },
                    onMarkerHoverChanged: {
                        name: "markerHoverChanged"
                    },
                    onMarkerSelectionChanged: {
                        name: "markerSelectionChanged"
                    },
                    onHoverChanged: {
                        name: "hoverChanged"
                    },
                    onSelectionChanged: {
                        name: "selectionChanged"
                    }
                },
                _setDeprecatedOptions: function() {
                    this.callBase.apply(this, arguments);
                    _extend(this._deprecatedOptions, {
                        areaSettings: {
                            since: "15.2",
                            message: "Use the 'layers' option instead"
                        },
                        markerSettings: {
                            since: "15.2",
                            message: "Use the 'layers' option instead"
                        },
                        mapData: {
                            since: "15.2",
                            message: "Use the 'layers' option instead"
                        },
                        markers: {
                            since: "15.2",
                            message: "Use the 'layers' option instead"
                        },
                        onAreaClick: {
                            since: "15.2",
                            message: "Use the 'onClick' option instead"
                        },
                        onMarkerClick: {
                            since: "15.2",
                            message: "Use the 'onClick' option instead"
                        },
                        onAreaHoverChanged: {
                            since: "15.2",
                            message: "Use the 'onHoverChanged' option instead"
                        },
                        onMarkerHoverChanged: {
                            since: "15.2",
                            message: "Use the 'onHoverChanged' option instead"
                        },
                        onAreaSelectionChanged: {
                            since: "15.2",
                            message: "Use the 'onSelectionChanged' option instead"
                        },
                        onMarkerSelectionChanged: {
                            since: "15.2",
                            message: "Use the 'onSelectionChanged' option instead"
                        },
                        "layers.data": {
                            since: "15.2",
                            message: "Use the 'layers.dataSource' option instead"
                        }
                    })
                },
                _rootClassPrefix: "dxm",
                _rootClass: "dxm-vector-map",
                _createThemeManager: function() {
                    return new themeManagerModule.ThemeManager
                },
                _initLayerCollection: function(dataKey) {
                    var that = this;
                    that._layerCollection = new mapLayerModule.MapLayerCollection({
                        renderer: that._renderer,
                        projection: that._projection,
                        themeManager: that._themeManager,
                        tracker: that._tracker,
                        dataKey: dataKey,
                        eventTrigger: that._eventTrigger,
                        dataExchanger: that._dataExchanger,
                        tooltip: that._tooltip,
                        notifyDirty: that._notifyDirty,
                        notifyReady: that._notifyReady
                    });
                    if (void 0 === that._options.layers && (that._options.mapData || that._options.markers)) {
                        applyDeprecatedMode(that)
                    } else {
                        suspendLayersData(that._layerCollection, that._options.layers)
                    }
                },
                _initLegendsControl: function() {
                    var that = this;
                    that._legendsControl = new legendModule.LegendsControl({
                        renderer: that._renderer,
                        container: that._root,
                        layoutControl: that._layoutControl,
                        themeManager: that._themeManager,
                        dataExchanger: that._dataExchanger,
                        notifyDirty: that._notifyDirty,
                        notifyReady: that._notifyReady
                    })
                },
                _initControlBar: function(dataKey) {
                    var that = this;
                    that._controlBar = new controlBarModule.ControlBar({
                        renderer: that._renderer,
                        container: that._root,
                        layoutControl: that._layoutControl,
                        projection: that._projection,
                        tracker: that._tracker,
                        dataKey: dataKey
                    })
                },
                _initElements: function() {
                    var that = this,
                        dataKey = generateDataKey(),
                        notifyCounter = 0;
                    that._notifyDirty = function() {
                        that._resetIsReady();
                        ++notifyCounter
                    };
                    that._notifyReady = function() {
                        if (0 === --notifyCounter) {
                            that._drawn()
                        }
                    };
                    that._dataExchanger = new dataExchangerModule.DataExchanger;
                    that._projection = new projectionModule.Projection({
                        centerChanged: function(value) {
                            if (that._initialized) {
                                that._eventTrigger("centerChanged", {
                                    center: value
                                })
                            }
                        },
                        zoomChanged: function(value) {
                            if (that._initialized) {
                                that._eventTrigger("zoomFactorChanged", {
                                    zoomFactor: value
                                })
                            }
                        }
                    });
                    that._tracker = new trackerModule.Tracker({
                        root: that._root,
                        projection: that._projection,
                        dataKey: dataKey
                    });
                    that._gestureHandler = new gestureHandlerModule.GestureHandler({
                        projection: that._projection,
                        renderer: that._renderer,
                        tracker: that._tracker
                    });
                    that._layoutControl = new layoutModule.LayoutControl;
                    that._layoutControl.suspend();
                    that._initLayerCollection(dataKey);
                    that._initControlBar(dataKey);
                    that._initLegendsControl();
                    that._tooltipViewer = new tooltipViewerModule.TooltipViewer({
                        tracker: that._tracker,
                        tooltip: that._tooltip,
                        layerCollection: that._layerCollection
                    })
                },
                _init: function() {
                    this.callBase.apply(this, arguments);
                    this._afterInit();
                    this._layoutControl.resume()
                },
                _initialChanges: ["PROJECTION", "BOUNDS", "MAX_ZOOM_FACTOR", "ZOOM_FACTOR", "CENTER"],
                _afterInit: function() {
                    resumeLayersData(this._layerCollection, this._options.layers, this._renderer)
                },
                _initCore: function() {
                    this._root = this._renderer.root.attr({
                        align: "center",
                        cursor: "default"
                    });
                    this._initElements()
                },
                _disposeCore: function() {
                    var that = this;
                    that._controlBar.dispose();
                    that._gestureHandler.dispose();
                    that._tracker.dispose();
                    that._legendsControl.dispose();
                    that._layerCollection.dispose();
                    that._layoutControl.dispose();
                    that._tooltipViewer.dispose();
                    that._dataExchanger.dispose();
                    that._projection.dispose();
                    that._dataExchanger = that._gestureHandler = that._projection = that._tracker = that._layoutControl = that._root = that._layerCollection = that._controlBar = that._legendsControl = null
                },
                _setupInteraction: function() {
                    var options = {
                        centeringEnabled: !!_parseScalar(this._getOption("panningEnabled", true), true),
                        zoomingEnabled: !!_parseScalar(this._getOption("zoomingEnabled", true), true)
                    };
                    this._gestureHandler.setInteraction(options);
                    this._controlBar.setInteraction(options)
                },
                _getDefaultSize: function() {
                    return {
                        width: DEFAULT_WIDTH,
                        height: DEFAULT_HEIGHT
                    }
                },
                _applySize: function(rect) {
                    var layout = {
                        left: rect[0],
                        top: rect[1],
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1],
                        right: 0,
                        bottom: 0
                    };
                    this._projection.setSize(layout);
                    this._layoutControl.setSize(layout);
                    this._layerCollection.setRect([layout.left, layout.top, layout.width, layout.height])
                },
                _optionChanging: function(name, currentValue, nextValue) {
                    if (currentValue && nextValue) {
                        if (RE_STARTS_LAYERS.test(name)) {
                            if (currentValue.dataSource && nextValue.dataSource && currentValue !== nextValue) {
                                currentValue.dataSource = null
                            } else {
                                if (currentValue.data && nextValue.data && currentValue !== nextValue) {
                                    currentValue.data = null
                                } else {
                                    if (RE_ENDS_DATA_SOURCE.test(name)) {
                                        this.option(name, null)
                                    }
                                }
                            }
                        }
                        if ("mapData" === name) {
                            this._options.mapData = null
                        }
                        if ("markers" === name) {
                            this._options.markers = null
                        }
                    }
                },
                _applyChanges: function() {
                    this._notifyDirty();
                    this.callBase.apply(this, arguments);
                    this._notifyReady()
                },
                _optionChangesMap: {
                    background: "BACKGROUND",
                    layers: "LAYERS",
                    areaSettings: "LAYERS",
                    markerSettings: "LAYERS",
                    mapData: "LAYERS",
                    markers: "LAYERS",
                    controlBar: "CONTROL_BAR",
                    legends: "LEGENDS",
                    touchEnabled: "TRACKER",
                    wheelEnabled: "TRACKER",
                    panningEnabled: "INTERACTION",
                    zoomingEnabled: "INTERACTION",
                    projection: "PROJECTION",
                    bounds: "BOUNDS",
                    maxZoomFactor: "MAX_ZOOM_FACTOR",
                    zoomFactor: "ZOOM_FACTOR",
                    center: "CENTER"
                },
                _optionChangesOrder: ["PROJECTION", "BOUNDS", "MAX_ZOOM_FACTOR", "ZOOM_FACTOR", "CENTER", "BACKGROUND", "LAYERS", "CONTROL_BAR", "LEGENDS", "TRACKER", "INTERACTION"],
                _change_PROJECTION: function() {
                    this._setProjection()
                },
                _change_BOUNDS: function() {
                    this._setBounds()
                },
                _change_MAX_ZOOM_FACTOR: function() {
                    this._setMaxZoom()
                },
                _change_ZOOM_FACTOR: function() {
                    this._setZoom()
                },
                _change_CENTER: function() {
                    this._setCenter()
                },
                _change_BACKGROUND: function() {
                    this._setBackgroundOptions()
                },
                _change_LAYERS: function() {
                    this._setLayerCollectionOptions()
                },
                _change_CONTROL_BAR: function() {
                    this._setControlBarOptions()
                },
                _change_LEGENDS: function() {
                    this._setLegendsOptions()
                },
                _change_TRACKER: function() {
                    this._setTrackerOptions()
                },
                _change_INTERACTION: function() {
                    this._setupInteraction()
                },
                _themeDependentChanges: ["BACKGROUND", "LAYERS", "CONTROL_BAR", "LEGENDS", "TRACKER", "INTERACTION"],
                _setProjection: function() {
                    this._projection.setEngine(this.option("projection"))
                },
                _setBounds: function() {
                    this._projection.setBounds(this.option("bounds"))
                },
                _setMaxZoom: function() {
                    this._projection.setMaxZoom(this.option("maxZoomFactor"))
                },
                _setZoom: function() {
                    this._projection.setZoom(this.option("zoomFactor"))
                },
                _setCenter: function() {
                    this._projection.setCenter(this.option("center"))
                },
                _setBackgroundOptions: function() {
                    this._layerCollection.setBackgroundOptions(this._getOption("background"))
                },
                _setLayerCollectionOptions: function() {
                    this._layerCollection.setOptions(this.option("layers"))
                },
                _setControlBarOptions: function() {
                    this._controlBar.setOptions(this._getOption("controlBar"))
                },
                _setLegendsOptions: function() {
                    this._legendsControl.setOptions(this.option("legends"))
                },
                _setTrackerOptions: function() {
                    this._tracker.setOptions({
                        touchEnabled: this._getOption("touchEnabled", true),
                        wheelEnabled: this._getOption("wheelEnabled", true)
                    })
                },
                getLayers: function() {
                    var i, layers = this._layerCollection.items(),
                        list = [],
                        ii = list.length = layers.length;
                    for (i = 0; i < ii; ++i) {
                        list[i] = layers[i].proxy
                    }
                    return list
                },
                getLayerByIndex: function(index) {
                    var layer = this._layerCollection.byIndex(index);
                    return layer ? layer.proxy : null
                },
                getLayerByName: function(name) {
                    var layer = this._layerCollection.byName(name);
                    return layer ? layer.proxy : null
                },
                clearSelection: function(_noEvent) {
                    var i, layers = this._layerCollection.items(),
                        ii = layers.length;
                    for (i = 0; i < ii; ++i) {
                        layers[i].clearSelection(_noEvent)
                    }
                    return this
                },
                getAreas: _noop,
                getMarkers: _noop,
                clearAreaSelection: _noop,
                clearMarkerSelection: _noop,
                center: function(value) {
                    var that = this;
                    if (void 0 === value) {
                        return that._projection.getCenter()
                    } else {
                        that._projection.setCenter(value);
                        return that
                    }
                },
                zoomFactor: function(value) {
                    var that = this;
                    if (void 0 === value) {
                        return that._projection.getZoom()
                    } else {
                        that._projection.setZoom(value);
                        return that
                    }
                },
                viewport: function(value) {
                    var that = this;
                    if (void 0 === value) {
                        return that._projection.getViewport()
                    } else {
                        that._projection.setViewport(value);
                        return that
                    }
                },
                convertCoordinates: function(coordinates) {
                    coordinates = coordinates && coordinates.length ? coordinates : [arguments[0], arguments[1]];
                    return this._projection.fromScreenPoint(coordinates)
                }
            });

            function suspendLayersData(layerCollection, options) {
                if (options) {
                    layerCollection.__data = options.length ? $.map(options, patch) : patch(options)
                }

                function patch(ops) {
                    var ret = {};
                    swapData(ops || {}, ret);
                    return ret
                }
            }

            function resumeLayersData(layerCollection, options, renderer) {
                var data = layerCollection.__data;
                if (data) {
                    layerCollection.__data = void 0;
                    if (data.length) {
                        $.each(data, function(i, item) {
                            swapData(item, options[i])
                        })
                    } else {
                        swapData(data, options)
                    }
                    renderer.lock();
                    layerCollection.setOptions(options);
                    renderer.unlock()
                }
            }

            function swapData(source, target) {
                var name = !("dataSource" in source) && "data" in source ? "data" : "dataSource";
                target[name] = source[name];
                source[name] = void 0
            }

            function applyDeprecatedMode(map) {
                var log = __webpack_require__( /*! ../../core/errors */ 10).log,
                    mapData = map._options.mapData,
                    markers = map._options.markers;
                map._options.mapData = map._options.markers = void 0;
                map._afterInit = function() {
                    this._options.mapData = mapData;
                    this._options.markers = markers;
                    this._renderer.lock();
                    this._setLayerCollectionOptions();
                    this._renderer.unlock();
                    mapData = markers = void 0
                };
                map._setLayerCollectionOptions = function() {
                    var options = this._options,
                        mapData = options.mapData,
                        markers = options.markers;
                    mapData = mapData && mapData.features ? _extend({}, mapData) : mapData;
                    markers = markers && markers.features ? _extend({}, markers) : markers;
                    this._layerCollection.setOptions([_extend({}, options.areaSettings, {
                        name: "areas",
                        _deprecated: true,
                        dataSource: mapData,
                        type: "area"
                    }), _extend({}, options.markerSettings, {
                        name: "markers",
                        _deprecated: true,
                        dataSource: markers,
                        type: "marker",
                        elementType: options.markerSettings && options.markerSettings.type
                    })])
                };
                map.getAreas = function() {
                    log("W0002", this.NAME, "getAreas", "15.2", "Use the 'getLayerByName('areas').getElements()' instead");
                    return this.getLayerByName("areas").getElements()
                };
                map.getMarkers = function() {
                    log("W0002", this.NAME, "getMarkers", "15.2", "Use the 'getLayerByName('markers').getElements()' instead");
                    return this.getLayerByName("markers").getElements()
                };
                map.clearAreaSelection = function(_noEvent) {
                    log("W0002", this.NAME, "clearAreaSelection", "15.2", "Use the 'getLayerByName('areas').clearSelection()' instead");
                    this.getLayerByName("areas").clearSelection(_noEvent);
                    return this
                };
                map.clearMarkerSelection = function(_noEvent) {
                    log("W0002", this.NAME, "clearMarkerSelection", "15.2", "Use the 'getLayerByName('markers').clearSelection()' instead");
                    this.getLayerByName("markers").clearSelection(_noEvent);
                    return this
                };
                var clickMap = {
                        areas: "areaClick",
                        markers: "markerClick"
                    },
                    hoverChangedMap = {
                        areas: "areaHoverChanged",
                        markers: "markerHoverChanged"
                    },
                    selectionChangedMap = {
                        areas: "areaSelectionChanged",
                        markers: "markerSelectionChanged"
                    };
                map.on("click", function(e) {
                    if (e.target) {
                        this._eventTrigger(clickMap[e.target.layer.name], e)
                    }
                });
                map.on("hoverChanged", function(e) {
                    if (e.target) {
                        this._eventTrigger(hoverChangedMap[e.target.layer.name], e)
                    }
                });
                map.on("selectionChanged", function(e) {
                    if (e.target) {
                        this._eventTrigger(selectionChangedMap[e.target.layer.name], e)
                    }
                })
            }
            __webpack_require__( /*! ../../core/component_registrator */ 3)("dxVectorMap", dxVectorMap);
            module.exports = dxVectorMap;
            module.exports._TESTS_resetDataKey = function() {
                nextDataKey = 1
            };
            dxVectorMap.addPlugin(__webpack_require__( /*! ../core/export */ 127).plugin);
            dxVectorMap.addPlugin(__webpack_require__( /*! ../core/title */ 164).plugin);
            dxVectorMap.addPlugin(__webpack_require__( /*! ../core/tooltip */ 165).plugin);
            dxVectorMap.addPlugin(__webpack_require__( /*! ../core/loading_indicator */ 163).plugin)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    },
    /*!**********************************************!*\
      !*** ./Scripts/bundles/modules/parts/viz.js ***!
      \**********************************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            var DevExpress = __webpack_require__( /*! ./core */ 221);
            __webpack_require__( /*! ./data */ 238);
            var viz = DevExpress.viz = __webpack_require__( /*! ../../../bundles/modules/viz */ 420);
            viz.currentTheme = __webpack_require__( /*! ../../../viz/themes */ 69).currentTheme;
            viz.registerTheme = __webpack_require__( /*! ../../../viz/themes */ 69).registerTheme;
            viz.exportFromMarkup = __webpack_require__( /*! ../../../viz/export */ 521).exportFromMarkup;
            viz.currentPalette = __webpack_require__( /*! ../../../viz/palette */ 121).currentPalette;
            viz.getPalette = __webpack_require__( /*! ../../../viz/palette */ 121).getPalette;
            viz.registerPalette = __webpack_require__( /*! ../../../viz/palette */ 121).registerPalette;
            viz.dxChart = __webpack_require__( /*! ../../../viz/chart */ 505);
            viz.dxPieChart = __webpack_require__( /*! ../../../viz/pie_chart */ 530);
            viz.dxPolarChart = __webpack_require__( /*! ../../../viz/polar_chart */ 531);
            viz.dxLinearGauge = __webpack_require__( /*! ../../../viz/linear_gauge */ 529);
            viz.dxCircularGauge = __webpack_require__( /*! ../../../viz/circular_gauge */ 511);
            viz.dxBarGauge = __webpack_require__( /*! ../../../viz/bar_gauge */ 503);
            viz.dxRangeSelector = __webpack_require__( /*! ../../../viz/range_selector */ 532);
            viz.dxVectorMap = __webpack_require__( /*! ../../../viz/vector_map */ 568);
            viz.map = {};
            viz.map.sources = {};
            viz.map.projection = __webpack_require__( /*! ../../../viz/vector_map/projection */ 349).projection;
            viz.dxSparkline = __webpack_require__( /*! ../../../viz/sparkline */ 551);
            viz.dxBullet = __webpack_require__( /*! ../../../viz/bullet */ 504);
            viz.dxTreeMap = __webpack_require__( /*! ../../../viz/tree_map */ 558);
            var core = {};
            viz.core = core;
            core.currentTheme = __webpack_require__( /*! ../../../viz/themes */ 69).currentTheme;
            core.registerTheme = __webpack_require__( /*! ../../../viz/themes */ 69).registerTheme;
            core.currentPalette = __webpack_require__( /*! ../../../viz/palette */ 121).currentPalette;
            core.getPalette = __webpack_require__( /*! ../../../viz/palette */ 121).getPalette;
            core.registerPalette = __webpack_require__( /*! ../../../viz/palette */ 121).registerPalette;
            viz.BaseWidget = __webpack_require__( /*! ../../../viz/core/base_widget */ 109);
            viz.findTheme = __webpack_require__( /*! ../../../viz/themes */ 69).findTheme;
            viz.refreshAll = __webpack_require__( /*! ../../../viz/themes */ 69).refreshAll;
            viz.gauges = {
                __internals: {}
            };
            viz._dashboard = {};
            viz._dashboard.Renderer = __webpack_require__( /*! ../../../viz/core/renderers/renderer */ 176).Renderer;
            viz._dashboard.SvgElement = __webpack_require__( /*! ../../../viz/core/renderers/svg_renderer */ 261).SvgElement;
            viz._dashboard.isSvg = __webpack_require__( /*! ../../../viz/core/renderers/renderer */ 176).isSvg;
            viz._dashboard.patchFontOptions = __webpack_require__( /*! ../../../viz/core/utils */ 6).patchFontOptions;
            module.exports = viz
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }, , , , , , , , , , ,
    /*!***********************************!*\
      !*** ./Scripts/bundles/dx.viz.js ***!
      \***********************************/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
            __webpack_require__( /*! ./modules/parts/viz */ 579)
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }
]);
